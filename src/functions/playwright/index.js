var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function rawHeaders(headers) {
  const rawHeaders2 = [];
  for (const key in headers) {
    if (Array.isArray(headers[key])) {
      for (const h of headers[key]) {
        rawHeaders2.push(key, h);
      }
    } else {
      rawHeaders2.push(key, headers[key]);
    }
  }
  return rawHeaders2;
}
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(rawHeaders, "rawHeaders");
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance2;
var init_performance = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options2) {
        this.name = name;
        this.startTime = options2?.startTime || _performanceNow();
        this.detail = options2?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type2) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type2) {
        return this._entries.filter((e) => e.name === name && (!type2 || e.entryType === type2));
      }
      getEntriesByType(type2) {
        return this._entries.filter((e) => e.entryType === type2);
      }
      mark(name, options2) {
        const entry = new PerformanceMark(name, options2);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type2, listener, options2) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type2, listener, options2) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options2) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance2 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance2;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env3) {
        return 1;
      }
      hasColors(count3, env3) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding2, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      emitWarning(warning, type2, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type2 ? `${type2}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      ref() {
      }
      unref() {
      }
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      mainModule = void 0;
      domain = void 0;
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, exit, platform, nextTick, unenvProcess, abort, addListener, allowedNodeEnvironmentFlags, hasUncaughtExceptionCaptureCallback, setUncaughtExceptionCaptureCallback, loadEnvFile, sourceMapsEnabled, arch, argv, argv0, chdir, config, connected, constrainedMemory, availableMemory, cpuUsage, cwd, debugPort, dlopen, disconnect, emit, emitWarning, env, eventNames, execArgv, execPath, finalization, features, getActiveResourcesInfo, getMaxListeners, hrtime3, kill, listeners, listenerCount, memoryUsage, on, off, once, pid, ppid, prependListener, prependOnceListener, rawListeners, release, removeAllListeners, removeListener, report, resourceUsage, setMaxListeners, setSourceMapsEnabled, stderr, stdin, stdout, title, throwDeprecation, traceDeprecation, umask, uptime, version, versions, domain, initgroups, moduleLoadList, reallyExit, openStdin, assert2, binding, send, exitCode, channel, getegid, geteuid, getgid, getgroups, getuid, setegid, seteuid, setgid, setgroups, setuid, permission, mainModule, _events, _eventsCount, _exiting, _maxListeners, _debugEnd, _debugProcess, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, _disconnect, _handleQueue, _pendingMessage, _channel, _send, _linkedBinding, _process, process_default;
var init_process2 = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    ({ exit, platform, nextTick } = getBuiltinModule(
      "node:process"
    ));
    unenvProcess = new Process({
      env: globalProcess.env,
      hrtime,
      nextTick
    });
    ({
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      finalization,
      features,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      on,
      off,
      once,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    } = unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// node-built-in-modules:process
var require_process = __commonJS({
  "node-built-in-modules:process"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_process2();
    module.exports = process_default;
  }
});

// node-built-in-modules:url
import libDefault from "url";
var require_url = __commonJS({
  "node-built-in-modules:url"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault;
  }
});

// node-built-in-modules:path
import libDefault2 from "path";
var require_path = __commonJS({
  "node-built-in-modules:path"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault2;
  }
});

// src/index.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/patch.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_process2();
process_default.versions.node = "20.0.0";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/inProcessFactory.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/androidServerImpl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/remote/playwrightServer.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/remote/playwrightConnection.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/socksProxy.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import require$$0$33 from "node:events";
import net3 from "node:net";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/assert.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function assert3(value, message) {
  if (!value)
    throw new Error(message || "Assertion error");
}
__name(assert3, "assert");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/crypto.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/crypto/node.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
var webcrypto = new Proxy(globalThis.crypto, { get(_, key) {
  if (key === "CryptoKey") {
    return globalThis.CryptoKey;
  }
  if (typeof globalThis.crypto[key] === "function") {
    return globalThis.crypto[key].bind(globalThis.crypto);
  }
  return globalThis.crypto[key];
} });
var createCipher = /* @__PURE__ */ notImplemented("crypto.createCipher");
var createDecipher = /* @__PURE__ */ notImplemented("crypto.createDecipher");
var pseudoRandomBytes = /* @__PURE__ */ notImplemented("crypto.pseudoRandomBytes");
var Cipher = /* @__PURE__ */ notImplementedClass("crypto.Cipher");
var Decipher = /* @__PURE__ */ notImplementedClass("crypto.Decipher");

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/crypto/constants.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SSL_OP_ALL = 2147485776;
var SSL_OP_ALLOW_NO_DHE_KEX = 1024;
var SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = 262144;
var SSL_OP_CIPHER_SERVER_PREFERENCE = 4194304;
var SSL_OP_CISCO_ANYCONNECT = 32768;
var SSL_OP_COOKIE_EXCHANGE = 8192;
var SSL_OP_CRYPTOPRO_TLSEXT_BUG = 2147483648;
var SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = 2048;
var SSL_OP_LEGACY_SERVER_CONNECT = 4;
var SSL_OP_NO_COMPRESSION = 131072;
var SSL_OP_NO_ENCRYPT_THEN_MAC = 524288;
var SSL_OP_NO_QUERY_MTU = 4096;
var SSL_OP_NO_RENEGOTIATION = 1073741824;
var SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = 65536;
var SSL_OP_NO_SSLv2 = 0;
var SSL_OP_NO_SSLv3 = 33554432;
var SSL_OP_NO_TICKET = 16384;
var SSL_OP_NO_TLSv1 = 67108864;
var SSL_OP_NO_TLSv1_1 = 268435456;
var SSL_OP_NO_TLSv1_2 = 134217728;
var SSL_OP_NO_TLSv1_3 = 536870912;
var SSL_OP_PRIORITIZE_CHACHA = 2097152;
var SSL_OP_TLS_ROLLBACK_BUG = 8388608;
var ENGINE_METHOD_RSA = 1;
var ENGINE_METHOD_DSA = 2;
var ENGINE_METHOD_DH = 4;
var ENGINE_METHOD_RAND = 8;
var ENGINE_METHOD_EC = 2048;
var ENGINE_METHOD_CIPHERS = 64;
var ENGINE_METHOD_DIGESTS = 128;
var ENGINE_METHOD_PKEY_METHS = 512;
var ENGINE_METHOD_PKEY_ASN1_METHS = 1024;
var ENGINE_METHOD_ALL = 65535;
var ENGINE_METHOD_NONE = 0;
var DH_CHECK_P_NOT_SAFE_PRIME = 2;
var DH_CHECK_P_NOT_PRIME = 1;
var DH_UNABLE_TO_CHECK_GENERATOR = 4;
var DH_NOT_SUITABLE_GENERATOR = 8;
var RSA_PKCS1_PADDING = 1;
var RSA_NO_PADDING = 3;
var RSA_PKCS1_OAEP_PADDING = 4;
var RSA_X931_PADDING = 5;
var RSA_PKCS1_PSS_PADDING = 6;
var RSA_PSS_SALTLEN_DIGEST = -1;
var RSA_PSS_SALTLEN_MAX_SIGN = -2;
var RSA_PSS_SALTLEN_AUTO = -2;
var POINT_CONVERSION_COMPRESSED = 2;
var POINT_CONVERSION_UNCOMPRESSED = 4;
var POINT_CONVERSION_HYBRID = 6;
var defaultCoreCipherList = "";
var OPENSSL_VERSION_NUMBER = 0;
var TLS1_VERSION = 0;
var TLS1_1_VERSION = 0;
var TLS1_2_VERSION = 0;
var TLS1_3_VERSION = 0;

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs
var workerdCrypto = process.getBuiltinModule("node:crypto");
var {
  Certificate,
  checkPrime,
  checkPrimeSync,
  constants,
  // @ts-expect-error
  Cipheriv,
  createCipheriv,
  createDecipheriv,
  createDiffieHellman,
  createDiffieHellmanGroup,
  createECDH,
  createHash,
  createHmac,
  createPrivateKey,
  createPublicKey,
  createSecretKey,
  createSign,
  createVerify,
  // @ts-expect-error
  Decipheriv,
  diffieHellman,
  DiffieHellman,
  DiffieHellmanGroup,
  ECDH,
  fips,
  generateKey,
  generateKeyPair,
  generateKeyPairSync,
  generateKeySync,
  generatePrime,
  generatePrimeSync,
  getCipherInfo,
  getCiphers,
  getCurves,
  getDiffieHellman,
  getFips,
  getHashes,
  getRandomValues,
  hash,
  Hash,
  hkdf,
  hkdfSync,
  Hmac,
  KeyObject,
  pbkdf2,
  pbkdf2Sync,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  randomUUID,
  scrypt,
  scryptSync,
  secureHeapUsed,
  setEngine,
  setFips,
  sign,
  Sign,
  subtle,
  timingSafeEqual,
  verify,
  Verify,
  X509Certificate
} = workerdCrypto;
var webcrypto2 = {
  // @ts-expect-error
  CryptoKey: webcrypto.CryptoKey,
  getRandomValues,
  randomUUID,
  subtle
};
var crypto_default = {
  /**
   * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
   */
  Certificate,
  Cipher,
  Cipheriv,
  Decipher,
  Decipheriv,
  ECDH,
  Sign,
  Verify,
  X509Certificate,
  constants,
  createCipheriv,
  createDecipheriv,
  createECDH,
  createSign,
  createVerify,
  diffieHellman,
  getCipherInfo,
  hash,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
  scrypt,
  scryptSync,
  sign,
  verify,
  // default-only export from unenv
  // @ts-expect-error unenv has unknown type
  createCipher,
  // @ts-expect-error unenv has unknown type
  createDecipher,
  // @ts-expect-error unenv has unknown type
  pseudoRandomBytes,
  /**
   * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
   */
  DiffieHellman,
  DiffieHellmanGroup,
  Hash,
  Hmac,
  KeyObject,
  checkPrime,
  checkPrimeSync,
  createDiffieHellman,
  createDiffieHellmanGroup,
  createHash,
  createHmac,
  createPrivateKey,
  createPublicKey,
  createSecretKey,
  generateKey,
  generateKeyPair,
  generateKeyPairSync,
  generateKeySync,
  generatePrime,
  generatePrimeSync,
  getCiphers,
  getCurves,
  getDiffieHellman,
  getFips,
  getHashes,
  getRandomValues,
  hkdf,
  hkdfSync,
  pbkdf2,
  pbkdf2Sync,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  randomUUID,
  secureHeapUsed,
  setEngine,
  setFips,
  subtle,
  timingSafeEqual,
  // default-only export from workerd
  fips,
  // special-cased deep merged symbols
  webcrypto: webcrypto2
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/crypto.js
function createGuid() {
  return Array.from({ length: 16 }, () => Math.floor(Math.random() * 256)).map((byte) => byte.toString(16).padStart(2, "0")).join("");
}
__name(createGuid, "createGuid");
function calculateSha1(buffer2) {
  const hash2 = crypto_default.createHash("sha1");
  hash2.update(buffer2);
  return hash2.digest("hex");
}
__name(calculateSha1, "calculateSha1");
function encodeBase128(value) {
  const bytes = [];
  do {
    let byte = value & 127;
    value >>>= 7;
    if (bytes.length > 0)
      byte |= 128;
    bytes.push(byte);
  } while (value > 0);
  return Buffer.from(bytes.reverse());
}
__name(encodeBase128, "encodeBase128");
var DER = class {
  static {
    __name(this, "DER");
  }
  static encodeSequence(data) {
    return this._encode(48, Buffer.concat(data));
  }
  static encodeInteger(data) {
    assert3(data >= -128 && data <= 127);
    return this._encode(2, Buffer.from([data]));
  }
  static encodeObjectIdentifier(oid) {
    const parts = oid.split(".").map((v) => Number(v));
    const output = [encodeBase128(40 * parts[0] + parts[1])];
    for (let i = 2; i < parts.length; i++)
      output.push(encodeBase128(parts[i]));
    return this._encode(6, Buffer.concat(output));
  }
  static encodeNull() {
    return Buffer.from([5, 0]);
  }
  static encodeSet(data) {
    assert3(data.length === 1, "Only one item in the set is supported. We'd need to sort the data to support more.");
    return this._encode(49, Buffer.concat(data));
  }
  static encodeExplicitContextDependent(tag, data) {
    return this._encode(160 + tag, data);
  }
  static encodePrintableString(data) {
    return this._encode(19, Buffer.from(data));
  }
  static encodeBitString(data) {
    const unusedBits = 0;
    const content = Buffer.concat([Buffer.from([unusedBits]), data]);
    return this._encode(3, content);
  }
  static encodeDate(date) {
    const year = date.getUTCFullYear();
    const isGeneralizedTime = year >= 2050;
    const parts = [
      isGeneralizedTime ? year.toString() : year.toString().slice(-2),
      (date.getUTCMonth() + 1).toString().padStart(2, "0"),
      date.getUTCDate().toString().padStart(2, "0"),
      date.getUTCHours().toString().padStart(2, "0"),
      date.getUTCMinutes().toString().padStart(2, "0"),
      date.getUTCSeconds().toString().padStart(2, "0")
    ];
    const encodedDate = parts.join("") + "Z";
    const tag = isGeneralizedTime ? 24 : 23;
    return this._encode(tag, Buffer.from(encodedDate));
  }
  static _encode(tag, data) {
    const lengthBytes = this._encodeLength(data.length);
    return Buffer.concat([Buffer.from([tag]), lengthBytes, data]);
  }
  static _encodeLength(length) {
    if (length < 128) {
      return Buffer.from([length]);
    } else {
      const lengthBytes = [];
      while (length > 0) {
        lengthBytes.unshift(length & 255);
        length >>= 8;
      }
      return Buffer.from([128 | lengthBytes.length, ...lengthBytes]);
    }
  }
};
function generateSelfSignedCertificate() {
  const { privateKey, publicKey } = crypto_default.generateKeyPairSync("rsa", { modulusLength: 2048 });
  const publicKeyDer = publicKey.export({ type: "pkcs1", format: "der" });
  const oneYearInMilliseconds = 365 * 24 * 60 * 60 * 1e3;
  const notBefore = new Date((/* @__PURE__ */ new Date()).getTime() - oneYearInMilliseconds);
  const notAfter = new Date((/* @__PURE__ */ new Date()).getTime() + oneYearInMilliseconds);
  const tbsCertificate = DER.encodeSequence([
    DER.encodeExplicitContextDependent(0, DER.encodeInteger(1)),
    // version
    DER.encodeInteger(1),
    // serialNumber
    DER.encodeSequence([
      DER.encodeObjectIdentifier("1.2.840.113549.1.1.11"),
      // sha256WithRSAEncryption PKCS #1
      DER.encodeNull()
    ]),
    // signature
    DER.encodeSequence([
      DER.encodeSet([
        DER.encodeSequence([
          DER.encodeObjectIdentifier("2.5.4.3"),
          // commonName X.520 DN component
          DER.encodePrintableString("localhost")
        ])
      ]),
      DER.encodeSet([
        DER.encodeSequence([
          DER.encodeObjectIdentifier("2.5.4.10"),
          // organizationName X.520 DN component
          DER.encodePrintableString("Playwright Client Certificate Support")
        ])
      ])
    ]),
    // issuer
    DER.encodeSequence([
      DER.encodeDate(notBefore),
      // notBefore
      DER.encodeDate(notAfter)
      // notAfter
    ]),
    // validity
    DER.encodeSequence([
      DER.encodeSet([
        DER.encodeSequence([
          DER.encodeObjectIdentifier("2.5.4.3"),
          // commonName X.520 DN component
          DER.encodePrintableString("localhost")
        ])
      ]),
      DER.encodeSet([
        DER.encodeSequence([
          DER.encodeObjectIdentifier("2.5.4.10"),
          // organizationName X.520 DN component
          DER.encodePrintableString("Playwright Client Certificate Support")
        ])
      ])
    ]),
    // subject
    DER.encodeSequence([
      DER.encodeSequence([
        DER.encodeObjectIdentifier("1.2.840.113549.1.1.1"),
        // rsaEncryption PKCS #1
        DER.encodeNull()
      ]),
      DER.encodeBitString(publicKeyDer)
    ])
    // SubjectPublicKeyInfo
  ]);
  const signature = crypto_default.sign("sha256", tbsCertificate, privateKey);
  const certificate = DER.encodeSequence([
    tbsCertificate,
    DER.encodeSequence([
      DER.encodeObjectIdentifier("1.2.840.113549.1.1.11"),
      // sha256WithRSAEncryption PKCS #1
      DER.encodeNull()
    ]),
    DER.encodeBitString(signature)
  ]);
  const certPem = [
    "-----BEGIN CERTIFICATE-----",
    // Split the base64 string into lines of 64 characters
    certificate.toString("base64").match(/.{1,64}/g).join("\n"),
    "-----END CERTIFICATE-----"
  ].join("\n");
  return {
    cert: certPem,
    key: privateKey.export({ type: "pkcs1", format: "pem" })
  };
}
__name(generateSelfSignedCertificate, "generateSelfSignedCertificate");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/debugLogger.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/bundles/fs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import require$$0$1 from "node:buffer";
import require$$5 from "node:assert";

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/util.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/util.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
import types from "node:util/types";

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/util/legacy-types.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isRegExp = /* @__PURE__ */ __name((val) => val instanceof RegExp, "isRegExp");
var isDate = /* @__PURE__ */ __name((val) => val instanceof Date, "isDate");
var isBoolean = /* @__PURE__ */ __name((val) => typeof val === "boolean", "isBoolean");
var isNull = /* @__PURE__ */ __name((val) => val === null, "isNull");
var isNullOrUndefined = /* @__PURE__ */ __name((val) => val === null || val === void 0, "isNullOrUndefined");
var isNumber = /* @__PURE__ */ __name((val) => typeof val === "number", "isNumber");
var isString = /* @__PURE__ */ __name((val) => typeof val === "string", "isString");
var isSymbol = /* @__PURE__ */ __name((val) => typeof val === "symbol", "isSymbol");
var isUndefined = /* @__PURE__ */ __name((val) => val === void 0, "isUndefined");
var isFunction = /* @__PURE__ */ __name((val) => typeof val === "function", "isFunction");
var isBuffer = /* @__PURE__ */ __name((val) => {
  return val && typeof val === "object" && typeof val.copy === "function" && typeof val.fill === "function" && typeof val.readUInt8 === "function";
}, "isBuffer");
var isObject = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object" && Object.getPrototypeOf(val).isPrototypeOf(Object), "isObject");
var isError = /* @__PURE__ */ __name((val) => val instanceof Error, "isError");
var isPrimitive = /* @__PURE__ */ __name((val) => {
  if (typeof val === "object") {
    return val === null;
  }
  return typeof val !== "function";
}, "isPrimitive");

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/util.mjs
import { default as default2 } from "node:util/types";
var TextDecoder2 = globalThis.TextDecoder;
var TextEncoder2 = globalThis.TextEncoder;
var _errnoException = /* @__PURE__ */ notImplemented("util._errnoException");
var _exceptionWithHostPort = /* @__PURE__ */ notImplemented("util._exceptionWithHostPort");
var getSystemErrorMap = /* @__PURE__ */ notImplemented("util.getSystemErrorMap");
var getSystemErrorName = /* @__PURE__ */ notImplemented("util.getSystemErrorName");
var parseEnv = /* @__PURE__ */ notImplemented("util.parseEnv");
var styleText = /* @__PURE__ */ notImplemented("util.styleText");

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/util.mjs
var workerdUtil = process.getBuiltinModule("node:util");
var {
  MIMEParams,
  MIMEType,
  TextDecoder: TextDecoder3,
  TextEncoder: TextEncoder3,
  // @ts-expect-error missing types?
  _extend,
  aborted,
  callbackify,
  debug: debug3,
  debuglog,
  deprecate,
  format,
  formatWithOptions,
  // @ts-expect-error unknown type
  getCallSite,
  inherits,
  inspect,
  isArray,
  isDeepStrictEqual,
  log: log3,
  parseArgs,
  promisify,
  stripVTControlCharacters,
  toUSVString,
  transferableAbortController,
  transferableAbortSignal
} = workerdUtil;
var types2 = workerdUtil.types;
var util_default = {
  /**
   * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
   */
  _errnoException,
  _exceptionWithHostPort,
  // @ts-expect-error unenv has unknown type
  getSystemErrorMap,
  // @ts-expect-error unenv has unknown type
  getSystemErrorName,
  isBoolean,
  isBuffer,
  isDate,
  isError,
  isFunction,
  isNull,
  isNullOrUndefined,
  isNumber,
  isObject,
  isPrimitive,
  isRegExp,
  isString,
  isSymbol,
  isUndefined,
  // @ts-expect-error unenv has unknown type
  parseEnv,
  // @ts-expect-error unenv has unknown type
  styleText,
  /**
   * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
   */
  _extend,
  aborted,
  callbackify,
  debug: debug3,
  debuglog,
  deprecate,
  format,
  formatWithOptions,
  getCallSite,
  inherits,
  inspect,
  isArray,
  isDeepStrictEqual,
  log: log3,
  MIMEParams,
  MIMEType,
  parseArgs,
  promisify,
  stripVTControlCharacters,
  TextDecoder: TextDecoder3,
  TextEncoder: TextEncoder3,
  toUSVString,
  transferableAbortController,
  transferableAbortSignal,
  // special-cased deep merged symbols
  types: types2
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/bundles/fs.js
import path from "node:path";
import require$$0$3 from "node:events";
import require$$6 from "node:stream";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = /* @__PURE__ */ __name(function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    }, "a");
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return n[k];
      }, "get")
    });
  });
  return a;
}
__name(getAugmentedNamespace, "getAugmentedNamespace");
var lib$1 = { exports: {} };
var Stats$1 = {};
var constants$2 = {};
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$2;
  hasRequiredConstants$1 = 1;
  Object.defineProperty(constants$2, "__esModule", { value: true });
  constants$2.constants = void 0;
  constants$2.constants = {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 64,
    O_EXCL: 128,
    O_NOCTTY: 256,
    O_TRUNC: 512,
    O_APPEND: 1024,
    O_DIRECTORY: 65536,
    O_NOATIME: 262144,
    O_NOFOLLOW: 131072,
    O_SYNC: 1052672,
    O_SYMLINK: 2097152,
    O_DIRECT: 16384,
    O_NONBLOCK: 2048,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    UV_FS_COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_EXCL: 1,
    COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE_FORCE: 4
  };
  return constants$2;
}
__name(requireConstants$1, "requireConstants$1");
var hasRequiredStats;
function requireStats() {
  if (hasRequiredStats) return Stats$1;
  hasRequiredStats = 1;
  Object.defineProperty(Stats$1, "__esModule", { value: true });
  Stats$1.Stats = void 0;
  const constants_1 = requireConstants$1();
  const { S_IFMT: S_IFMT2, S_IFDIR: S_IFDIR2, S_IFREG: S_IFREG2, S_IFBLK: S_IFBLK2, S_IFCHR: S_IFCHR2, S_IFLNK: S_IFLNK2, S_IFIFO: S_IFIFO2, S_IFSOCK: S_IFSOCK2 } = constants_1.constants;
  class Stats2 {
    static {
      __name(this, "Stats");
    }
    static build(node2, bigint2 = false) {
      const stats = new Stats2();
      const { uid, gid, atime, mtime, ctime } = node2;
      const getStatNumber = !bigint2 ? (number) => number : (number) => BigInt(number);
      stats.uid = getStatNumber(uid);
      stats.gid = getStatNumber(gid);
      stats.rdev = getStatNumber(node2.rdev);
      stats.blksize = getStatNumber(4096);
      stats.ino = getStatNumber(node2.ino);
      stats.size = getStatNumber(node2.getSize());
      stats.blocks = getStatNumber(1);
      stats.atime = atime;
      stats.mtime = mtime;
      stats.ctime = ctime;
      stats.birthtime = ctime;
      stats.atimeMs = getStatNumber(atime.getTime());
      stats.mtimeMs = getStatNumber(mtime.getTime());
      const ctimeMs = getStatNumber(ctime.getTime());
      stats.ctimeMs = ctimeMs;
      stats.birthtimeMs = ctimeMs;
      if (bigint2) {
        stats.atimeNs = BigInt(atime.getTime()) * BigInt(1e6);
        stats.mtimeNs = BigInt(mtime.getTime()) * BigInt(1e6);
        const ctimeNs = BigInt(ctime.getTime()) * BigInt(1e6);
        stats.ctimeNs = ctimeNs;
        stats.birthtimeNs = ctimeNs;
      }
      stats.dev = getStatNumber(0);
      stats.mode = getStatNumber(node2.mode);
      stats.nlink = getStatNumber(node2.nlink);
      return stats;
    }
    _checkModeProperty(property) {
      return (Number(this.mode) & S_IFMT2) === property;
    }
    isDirectory() {
      return this._checkModeProperty(S_IFDIR2);
    }
    isFile() {
      return this._checkModeProperty(S_IFREG2);
    }
    isBlockDevice() {
      return this._checkModeProperty(S_IFBLK2);
    }
    isCharacterDevice() {
      return this._checkModeProperty(S_IFCHR2);
    }
    isSymbolicLink() {
      return this._checkModeProperty(S_IFLNK2);
    }
    isFIFO() {
      return this._checkModeProperty(S_IFIFO2);
    }
    isSocket() {
      return this._checkModeProperty(S_IFSOCK2);
    }
  }
  Stats$1.Stats = Stats2;
  Stats$1.default = Stats2;
  return Stats$1;
}
__name(requireStats, "requireStats");
var Dirent$1 = {};
var encoding = {};
var buffer = {};
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferFrom = exports.bufferAllocUnsafe = exports.Buffer = void 0;
    const buffer_1 = require$$0$1;
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return buffer_1.Buffer;
    }, "get") });
    function bufferV0P12Ponyfill(arg0, ...args) {
      return new buffer_1.Buffer(arg0, ...args);
    }
    __name(bufferV0P12Ponyfill, "bufferV0P12Ponyfill");
    const bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
    exports.bufferAllocUnsafe = bufferAllocUnsafe;
    const bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
    exports.bufferFrom = bufferFrom;
  })(buffer);
  return buffer;
}
__name(requireBuffer, "requireBuffer");
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AssertionError = exports.RangeError = exports.TypeError = exports.Error = void 0;
    exports.message = message;
    exports.E = E;
    const assert4 = require$$5;
    const util3 = util_default;
    const kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
    const messages2 = {};
    function makeNodeError(Base) {
      return class NodeError extends Base {
        static {
          __name(this, "NodeError");
        }
        constructor(key, ...args) {
          super(message(key, args));
          this.code = key;
          this[kCode] = key;
          this.name = `${super.name} [${this[kCode]}]`;
        }
      };
    }
    __name(makeNodeError, "makeNodeError");
    const g = typeof globalThis !== "undefined" ? globalThis : commonjsGlobal;
    class AssertionError extends g.Error {
      static {
        __name(this, "AssertionError");
      }
      constructor(options2) {
        if (typeof options2 !== "object" || options2 === null) {
          throw new exports.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
        }
        if (options2.message) {
          super(options2.message);
        } else {
          super(`${util3.inspect(options2.actual).slice(0, 128)} ${options2.operator} ${util3.inspect(options2.expected).slice(0, 128)}`);
        }
        this.generatedMessage = !options2.message;
        this.name = "AssertionError [ERR_ASSERTION]";
        this.code = "ERR_ASSERTION";
        this.actual = options2.actual;
        this.expected = options2.expected;
        this.operator = options2.operator;
        exports.Error.captureStackTrace(this, options2.stackStartFunction);
      }
    }
    exports.AssertionError = AssertionError;
    function message(key, args) {
      assert4.strictEqual(typeof key, "string");
      const msg = messages2[key];
      assert4(msg, `An invalid error message key was used: ${key}.`);
      let fmt;
      if (typeof msg === "function") {
        fmt = msg;
      } else {
        fmt = util3.format;
        if (args === void 0 || args.length === 0)
          return msg;
        args.unshift(msg);
      }
      return String(fmt.apply(null, args));
    }
    __name(message, "message");
    function E(sym, val) {
      messages2[sym] = typeof val === "function" ? val : String(val);
    }
    __name(E, "E");
    exports.Error = makeNodeError(g.Error);
    exports.TypeError = makeNodeError(g.TypeError);
    exports.RangeError = makeNodeError(g.RangeError);
    E("ERR_ARG_NOT_ITERABLE", "%s must be iterable");
    E("ERR_ASSERTION", "%s");
    E("ERR_BUFFER_OUT_OF_BOUNDS", bufferOutOfBounds);
    E("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
    E("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s");
    E("ERR_CPU_USAGE", "Unable to obtain cpu usage %s");
    E("ERR_DNS_SET_SERVERS_FAILED", (err, servers) => `c-ares failed to set servers: "${err}" [${servers}]`);
    E("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
    E("ERR_ENCODING_NOT_SUPPORTED", (enc) => `The "${enc}" encoding is not supported`);
    E("ERR_ENCODING_INVALID_ENCODED_DATA", (enc) => `The encoded data was not valid for encoding ${enc}`);
    E("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client");
    E("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s");
    E("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding");
    E("ERR_INDEX_OUT_OF_RANGE", "Index out of range");
    E("ERR_INVALID_ARG_TYPE", invalidArgType);
    E("ERR_INVALID_ARRAY_LENGTH", (name, len, actual) => {
      assert4.strictEqual(typeof actual, "number");
      return `The array "${name}" (length ${actual}) must be of length ${len}.`;
    });
    E("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s");
    E("ERR_INVALID_CALLBACK", "Callback must be a function");
    E("ERR_INVALID_CHAR", "Invalid character in %s");
    E("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column");
    E("ERR_INVALID_FD", '"fd" must be a positive integer: %s');
    E("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
    E("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
    E("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent");
    E("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s");
    E("ERR_INVALID_OPT_VALUE", (name, value) => {
      return `The value "${String(value)}" is invalid for option "${name}"`;
    });
    E("ERR_INVALID_OPT_VALUE_ENCODING", (value) => `The value "${String(value)}" is invalid for option "encoding"`);
    E("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
    E("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s");
    E("ERR_INVALID_THIS", 'Value of "this" must be of type %s');
    E("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple");
    E("ERR_INVALID_URL", "Invalid URL: %s");
    E("ERR_INVALID_URL_SCHEME", (expected) => `The URL must be ${oneOf(expected, "scheme")}`);
    E("ERR_IPC_CHANNEL_CLOSED", "Channel closed");
    E("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected");
    E("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe");
    E("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks");
    E("ERR_MISSING_ARGS", missingArgs);
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    E("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function");
    E("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object");
    E("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support");
    E("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported");
    E("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s");
    E("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound");
    E("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536");
    E("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6");
    E("ERR_SOCKET_CANNOT_SEND", "Unable to send data");
    E("ERR_SOCKET_CLOSED", "Socket is closed");
    E("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running");
    E("ERR_STDERR_CLOSE", "process.stderr cannot be closed");
    E("ERR_STDOUT_CLOSE", "process.stdout cannot be closed");
    E("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode");
    E("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s");
    E("ERR_TLS_DH_PARAM_SIZE", (size) => `DH parameter size ${size} is less than 2048`);
    E("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout");
    E("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate");
    E("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext');
    E("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected");
    E("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming");
    E("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0");
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s");
    E("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s");
    E("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type");
    E("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type");
    E("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
    function invalidArgType(name, expected, actual) {
      assert4(name, "name is required");
      let determiner;
      if (expected.includes("not ")) {
        determiner = "must not be";
        expected = expected.split("not ")[1];
      } else {
        determiner = "must be";
      }
      let msg;
      if (Array.isArray(name)) {
        const names = name.map((val) => `"${val}"`).join(", ");
        msg = `The ${names} arguments ${determiner} ${oneOf(expected, "type")}`;
      } else if (name.includes(" argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type2 = name.includes(".") ? "property" : "argument";
        msg = `The "${name}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
      }
      if (arguments.length >= 3) {
        msg += `. Received type ${actual !== null ? typeof actual : "null"}`;
      }
      return msg;
    }
    __name(invalidArgType, "invalidArgType");
    function missingArgs(...args) {
      assert4(args.length > 0, "At least one arg needs to be specified");
      let msg = "The ";
      const len = args.length;
      args = args.map((a) => `"${a}"`);
      switch (len) {
        case 1:
          msg += `${args[0]} argument`;
          break;
        case 2:
          msg += `${args[0]} and ${args[1]} arguments`;
          break;
        default:
          msg += args.slice(0, len - 1).join(", ");
          msg += `, and ${args[len - 1]} arguments`;
          break;
      }
      return `${msg} must be specified`;
    }
    __name(missingArgs, "missingArgs");
    function oneOf(expected, thing) {
      assert4(expected, "expected is required");
      assert4(typeof thing === "string", "thing is required");
      if (Array.isArray(expected)) {
        const len = expected.length;
        assert4(len > 0, "At least one expected value needs to be specified");
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    __name(oneOf, "oneOf");
    function bufferOutOfBounds(name, isWriting) {
      if (isWriting) {
        return "Attempt to write outside buffer bounds";
      } else {
        return `"${name}" is outside of buffer bounds`;
      }
    }
    __name(bufferOutOfBounds, "bufferOutOfBounds");
  })(errors);
  return errors;
}
__name(requireErrors, "requireErrors");
var hasRequiredEncoding;
function requireEncoding() {
  if (hasRequiredEncoding) return encoding;
  hasRequiredEncoding = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ENCODING_UTF8 = void 0;
    exports.assertEncoding = assertEncoding;
    exports.strToEncoding = strToEncoding;
    const buffer_1 = requireBuffer();
    const errors3 = requireErrors();
    exports.ENCODING_UTF8 = "utf8";
    function assertEncoding(encoding2) {
      if (encoding2 && !buffer_1.Buffer.isEncoding(encoding2))
        throw new errors3.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", encoding2);
    }
    __name(assertEncoding, "assertEncoding");
    function strToEncoding(str, encoding2) {
      if (!encoding2 || encoding2 === exports.ENCODING_UTF8)
        return str;
      if (encoding2 === "buffer")
        return new buffer_1.Buffer(str);
      return new buffer_1.Buffer(str).toString(encoding2);
    }
    __name(strToEncoding, "strToEncoding");
  })(encoding);
  return encoding;
}
__name(requireEncoding, "requireEncoding");
var hasRequiredDirent;
function requireDirent() {
  if (hasRequiredDirent) return Dirent$1;
  hasRequiredDirent = 1;
  Object.defineProperty(Dirent$1, "__esModule", { value: true });
  Dirent$1.Dirent = void 0;
  const constants_1 = requireConstants$1();
  const encoding_1 = requireEncoding();
  const { S_IFMT: S_IFMT2, S_IFDIR: S_IFDIR2, S_IFREG: S_IFREG2, S_IFBLK: S_IFBLK2, S_IFCHR: S_IFCHR2, S_IFLNK: S_IFLNK2, S_IFIFO: S_IFIFO2, S_IFSOCK: S_IFSOCK2 } = constants_1.constants;
  class Dirent2 {
    static {
      __name(this, "Dirent");
    }
    constructor() {
      this.name = "";
      this.path = "";
      this.parentPath = "";
      this.mode = 0;
    }
    static build(link2, encoding2) {
      const dirent = new Dirent2();
      const { mode } = link2.getNode();
      dirent.name = (0, encoding_1.strToEncoding)(link2.getName(), encoding2);
      dirent.mode = mode;
      dirent.path = link2.getParentPath();
      dirent.parentPath = dirent.path;
      return dirent;
    }
    _checkModeProperty(property) {
      return (this.mode & S_IFMT2) === property;
    }
    isDirectory() {
      return this._checkModeProperty(S_IFDIR2);
    }
    isFile() {
      return this._checkModeProperty(S_IFREG2);
    }
    isBlockDevice() {
      return this._checkModeProperty(S_IFBLK2);
    }
    isCharacterDevice() {
      return this._checkModeProperty(S_IFCHR2);
    }
    isSymbolicLink() {
      return this._checkModeProperty(S_IFLNK2);
    }
    isFIFO() {
      return this._checkModeProperty(S_IFIFO2);
    }
    isSocket() {
      return this._checkModeProperty(S_IFSOCK2);
    }
  }
  Dirent$1.Dirent = Dirent2;
  Dirent$1.default = Dirent2;
  return Dirent$1;
}
__name(requireDirent, "requireDirent");
var volume = {};
var node = {};
var process$1 = {};
var hasRequiredProcess;
function requireProcess() {
  if (hasRequiredProcess) return process$1;
  hasRequiredProcess = 1;
  Object.defineProperty(process$1, "__esModule", { value: true });
  process$1.createProcess = createProcess;
  const maybeReturnProcess = /* @__PURE__ */ __name(() => {
    if (typeof process !== "undefined") {
      return process;
    }
    try {
      return require_process();
    } catch (_a) {
      return void 0;
    }
  }, "maybeReturnProcess");
  function createProcess() {
    const p = maybeReturnProcess() || {};
    if (!p.cwd)
      p.cwd = () => "/";
    if (!p.emitWarning)
      p.emitWarning = (message, type2) => {
        console.warn(`${type2}${type2 ? ": " : ""}${message}`);
      };
    if (!p.env)
      p.env = {};
    return p;
  }
  __name(createProcess, "createProcess");
  process$1.default = createProcess();
  return process$1;
}
__name(requireProcess, "requireProcess");
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.File = exports.Link = exports.Node = exports.SEP = void 0;
    const process_1 = requireProcess();
    const buffer_1 = requireBuffer();
    const constants_1 = requireConstants$1();
    const events_1 = require$$0$3;
    const Stats_1 = requireStats();
    const { S_IFMT: S_IFMT2, S_IFDIR: S_IFDIR2, S_IFREG: S_IFREG2, S_IFLNK: S_IFLNK2, S_IFCHR: S_IFCHR2, O_APPEND: O_APPEND2 } = constants_1.constants;
    const getuid2 = /* @__PURE__ */ __name(() => {
      var _a, _b;
      return (_b = (_a = process_1.default.getuid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0;
    }, "getuid");
    const getgid2 = /* @__PURE__ */ __name(() => {
      var _a, _b;
      return (_b = (_a = process_1.default.getgid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0;
    }, "getgid");
    exports.SEP = "/";
    class Node2 extends events_1.EventEmitter {
      static {
        __name(this, "Node");
      }
      constructor(ino, mode = 438) {
        super();
        this._uid = getuid2();
        this._gid = getgid2();
        this._atime = /* @__PURE__ */ new Date();
        this._mtime = /* @__PURE__ */ new Date();
        this._ctime = /* @__PURE__ */ new Date();
        this.rdev = 0;
        this._nlink = 1;
        this.mode = mode;
        this.ino = ino;
      }
      set ctime(ctime) {
        this._ctime = ctime;
      }
      get ctime() {
        return this._ctime;
      }
      set uid(uid) {
        this._uid = uid;
        this.ctime = /* @__PURE__ */ new Date();
      }
      get uid() {
        return this._uid;
      }
      set gid(gid) {
        this._gid = gid;
        this.ctime = /* @__PURE__ */ new Date();
      }
      get gid() {
        return this._gid;
      }
      set atime(atime) {
        this._atime = atime;
        this.ctime = /* @__PURE__ */ new Date();
      }
      get atime() {
        return this._atime;
      }
      set mtime(mtime) {
        this._mtime = mtime;
        this.ctime = /* @__PURE__ */ new Date();
      }
      get mtime() {
        return this._mtime;
      }
      get perm() {
        return this.mode & ~S_IFMT2;
      }
      set perm(perm) {
        this.mode = this.mode & S_IFMT2 | perm & ~S_IFMT2;
        this.ctime = /* @__PURE__ */ new Date();
      }
      set nlink(nlink) {
        this._nlink = nlink;
        this.ctime = /* @__PURE__ */ new Date();
      }
      get nlink() {
        return this._nlink;
      }
      getString(encoding2 = "utf8") {
        this.atime = /* @__PURE__ */ new Date();
        return this.getBuffer().toString(encoding2);
      }
      setString(str) {
        this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
        this.touch();
      }
      getBuffer() {
        this.atime = /* @__PURE__ */ new Date();
        if (!this.buf)
          this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
        return (0, buffer_1.bufferFrom)(this.buf);
      }
      setBuffer(buf) {
        this.buf = (0, buffer_1.bufferFrom)(buf);
        this.touch();
      }
      getSize() {
        return this.buf ? this.buf.length : 0;
      }
      setModeProperty(property) {
        this.mode = property;
      }
      isFile() {
        return (this.mode & S_IFMT2) === S_IFREG2;
      }
      isDirectory() {
        return (this.mode & S_IFMT2) === S_IFDIR2;
      }
      isSymlink() {
        return (this.mode & S_IFMT2) === S_IFLNK2;
      }
      isCharacterDevice() {
        return (this.mode & S_IFMT2) === S_IFCHR2;
      }
      makeSymlink(symlink2) {
        this.mode = S_IFLNK2 | 438;
        this.symlink = symlink2;
      }
      write(buf, off2 = 0, len = buf.length, pos = 0) {
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        if (pos + len > this.buf.length) {
          const newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
          this.buf.copy(newBuf, 0, 0, this.buf.length);
          this.buf = newBuf;
        }
        buf.copy(this.buf, pos, off2, off2 + len);
        this.touch();
        return len;
      }
      // Returns the number of bytes read.
      read(buf, off2 = 0, len = buf.byteLength, pos = 0) {
        this.atime = /* @__PURE__ */ new Date();
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        let actualLen = len;
        if (actualLen > buf.byteLength) {
          actualLen = buf.byteLength;
        }
        if (actualLen + pos > this.buf.length) {
          actualLen = this.buf.length - pos;
        }
        const buf2 = buf instanceof buffer_1.Buffer ? buf : buffer_1.Buffer.from(buf.buffer);
        this.buf.copy(buf2, off2, pos, pos + actualLen);
        return actualLen;
      }
      truncate(len = 0) {
        if (!len)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        else {
          if (!this.buf)
            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          if (len <= this.buf.length) {
            this.buf = this.buf.slice(0, len);
          } else {
            const buf = (0, buffer_1.bufferAllocUnsafe)(len);
            this.buf.copy(buf);
            buf.fill(0, this.buf.length);
            this.buf = buf;
          }
        }
        this.touch();
      }
      chmod(perm) {
        this.mode = this.mode & S_IFMT2 | perm & ~S_IFMT2;
        this.touch();
      }
      chown(uid, gid) {
        this.uid = uid;
        this.gid = gid;
        this.touch();
      }
      touch() {
        this.mtime = /* @__PURE__ */ new Date();
        this.emit("change", this);
      }
      canRead(uid = getuid2(), gid = getgid2()) {
        if (this.perm & 4) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 32) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 256) {
            return true;
          }
        }
        return false;
      }
      canWrite(uid = getuid2(), gid = getgid2()) {
        if (this.perm & 2) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 16) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 128) {
            return true;
          }
        }
        return false;
      }
      canExecute(uid = getuid2(), gid = getgid2()) {
        if (this.perm & 1) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 8) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 64) {
            return true;
          }
        }
        return false;
      }
      del() {
        this.emit("delete", this);
      }
      toJSON() {
        return {
          ino: this.ino,
          uid: this.uid,
          gid: this.gid,
          atime: this.atime.getTime(),
          mtime: this.mtime.getTime(),
          ctime: this.ctime.getTime(),
          perm: this.perm,
          mode: this.mode,
          nlink: this.nlink,
          symlink: this.symlink,
          data: this.getString()
        };
      }
    }
    exports.Node = Node2;
    class Link extends events_1.EventEmitter {
      static {
        __name(this, "Link");
      }
      get steps() {
        return this._steps;
      }
      // Recursively sync children steps, e.g. in case of dir rename
      set steps(val) {
        this._steps = val;
        for (const [child, link2] of this.children.entries()) {
          if (child === "." || child === "..") {
            continue;
          }
          link2 === null || link2 === void 0 ? void 0 : link2.syncSteps();
        }
      }
      constructor(vol, parent, name) {
        super();
        this.children = /* @__PURE__ */ new Map();
        this._steps = [];
        this.ino = 0;
        this.length = 0;
        this.vol = vol;
        this.parent = parent;
        this.name = name;
        this.syncSteps();
      }
      setNode(node2) {
        this.node = node2;
        this.ino = node2.ino;
      }
      getNode() {
        return this.node;
      }
      createChild(name, node2 = this.vol.createNode(S_IFREG2 | 438)) {
        const link2 = new Link(this.vol, this, name);
        link2.setNode(node2);
        if (node2.isDirectory()) {
          link2.children.set(".", link2);
          link2.getNode().nlink++;
        }
        this.setChild(name, link2);
        return link2;
      }
      setChild(name, link2 = new Link(this.vol, this, name)) {
        this.children.set(name, link2);
        link2.parent = this;
        this.length++;
        const node2 = link2.getNode();
        if (node2.isDirectory()) {
          link2.children.set("..", this);
          this.getNode().nlink++;
        }
        this.getNode().mtime = /* @__PURE__ */ new Date();
        this.emit("child:add", link2, this);
        return link2;
      }
      deleteChild(link2) {
        const node2 = link2.getNode();
        if (node2.isDirectory()) {
          link2.children.delete("..");
          this.getNode().nlink--;
        }
        this.children.delete(link2.getName());
        this.length--;
        this.getNode().mtime = /* @__PURE__ */ new Date();
        this.emit("child:delete", link2, this);
      }
      getChild(name) {
        this.getNode().mtime = /* @__PURE__ */ new Date();
        return this.children.get(name);
      }
      getPath() {
        return this.steps.join(exports.SEP);
      }
      getParentPath() {
        return this.steps.slice(0, -1).join(exports.SEP);
      }
      getName() {
        return this.steps[this.steps.length - 1];
      }
      // del() {
      //     const parent = this.parent;
      //     if(parent) {
      //         parent.deleteChild(link);
      //     }
      //     this.parent = null;
      //     this.vol = null;
      // }
      toJSON() {
        return {
          steps: this.steps,
          ino: this.ino,
          children: Array.from(this.children.keys())
        };
      }
      syncSteps() {
        this.steps = this.parent ? this.parent.steps.concat([this.name]) : [this.name];
      }
    }
    exports.Link = Link;
    class File {
      static {
        __name(this, "File");
      }
      /**
       * Open a Link-Node pair. `node` is provided separately as that might be a different node
       * rather the one `link` points to, because it might be a symlink.
       * @param link
       * @param node
       * @param flags
       * @param fd
       */
      constructor(link2, node2, flags, fd) {
        this.link = link2;
        this.node = node2;
        this.flags = flags;
        this.fd = fd;
        this.position = 0;
        if (this.flags & O_APPEND2)
          this.position = this.getSize();
      }
      getString(encoding2 = "utf8") {
        return this.node.getString();
      }
      setString(str) {
        this.node.setString(str);
      }
      getBuffer() {
        return this.node.getBuffer();
      }
      setBuffer(buf) {
        this.node.setBuffer(buf);
      }
      getSize() {
        return this.node.getSize();
      }
      truncate(len) {
        this.node.truncate(len);
      }
      seekTo(position) {
        this.position = position;
      }
      stats() {
        return Stats_1.default.build(this.node);
      }
      write(buf, offset = 0, length = buf.length, position) {
        if (typeof position !== "number")
          position = this.position;
        const bytes = this.node.write(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
      }
      read(buf, offset = 0, length = buf.byteLength, position) {
        if (typeof position !== "number")
          position = this.position;
        const bytes = this.node.read(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
      }
      chmod(perm) {
        this.node.chmod(perm);
      }
      chown(uid, gid) {
        this.node.chown(uid, gid);
      }
    }
    exports.File = File;
  })(node);
  return node;
}
__name(requireNode, "requireNode");
var setImmediate$1 = {};
var hasRequiredSetImmediate;
function requireSetImmediate() {
  if (hasRequiredSetImmediate) return setImmediate$1;
  hasRequiredSetImmediate = 1;
  Object.defineProperty(setImmediate$1, "__esModule", { value: true });
  let _setImmediate;
  if (typeof setImmediate === "function")
    _setImmediate = setImmediate.bind(typeof globalThis !== "undefined" ? globalThis : commonjsGlobal);
  else
    _setImmediate = setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : commonjsGlobal);
  setImmediate$1.default = _setImmediate;
  return setImmediate$1;
}
__name(requireSetImmediate, "requireSetImmediate");
var queueMicrotask$1 = {};
var hasRequiredQueueMicrotask;
function requireQueueMicrotask() {
  if (hasRequiredQueueMicrotask) return queueMicrotask$1;
  hasRequiredQueueMicrotask = 1;
  Object.defineProperty(queueMicrotask$1, "__esModule", { value: true });
  queueMicrotask$1.default = typeof queueMicrotask === "function" ? queueMicrotask : (cb) => Promise.resolve().then(() => cb()).catch(() => {
  });
  return queueMicrotask$1;
}
__name(requireQueueMicrotask, "requireQueueMicrotask");
var setTimeoutUnref = {};
var hasRequiredSetTimeoutUnref;
function requireSetTimeoutUnref() {
  if (hasRequiredSetTimeoutUnref) return setTimeoutUnref;
  hasRequiredSetTimeoutUnref = 1;
  Object.defineProperty(setTimeoutUnref, "__esModule", { value: true });
  function setTimeoutUnref$1(callback, time3, args) {
    const ref = setTimeout.apply(typeof globalThis !== "undefined" ? globalThis : commonjsGlobal, arguments);
    if (ref && typeof ref === "object" && typeof ref.unref === "function")
      ref.unref();
    return ref;
  }
  __name(setTimeoutUnref$1, "setTimeoutUnref$1");
  setTimeoutUnref.default = setTimeoutUnref$1;
  return setTimeoutUnref;
}
__name(requireSetTimeoutUnref, "requireSetTimeoutUnref");
var FileHandle = {};
var util$1 = {};
var constants$1 = {};
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants$1;
  hasRequiredConstants = 1;
  Object.defineProperty(constants$1, "__esModule", { value: true });
  constants$1.FLAGS = constants$1.ERRSTR = void 0;
  const constants_1 = requireConstants$1();
  constants$1.ERRSTR = {
    PATH_STR: "path must be a string, Buffer, or Uint8Array",
    // FD:             'file descriptor must be a unsigned 32-bit integer',
    FD: "fd must be a file descriptor",
    MODE_INT: "mode must be an int",
    CB: "callback must be a function",
    UID: "uid must be an unsigned int",
    GID: "gid must be an unsigned int",
    LEN: "len must be an integer",
    ATIME: "atime must be an integer",
    MTIME: "mtime must be an integer",
    PREFIX: "filename prefix is required",
    BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
    OFFSET: "offset must be an integer",
    LENGTH: "length must be an integer",
    POSITION: "position must be an integer"
  };
  const { O_RDONLY: O_RDONLY2, O_WRONLY: O_WRONLY2, O_RDWR: O_RDWR2, O_CREAT: O_CREAT2, O_EXCL: O_EXCL2, O_TRUNC: O_TRUNC2, O_APPEND: O_APPEND2, O_SYNC: O_SYNC2 } = constants_1.constants;
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2["r"] = O_RDONLY2] = "r";
    FLAGS2[FLAGS2["r+"] = O_RDWR2] = "r+";
    FLAGS2[FLAGS2["rs"] = O_RDONLY2 | O_SYNC2] = "rs";
    FLAGS2[FLAGS2["sr"] = FLAGS2.rs] = "sr";
    FLAGS2[FLAGS2["rs+"] = O_RDWR2 | O_SYNC2] = "rs+";
    FLAGS2[FLAGS2["sr+"] = FLAGS2["rs+"]] = "sr+";
    FLAGS2[FLAGS2["w"] = O_WRONLY2 | O_CREAT2 | O_TRUNC2] = "w";
    FLAGS2[FLAGS2["wx"] = O_WRONLY2 | O_CREAT2 | O_TRUNC2 | O_EXCL2] = "wx";
    FLAGS2[FLAGS2["xw"] = FLAGS2.wx] = "xw";
    FLAGS2[FLAGS2["w+"] = O_RDWR2 | O_CREAT2 | O_TRUNC2] = "w+";
    FLAGS2[FLAGS2["wx+"] = O_RDWR2 | O_CREAT2 | O_TRUNC2 | O_EXCL2] = "wx+";
    FLAGS2[FLAGS2["xw+"] = FLAGS2["wx+"]] = "xw+";
    FLAGS2[FLAGS2["a"] = O_WRONLY2 | O_APPEND2 | O_CREAT2] = "a";
    FLAGS2[FLAGS2["ax"] = O_WRONLY2 | O_APPEND2 | O_CREAT2 | O_EXCL2] = "ax";
    FLAGS2[FLAGS2["xa"] = FLAGS2.ax] = "xa";
    FLAGS2[FLAGS2["a+"] = O_RDWR2 | O_APPEND2 | O_CREAT2] = "a+";
    FLAGS2[FLAGS2["ax+"] = O_RDWR2 | O_APPEND2 | O_CREAT2 | O_EXCL2] = "ax+";
    FLAGS2[FLAGS2["xa+"] = FLAGS2["ax+"]] = "xa+";
  })(FLAGS || (constants$1.FLAGS = FLAGS = {}));
  return constants$1;
}
__name(requireConstants, "requireConstants");
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unixify = exports.getWriteSyncArgs = exports.getWriteArgs = exports.bufToUint8 = exports.isWin = void 0;
    exports.promisify = promisify3;
    exports.validateCallback = validateCallback;
    exports.modeToNumber = modeToNumber;
    exports.nullCheck = nullCheck;
    exports.pathToFilename = pathToFilename;
    exports.createError = createError;
    exports.genRndStr6 = genRndStr6;
    exports.flagsToNumber = flagsToNumber;
    exports.isFd = isFd;
    exports.validateFd = validateFd;
    exports.streamToBuffer = streamToBuffer;
    exports.dataToBuffer = dataToBuffer;
    exports.bufferToEncoding = bufferToEncoding;
    exports.isReadableStream = isReadableStream;
    const constants_1 = requireConstants();
    const errors3 = requireErrors();
    const buffer_1 = requireBuffer();
    const encoding_1 = requireEncoding();
    const buffer_2 = requireBuffer();
    const queueMicrotask_1 = requireQueueMicrotask();
    exports.isWin = process.platform === "win32";
    function promisify3(fs2, fn, getResult = (input) => input) {
      return (...args) => new Promise((resolve, reject) => {
        fs2[fn].bind(fs2)(...args, (error4, result) => {
          if (error4)
            return reject(error4);
          return resolve(getResult(result));
        });
      });
    }
    __name(promisify3, "promisify");
    function validateCallback(callback) {
      if (typeof callback !== "function")
        throw TypeError(constants_1.ERRSTR.CB);
      return callback;
    }
    __name(validateCallback, "validateCallback");
    function _modeToNumber(mode, def) {
      if (typeof mode === "number")
        return mode;
      if (typeof mode === "string")
        return parseInt(mode, 8);
      if (def)
        return modeToNumber(def);
      return void 0;
    }
    __name(_modeToNumber, "_modeToNumber");
    function modeToNumber(mode, def) {
      const result = _modeToNumber(mode, def);
      if (typeof result !== "number" || isNaN(result))
        throw new TypeError(constants_1.ERRSTR.MODE_INT);
      return result;
    }
    __name(modeToNumber, "modeToNumber");
    function nullCheck(path31, callback) {
      if (("" + path31).indexOf("\0") !== -1) {
        const er = new Error("Path must be a string without null bytes");
        er.code = "ENOENT";
        if (typeof callback !== "function")
          throw er;
        (0, queueMicrotask_1.default)(() => {
          callback(er);
        });
        return false;
      }
      return true;
    }
    __name(nullCheck, "nullCheck");
    function getPathFromURLPosix(url4) {
      if (url4.hostname !== "") {
        throw new errors3.TypeError("ERR_INVALID_FILE_URL_HOST", process.platform);
      }
      const pathname = url4.pathname;
      for (let n = 0; n < pathname.length; n++) {
        if (pathname[n] === "%") {
          const third = pathname.codePointAt(n + 2) | 32;
          if (pathname[n + 1] === "2" && third === 102) {
            throw new errors3.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
          }
        }
      }
      return decodeURIComponent(pathname);
    }
    __name(getPathFromURLPosix, "getPathFromURLPosix");
    function pathToFilename(path31) {
      if (path31 instanceof Uint8Array) {
        path31 = (0, buffer_2.bufferFrom)(path31);
      }
      if (typeof path31 !== "string" && !buffer_1.Buffer.isBuffer(path31)) {
        try {
          if (!(path31 instanceof require_url().URL))
            throw new TypeError(constants_1.ERRSTR.PATH_STR);
        } catch (err) {
          throw new TypeError(constants_1.ERRSTR.PATH_STR);
        }
        path31 = getPathFromURLPosix(path31);
      }
      const pathString = String(path31);
      nullCheck(pathString);
      return pathString;
    }
    __name(pathToFilename, "pathToFilename");
    const ENOENT2 = "ENOENT";
    const EBADF2 = "EBADF";
    const EINVAL2 = "EINVAL";
    const EPERM2 = "EPERM";
    const EPROTO2 = "EPROTO";
    const EEXIST2 = "EEXIST";
    const ENOTDIR2 = "ENOTDIR";
    const EMFILE2 = "EMFILE";
    const EACCES2 = "EACCES";
    const EISDIR2 = "EISDIR";
    const ENOTEMPTY2 = "ENOTEMPTY";
    const ENOSYS2 = "ENOSYS";
    const ERR_FS_EISDIR = "ERR_FS_EISDIR";
    const ERR_OUT_OF_RANGE = "ERR_OUT_OF_RANGE";
    function formatError(errorCode, func = "", path31 = "", path210 = "") {
      let pathFormatted = "";
      if (path31)
        pathFormatted = ` '${path31}'`;
      if (path210)
        pathFormatted += ` -> '${path210}'`;
      switch (errorCode) {
        case ENOENT2:
          return `ENOENT: no such file or directory, ${func}${pathFormatted}`;
        case EBADF2:
          return `EBADF: bad file descriptor, ${func}${pathFormatted}`;
        case EINVAL2:
          return `EINVAL: invalid argument, ${func}${pathFormatted}`;
        case EPERM2:
          return `EPERM: operation not permitted, ${func}${pathFormatted}`;
        case EPROTO2:
          return `EPROTO: protocol error, ${func}${pathFormatted}`;
        case EEXIST2:
          return `EEXIST: file already exists, ${func}${pathFormatted}`;
        case ENOTDIR2:
          return `ENOTDIR: not a directory, ${func}${pathFormatted}`;
        case EISDIR2:
          return `EISDIR: illegal operation on a directory, ${func}${pathFormatted}`;
        case EACCES2:
          return `EACCES: permission denied, ${func}${pathFormatted}`;
        case ENOTEMPTY2:
          return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
        case EMFILE2:
          return `EMFILE: too many open files, ${func}${pathFormatted}`;
        case ENOSYS2:
          return `ENOSYS: function not implemented, ${func}${pathFormatted}`;
        case ERR_FS_EISDIR:
          return `[ERR_FS_EISDIR]: Path is a directory: ${func} returned EISDIR (is a directory) ${path31}`;
        case ERR_OUT_OF_RANGE:
          return `[ERR_OUT_OF_RANGE]: value out of range, ${func}${pathFormatted}`;
        default:
          return `${errorCode}: error occurred, ${func}${pathFormatted}`;
      }
    }
    __name(formatError, "formatError");
    function createError(errorCode, func = "", path31 = "", path210 = "", Constructor = Error) {
      const error4 = new Constructor(formatError(errorCode, func, path31, path210));
      error4.code = errorCode;
      if (path31) {
        error4.path = path31;
      }
      return error4;
    }
    __name(createError, "createError");
    function genRndStr6() {
      const str = (Math.random() + 1).toString(36).substring(2, 8);
      if (str.length === 6)
        return str;
      else
        return genRndStr6();
    }
    __name(genRndStr6, "genRndStr6");
    function flagsToNumber(flags) {
      if (typeof flags === "number")
        return flags;
      if (typeof flags === "string") {
        const flagsNum = constants_1.FLAGS[flags];
        if (typeof flagsNum !== "undefined")
          return flagsNum;
      }
      throw new errors3.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
    }
    __name(flagsToNumber, "flagsToNumber");
    function isFd(path31) {
      return path31 >>> 0 === path31;
    }
    __name(isFd, "isFd");
    function validateFd(fd) {
      if (!isFd(fd))
        throw TypeError(constants_1.ERRSTR.FD);
    }
    __name(validateFd, "validateFd");
    function streamToBuffer(stream) {
      const chunks = [];
      return new Promise((resolve, reject) => {
        stream.on("data", (chunk) => chunks.push(chunk));
        stream.on("end", () => resolve(buffer_1.Buffer.concat(chunks)));
        stream.on("error", reject);
      });
    }
    __name(streamToBuffer, "streamToBuffer");
    function dataToBuffer(data, encoding2 = encoding_1.ENCODING_UTF8) {
      if (buffer_1.Buffer.isBuffer(data))
        return data;
      else if (data instanceof Uint8Array)
        return (0, buffer_2.bufferFrom)(data);
      else
        return (0, buffer_2.bufferFrom)(String(data), encoding2);
    }
    __name(dataToBuffer, "dataToBuffer");
    const bufToUint8 = /* @__PURE__ */ __name((buf) => new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength), "bufToUint8");
    exports.bufToUint8 = bufToUint8;
    const getWriteArgs = /* @__PURE__ */ __name((fd, a, b, c, d, e) => {
      validateFd(fd);
      let offset = 0;
      let length;
      let position = null;
      let encoding2;
      let callback;
      const tipa = typeof a;
      const tipb = typeof b;
      const tipc = typeof c;
      const tipd = typeof d;
      if (tipa !== "string") {
        if (tipb === "function") {
          callback = b;
        } else if (tipc === "function") {
          offset = b | 0;
          callback = c;
        } else if (tipd === "function") {
          offset = b | 0;
          length = c;
          callback = d;
        } else {
          offset = b | 0;
          length = c;
          position = d;
          callback = e;
        }
      } else {
        if (tipb === "function") {
          callback = b;
        } else if (tipc === "function") {
          position = b;
          callback = c;
        } else if (tipd === "function") {
          position = b;
          encoding2 = c;
          callback = d;
        }
      }
      const buf = dataToBuffer(a, encoding2);
      if (tipa !== "string") {
        if (typeof length === "undefined")
          length = buf.length;
      } else {
        offset = 0;
        length = buf.length;
      }
      const cb = validateCallback(callback);
      return [fd, tipa === "string", buf, offset, length, position, cb];
    }, "getWriteArgs");
    exports.getWriteArgs = getWriteArgs;
    const getWriteSyncArgs = /* @__PURE__ */ __name((fd, a, b, c, d) => {
      validateFd(fd);
      let encoding2;
      let offset;
      let length;
      let position;
      const isBuffer2 = typeof a !== "string";
      if (isBuffer2) {
        offset = (b || 0) | 0;
        length = c;
        position = d;
      } else {
        position = b;
        encoding2 = c;
      }
      const buf = dataToBuffer(a, encoding2);
      if (isBuffer2) {
        if (typeof length === "undefined") {
          length = buf.length;
        }
      } else {
        offset = 0;
        length = buf.length;
      }
      return [fd, buf, offset || 0, length, position];
    }, "getWriteSyncArgs");
    exports.getWriteSyncArgs = getWriteSyncArgs;
    function bufferToEncoding(buffer2, encoding2) {
      if (!encoding2 || encoding2 === "buffer")
        return buffer2;
      else
        return buffer2.toString(encoding2);
    }
    __name(bufferToEncoding, "bufferToEncoding");
    function isReadableStream(stream) {
      return stream !== null && typeof stream === "object" && typeof stream.pipe === "function" && typeof stream.on === "function" && stream.readable === true;
    }
    __name(isReadableStream, "isReadableStream");
    const isSeparator = /* @__PURE__ */ __name((str, i) => {
      let char = str[i];
      return i > 0 && (char === "/" || exports.isWin && char === "\\");
    }, "isSeparator");
    const removeTrailingSeparator = /* @__PURE__ */ __name((str) => {
      let i = str.length - 1;
      if (i < 2)
        return str;
      while (isSeparator(str, i))
        i--;
      return str.substr(0, i + 1);
    }, "removeTrailingSeparator");
    const normalizePath = /* @__PURE__ */ __name((str, stripTrailing) => {
      if (typeof str !== "string")
        throw new TypeError("expected a string");
      str = str.replace(/[\\\/]+/g, "/");
      if (stripTrailing !== false)
        str = removeTrailingSeparator(str);
      return str;
    }, "normalizePath");
    const unixify = /* @__PURE__ */ __name((filepath, stripTrailing = true) => {
      if (exports.isWin) {
        filepath = normalizePath(filepath, stripTrailing);
        return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
      }
      return filepath;
    }, "unixify");
    exports.unixify = unixify;
  })(util$1);
  return util$1;
}
__name(requireUtil$1, "requireUtil$1");
var hasRequiredFileHandle;
function requireFileHandle() {
  if (hasRequiredFileHandle) return FileHandle;
  hasRequiredFileHandle = 1;
  Object.defineProperty(FileHandle, "__esModule", { value: true });
  FileHandle.FileHandle = void 0;
  const util_1 = requireUtil$1();
  let FileHandle$1 = class FileHandle {
    static {
      __name(this, "FileHandle");
    }
    constructor(fs2, fd) {
      this.fs = fs2;
      this.fd = fd;
    }
    appendFile(data, options2) {
      return (0, util_1.promisify)(this.fs, "appendFile")(this.fd, data, options2);
    }
    chmod(mode) {
      return (0, util_1.promisify)(this.fs, "fchmod")(this.fd, mode);
    }
    chown(uid, gid) {
      return (0, util_1.promisify)(this.fs, "fchown")(this.fd, uid, gid);
    }
    close() {
      return (0, util_1.promisify)(this.fs, "close")(this.fd);
    }
    datasync() {
      return (0, util_1.promisify)(this.fs, "fdatasync")(this.fd);
    }
    createReadStream(options2) {
      return this.fs.createReadStream("", Object.assign(Object.assign({}, options2), { fd: this }));
    }
    createWriteStream(options2) {
      return this.fs.createWriteStream("", Object.assign(Object.assign({}, options2), { fd: this }));
    }
    readableWebStream(options2) {
      return new ReadableStream({
        pull: /* @__PURE__ */ __name(async (controller) => {
          const data = await this.readFile();
          controller.enqueue(data);
          controller.close();
        }, "pull")
      });
    }
    read(buffer2, offset, length, position) {
      return (0, util_1.promisify)(this.fs, "read", (bytesRead) => ({ bytesRead, buffer: buffer2 }))(this.fd, buffer2, offset, length, position);
    }
    readv(buffers, position) {
      return (0, util_1.promisify)(this.fs, "readv", (bytesRead) => ({ bytesRead, buffers }))(this.fd, buffers, position);
    }
    readFile(options2) {
      return (0, util_1.promisify)(this.fs, "readFile")(this.fd, options2);
    }
    stat(options2) {
      return (0, util_1.promisify)(this.fs, "fstat")(this.fd, options2);
    }
    sync() {
      return (0, util_1.promisify)(this.fs, "fsync")(this.fd);
    }
    truncate(len) {
      return (0, util_1.promisify)(this.fs, "ftruncate")(this.fd, len);
    }
    utimes(atime, mtime) {
      return (0, util_1.promisify)(this.fs, "futimes")(this.fd, atime, mtime);
    }
    write(buffer2, offset, length, position) {
      return (0, util_1.promisify)(this.fs, "write", (bytesWritten) => ({ bytesWritten, buffer: buffer2 }))(this.fd, buffer2, offset, length, position);
    }
    writev(buffers, position) {
      return (0, util_1.promisify)(this.fs, "writev", (bytesWritten) => ({ bytesWritten, buffers }))(this.fd, buffers, position);
    }
    writeFile(data, options2) {
      return (0, util_1.promisify)(this.fs, "writeFile")(this.fd, data, options2);
    }
  };
  FileHandle.FileHandle = FileHandle$1;
  return FileHandle;
}
__name(requireFileHandle, "requireFileHandle");
var FsPromises = {};
var hasRequiredFsPromises;
function requireFsPromises() {
  if (hasRequiredFsPromises) return FsPromises;
  hasRequiredFsPromises = 1;
  Object.defineProperty(FsPromises, "__esModule", { value: true });
  FsPromises.FsPromises = void 0;
  const util_1 = requireUtil$1();
  const constants_1 = requireConstants$1();
  let FsPromises$1 = class FsPromises {
    static {
      __name(this, "FsPromises");
    }
    constructor(fs2, FileHandle2) {
      this.fs = fs2;
      this.FileHandle = FileHandle2;
      this.constants = constants_1.constants;
      this.cp = (0, util_1.promisify)(this.fs, "cp");
      this.opendir = (0, util_1.promisify)(this.fs, "opendir");
      this.statfs = (0, util_1.promisify)(this.fs, "statfs");
      this.lutimes = (0, util_1.promisify)(this.fs, "lutimes");
      this.access = (0, util_1.promisify)(this.fs, "access");
      this.chmod = (0, util_1.promisify)(this.fs, "chmod");
      this.chown = (0, util_1.promisify)(this.fs, "chown");
      this.copyFile = (0, util_1.promisify)(this.fs, "copyFile");
      this.lchmod = (0, util_1.promisify)(this.fs, "lchmod");
      this.lchown = (0, util_1.promisify)(this.fs, "lchown");
      this.link = (0, util_1.promisify)(this.fs, "link");
      this.lstat = (0, util_1.promisify)(this.fs, "lstat");
      this.mkdir = (0, util_1.promisify)(this.fs, "mkdir");
      this.mkdtemp = (0, util_1.promisify)(this.fs, "mkdtemp");
      this.readdir = (0, util_1.promisify)(this.fs, "readdir");
      this.readlink = (0, util_1.promisify)(this.fs, "readlink");
      this.realpath = (0, util_1.promisify)(this.fs, "realpath");
      this.rename = (0, util_1.promisify)(this.fs, "rename");
      this.rmdir = (0, util_1.promisify)(this.fs, "rmdir");
      this.rm = (0, util_1.promisify)(this.fs, "rm");
      this.stat = (0, util_1.promisify)(this.fs, "stat");
      this.symlink = (0, util_1.promisify)(this.fs, "symlink");
      this.truncate = (0, util_1.promisify)(this.fs, "truncate");
      this.unlink = (0, util_1.promisify)(this.fs, "unlink");
      this.utimes = (0, util_1.promisify)(this.fs, "utimes");
      this.readFile = (id, options2) => {
        return (0, util_1.promisify)(this.fs, "readFile")(id instanceof this.FileHandle ? id.fd : id, options2);
      };
      this.appendFile = (path31, data, options2) => {
        return (0, util_1.promisify)(this.fs, "appendFile")(path31 instanceof this.FileHandle ? path31.fd : path31, data, options2);
      };
      this.open = (path31, flags = "r", mode) => {
        return (0, util_1.promisify)(this.fs, "open", (fd) => new this.FileHandle(this.fs, fd))(path31, flags, mode);
      };
      this.writeFile = (id, data, options2) => {
        const dataPromise = (0, util_1.isReadableStream)(data) ? (0, util_1.streamToBuffer)(data) : Promise.resolve(data);
        return dataPromise.then((data2) => (0, util_1.promisify)(this.fs, "writeFile")(id instanceof this.FileHandle ? id.fd : id, data2, options2));
      };
      this.watch = () => {
        throw new Error("Not implemented");
      };
    }
  };
  FsPromises.FsPromises = FsPromises$1;
  return FsPromises;
}
__name(requireFsPromises, "requireFsPromises");
var print = {};
var lib = {};
var extendStatics = /* @__PURE__ */ __name(function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
}, "extendStatics");
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  __name(__, "__");
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
__name(__extends, "__extends");
var __assign = /* @__PURE__ */ __name(function() {
  __assign = Object.assign || /* @__PURE__ */ __name(function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  }, "__assign");
  return __assign.apply(this, arguments);
}, "__assign");
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
__name(__rest, "__rest");
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(__decorate, "__decorate");
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
__name(__param, "__param");
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context2 = {};
    for (var p in contextIn) context2[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context2.access[p] = contextIn.access[p];
    context2.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
__name(__esDecorate, "__esDecorate");
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
__name(__runInitializers, "__runInitializers");
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
__name(__propKey, "__propKey");
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
__name(__setFunctionName, "__setFunctionName");
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
__name(__metadata, "__metadata");
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
__name(__awaiter, "__awaiter");
function __generator(thisArg, body) {
  var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, "sent"), trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  __name(verb, "verb");
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
  __name(step, "step");
}
__name(__generator, "__generator");
var __createBinding = Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return m[k];
    }, "get") };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
};
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
__name(__exportStar, "__exportStar");
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: /* @__PURE__ */ __name(function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }, "next")
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
__name(__values, "__values");
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error4) {
    e = { error: error4 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
__name(__read, "__read");
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
__name(__spread, "__spread");
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
__name(__spreadArrays, "__spreadArrays");
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
__name(__spreadArray, "__spreadArray");
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
__name(__await, "__await");
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  __name(awaitReturn, "awaitReturn");
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  __name(verb, "verb");
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  __name(resume, "resume");
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  __name(step, "step");
  function fulfill(value) {
    resume("next", value);
  }
  __name(fulfill, "fulfill");
  function reject(value) {
    resume("throw", value);
  }
  __name(reject, "reject");
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
  __name(settle, "settle");
}
__name(__asyncGenerator, "__asyncGenerator");
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
  __name(verb, "verb");
}
__name(__asyncDelegator, "__asyncDelegator");
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  __name(verb, "verb");
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
  __name(settle, "settle");
}
__name(__asyncValues, "__asyncValues");
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
__name(__makeTemplateObject, "__makeTemplateObject");
var __setModuleDefault = Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
};
var ownKeys = /* @__PURE__ */ __name(function(o) {
  ownKeys = Object.getOwnPropertyNames || function(o2) {
    var ar = [];
    for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
}, "ownKeys");
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  }
  __setModuleDefault(result, mod);
  return result;
}
__name(__importStar, "__importStar");
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
__name(__importDefault, "__importDefault");
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
__name(__classPrivateFieldGet, "__classPrivateFieldGet");
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
__name(__classPrivateFieldSet, "__classPrivateFieldSet");
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
__name(__classPrivateFieldIn, "__classPrivateFieldIn");
function __addDisposableResource(env3, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = /* @__PURE__ */ __name(function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    }, "dispose");
    env3.stack.push({ value, dispose, async });
  } else if (async) {
    env3.stack.push({ async: true });
  }
  return value;
}
__name(__addDisposableResource, "__addDisposableResource");
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error4, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error4, e.suppressed = suppressed, e;
};
function __disposeResources(env3) {
  function fail(e) {
    env3.error = env3.hasError ? new _SuppressedError(e, env3.error, "An error was suppressed during disposal.") : e;
    env3.hasError = true;
  }
  __name(fail, "fail");
  var r, s = 0;
  function next() {
    while (r = env3.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env3.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env3.hasError ? Promise.reject(env3.error) : Promise.resolve();
    if (env3.hasError) throw env3.error;
  }
  __name(next, "next");
  return next();
}
__name(__disposeResources, "__disposeResources");
function __rewriteRelativeImportExtension(path31, preserveJsx) {
  if (typeof path31 === "string" && /^\.\.?\//.test(path31)) {
    return path31.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path31;
}
__name(__rewriteRelativeImportExtension, "__rewriteRelativeImportExtension");
var tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
};
var tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __rewriteRelativeImportExtension,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
var printTree = {};
var hasRequiredPrintTree;
function requirePrintTree() {
  if (hasRequiredPrintTree) return printTree;
  hasRequiredPrintTree = 1;
  Object.defineProperty(printTree, "__esModule", { value: true });
  printTree.printTree = void 0;
  const printTree$1 = /* @__PURE__ */ __name((tab = "", children) => {
    let str = "";
    let last = children.length - 1;
    for (; last >= 0; last--)
      if (children[last])
        break;
    for (let i = 0; i <= last; i++) {
      const fn = children[i];
      if (!fn)
        continue;
      const isLast = i === last;
      const child = fn(tab + (isLast ? " " : "\u2502") + "  ");
      const branch = child ? isLast ? "\u2514\u2500" : "\u251C\u2500" : "\u2502";
      str += "\n" + tab + branch + (child ? " " + child : "");
    }
    return str;
  }, "printTree$1");
  printTree.printTree = printTree$1;
  return printTree;
}
__name(requirePrintTree, "requirePrintTree");
var printBinary = {};
var hasRequiredPrintBinary;
function requirePrintBinary() {
  if (hasRequiredPrintBinary) return printBinary;
  hasRequiredPrintBinary = 1;
  Object.defineProperty(printBinary, "__esModule", { value: true });
  printBinary.printBinary = void 0;
  const printBinary$1 = /* @__PURE__ */ __name((tab = "", children) => {
    const left = children[0], right = children[1];
    let str = "";
    if (left)
      str += "\n" + tab + "\u2190 " + left(tab + "  ");
    if (right)
      str += "\n" + tab + "\u2192 " + right(tab + "  ");
    return str;
  }, "printBinary$1");
  printBinary.printBinary = printBinary$1;
  return printBinary;
}
__name(requirePrintBinary, "requirePrintBinary");
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib;
  hasRequiredLib$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requirePrintTree(), exports);
    tslib_1.__exportStar(requirePrintBinary(), exports);
  })(lib);
  return lib;
}
__name(requireLib$1, "requireLib$1");
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", { value: true });
  util.newNotAllowedError = util.newTypeMismatchError = util.newNotFoundError = util.assertCanWrite = util.assertName = util.basename = util.ctx = void 0;
  const ctx = /* @__PURE__ */ __name((partial = {}) => {
    return Object.assign({ separator: "/", syncHandleAllowed: false, mode: "read" }, partial);
  }, "ctx");
  util.ctx = ctx;
  const basename = /* @__PURE__ */ __name((path31, separator) => {
    if (path31[path31.length - 1] === separator)
      path31 = path31.slice(0, -1);
    const lastSlashIndex = path31.lastIndexOf(separator);
    return lastSlashIndex === -1 ? path31 : path31.slice(lastSlashIndex + 1);
  }, "basename");
  util.basename = basename;
  const nameRegex = /^(\.{1,2})$|^(.*([\/\\]).*)$/;
  const assertName = /* @__PURE__ */ __name((name, method, klass) => {
    const isInvalid = !name || nameRegex.test(name);
    if (isInvalid)
      throw new TypeError(`Failed to execute '${method}' on '${klass}': Name is not allowed.`);
  }, "assertName");
  util.assertName = assertName;
  const assertCanWrite = /* @__PURE__ */ __name((mode) => {
    if (mode !== "readwrite")
      throw new DOMException("The request is not allowed by the user agent or the platform in the current context.", "NotAllowedError");
  }, "assertCanWrite");
  util.assertCanWrite = assertCanWrite;
  const newNotFoundError = /* @__PURE__ */ __name(() => new DOMException("A requested file or directory could not be found at the time an operation was processed.", "NotFoundError"), "newNotFoundError");
  util.newNotFoundError = newNotFoundError;
  const newTypeMismatchError = /* @__PURE__ */ __name(() => new DOMException("The path supplied exists, but was not an entry of requested type.", "TypeMismatchError"), "newTypeMismatchError");
  util.newTypeMismatchError = newTypeMismatchError;
  const newNotAllowedError = /* @__PURE__ */ __name(() => new DOMException("Permission not granted.", "NotAllowedError"), "newNotAllowedError");
  util.newNotAllowedError = newNotAllowedError;
  return util;
}
__name(requireUtil, "requireUtil");
var hasRequiredPrint;
function requirePrint() {
  if (hasRequiredPrint) return print;
  hasRequiredPrint = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toTreeSync = void 0;
    const tree_dump_1 = requireLib$1();
    const util_1 = requireUtil();
    const toTreeSync = /* @__PURE__ */ __name((fs2, opts = {}) => {
      var _a;
      const separator = opts.separator || "/";
      let dir3 = opts.dir || separator;
      if (dir3[dir3.length - 1] !== separator)
        dir3 += separator;
      const tab = opts.tab || "";
      const depth = (_a = opts.depth) !== null && _a !== void 0 ? _a : 10;
      let subtree = " (...)";
      if (depth > 0) {
        const list = fs2.readdirSync(dir3, { withFileTypes: true });
        subtree = (0, tree_dump_1.printTree)(tab, list.map((entry) => (tab2) => {
          if (entry.isDirectory()) {
            return (0, exports.toTreeSync)(fs2, { dir: dir3 + entry.name, depth: depth - 1, tab: tab2 });
          } else if (entry.isSymbolicLink()) {
            return "" + entry.name + " \u2192 " + fs2.readlinkSync(dir3 + entry.name);
          } else {
            return "" + entry.name;
          }
        }));
      }
      const base = (0, util_1.basename)(dir3, separator) + separator;
      return base + subtree;
    }, "toTreeSync");
    exports.toTreeSync = toTreeSync;
  })(print);
  return print;
}
__name(requirePrint, "requirePrint");
var options = {};
var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions) return options;
  hasRequiredOptions = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWriteFileOptions = exports.writeFileDefaults = exports.getRealpathOptsAndCb = exports.getRealpathOptions = exports.getStatOptsAndCb = exports.getStatOptions = exports.getAppendFileOptsAndCb = exports.getAppendFileOpts = exports.getOpendirOptsAndCb = exports.getOpendirOptions = exports.getReaddirOptsAndCb = exports.getReaddirOptions = exports.getReadFileOptions = exports.getRmOptsAndCb = exports.getRmdirOptions = exports.getDefaultOptsAndCb = exports.getDefaultOpts = exports.optsDefaults = exports.getMkdirOptions = void 0;
    exports.getOptions = getOptions;
    exports.optsGenerator = optsGenerator;
    exports.optsAndCbGenerator = optsAndCbGenerator;
    const constants_1 = requireConstants();
    const encoding_1 = requireEncoding();
    const util_1 = requireUtil$1();
    const mkdirDefaults = {
      mode: 511,
      recursive: false
    };
    const getMkdirOptions = /* @__PURE__ */ __name((options2) => {
      if (typeof options2 === "number")
        return Object.assign({}, mkdirDefaults, { mode: options2 });
      return Object.assign({}, mkdirDefaults, options2);
    }, "getMkdirOptions");
    exports.getMkdirOptions = getMkdirOptions;
    const ERRSTR_OPTS = /* @__PURE__ */ __name((tipeof) => `Expected options to be either an object or a string, but got ${tipeof} instead`, "ERRSTR_OPTS");
    function getOptions(defaults, options2) {
      let opts;
      if (!options2)
        return defaults;
      else {
        const tipeof = typeof options2;
        switch (tipeof) {
          case "string":
            opts = Object.assign({}, defaults, { encoding: options2 });
            break;
          case "object":
            opts = Object.assign({}, defaults, options2);
            break;
          default:
            throw TypeError(ERRSTR_OPTS(tipeof));
        }
      }
      if (opts.encoding !== "buffer")
        (0, encoding_1.assertEncoding)(opts.encoding);
      return opts;
    }
    __name(getOptions, "getOptions");
    function optsGenerator(defaults) {
      return (options2) => getOptions(defaults, options2);
    }
    __name(optsGenerator, "optsGenerator");
    function optsAndCbGenerator(getOpts) {
      return (options2, callback) => typeof options2 === "function" ? [getOpts(), options2] : [getOpts(options2), (0, util_1.validateCallback)(callback)];
    }
    __name(optsAndCbGenerator, "optsAndCbGenerator");
    exports.optsDefaults = {
      encoding: "utf8"
    };
    exports.getDefaultOpts = optsGenerator(exports.optsDefaults);
    exports.getDefaultOptsAndCb = optsAndCbGenerator(exports.getDefaultOpts);
    const rmdirDefaults = {
      recursive: false
    };
    const getRmdirOptions = /* @__PURE__ */ __name((options2) => {
      return Object.assign({}, rmdirDefaults, options2);
    }, "getRmdirOptions");
    exports.getRmdirOptions = getRmdirOptions;
    const getRmOpts = optsGenerator(exports.optsDefaults);
    exports.getRmOptsAndCb = optsAndCbGenerator(getRmOpts);
    const readFileOptsDefaults = {
      flag: "r"
    };
    exports.getReadFileOptions = optsGenerator(readFileOptsDefaults);
    const readdirDefaults = {
      encoding: "utf8",
      recursive: false,
      withFileTypes: false
    };
    exports.getReaddirOptions = optsGenerator(readdirDefaults);
    exports.getReaddirOptsAndCb = optsAndCbGenerator(exports.getReaddirOptions);
    const opendirDefaults = {
      encoding: "utf8",
      bufferSize: 32,
      recursive: false
    };
    exports.getOpendirOptions = optsGenerator(opendirDefaults);
    exports.getOpendirOptsAndCb = optsAndCbGenerator(exports.getOpendirOptions);
    const appendFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: constants_1.FLAGS[constants_1.FLAGS.a]
    };
    exports.getAppendFileOpts = optsGenerator(appendFileDefaults);
    exports.getAppendFileOptsAndCb = optsAndCbGenerator(exports.getAppendFileOpts);
    const statDefaults = {
      bigint: false
    };
    const getStatOptions = /* @__PURE__ */ __name((options2 = {}) => Object.assign({}, statDefaults, options2), "getStatOptions");
    exports.getStatOptions = getStatOptions;
    const getStatOptsAndCb = /* @__PURE__ */ __name((options2, callback) => typeof options2 === "function" ? [(0, exports.getStatOptions)(), options2] : [(0, exports.getStatOptions)(options2), (0, util_1.validateCallback)(callback)], "getStatOptsAndCb");
    exports.getStatOptsAndCb = getStatOptsAndCb;
    const realpathDefaults = exports.optsDefaults;
    exports.getRealpathOptions = optsGenerator(realpathDefaults);
    exports.getRealpathOptsAndCb = optsAndCbGenerator(exports.getRealpathOptions);
    exports.writeFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: constants_1.FLAGS[constants_1.FLAGS.w]
    };
    exports.getWriteFileOptions = optsGenerator(exports.writeFileDefaults);
  })(options);
  return options;
}
__name(requireOptions, "requireOptions");
var Dir = {};
var hasRequiredDir;
function requireDir() {
  if (hasRequiredDir) return Dir;
  hasRequiredDir = 1;
  Object.defineProperty(Dir, "__esModule", { value: true });
  Dir.Dir = void 0;
  const util_1 = requireUtil$1();
  const Dirent_1 = requireDirent();
  let Dir$1 = class Dir {
    static {
      __name(this, "Dir");
    }
    constructor(link2, options2) {
      this.link = link2;
      this.options = options2;
      this.iteratorInfo = [];
      this.path = link2.getParentPath();
      this.iteratorInfo.push(link2.children[Symbol.iterator]());
    }
    wrapAsync(method, args, callback) {
      (0, util_1.validateCallback)(callback);
      setImmediate(() => {
        let result;
        try {
          result = method.apply(this, args);
        } catch (err) {
          callback(err);
          return;
        }
        callback(null, result);
      });
    }
    isFunction(x) {
      return typeof x === "function";
    }
    promisify(obj, fn) {
      return (...args) => new Promise((resolve, reject) => {
        if (this.isFunction(obj[fn])) {
          obj[fn].bind(obj)(...args, (error4, result) => {
            if (error4)
              reject(error4);
            resolve(result);
          });
        } else {
          reject("Not a function");
        }
      });
    }
    closeBase() {
    }
    readBase(iteratorInfo) {
      let done;
      let value;
      let name;
      let link2;
      do {
        do {
          ({ done, value } = iteratorInfo[iteratorInfo.length - 1].next());
          if (!done) {
            [name, link2] = value;
          } else {
            break;
          }
        } while (name === "." || name === "..");
        if (done) {
          iteratorInfo.pop();
          if (iteratorInfo.length === 0) {
            break;
          } else {
            done = false;
          }
        } else {
          if (this.options.recursive && link2.children.size) {
            iteratorInfo.push(link2.children[Symbol.iterator]());
          }
          return Dirent_1.default.build(link2, this.options.encoding);
        }
      } while (!done);
      return null;
    }
    closeBaseAsync(callback) {
      this.wrapAsync(this.closeBase, [], callback);
    }
    close(callback) {
      if (typeof callback === "function") {
        this.closeBaseAsync(callback);
      } else {
        return this.promisify(this, "closeBaseAsync")();
      }
    }
    closeSync() {
      this.closeBase();
    }
    readBaseAsync(callback) {
      this.wrapAsync(this.readBase, [this.iteratorInfo], callback);
    }
    read(callback) {
      if (typeof callback === "function") {
        this.readBaseAsync(callback);
      } else {
        return this.promisify(this, "readBaseAsync")();
      }
    }
    readSync() {
      return this.readBase(this.iteratorInfo);
    }
    [Symbol.asyncIterator]() {
      const iteratorInfo = [];
      const _this = this;
      iteratorInfo.push(_this.link.children[Symbol.iterator]());
      const o = {
        readBaseAsync(callback) {
          _this.wrapAsync(_this.readBase, [iteratorInfo], callback);
        }
      };
      return {
        async next() {
          const dirEnt = await _this.promisify(o, "readBaseAsync")();
          if (dirEnt !== null) {
            return { done: false, value: dirEnt };
          } else {
            return { done: true, value: void 0 };
          }
        },
        [Symbol.asyncIterator]() {
          throw new Error("Not implemented");
        }
      };
    }
  };
  Dir.Dir = Dir$1;
  return Dir;
}
__name(requireDir, "requireDir");
var hasRequiredVolume;
function requireVolume() {
  if (hasRequiredVolume) return volume;
  hasRequiredVolume = 1;
  Object.defineProperty(volume, "__esModule", { value: true });
  volume.FSWatcher = volume.StatWatcher = volume.Volume = void 0;
  volume.filenameToSteps = filenameToSteps;
  volume.pathToSteps = pathToSteps;
  volume.dataToStr = dataToStr;
  volume.toUnixTimestamp = toUnixTimestamp;
  const pathModule = path;
  const node_1 = requireNode();
  const Stats_1 = requireStats();
  const Dirent_1 = requireDirent();
  const buffer_1 = requireBuffer();
  const setImmediate_1 = requireSetImmediate();
  const queueMicrotask_1 = requireQueueMicrotask();
  const process_1 = requireProcess();
  const setTimeoutUnref_1 = requireSetTimeoutUnref();
  const stream_1 = require$$6;
  const constants_1 = requireConstants$1();
  const events_1 = require$$0$3;
  const encoding_1 = requireEncoding();
  const FileHandle_1 = requireFileHandle();
  const util3 = util_default;
  const FsPromises_1 = requireFsPromises();
  const print_1 = requirePrint();
  const constants_2 = requireConstants();
  const options_1 = requireOptions();
  const util_1 = requireUtil$1();
  const Dir_1 = requireDir();
  const resolveCrossPlatform = pathModule.resolve;
  const { O_RDONLY: O_RDONLY2, O_WRONLY: O_WRONLY2, O_RDWR: O_RDWR2, O_CREAT: O_CREAT2, O_EXCL: O_EXCL2, O_TRUNC: O_TRUNC2, O_APPEND: O_APPEND2, O_DIRECTORY: O_DIRECTORY2, O_SYMLINK, F_OK: F_OK2, COPYFILE_EXCL: COPYFILE_EXCL2, COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE2 } = constants_1.constants;
  const { sep, relative, join: join2, dirname } = pathModule.posix ? pathModule.posix : pathModule;
  const kMinPoolSpace = 128;
  const EPERM2 = "EPERM";
  const ENOENT2 = "ENOENT";
  const EBADF2 = "EBADF";
  const EINVAL2 = "EINVAL";
  const EEXIST2 = "EEXIST";
  const ENOTDIR2 = "ENOTDIR";
  const EMFILE2 = "EMFILE";
  const EACCES2 = "EACCES";
  const EISDIR2 = "EISDIR";
  const ENOTEMPTY2 = "ENOTEMPTY";
  const ENOSYS2 = "ENOSYS";
  const ERR_FS_EISDIR = "ERR_FS_EISDIR";
  const ERR_OUT_OF_RANGE = "ERR_OUT_OF_RANGE";
  let resolve = /* @__PURE__ */ __name((filename, base = process_1.default.cwd()) => resolveCrossPlatform(base, filename), "resolve");
  if (util_1.isWin) {
    const _resolve = resolve;
    resolve = /* @__PURE__ */ __name((filename, base) => (0, util_1.unixify)(_resolve(filename, base)), "resolve");
  }
  function filenameToSteps(filename, base) {
    const fullPath = resolve(filename, base);
    const fullPathSansSlash = fullPath.substring(1);
    if (!fullPathSansSlash)
      return [];
    return fullPathSansSlash.split(sep);
  }
  __name(filenameToSteps, "filenameToSteps");
  function pathToSteps(path31) {
    return filenameToSteps((0, util_1.pathToFilename)(path31));
  }
  __name(pathToSteps, "pathToSteps");
  function dataToStr(data, encoding2 = encoding_1.ENCODING_UTF8) {
    if (buffer_1.Buffer.isBuffer(data))
      return data.toString(encoding2);
    else if (data instanceof Uint8Array)
      return (0, buffer_1.bufferFrom)(data).toString(encoding2);
    else
      return String(data);
  }
  __name(dataToStr, "dataToStr");
  function toUnixTimestamp(time3) {
    if (typeof time3 === "string" && +time3 == time3) {
      return +time3;
    }
    if (time3 instanceof Date) {
      return time3.getTime() / 1e3;
    }
    if (isFinite(time3)) {
      if (time3 < 0) {
        return Date.now() / 1e3;
      }
      return time3;
    }
    throw new Error("Cannot parse time: " + time3);
  }
  __name(toUnixTimestamp, "toUnixTimestamp");
  function validateUid(uid) {
    if (typeof uid !== "number")
      throw TypeError(constants_2.ERRSTR.UID);
  }
  __name(validateUid, "validateUid");
  function validateGid(gid) {
    if (typeof gid !== "number")
      throw TypeError(constants_2.ERRSTR.GID);
  }
  __name(validateGid, "validateGid");
  function flattenJSON(nestedJSON) {
    const flatJSON = {};
    function flatten(pathPrefix, node2) {
      for (const path31 in node2) {
        const contentOrNode = node2[path31];
        const joinedPath = join2(pathPrefix, path31);
        if (typeof contentOrNode === "string" || contentOrNode instanceof buffer_1.Buffer) {
          flatJSON[joinedPath] = contentOrNode;
        } else if (typeof contentOrNode === "object" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
          flatten(joinedPath, contentOrNode);
        } else {
          flatJSON[joinedPath] = null;
        }
      }
    }
    __name(flatten, "flatten");
    flatten("", nestedJSON);
    return flatJSON;
  }
  __name(flattenJSON, "flattenJSON");
  const notImplemented2 = /* @__PURE__ */ __name(() => {
    throw new Error("Not implemented");
  }, "notImplemented");
  class Volume {
    static {
      __name(this, "Volume");
    }
    static fromJSON(json, cwd2) {
      const vol = new Volume();
      vol.fromJSON(json, cwd2);
      return vol;
    }
    static fromNestedJSON(json, cwd2) {
      const vol = new Volume();
      vol.fromNestedJSON(json, cwd2);
      return vol;
    }
    get promises() {
      if (this.promisesApi === null)
        throw new Error("Promise is not supported in this environment.");
      return this.promisesApi;
    }
    constructor(props = {}) {
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.maxFiles = 1e4;
      this.openFiles = 0;
      this.promisesApi = new FsPromises_1.FsPromises(this, FileHandle_1.FileHandle);
      this.statWatchers = {};
      this.cpSync = notImplemented2;
      this.statfsSync = notImplemented2;
      this.cp = notImplemented2;
      this.statfs = notImplemented2;
      this.openAsBlob = notImplemented2;
      this.props = Object.assign({ Node: node_1.Node, Link: node_1.Link, File: node_1.File }, props);
      const root = this.createLink();
      root.setNode(this.createNode(constants_1.constants.S_IFDIR | 511));
      const self2 = this;
      this.StatWatcher = class extends StatWatcher {
        constructor() {
          super(self2);
        }
      };
      const _ReadStream = FsReadStream;
      this.ReadStream = class extends _ReadStream {
        constructor(...args) {
          super(self2, ...args);
        }
      };
      const _WriteStream = FsWriteStream;
      this.WriteStream = class extends _WriteStream {
        constructor(...args) {
          super(self2, ...args);
        }
      };
      this.FSWatcher = class extends FSWatcher {
        constructor() {
          super(self2);
        }
      };
      root.setChild(".", root);
      root.getNode().nlink++;
      root.setChild("..", root);
      root.getNode().nlink++;
      this.root = root;
    }
    createLink(parent, name, isDirectory = false, mode) {
      if (!parent) {
        return new this.props.Link(this, null, "");
      }
      if (!name) {
        throw new Error("createLink: name cannot be empty");
      }
      const finalPerm = mode !== null && mode !== void 0 ? mode : isDirectory ? 511 : 438;
      const hasFileType = mode && mode & constants_1.constants.S_IFMT;
      const modeType = hasFileType ? mode & constants_1.constants.S_IFMT : isDirectory ? constants_1.constants.S_IFDIR : constants_1.constants.S_IFREG;
      const finalMode = finalPerm & ~constants_1.constants.S_IFMT | modeType;
      return parent.createChild(name, this.createNode(finalMode));
    }
    deleteLink(link2) {
      const parent = link2.parent;
      if (parent) {
        parent.deleteChild(link2);
        return true;
      }
      return false;
    }
    newInoNumber() {
      const releasedFd = this.releasedInos.pop();
      if (releasedFd)
        return releasedFd;
      else {
        this.ino = (this.ino + 1) % 4294967295;
        return this.ino;
      }
    }
    newFdNumber() {
      const releasedFd = this.releasedFds.pop();
      return typeof releasedFd === "number" ? releasedFd : Volume.fd--;
    }
    createNode(mode) {
      const node2 = new this.props.Node(this.newInoNumber(), mode);
      this.inodes[node2.ino] = node2;
      return node2;
    }
    deleteNode(node2) {
      node2.del();
      delete this.inodes[node2.ino];
      this.releasedInos.push(node2.ino);
    }
    walk(stepsOrFilenameOrLink, resolveSymlinks = false, checkExistence = false, checkAccess = false, funcName) {
      var _a;
      let steps;
      let filename;
      if (stepsOrFilenameOrLink instanceof node_1.Link) {
        steps = stepsOrFilenameOrLink.steps;
        filename = sep + steps.join(sep);
      } else if (typeof stepsOrFilenameOrLink === "string") {
        steps = filenameToSteps(stepsOrFilenameOrLink);
        filename = stepsOrFilenameOrLink;
      } else {
        steps = stepsOrFilenameOrLink;
        filename = sep + steps.join(sep);
      }
      let curr = this.root;
      let i = 0;
      while (i < steps.length) {
        let node2 = curr.getNode();
        if (node2.isDirectory()) {
          if (checkAccess && !node2.canExecute()) {
            throw (0, util_1.createError)(EACCES2, funcName, filename);
          }
        } else {
          if (i < steps.length - 1)
            throw (0, util_1.createError)(ENOTDIR2, funcName, filename);
        }
        curr = (_a = curr.getChild(steps[i])) !== null && _a !== void 0 ? _a : null;
        if (!curr)
          if (checkExistence)
            throw (0, util_1.createError)(ENOENT2, funcName, filename);
          else
            return null;
        node2 = curr === null || curr === void 0 ? void 0 : curr.getNode();
        if (resolveSymlinks && node2.isSymlink()) {
          const resolvedPath = pathModule.isAbsolute(node2.symlink) ? node2.symlink : join2(pathModule.dirname(curr.getPath()), node2.symlink);
          steps = filenameToSteps(resolvedPath).concat(steps.slice(i + 1));
          curr = this.root;
          i = 0;
          continue;
        }
        i++;
      }
      return curr;
    }
    // Returns a `Link` (hard link) referenced by path "split" into steps.
    getLink(steps) {
      return this.walk(steps, false, false, false);
    }
    // Just link `getLink`, but throws a correct user error, if link to found.
    getLinkOrThrow(filename, funcName) {
      return this.walk(filename, false, true, true, funcName);
    }
    // Just like `getLink`, but also dereference/resolves symbolic links.
    getResolvedLink(filenameOrSteps) {
      return this.walk(filenameOrSteps, true, false, false);
    }
    // Just like `getLinkOrThrow`, but also dereference/resolves symbolic links.
    getResolvedLinkOrThrow(filename, funcName) {
      return this.walk(filename, true, true, true, funcName);
    }
    resolveSymlinks(link2) {
      return this.getResolvedLink(link2.steps.slice(1));
    }
    // Just like `getLinkOrThrow`, but also verifies that the link is a directory.
    getLinkAsDirOrThrow(filename, funcName) {
      const link2 = this.getLinkOrThrow(filename, funcName);
      if (!link2.getNode().isDirectory())
        throw (0, util_1.createError)(ENOTDIR2, funcName, filename);
      return link2;
    }
    // Get the immediate parent directory of the link.
    getLinkParent(steps) {
      return this.getLink(steps.slice(0, -1));
    }
    getLinkParentAsDirOrThrow(filenameOrSteps, funcName) {
      const steps = (filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps)).slice(0, -1);
      const filename = sep + steps.join(sep);
      const link2 = this.getLinkOrThrow(filename, funcName);
      if (!link2.getNode().isDirectory())
        throw (0, util_1.createError)(ENOTDIR2, funcName, filename);
      return link2;
    }
    getFileByFd(fd) {
      return this.fds[String(fd)];
    }
    getFileByFdOrThrow(fd, funcName) {
      if (!(0, util_1.isFd)(fd))
        throw TypeError(constants_2.ERRSTR.FD);
      const file = this.getFileByFd(fd);
      if (!file)
        throw (0, util_1.createError)(EBADF2, funcName);
      return file;
    }
    /**
     * @todo This is not used anymore. Remove.
     */
    /*
      private getNodeByIdOrCreate(id: TFileId, flags: number, perm: number): Node {
        if (typeof id === 'number') {
          const file = this.getFileByFd(id);
          if (!file) throw Error('File nto found');
          return file.node;
        } else {
          const steps = pathToSteps(id as PathLike);
          let link = this.getLink(steps);
          if (link) return link.getNode();

          // Try creating a node if not found.
          if (flags & O_CREAT) {
            const dirLink = this.getLinkParent(steps);
            if (dirLink) {
              const name = steps[steps.length - 1];
              link = this.createLink(dirLink, name, false, perm);
              return link.getNode();
            }
          }

          throw createError(ENOENT, 'getNodeByIdOrCreate', pathToFilename(id));
        }
      }
      */
    wrapAsync(method, args, callback) {
      (0, util_1.validateCallback)(callback);
      (0, setImmediate_1.default)(() => {
        let result;
        try {
          result = method.apply(this, args);
        } catch (err) {
          callback(err);
          return;
        }
        callback(null, result);
      });
    }
    _toJSON(link2 = this.root, json = {}, path31, asBuffer) {
      let isEmpty2 = true;
      let children = link2.children;
      if (link2.getNode().isFile()) {
        children = /* @__PURE__ */ new Map([[link2.getName(), link2.parent.getChild(link2.getName())]]);
        link2 = link2.parent;
      }
      for (const name of children.keys()) {
        if (name === "." || name === "..") {
          continue;
        }
        isEmpty2 = false;
        const child = link2.getChild(name);
        if (!child) {
          throw new Error("_toJSON: unexpected undefined");
        }
        const node2 = child.getNode();
        if (node2.isFile()) {
          let filename = child.getPath();
          if (path31)
            filename = relative(path31, filename);
          json[filename] = asBuffer ? node2.getBuffer() : node2.getString();
        } else if (node2.isDirectory()) {
          this._toJSON(child, json, path31, asBuffer);
        }
      }
      let dirPath = link2.getPath();
      if (path31)
        dirPath = relative(path31, dirPath);
      if (dirPath && isEmpty2) {
        json[dirPath] = null;
      }
      return json;
    }
    toJSON(paths, json = {}, isRelative = false, asBuffer = false) {
      const links = [];
      if (paths) {
        if (!Array.isArray(paths))
          paths = [paths];
        for (const path31 of paths) {
          const filename = (0, util_1.pathToFilename)(path31);
          const link2 = this.getResolvedLink(filename);
          if (!link2)
            continue;
          links.push(link2);
        }
      } else {
        links.push(this.root);
      }
      if (!links.length)
        return json;
      for (const link2 of links)
        this._toJSON(link2, json, isRelative ? link2.getPath() : "", asBuffer);
      return json;
    }
    // TODO: `cwd` should probably not invoke `process.cwd()`.
    fromJSON(json, cwd2 = process_1.default.cwd()) {
      for (let filename in json) {
        const data = json[filename];
        filename = resolve(filename, cwd2);
        if (typeof data === "string" || data instanceof buffer_1.Buffer) {
          const dir3 = dirname(filename);
          this.mkdirpBase(
            dir3,
            511
            /* MODE.DIR */
          );
          this.writeFileSync(filename, data);
        } else {
          this.mkdirpBase(
            filename,
            511
            /* MODE.DIR */
          );
        }
      }
    }
    fromNestedJSON(json, cwd2) {
      this.fromJSON(flattenJSON(json), cwd2);
    }
    toTree(opts = { separator: sep }) {
      return (0, print_1.toTreeSync)(this, opts);
    }
    reset() {
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.openFiles = 0;
      this.root = this.createLink();
      this.root.setNode(this.createNode(constants_1.constants.S_IFDIR | 511));
    }
    // Legacy interface
    mountSync(mountpoint, json) {
      this.fromJSON(json, mountpoint);
    }
    openLink(link2, flagsNum, resolveSymlinks = true) {
      if (this.openFiles >= this.maxFiles) {
        throw (0, util_1.createError)(EMFILE2, "open", link2.getPath());
      }
      let realLink = link2;
      if (resolveSymlinks)
        realLink = this.getResolvedLinkOrThrow(link2.getPath(), "open");
      const node2 = realLink.getNode();
      if (node2.isDirectory()) {
        if ((flagsNum & (O_RDONLY2 | O_RDWR2 | O_WRONLY2)) !== O_RDONLY2)
          throw (0, util_1.createError)(EISDIR2, "open", link2.getPath());
      } else {
        if (flagsNum & O_DIRECTORY2)
          throw (0, util_1.createError)(ENOTDIR2, "open", link2.getPath());
      }
      if (!(flagsNum & O_WRONLY2)) {
        if (!node2.canRead()) {
          throw (0, util_1.createError)(EACCES2, "open", link2.getPath());
        }
      }
      if (!(flagsNum & O_RDONLY2)) {
        if (!node2.canWrite()) {
          throw (0, util_1.createError)(EACCES2, "open", link2.getPath());
        }
      }
      const file = new this.props.File(link2, node2, flagsNum, this.newFdNumber());
      this.fds[file.fd] = file;
      this.openFiles++;
      if (flagsNum & O_TRUNC2)
        file.truncate();
      return file;
    }
    openFile(filename, flagsNum, modeNum, resolveSymlinks = true) {
      const steps = filenameToSteps(filename);
      let link2;
      try {
        link2 = resolveSymlinks ? this.getResolvedLinkOrThrow(filename, "open") : this.getLinkOrThrow(filename, "open");
        if (link2 && flagsNum & O_CREAT2 && flagsNum & O_EXCL2)
          throw (0, util_1.createError)(EEXIST2, "open", filename);
      } catch (err) {
        if (err.code === ENOENT2 && flagsNum & O_CREAT2) {
          const dirname2 = pathModule.dirname(filename);
          const dirLink = this.getResolvedLinkOrThrow(dirname2);
          const dirNode = dirLink.getNode();
          if (!dirNode.isDirectory())
            throw (0, util_1.createError)(ENOTDIR2, "open", filename);
          if (!dirNode.canExecute() || !dirNode.canWrite())
            throw (0, util_1.createError)(EACCES2, "open", filename);
          modeNum !== null && modeNum !== void 0 ? modeNum : modeNum = 438;
          link2 = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
        } else
          throw err;
      }
      if (link2)
        return this.openLink(link2, flagsNum, resolveSymlinks);
      throw (0, util_1.createError)(ENOENT2, "open", filename);
    }
    openBase(filename, flagsNum, modeNum, resolveSymlinks = true) {
      const file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
      if (!file)
        throw (0, util_1.createError)(ENOENT2, "open", filename);
      return file.fd;
    }
    openSync(path31, flags, mode = 438) {
      const modeNum = (0, util_1.modeToNumber)(mode);
      const fileName = (0, util_1.pathToFilename)(path31);
      const flagsNum = (0, util_1.flagsToNumber)(flags);
      return this.openBase(fileName, flagsNum, modeNum, !(flagsNum & O_SYMLINK));
    }
    open(path31, flags, a, b) {
      let mode = a;
      let callback = b;
      if (typeof a === "function") {
        mode = 438;
        callback = a;
      }
      mode = mode || 438;
      const modeNum = (0, util_1.modeToNumber)(mode);
      const fileName = (0, util_1.pathToFilename)(path31);
      const flagsNum = (0, util_1.flagsToNumber)(flags);
      this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum, !(flagsNum & O_SYMLINK)], callback);
    }
    closeFile(file) {
      if (!this.fds[file.fd])
        return;
      this.openFiles--;
      delete this.fds[file.fd];
      this.releasedFds.push(file.fd);
    }
    closeSync(fd) {
      (0, util_1.validateFd)(fd);
      const file = this.getFileByFdOrThrow(fd, "close");
      this.closeFile(file);
    }
    close(fd, callback) {
      (0, util_1.validateFd)(fd);
      const file = this.getFileByFdOrThrow(fd, "close");
      this.wrapAsync(this.closeFile, [file], callback);
    }
    openFileOrGetById(id, flagsNum, modeNum) {
      if (typeof id === "number") {
        const file = this.fds[id];
        if (!file)
          throw (0, util_1.createError)(ENOENT2);
        return file;
      } else {
        return this.openFile((0, util_1.pathToFilename)(id), flagsNum, modeNum);
      }
    }
    readBase(fd, buffer2, offset, length, position) {
      if (buffer2.byteLength < length) {
        throw (0, util_1.createError)(ERR_OUT_OF_RANGE, "read", void 0, void 0, RangeError);
      }
      const file = this.getFileByFdOrThrow(fd);
      if (file.node.isSymlink()) {
        throw (0, util_1.createError)(EPERM2, "read", file.link.getPath());
      }
      return file.read(buffer2, Number(offset), Number(length), position === -1 || typeof position !== "number" ? void 0 : position);
    }
    readSync(fd, buffer2, offset, length, position) {
      (0, util_1.validateFd)(fd);
      return this.readBase(fd, buffer2, offset, length, position);
    }
    read(fd, buffer2, offset, length, position, callback) {
      (0, util_1.validateCallback)(callback);
      if (length === 0) {
        return (0, queueMicrotask_1.default)(() => {
          if (callback)
            callback(null, 0, buffer2);
        });
      }
      (0, setImmediate_1.default)(() => {
        try {
          const bytes = this.readBase(fd, buffer2, offset, length, position);
          callback(null, bytes, buffer2);
        } catch (err) {
          callback(err);
        }
      });
    }
    readvBase(fd, buffers, position) {
      const file = this.getFileByFdOrThrow(fd);
      let p = position !== null && position !== void 0 ? position : void 0;
      if (p === -1) {
        p = void 0;
      }
      let bytesRead = 0;
      for (const buffer2 of buffers) {
        const bytes = file.read(buffer2, 0, buffer2.byteLength, p);
        p = void 0;
        bytesRead += bytes;
        if (bytes < buffer2.byteLength)
          break;
      }
      return bytesRead;
    }
    readv(fd, buffers, a, b) {
      let position = a;
      let callback = b;
      if (typeof a === "function") {
        position = null;
        callback = a;
      }
      (0, util_1.validateCallback)(callback);
      (0, setImmediate_1.default)(() => {
        try {
          const bytes = this.readvBase(fd, buffers, position);
          callback(null, bytes, buffers);
        } catch (err) {
          callback(err);
        }
      });
    }
    readvSync(fd, buffers, position) {
      (0, util_1.validateFd)(fd);
      return this.readvBase(fd, buffers, position);
    }
    readFileBase(id, flagsNum, encoding2) {
      let result;
      const isUserFd = typeof id === "number";
      const userOwnsFd = isUserFd && (0, util_1.isFd)(id);
      let fd;
      if (userOwnsFd)
        fd = id;
      else {
        const filename = (0, util_1.pathToFilename)(id);
        const link2 = this.getResolvedLinkOrThrow(filename, "open");
        const node2 = link2.getNode();
        if (node2.isDirectory())
          throw (0, util_1.createError)(EISDIR2, "open", link2.getPath());
        fd = this.openSync(id, flagsNum);
      }
      try {
        result = (0, util_1.bufferToEncoding)(this.getFileByFdOrThrow(fd).getBuffer(), encoding2);
      } finally {
        if (!userOwnsFd) {
          this.closeSync(fd);
        }
      }
      return result;
    }
    readFileSync(file, options2) {
      const opts = (0, options_1.getReadFileOptions)(options2);
      const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
      return this.readFileBase(file, flagsNum, opts.encoding);
    }
    readFile(id, a, b) {
      const [opts, callback] = (0, options_1.optsAndCbGenerator)(options_1.getReadFileOptions)(a, b);
      const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
      this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
    }
    writeBase(fd, buf, offset, length, position) {
      const file = this.getFileByFdOrThrow(fd, "write");
      if (file.node.isSymlink()) {
        throw (0, util_1.createError)(EBADF2, "write", file.link.getPath());
      }
      return file.write(buf, offset, length, position === -1 || typeof position !== "number" ? void 0 : position);
    }
    writeSync(fd, a, b, c, d) {
      const [, buf, offset, length, position] = (0, util_1.getWriteSyncArgs)(fd, a, b, c, d);
      return this.writeBase(fd, buf, offset, length, position);
    }
    write(fd, a, b, c, d, e) {
      const [, asStr, buf, offset, length, position, cb] = (0, util_1.getWriteArgs)(fd, a, b, c, d, e);
      (0, setImmediate_1.default)(() => {
        try {
          const bytes = this.writeBase(fd, buf, offset, length, position);
          if (!asStr) {
            cb(null, bytes, buf);
          } else {
            cb(null, bytes, a);
          }
        } catch (err) {
          cb(err);
        }
      });
    }
    writevBase(fd, buffers, position) {
      const file = this.getFileByFdOrThrow(fd);
      let p = position !== null && position !== void 0 ? position : void 0;
      if (p === -1) {
        p = void 0;
      }
      let bytesWritten = 0;
      for (const buffer2 of buffers) {
        const nodeBuf = buffer_1.Buffer.from(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
        const bytes = file.write(nodeBuf, 0, nodeBuf.byteLength, p);
        p = void 0;
        bytesWritten += bytes;
        if (bytes < nodeBuf.byteLength)
          break;
      }
      return bytesWritten;
    }
    writev(fd, buffers, a, b) {
      let position = a;
      let callback = b;
      if (typeof a === "function") {
        position = null;
        callback = a;
      }
      (0, util_1.validateCallback)(callback);
      (0, setImmediate_1.default)(() => {
        try {
          const bytes = this.writevBase(fd, buffers, position);
          callback(null, bytes, buffers);
        } catch (err) {
          callback(err);
        }
      });
    }
    writevSync(fd, buffers, position) {
      (0, util_1.validateFd)(fd);
      return this.writevBase(fd, buffers, position);
    }
    writeFileBase(id, buf, flagsNum, modeNum) {
      const isUserFd = typeof id === "number";
      let fd;
      if (isUserFd)
        fd = id;
      else {
        fd = this.openBase((0, util_1.pathToFilename)(id), flagsNum, modeNum);
      }
      let offset = 0;
      let length = buf.length;
      let position = flagsNum & O_APPEND2 ? void 0 : 0;
      try {
        while (length > 0) {
          const written = this.writeSync(fd, buf, offset, length, position);
          offset += written;
          length -= written;
          if (position !== void 0)
            position += written;
        }
      } finally {
        if (!isUserFd)
          this.closeSync(fd);
      }
    }
    writeFileSync(id, data, options2) {
      const opts = (0, options_1.getWriteFileOptions)(options2);
      const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
      const modeNum = (0, util_1.modeToNumber)(opts.mode);
      const buf = (0, util_1.dataToBuffer)(data, opts.encoding);
      this.writeFileBase(id, buf, flagsNum, modeNum);
    }
    writeFile(id, data, a, b) {
      let options2 = a;
      let callback = b;
      if (typeof a === "function") {
        options2 = options_1.writeFileDefaults;
        callback = a;
      }
      const cb = (0, util_1.validateCallback)(callback);
      const opts = (0, options_1.getWriteFileOptions)(options2);
      const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
      const modeNum = (0, util_1.modeToNumber)(opts.mode);
      const buf = (0, util_1.dataToBuffer)(data, opts.encoding);
      this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
    }
    linkBase(filename1, filename2) {
      let link1;
      try {
        link1 = this.getLinkOrThrow(filename1, "link");
      } catch (err) {
        if (err.code)
          err = (0, util_1.createError)(err.code, "link", filename1, filename2);
        throw err;
      }
      const dirname2 = pathModule.dirname(filename2);
      let dir22;
      try {
        dir22 = this.getLinkOrThrow(dirname2, "link");
      } catch (err) {
        if (err.code)
          err = (0, util_1.createError)(err.code, "link", filename1, filename2);
        throw err;
      }
      const name = pathModule.basename(filename2);
      if (dir22.getChild(name))
        throw (0, util_1.createError)(EEXIST2, "link", filename1, filename2);
      const node2 = link1.getNode();
      node2.nlink++;
      dir22.createChild(name, node2);
    }
    copyFileBase(src2, dest, flags) {
      const buf = this.readFileSync(src2);
      if (flags & COPYFILE_EXCL2) {
        if (this.existsSync(dest)) {
          throw (0, util_1.createError)(EEXIST2, "copyFile", src2, dest);
        }
      }
      if (flags & COPYFILE_FICLONE_FORCE2) {
        throw (0, util_1.createError)(ENOSYS2, "copyFile", src2, dest);
      }
      this.writeFileBase(
        dest,
        buf,
        constants_2.FLAGS.w,
        438
        /* MODE.DEFAULT */
      );
    }
    copyFileSync(src2, dest, flags) {
      const srcFilename = (0, util_1.pathToFilename)(src2);
      const destFilename = (0, util_1.pathToFilename)(dest);
      return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
    }
    copyFile(src2, dest, a, b) {
      const srcFilename = (0, util_1.pathToFilename)(src2);
      const destFilename = (0, util_1.pathToFilename)(dest);
      let flags;
      let callback;
      if (typeof a === "function") {
        flags = 0;
        callback = a;
      } else {
        flags = a;
        callback = b;
      }
      (0, util_1.validateCallback)(callback);
      this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
    }
    linkSync(existingPath, newPath) {
      const existingPathFilename = (0, util_1.pathToFilename)(existingPath);
      const newPathFilename = (0, util_1.pathToFilename)(newPath);
      this.linkBase(existingPathFilename, newPathFilename);
    }
    link(existingPath, newPath, callback) {
      const existingPathFilename = (0, util_1.pathToFilename)(existingPath);
      const newPathFilename = (0, util_1.pathToFilename)(newPath);
      this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
    }
    unlinkBase(filename) {
      const link2 = this.getLinkOrThrow(filename, "unlink");
      if (link2.length)
        throw Error("Dir not empty...");
      this.deleteLink(link2);
      const node2 = link2.getNode();
      node2.nlink--;
      if (node2.nlink <= 0) {
        this.deleteNode(node2);
      }
    }
    unlinkSync(path31) {
      const filename = (0, util_1.pathToFilename)(path31);
      this.unlinkBase(filename);
    }
    unlink(path31, callback) {
      const filename = (0, util_1.pathToFilename)(path31);
      this.wrapAsync(this.unlinkBase, [filename], callback);
    }
    symlinkBase(targetFilename, pathFilename) {
      const pathSteps = filenameToSteps(pathFilename);
      let dirLink;
      try {
        dirLink = this.getLinkParentAsDirOrThrow(pathSteps);
      } catch (err) {
        if (err.code)
          err = (0, util_1.createError)(err.code, "symlink", targetFilename, pathFilename);
        throw err;
      }
      const name = pathSteps[pathSteps.length - 1];
      if (dirLink.getChild(name))
        throw (0, util_1.createError)(EEXIST2, "symlink", targetFilename, pathFilename);
      const node2 = dirLink.getNode();
      if (!node2.canExecute() || !node2.canWrite())
        throw (0, util_1.createError)(EACCES2, "symlink", targetFilename, pathFilename);
      const symlink2 = dirLink.createChild(name);
      symlink2.getNode().makeSymlink(targetFilename);
      return symlink2;
    }
    // `type` argument works only on Windows.
    symlinkSync(target, path31, type2) {
      const targetFilename = (0, util_1.pathToFilename)(target);
      const pathFilename = (0, util_1.pathToFilename)(path31);
      this.symlinkBase(targetFilename, pathFilename);
    }
    symlink(target, path31, a, b) {
      const callback = (0, util_1.validateCallback)(typeof a === "function" ? a : b);
      const targetFilename = (0, util_1.pathToFilename)(target);
      const pathFilename = (0, util_1.pathToFilename)(path31);
      this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
    }
    realpathBase(filename, encoding2) {
      const realLink = this.getResolvedLinkOrThrow(filename, "realpath");
      return (0, encoding_1.strToEncoding)(realLink.getPath() || "/", encoding2);
    }
    realpathSync(path31, options2) {
      return this.realpathBase((0, util_1.pathToFilename)(path31), (0, options_1.getRealpathOptions)(options2).encoding);
    }
    realpath(path31, a, b) {
      const [opts, callback] = (0, options_1.getRealpathOptsAndCb)(a, b);
      const pathFilename = (0, util_1.pathToFilename)(path31);
      this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
    }
    lstatBase(filename, bigint2 = false, throwIfNoEntry = false) {
      let link2;
      try {
        link2 = this.getLinkOrThrow(filename, "lstat");
      } catch (err) {
        if (err.code === ENOENT2 && !throwIfNoEntry)
          return void 0;
        else
          throw err;
      }
      return Stats_1.default.build(link2.getNode(), bigint2);
    }
    lstatSync(path31, options2) {
      const { throwIfNoEntry = true, bigint: bigint2 = false } = (0, options_1.getStatOptions)(options2);
      return this.lstatBase((0, util_1.pathToFilename)(path31), bigint2, throwIfNoEntry);
    }
    lstat(path31, a, b) {
      const [{ throwIfNoEntry = true, bigint: bigint2 = false }, callback] = (0, options_1.getStatOptsAndCb)(a, b);
      this.wrapAsync(this.lstatBase, [(0, util_1.pathToFilename)(path31), bigint2, throwIfNoEntry], callback);
    }
    statBase(filename, bigint2 = false, throwIfNoEntry = true) {
      let link2;
      try {
        link2 = this.getResolvedLinkOrThrow(filename, "stat");
      } catch (err) {
        if (err.code === ENOENT2 && !throwIfNoEntry)
          return void 0;
        else
          throw err;
      }
      return Stats_1.default.build(link2.getNode(), bigint2);
    }
    statSync(path31, options2) {
      const { bigint: bigint2 = true, throwIfNoEntry = true } = (0, options_1.getStatOptions)(options2);
      return this.statBase((0, util_1.pathToFilename)(path31), bigint2, throwIfNoEntry);
    }
    stat(path31, a, b) {
      const [{ bigint: bigint2 = false, throwIfNoEntry = true }, callback] = (0, options_1.getStatOptsAndCb)(a, b);
      this.wrapAsync(this.statBase, [(0, util_1.pathToFilename)(path31), bigint2, throwIfNoEntry], callback);
    }
    fstatBase(fd, bigint2 = false) {
      const file = this.getFileByFd(fd);
      if (!file)
        throw (0, util_1.createError)(EBADF2, "fstat");
      return Stats_1.default.build(file.node, bigint2);
    }
    fstatSync(fd, options2) {
      return this.fstatBase(fd, (0, options_1.getStatOptions)(options2).bigint);
    }
    fstat(fd, a, b) {
      const [opts, callback] = (0, options_1.getStatOptsAndCb)(a, b);
      this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
    }
    renameBase(oldPathFilename, newPathFilename) {
      let link2;
      try {
        link2 = this.getResolvedLinkOrThrow(oldPathFilename);
      } catch (err) {
        if (err.code)
          err = (0, util_1.createError)(err.code, "rename", oldPathFilename, newPathFilename);
        throw err;
      }
      let newPathDirLink;
      try {
        newPathDirLink = this.getLinkParentAsDirOrThrow(newPathFilename);
      } catch (err) {
        if (err.code)
          err = (0, util_1.createError)(err.code, "rename", oldPathFilename, newPathFilename);
        throw err;
      }
      const oldLinkParent = link2.parent;
      const oldParentNode = oldLinkParent.getNode();
      const newPathDirNode = newPathDirLink.getNode();
      if (!oldParentNode.canExecute() || !oldParentNode.canWrite() || !newPathDirNode.canExecute() || !newPathDirNode.canWrite()) {
        throw (0, util_1.createError)(EACCES2, "rename", oldPathFilename, newPathFilename);
      }
      oldLinkParent.deleteChild(link2);
      const name = pathModule.basename(newPathFilename);
      link2.name = name;
      link2.steps = [...newPathDirLink.steps, name];
      newPathDirLink.setChild(link2.getName(), link2);
    }
    renameSync(oldPath, newPath) {
      const oldPathFilename = (0, util_1.pathToFilename)(oldPath);
      const newPathFilename = (0, util_1.pathToFilename)(newPath);
      this.renameBase(oldPathFilename, newPathFilename);
    }
    rename(oldPath, newPath, callback) {
      const oldPathFilename = (0, util_1.pathToFilename)(oldPath);
      const newPathFilename = (0, util_1.pathToFilename)(newPath);
      this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
    }
    existsBase(filename) {
      return !!this.statBase(filename);
    }
    existsSync(path31) {
      try {
        return this.existsBase((0, util_1.pathToFilename)(path31));
      } catch (err) {
        return false;
      }
    }
    exists(path31, callback) {
      const filename = (0, util_1.pathToFilename)(path31);
      if (typeof callback !== "function")
        throw Error(constants_2.ERRSTR.CB);
      (0, setImmediate_1.default)(() => {
        try {
          callback(this.existsBase(filename));
        } catch (err) {
          callback(false);
        }
      });
    }
    accessBase(filename, mode) {
      this.getLinkOrThrow(filename, "access");
    }
    accessSync(path31, mode = F_OK2) {
      const filename = (0, util_1.pathToFilename)(path31);
      mode = mode | 0;
      this.accessBase(filename, mode);
    }
    access(path31, a, b) {
      let mode = F_OK2;
      let callback;
      if (typeof a !== "function") {
        mode = a | 0;
        callback = (0, util_1.validateCallback)(b);
      } else {
        callback = a;
      }
      const filename = (0, util_1.pathToFilename)(path31);
      this.wrapAsync(this.accessBase, [filename, mode], callback);
    }
    appendFileSync(id, data, options2) {
      const opts = (0, options_1.getAppendFileOpts)(options2);
      if (!opts.flag || (0, util_1.isFd)(id))
        opts.flag = "a";
      this.writeFileSync(id, data, opts);
    }
    appendFile(id, data, a, b) {
      const [opts, callback] = (0, options_1.getAppendFileOptsAndCb)(a, b);
      if (!opts.flag || (0, util_1.isFd)(id))
        opts.flag = "a";
      this.writeFile(id, data, opts, callback);
    }
    readdirBase(filename, options2) {
      filenameToSteps(filename);
      const link2 = this.getResolvedLinkOrThrow(filename, "scandir");
      const node2 = link2.getNode();
      if (!node2.isDirectory())
        throw (0, util_1.createError)(ENOTDIR2, "scandir", filename);
      if (!node2.canRead())
        throw (0, util_1.createError)(EACCES2, "scandir", filename);
      const list = [];
      for (const name of link2.children.keys()) {
        const child = link2.getChild(name);
        if (!child || name === "." || name === "..")
          continue;
        list.push(Dirent_1.default.build(child, options2.encoding));
        if (options2.recursive && child.children.size) {
          const recurseOptions = Object.assign(Object.assign({}, options2), { recursive: true, withFileTypes: true });
          const childList = this.readdirBase(child.getPath(), recurseOptions);
          list.push(...childList);
        }
      }
      if (!util_1.isWin && options2.encoding !== "buffer")
        list.sort((a, b) => {
          if (a.name < b.name)
            return -1;
          if (a.name > b.name)
            return 1;
          return 0;
        });
      if (options2.withFileTypes)
        return list;
      let filename2 = filename;
      if (util_1.isWin) {
        filename2 = filename2.replace(/\\/g, "/");
      }
      return list.map((dirent) => {
        if (options2.recursive) {
          let fullPath = pathModule.join(dirent.parentPath, dirent.name.toString());
          if (util_1.isWin) {
            fullPath = fullPath.replace(/\\/g, "/");
          }
          return fullPath.replace(filename2 + pathModule.posix.sep, "");
        }
        return dirent.name;
      });
    }
    readdirSync(path31, options2) {
      const opts = (0, options_1.getReaddirOptions)(options2);
      const filename = (0, util_1.pathToFilename)(path31);
      return this.readdirBase(filename, opts);
    }
    readdir(path31, a, b) {
      const [options2, callback] = (0, options_1.getReaddirOptsAndCb)(a, b);
      const filename = (0, util_1.pathToFilename)(path31);
      this.wrapAsync(this.readdirBase, [filename, options2], callback);
    }
    readlinkBase(filename, encoding2) {
      const link2 = this.getLinkOrThrow(filename, "readlink");
      const node2 = link2.getNode();
      if (!node2.isSymlink())
        throw (0, util_1.createError)(EINVAL2, "readlink", filename);
      return (0, encoding_1.strToEncoding)(node2.symlink, encoding2);
    }
    readlinkSync(path31, options2) {
      const opts = (0, options_1.getDefaultOpts)(options2);
      const filename = (0, util_1.pathToFilename)(path31);
      return this.readlinkBase(filename, opts.encoding);
    }
    readlink(path31, a, b) {
      const [opts, callback] = (0, options_1.getDefaultOptsAndCb)(a, b);
      const filename = (0, util_1.pathToFilename)(path31);
      this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
    }
    fsyncBase(fd) {
      this.getFileByFdOrThrow(fd, "fsync");
    }
    fsyncSync(fd) {
      this.fsyncBase(fd);
    }
    fsync(fd, callback) {
      this.wrapAsync(this.fsyncBase, [fd], callback);
    }
    fdatasyncBase(fd) {
      this.getFileByFdOrThrow(fd, "fdatasync");
    }
    fdatasyncSync(fd) {
      this.fdatasyncBase(fd);
    }
    fdatasync(fd, callback) {
      this.wrapAsync(this.fdatasyncBase, [fd], callback);
    }
    ftruncateBase(fd, len) {
      const file = this.getFileByFdOrThrow(fd, "ftruncate");
      file.truncate(len);
    }
    ftruncateSync(fd, len) {
      this.ftruncateBase(fd, len);
    }
    ftruncate(fd, a, b) {
      const len = typeof a === "number" ? a : 0;
      const callback = (0, util_1.validateCallback)(typeof a === "number" ? b : a);
      this.wrapAsync(this.ftruncateBase, [fd, len], callback);
    }
    truncateBase(path31, len) {
      const fd = this.openSync(path31, "r+");
      try {
        this.ftruncateSync(fd, len);
      } finally {
        this.closeSync(fd);
      }
    }
    /**
     * `id` should be a file descriptor or a path. `id` as file descriptor will
     * not be supported soon.
     */
    truncateSync(id, len) {
      if ((0, util_1.isFd)(id))
        return this.ftruncateSync(id, len);
      this.truncateBase(id, len);
    }
    truncate(id, a, b) {
      const len = typeof a === "number" ? a : 0;
      const callback = (0, util_1.validateCallback)(typeof a === "number" ? b : a);
      if ((0, util_1.isFd)(id))
        return this.ftruncate(id, len, callback);
      this.wrapAsync(this.truncateBase, [id, len], callback);
    }
    futimesBase(fd, atime, mtime) {
      const file = this.getFileByFdOrThrow(fd, "futimes");
      const node2 = file.node;
      node2.atime = new Date(atime * 1e3);
      node2.mtime = new Date(mtime * 1e3);
    }
    futimesSync(fd, atime, mtime) {
      this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
    }
    futimes(fd, atime, mtime, callback) {
      this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    }
    utimesBase(filename, atime, mtime, followSymlinks = true) {
      const link2 = followSymlinks ? this.getResolvedLinkOrThrow(filename, "utimes") : this.getLinkOrThrow(filename, "lutimes");
      const node2 = link2.getNode();
      node2.atime = new Date(atime * 1e3);
      node2.mtime = new Date(mtime * 1e3);
    }
    utimesSync(path31, atime, mtime) {
      this.utimesBase((0, util_1.pathToFilename)(path31), toUnixTimestamp(atime), toUnixTimestamp(mtime), true);
    }
    utimes(path31, atime, mtime, callback) {
      this.wrapAsync(this.utimesBase, [(0, util_1.pathToFilename)(path31), toUnixTimestamp(atime), toUnixTimestamp(mtime), true], callback);
    }
    lutimesSync(path31, atime, mtime) {
      this.utimesBase((0, util_1.pathToFilename)(path31), toUnixTimestamp(atime), toUnixTimestamp(mtime), false);
    }
    lutimes(path31, atime, mtime, callback) {
      this.wrapAsync(this.utimesBase, [(0, util_1.pathToFilename)(path31), toUnixTimestamp(atime), toUnixTimestamp(mtime), false], callback);
    }
    mkdirBase(filename, modeNum) {
      const steps = filenameToSteps(filename);
      if (!steps.length) {
        throw (0, util_1.createError)(EEXIST2, "mkdir", filename);
      }
      const dir3 = this.getLinkParentAsDirOrThrow(filename, "mkdir");
      const name = steps[steps.length - 1];
      if (dir3.getChild(name))
        throw (0, util_1.createError)(EEXIST2, "mkdir", filename);
      const node2 = dir3.getNode();
      if (!node2.canWrite() || !node2.canExecute())
        throw (0, util_1.createError)(EACCES2, "mkdir", filename);
      dir3.createChild(name, this.createNode(constants_1.constants.S_IFDIR | modeNum));
    }
    /**
     * Creates directory tree recursively.
     */
    mkdirpBase(filename, modeNum) {
      let created = false;
      const steps = filenameToSteps(filename);
      let curr = null;
      let i = steps.length;
      for (i = steps.length; i >= 0; i--) {
        curr = this.getResolvedLink(steps.slice(0, i));
        if (curr)
          break;
      }
      if (!curr) {
        curr = this.root;
        i = 0;
      }
      curr = this.getResolvedLinkOrThrow(sep + steps.slice(0, i).join(sep), "mkdir");
      for (i; i < steps.length; i++) {
        const node2 = curr.getNode();
        if (node2.isDirectory()) {
          if (!node2.canExecute() || !node2.canWrite())
            throw (0, util_1.createError)(EACCES2, "mkdir", filename);
        } else {
          throw (0, util_1.createError)(ENOTDIR2, "mkdir", filename);
        }
        created = true;
        curr = curr.createChild(steps[i], this.createNode(constants_1.constants.S_IFDIR | modeNum));
      }
      return created ? filename : void 0;
    }
    mkdirSync(path31, options2) {
      const opts = (0, options_1.getMkdirOptions)(options2);
      const modeNum = (0, util_1.modeToNumber)(opts.mode, 511);
      const filename = (0, util_1.pathToFilename)(path31);
      if (opts.recursive)
        return this.mkdirpBase(filename, modeNum);
      this.mkdirBase(filename, modeNum);
    }
    mkdir(path31, a, b) {
      const opts = (0, options_1.getMkdirOptions)(a);
      const callback = (0, util_1.validateCallback)(typeof a === "function" ? a : b);
      const modeNum = (0, util_1.modeToNumber)(opts.mode, 511);
      const filename = (0, util_1.pathToFilename)(path31);
      if (opts.recursive)
        this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
      else
        this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
    }
    mkdtempBase(prefix, encoding2, retry2 = 5) {
      const filename = prefix + (0, util_1.genRndStr6)();
      try {
        this.mkdirBase(
          filename,
          511
          /* MODE.DIR */
        );
        return (0, encoding_1.strToEncoding)(filename, encoding2);
      } catch (err) {
        if (err.code === EEXIST2) {
          if (retry2 > 1)
            return this.mkdtempBase(prefix, encoding2, retry2 - 1);
          else
            throw Error("Could not create temp dir.");
        } else
          throw err;
      }
    }
    mkdtempSync(prefix, options2) {
      const { encoding: encoding2 } = (0, options_1.getDefaultOpts)(options2);
      if (!prefix || typeof prefix !== "string")
        throw new TypeError("filename prefix is required");
      (0, util_1.nullCheck)(prefix);
      return this.mkdtempBase(prefix, encoding2);
    }
    mkdtemp(prefix, a, b) {
      const [{ encoding: encoding2 }, callback] = (0, options_1.getDefaultOptsAndCb)(a, b);
      if (!prefix || typeof prefix !== "string")
        throw new TypeError("filename prefix is required");
      if (!(0, util_1.nullCheck)(prefix))
        return;
      this.wrapAsync(this.mkdtempBase, [prefix, encoding2], callback);
    }
    rmdirBase(filename, options2) {
      const opts = (0, options_1.getRmdirOptions)(options2);
      const link2 = this.getLinkAsDirOrThrow(filename, "rmdir");
      if (link2.length && !opts.recursive)
        throw (0, util_1.createError)(ENOTEMPTY2, "rmdir", filename);
      this.deleteLink(link2);
    }
    rmdirSync(path31, options2) {
      this.rmdirBase((0, util_1.pathToFilename)(path31), options2);
    }
    rmdir(path31, a, b) {
      const opts = (0, options_1.getRmdirOptions)(a);
      const callback = (0, util_1.validateCallback)(typeof a === "function" ? a : b);
      this.wrapAsync(this.rmdirBase, [(0, util_1.pathToFilename)(path31), opts], callback);
    }
    rmBase(filename, options2 = {}) {
      let link2;
      try {
        link2 = this.getResolvedLinkOrThrow(filename, "stat");
      } catch (err) {
        if (err.code === ENOENT2 && options2.force)
          return;
        else
          throw err;
      }
      if (link2.getNode().isDirectory() && !options2.recursive)
        throw (0, util_1.createError)(ERR_FS_EISDIR, "rm", filename);
      if (!link2.parent.getNode().canWrite())
        throw (0, util_1.createError)(EACCES2, "rm", filename);
      this.deleteLink(link2);
    }
    rmSync(path31, options2) {
      this.rmBase((0, util_1.pathToFilename)(path31), options2);
    }
    rm(path31, a, b) {
      const [opts, callback] = (0, options_1.getRmOptsAndCb)(a, b);
      this.wrapAsync(this.rmBase, [(0, util_1.pathToFilename)(path31), opts], callback);
    }
    fchmodBase(fd, modeNum) {
      const file = this.getFileByFdOrThrow(fd, "fchmod");
      file.chmod(modeNum);
    }
    fchmodSync(fd, mode) {
      this.fchmodBase(fd, (0, util_1.modeToNumber)(mode));
    }
    fchmod(fd, mode, callback) {
      this.wrapAsync(this.fchmodBase, [fd, (0, util_1.modeToNumber)(mode)], callback);
    }
    chmodBase(filename, modeNum, followSymlinks = true) {
      const link2 = followSymlinks ? this.getResolvedLinkOrThrow(filename, "chmod") : this.getLinkOrThrow(filename, "chmod");
      const node2 = link2.getNode();
      node2.chmod(modeNum);
    }
    chmodSync(path31, mode) {
      const modeNum = (0, util_1.modeToNumber)(mode);
      const filename = (0, util_1.pathToFilename)(path31);
      this.chmodBase(filename, modeNum, true);
    }
    chmod(path31, mode, callback) {
      const modeNum = (0, util_1.modeToNumber)(mode);
      const filename = (0, util_1.pathToFilename)(path31);
      this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
    }
    lchmodBase(filename, modeNum) {
      this.chmodBase(filename, modeNum, false);
    }
    lchmodSync(path31, mode) {
      const modeNum = (0, util_1.modeToNumber)(mode);
      const filename = (0, util_1.pathToFilename)(path31);
      this.lchmodBase(filename, modeNum);
    }
    lchmod(path31, mode, callback) {
      const modeNum = (0, util_1.modeToNumber)(mode);
      const filename = (0, util_1.pathToFilename)(path31);
      this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
    }
    fchownBase(fd, uid, gid) {
      this.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
    }
    fchownSync(fd, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.fchownBase(fd, uid, gid);
    }
    fchown(fd, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
    }
    chownBase(filename, uid, gid) {
      const link2 = this.getResolvedLinkOrThrow(filename, "chown");
      const node2 = link2.getNode();
      node2.chown(uid, gid);
    }
    chownSync(path31, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.chownBase((0, util_1.pathToFilename)(path31), uid, gid);
    }
    chown(path31, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.chownBase, [(0, util_1.pathToFilename)(path31), uid, gid], callback);
    }
    lchownBase(filename, uid, gid) {
      this.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
    }
    lchownSync(path31, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.lchownBase((0, util_1.pathToFilename)(path31), uid, gid);
    }
    lchown(path31, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.lchownBase, [(0, util_1.pathToFilename)(path31), uid, gid], callback);
    }
    watchFile(path31, a, b) {
      const filename = (0, util_1.pathToFilename)(path31);
      let options2 = a;
      let listener = b;
      if (typeof options2 === "function") {
        listener = a;
        options2 = null;
      }
      if (typeof listener !== "function") {
        throw Error('"watchFile()" requires a listener function');
      }
      let interval = 5007;
      let persistent = true;
      if (options2 && typeof options2 === "object") {
        if (typeof options2.interval === "number")
          interval = options2.interval;
        if (typeof options2.persistent === "boolean")
          persistent = options2.persistent;
      }
      let watcher = this.statWatchers[filename];
      if (!watcher) {
        watcher = new this.StatWatcher();
        watcher.start(filename, persistent, interval);
        this.statWatchers[filename] = watcher;
      }
      watcher.addListener("change", listener);
      return watcher;
    }
    unwatchFile(path31, listener) {
      const filename = (0, util_1.pathToFilename)(path31);
      const watcher = this.statWatchers[filename];
      if (!watcher)
        return;
      if (typeof listener === "function") {
        watcher.removeListener("change", listener);
      } else {
        watcher.removeAllListeners("change");
      }
      if (watcher.listenerCount("change") === 0) {
        watcher.stop();
        delete this.statWatchers[filename];
      }
    }
    createReadStream(path31, options2) {
      return new this.ReadStream(path31, options2);
    }
    createWriteStream(path31, options2) {
      return new this.WriteStream(path31, options2);
    }
    // watch(path: PathLike): FSWatcher;
    // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;
    watch(path31, options2, listener) {
      const filename = (0, util_1.pathToFilename)(path31);
      let givenOptions = options2;
      if (typeof options2 === "function") {
        listener = options2;
        givenOptions = null;
      }
      let { persistent, recursive, encoding: encoding2 } = (0, options_1.getDefaultOpts)(givenOptions);
      if (persistent === void 0)
        persistent = true;
      if (recursive === void 0)
        recursive = false;
      const watcher = new this.FSWatcher();
      watcher.start(filename, persistent, recursive, encoding2);
      if (listener) {
        watcher.addListener("change", listener);
      }
      return watcher;
    }
    opendirBase(filename, options2) {
      const link2 = this.getResolvedLinkOrThrow(filename, "scandir");
      const node2 = link2.getNode();
      if (!node2.isDirectory())
        throw (0, util_1.createError)(ENOTDIR2, "scandir", filename);
      return new Dir_1.Dir(link2, options2);
    }
    opendirSync(path31, options2) {
      const opts = (0, options_1.getOpendirOptions)(options2);
      const filename = (0, util_1.pathToFilename)(path31);
      return this.opendirBase(filename, opts);
    }
    opendir(path31, a, b) {
      const [options2, callback] = (0, options_1.getOpendirOptsAndCb)(a, b);
      const filename = (0, util_1.pathToFilename)(path31);
      this.wrapAsync(this.opendirBase, [filename, options2], callback);
    }
  }
  volume.Volume = Volume;
  Volume.fd = 2147483647;
  function emitStop(self2) {
    self2.emit("stop");
  }
  __name(emitStop, "emitStop");
  class StatWatcher extends events_1.EventEmitter {
    static {
      __name(this, "StatWatcher");
    }
    constructor(vol) {
      super();
      this.onInterval = () => {
        try {
          const stats = this.vol.statSync(this.filename);
          if (this.hasChanged(stats)) {
            this.emit("change", stats, this.prev);
            this.prev = stats;
          }
        } finally {
          this.loop();
        }
      };
      this.vol = vol;
    }
    loop() {
      this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
    }
    hasChanged(stats) {
      if (stats.mtimeMs > this.prev.mtimeMs)
        return true;
      if (stats.nlink !== this.prev.nlink)
        return true;
      return false;
    }
    start(path31, persistent = true, interval = 5007) {
      this.filename = (0, util_1.pathToFilename)(path31);
      this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : commonjsGlobal) : setTimeoutUnref_1.default;
      this.interval = interval;
      this.prev = this.vol.statSync(this.filename);
      this.loop();
    }
    stop() {
      clearTimeout(this.timeoutRef);
      (0, queueMicrotask_1.default)(() => {
        emitStop.call(this, this);
      });
    }
  }
  volume.StatWatcher = StatWatcher;
  var pool;
  function allocNewPool(poolSize) {
    pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
    pool.used = 0;
  }
  __name(allocNewPool, "allocNewPool");
  util3.inherits(FsReadStream, stream_1.Readable);
  volume.ReadStream = FsReadStream;
  function FsReadStream(vol, path31, options2) {
    if (!(this instanceof FsReadStream))
      return new FsReadStream(vol, path31, options2);
    this._vol = vol;
    options2 = Object.assign({}, (0, options_1.getOptions)(options2, {}));
    if (options2.highWaterMark === void 0)
      options2.highWaterMark = 64 * 1024;
    stream_1.Readable.call(this, options2);
    this.path = (0, util_1.pathToFilename)(path31);
    this.fd = options2.fd === void 0 ? null : typeof options2.fd !== "number" ? options2.fd.fd : options2.fd;
    this.flags = options2.flags === void 0 ? "r" : options2.flags;
    this.mode = options2.mode === void 0 ? 438 : options2.mode;
    this.start = options2.start;
    this.end = options2.end;
    this.autoClose = options2.autoClose === void 0 ? true : options2.autoClose;
    this.pos = void 0;
    this.bytesRead = 0;
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw new TypeError('"start" option must be a Number');
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (typeof this.end !== "number") {
        throw new TypeError('"end" option must be a Number');
      }
      if (this.start > this.end) {
        throw new Error('"start" option must be <= "end" option');
      }
      this.pos = this.start;
    }
    if (typeof this.fd !== "number")
      this.open();
    this.on("end", function() {
      if (this.autoClose) {
        if (this.destroy)
          this.destroy();
      }
    });
  }
  __name(FsReadStream, "FsReadStream");
  FsReadStream.prototype.open = function() {
    var self2 = this;
    this._vol.open(this.path, this.flags, this.mode, (er, fd) => {
      if (er) {
        if (self2.autoClose) {
          if (self2.destroy)
            self2.destroy();
        }
        self2.emit("error", er);
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2.read();
    });
  };
  FsReadStream.prototype._read = function(n) {
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._read(n);
      });
    }
    if (this.destroyed)
      return;
    if (!pool || pool.length - pool.used < kMinPoolSpace) {
      allocNewPool(this._readableState.highWaterMark);
    }
    var thisPool = pool;
    var toRead = Math.min(pool.length - pool.used, n);
    var start = pool.used;
    if (this.pos !== void 0)
      toRead = Math.min(this.end - this.pos + 1, toRead);
    if (toRead <= 0)
      return this.push(null);
    var self2 = this;
    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
    if (this.pos !== void 0)
      this.pos += toRead;
    pool.used += toRead;
    function onread(er, bytesRead) {
      if (er) {
        if (self2.autoClose && self2.destroy) {
          self2.destroy();
        }
        self2.emit("error", er);
      } else {
        var b = null;
        if (bytesRead > 0) {
          self2.bytesRead += bytesRead;
          b = thisPool.slice(start, start + bytesRead);
        }
        self2.push(b);
      }
    }
    __name(onread, "onread");
  };
  FsReadStream.prototype._destroy = function(err, cb) {
    this.close((err2) => {
      cb(err || err2);
    });
  };
  FsReadStream.prototype.close = function(cb) {
    var _a;
    if (cb)
      this.once("close", cb);
    if (this.closed || typeof this.fd !== "number") {
      if (typeof this.fd !== "number") {
        this.once("open", closeOnOpen);
        return;
      }
      return (0, queueMicrotask_1.default)(() => this.emit("close"));
    }
    if (typeof ((_a = this._readableState) === null || _a === void 0 ? void 0 : _a.closed) === "boolean") {
      this._readableState.closed = true;
    } else {
      this.closed = true;
    }
    this._vol.close(this.fd, (er) => {
      if (er)
        this.emit("error", er);
      else
        this.emit("close");
    });
    this.fd = null;
  };
  function closeOnOpen(fd) {
    this.close();
  }
  __name(closeOnOpen, "closeOnOpen");
  util3.inherits(FsWriteStream, stream_1.Writable);
  volume.WriteStream = FsWriteStream;
  function FsWriteStream(vol, path31, options2) {
    if (!(this instanceof FsWriteStream))
      return new FsWriteStream(vol, path31, options2);
    this._vol = vol;
    options2 = Object.assign({}, (0, options_1.getOptions)(options2, {}));
    stream_1.Writable.call(this, options2);
    this.path = (0, util_1.pathToFilename)(path31);
    this.fd = options2.fd === void 0 ? null : typeof options2.fd !== "number" ? options2.fd.fd : options2.fd;
    this.flags = options2.flags === void 0 ? "w" : options2.flags;
    this.mode = options2.mode === void 0 ? 438 : options2.mode;
    this.start = options2.start;
    this.autoClose = options2.autoClose === void 0 ? true : !!options2.autoClose;
    this.pos = void 0;
    this.bytesWritten = 0;
    this.pending = true;
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw new TypeError('"start" option must be a Number');
      }
      if (this.start < 0) {
        throw new Error('"start" must be >= zero');
      }
      this.pos = this.start;
    }
    if (options2.encoding)
      this.setDefaultEncoding(options2.encoding);
    if (typeof this.fd !== "number")
      this.open();
    this.once("finish", function() {
      if (this.autoClose) {
        this.close();
      }
    });
  }
  __name(FsWriteStream, "FsWriteStream");
  FsWriteStream.prototype.open = function() {
    this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
      if (er) {
        if (this.autoClose && this.destroy) {
          this.destroy();
        }
        this.emit("error", er);
        return;
      }
      this.fd = fd;
      this.pending = false;
      this.emit("open", fd);
    }.bind(this));
  };
  FsWriteStream.prototype._write = function(data, encoding2, cb) {
    if (!(data instanceof buffer_1.Buffer || data instanceof Uint8Array))
      return this.emit("error", new Error("Invalid data"));
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._write(data, encoding2, cb);
      });
    }
    var self2 = this;
    this._vol.write(this.fd, data, 0, data.length, this.pos, (er, bytes) => {
      if (er) {
        if (self2.autoClose && self2.destroy) {
          self2.destroy();
        }
        return cb(er);
      }
      self2.bytesWritten += bytes;
      cb();
    });
    if (this.pos !== void 0)
      this.pos += data.length;
  };
  FsWriteStream.prototype._writev = function(data, cb) {
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._writev(data, cb);
      });
    }
    const self2 = this;
    const len = data.length;
    const chunks = new Array(len);
    var size = 0;
    for (var i = 0; i < len; i++) {
      var chunk = data[i].chunk;
      chunks[i] = chunk;
      size += chunk.length;
    }
    const buf = buffer_1.Buffer.concat(chunks);
    this._vol.write(this.fd, buf, 0, buf.length, this.pos, (er, bytes) => {
      if (er) {
        if (self2.destroy)
          self2.destroy();
        return cb(er);
      }
      self2.bytesWritten += bytes;
      cb();
    });
    if (this.pos !== void 0)
      this.pos += size;
  };
  FsWriteStream.prototype.close = function(cb) {
    var _a;
    if (cb)
      this.once("close", cb);
    if (this.closed || typeof this.fd !== "number") {
      if (typeof this.fd !== "number") {
        this.once("open", closeOnOpen);
        return;
      }
      return (0, queueMicrotask_1.default)(() => this.emit("close"));
    }
    if (typeof ((_a = this._writableState) === null || _a === void 0 ? void 0 : _a.closed) === "boolean") {
      this._writableState.closed = true;
    } else {
      this.closed = true;
    }
    this._vol.close(this.fd, (er) => {
      if (er)
        this.emit("error", er);
      else
        this.emit("close");
    });
    this.fd = null;
  };
  FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
  FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
  class FSWatcher extends events_1.EventEmitter {
    static {
      __name(this, "FSWatcher");
    }
    constructor(vol) {
      super();
      this._filename = "";
      this._filenameEncoded = "";
      this._recursive = false;
      this._encoding = encoding_1.ENCODING_UTF8;
      this._listenerRemovers = /* @__PURE__ */ new Map();
      this._onParentChild = (link2) => {
        if (link2.getName() === this._getName()) {
          this._emit("rename");
        }
      };
      this._emit = (type2) => {
        this.emit("change", type2, this._filenameEncoded);
      };
      this._persist = () => {
        this._timer = setTimeout(this._persist, 1e6);
      };
      this._vol = vol;
    }
    _getName() {
      return this._steps[this._steps.length - 1];
    }
    start(path31, persistent = true, recursive = false, encoding2 = encoding_1.ENCODING_UTF8) {
      this._filename = (0, util_1.pathToFilename)(path31);
      this._steps = filenameToSteps(this._filename);
      this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
      this._recursive = recursive;
      this._encoding = encoding2;
      try {
        this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
      } catch (err) {
        const error4 = new Error(`watch ${this._filename} ${err.code}`);
        error4.code = err.code;
        error4.errno = err.code;
        throw error4;
      }
      const watchLinkNodeChanged = /* @__PURE__ */ __name((link2) => {
        var _a;
        const filepath = link2.getPath();
        const node2 = link2.getNode();
        const onNodeChange = /* @__PURE__ */ __name(() => {
          let filename = relative(this._filename, filepath);
          if (!filename) {
            filename = this._getName();
          }
          return this.emit("change", "change", filename);
        }, "onNodeChange");
        node2.on("change", onNodeChange);
        const removers = (_a = this._listenerRemovers.get(node2.ino)) !== null && _a !== void 0 ? _a : [];
        removers.push(() => node2.removeListener("change", onNodeChange));
        this._listenerRemovers.set(node2.ino, removers);
      }, "watchLinkNodeChanged");
      const watchLinkChildrenChanged = /* @__PURE__ */ __name((link2) => {
        var _a;
        const node2 = link2.getNode();
        const onLinkChildAdd = /* @__PURE__ */ __name((l) => {
          this.emit("change", "rename", relative(this._filename, l.getPath()));
          setTimeout(() => {
            watchLinkNodeChanged(l);
            watchLinkChildrenChanged(l);
          });
        }, "onLinkChildAdd");
        const onLinkChildDelete = /* @__PURE__ */ __name((l) => {
          const removeLinkNodeListeners = /* @__PURE__ */ __name((curLink) => {
            const ino = curLink.getNode().ino;
            const removers2 = this._listenerRemovers.get(ino);
            if (removers2) {
              removers2.forEach((r) => r());
              this._listenerRemovers.delete(ino);
            }
            for (const [name, childLink] of curLink.children.entries()) {
              if (childLink && name !== "." && name !== "..") {
                removeLinkNodeListeners(childLink);
              }
            }
          }, "removeLinkNodeListeners");
          removeLinkNodeListeners(l);
          this.emit("change", "rename", relative(this._filename, l.getPath()));
        }, "onLinkChildDelete");
        for (const [name, childLink] of link2.children.entries()) {
          if (childLink && name !== "." && name !== "..") {
            watchLinkNodeChanged(childLink);
          }
        }
        link2.on("child:add", onLinkChildAdd);
        link2.on("child:delete", onLinkChildDelete);
        const removers = (_a = this._listenerRemovers.get(node2.ino)) !== null && _a !== void 0 ? _a : [];
        removers.push(() => {
          link2.removeListener("child:add", onLinkChildAdd);
          link2.removeListener("child:delete", onLinkChildDelete);
        });
        if (recursive) {
          for (const [name, childLink] of link2.children.entries()) {
            if (childLink && name !== "." && name !== "..") {
              watchLinkChildrenChanged(childLink);
            }
          }
        }
      }, "watchLinkChildrenChanged");
      watchLinkNodeChanged(this._link);
      watchLinkChildrenChanged(this._link);
      const parent = this._link.parent;
      if (parent) {
        parent.setMaxListeners(parent.getMaxListeners() + 1);
        parent.on("child:delete", this._onParentChild);
      }
      if (persistent)
        this._persist();
    }
    close() {
      clearTimeout(this._timer);
      this._listenerRemovers.forEach((removers) => {
        removers.forEach((r) => r());
      });
      this._listenerRemovers.clear();
      const parent = this._link.parent;
      if (parent) {
        parent.removeListener("child:delete", this._onParentChild);
      }
    }
  }
  volume.FSWatcher = FSWatcher;
  return volume;
}
__name(requireVolume, "requireVolume");
var fsSynchronousApiList = {};
var hasRequiredFsSynchronousApiList;
function requireFsSynchronousApiList() {
  if (hasRequiredFsSynchronousApiList) return fsSynchronousApiList;
  hasRequiredFsSynchronousApiList = 1;
  Object.defineProperty(fsSynchronousApiList, "__esModule", { value: true });
  fsSynchronousApiList.fsSynchronousApiList = void 0;
  fsSynchronousApiList.fsSynchronousApiList = [
    "accessSync",
    "appendFileSync",
    "chmodSync",
    "chownSync",
    "closeSync",
    "copyFileSync",
    "existsSync",
    "fchmodSync",
    "fchownSync",
    "fdatasyncSync",
    "fstatSync",
    "fsyncSync",
    "ftruncateSync",
    "futimesSync",
    "lchmodSync",
    "lchownSync",
    "linkSync",
    "lstatSync",
    "mkdirSync",
    "mkdtempSync",
    "openSync",
    "readdirSync",
    "readFileSync",
    "readlinkSync",
    "readSync",
    "readvSync",
    "realpathSync",
    "renameSync",
    "rmdirSync",
    "rmSync",
    "statSync",
    "symlinkSync",
    "truncateSync",
    "unlinkSync",
    "utimesSync",
    "lutimesSync",
    "writeFileSync",
    "writeSync",
    "writevSync"
    // 'cpSync',
    // 'statfsSync',
  ];
  return fsSynchronousApiList;
}
__name(requireFsSynchronousApiList, "requireFsSynchronousApiList");
var fsCallbackApiList = {};
var hasRequiredFsCallbackApiList;
function requireFsCallbackApiList() {
  if (hasRequiredFsCallbackApiList) return fsCallbackApiList;
  hasRequiredFsCallbackApiList = 1;
  Object.defineProperty(fsCallbackApiList, "__esModule", { value: true });
  fsCallbackApiList.fsCallbackApiList = void 0;
  fsCallbackApiList.fsCallbackApiList = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "createReadStream",
    "createWriteStream",
    "exists",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "read",
    "readv",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "unwatchFile",
    "utimes",
    "lutimes",
    "watch",
    "watchFile",
    "write",
    "writev",
    "writeFile"
  ];
  return fsCallbackApiList;
}
__name(requireFsCallbackApiList, "requireFsCallbackApiList");
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$1.exports;
  hasRequiredLib = 1;
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.memfs = exports.fs = exports.vol = exports.Volume = void 0;
    exports.createFsFromVolume = createFsFromVolume;
    const Stats_1 = requireStats();
    const Dirent_1 = requireDirent();
    const volume_1 = requireVolume();
    const constants_1 = requireConstants$1();
    const fsSynchronousApiList_1 = requireFsSynchronousApiList();
    const fsCallbackApiList_1 = requireFsCallbackApiList();
    const { F_OK: F_OK2, R_OK: R_OK2, W_OK: W_OK2, X_OK: X_OK2 } = constants_1.constants;
    exports.Volume = volume_1.Volume;
    exports.vol = new volume_1.Volume();
    function createFsFromVolume(vol) {
      const fs2 = { F_OK: F_OK2, R_OK: R_OK2, W_OK: W_OK2, X_OK: X_OK2, constants: constants_1.constants, Stats: Stats_1.default, Dirent: Dirent_1.default };
      for (const method of fsSynchronousApiList_1.fsSynchronousApiList)
        if (typeof vol[method] === "function")
          fs2[method] = vol[method].bind(vol);
      for (const method of fsCallbackApiList_1.fsCallbackApiList)
        if (typeof vol[method] === "function")
          fs2[method] = vol[method].bind(vol);
      fs2.StatWatcher = vol.StatWatcher;
      fs2.FSWatcher = vol.FSWatcher;
      fs2.WriteStream = vol.WriteStream;
      fs2.ReadStream = vol.ReadStream;
      fs2.promises = vol.promises;
      fs2._toUnixTimestamp = volume_1.toUnixTimestamp;
      fs2.__vol = vol;
      return fs2;
    }
    __name(createFsFromVolume, "createFsFromVolume");
    exports.fs = createFsFromVolume(exports.vol);
    const memfs = /* @__PURE__ */ __name((json = {}, cwd2 = "/") => {
      const vol = exports.Volume.fromNestedJSON(json, cwd2);
      const fs2 = createFsFromVolume(vol);
      return { fs: fs2, vol };
    }, "memfs");
    exports.memfs = memfs;
    module.exports = Object.assign(Object.assign({}, module.exports), exports.fs);
    module.exports.semantic = true;
  })(lib$1, lib$1.exports);
  return lib$1.exports;
}
__name(requireLib, "requireLib");
var libExports = requireLib();
var { fs } = libExports.memfs({ "/tmp": null });
var {
  appendFile,
  appendFileSync,
  access,
  accessSync,
  chown,
  chownSync,
  chmod,
  chmodSync,
  close,
  closeSync,
  copyFile,
  copyFileSync,
  cp,
  cpSync,
  createReadStream,
  createWriteStream,
  exists,
  existsSync,
  fchown,
  fchownSync,
  fchmod,
  fchmodSync,
  fdatasync,
  fdatasyncSync,
  fstat,
  fstatSync,
  fsync,
  fsyncSync,
  ftruncate,
  ftruncateSync,
  futimes,
  futimesSync,
  lchown,
  lchownSync,
  lchmod,
  lchmodSync,
  link,
  linkSync,
  lstat,
  lstatSync,
  lutimes,
  lutimesSync,
  mkdir,
  mkdirSync,
  mkdtemp,
  mkdtempSync,
  open,
  openSync,
  opendir,
  opendirSync,
  readdir,
  readdirSync,
  read,
  readSync,
  readv,
  readvSync,
  readFile,
  readFileSync,
  readlink,
  readlinkSync,
  realpath,
  realpathSync,
  rename,
  renameSync,
  rm,
  rmSync,
  rmdir,
  rmdirSync,
  stat,
  statfs,
  statSync,
  statfsSync,
  symlink,
  symlinkSync,
  truncate,
  truncateSync,
  unwatchFile,
  unlink,
  unlinkSync,
  utimes,
  utimesSync,
  watch,
  watchFile,
  writeFile,
  writeFileSync,
  write,
  writeSync,
  writev,
  writevSync,
  Dirent,
  Stats,
  ReadStream: ReadStream2,
  WriteStream: WriteStream2,
  constants: constants2,
  promises
} = fs;

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utilsBundle.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/_virtual/utilsBundleImpl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/bundles/utilsBundleImpl.js
var utilsBundleImpl_exports = {};
__export(utilsBundleImpl_exports, {
  HttpsProxyAgent: () => HttpsProxyAgent,
  PNG: () => PNG,
  SocksProxyAgent: () => SocksProxyAgent,
  colors: () => colors,
  debug: () => debug4,
  diff: () => diff2,
  dotenv: () => dotenv,
  getProxyForUrl: () => getProxyForUrl,
  jpegjs: () => jpegjs,
  lockfile: () => lockfile,
  mime: () => mime,
  minimatch: () => minimatch,
  open: () => open2,
  program: () => program,
  progress: () => progress,
  ws: () => ws,
  wsReceiver: () => wsReceiver,
  wsSender: () => wsSender,
  wsServer: () => wsServer,
  yaml: () => yaml
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path2 from "node:path";

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/constants.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/os/constants.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var UV_UDP_REUSEADDR = 4;
var dlopen2 = {
  RTLD_LAZY: 1,
  RTLD_NOW: 2,
  RTLD_GLOBAL: 256,
  RTLD_LOCAL: 0,
  RTLD_DEEPBIND: 8
};
var errno = {
  E2BIG: 7,
  EACCES: 13,
  EADDRINUSE: 98,
  EADDRNOTAVAIL: 99,
  EAFNOSUPPORT: 97,
  EAGAIN: 11,
  EALREADY: 114,
  EBADF: 9,
  EBADMSG: 74,
  EBUSY: 16,
  ECANCELED: 125,
  ECHILD: 10,
  ECONNABORTED: 103,
  ECONNREFUSED: 111,
  ECONNRESET: 104,
  EDEADLK: 35,
  EDESTADDRREQ: 89,
  EDOM: 33,
  EDQUOT: 122,
  EEXIST: 17,
  EFAULT: 14,
  EFBIG: 27,
  EHOSTUNREACH: 113,
  EIDRM: 43,
  EILSEQ: 84,
  EINPROGRESS: 115,
  EINTR: 4,
  EINVAL: 22,
  EIO: 5,
  EISCONN: 106,
  EISDIR: 21,
  ELOOP: 40,
  EMFILE: 24,
  EMLINK: 31,
  EMSGSIZE: 90,
  EMULTIHOP: 72,
  ENAMETOOLONG: 36,
  ENETDOWN: 100,
  ENETRESET: 102,
  ENETUNREACH: 101,
  ENFILE: 23,
  ENOBUFS: 105,
  ENODATA: 61,
  ENODEV: 19,
  ENOENT: 2,
  ENOEXEC: 8,
  ENOLCK: 37,
  ENOLINK: 67,
  ENOMEM: 12,
  ENOMSG: 42,
  ENOPROTOOPT: 92,
  ENOSPC: 28,
  ENOSR: 63,
  ENOSTR: 60,
  ENOSYS: 38,
  ENOTCONN: 107,
  ENOTDIR: 20,
  ENOTEMPTY: 39,
  ENOTSOCK: 88,
  ENOTSUP: 95,
  ENOTTY: 25,
  ENXIO: 6,
  EOPNOTSUPP: 95,
  EOVERFLOW: 75,
  EPERM: 1,
  EPIPE: 32,
  EPROTO: 71,
  EPROTONOSUPPORT: 93,
  EPROTOTYPE: 91,
  ERANGE: 34,
  EROFS: 30,
  ESPIPE: 29,
  ESRCH: 3,
  ESTALE: 116,
  ETIME: 62,
  ETIMEDOUT: 110,
  ETXTBSY: 26,
  EWOULDBLOCK: 11,
  EXDEV: 18
};
var signals = {
  SIGHUP: 1,
  SIGINT: 2,
  SIGQUIT: 3,
  SIGILL: 4,
  SIGTRAP: 5,
  SIGABRT: 6,
  SIGIOT: 6,
  SIGBUS: 7,
  SIGFPE: 8,
  SIGKILL: 9,
  SIGUSR1: 10,
  SIGSEGV: 11,
  SIGUSR2: 12,
  SIGPIPE: 13,
  SIGALRM: 14,
  SIGTERM: 15,
  SIGCHLD: 17,
  SIGSTKFLT: 16,
  SIGCONT: 18,
  SIGSTOP: 19,
  SIGTSTP: 20,
  SIGTTIN: 21,
  SIGTTOU: 22,
  SIGURG: 23,
  SIGXCPU: 24,
  SIGXFSZ: 25,
  SIGVTALRM: 26,
  SIGPROF: 27,
  SIGWINCH: 28,
  SIGIO: 29,
  SIGPOLL: 29,
  SIGPWR: 30,
  SIGSYS: 31
};
var priority = {
  PRIORITY_LOW: 19,
  PRIORITY_BELOW_NORMAL: 10,
  PRIORITY_NORMAL: 0,
  PRIORITY_ABOVE_NORMAL: -7,
  PRIORITY_HIGH: -14,
  PRIORITY_HIGHEST: -20
};

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/fs/constants.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var UV_FS_SYMLINK_DIR = 1;
var UV_FS_SYMLINK_JUNCTION = 2;
var O_RDONLY = 0;
var O_WRONLY = 1;
var O_RDWR = 2;
var UV_DIRENT_UNKNOWN = 0;
var UV_DIRENT_FILE = 1;
var UV_DIRENT_DIR = 2;
var UV_DIRENT_LINK = 3;
var UV_DIRENT_FIFO = 4;
var UV_DIRENT_SOCKET = 5;
var UV_DIRENT_CHAR = 6;
var UV_DIRENT_BLOCK = 7;
var EXTENSIONLESS_FORMAT_JAVASCRIPT = 0;
var EXTENSIONLESS_FORMAT_WASM = 1;
var S_IFMT = 61440;
var S_IFREG = 32768;
var S_IFDIR = 16384;
var S_IFCHR = 8192;
var S_IFBLK = 24576;
var S_IFIFO = 4096;
var S_IFLNK = 40960;
var S_IFSOCK = 49152;
var O_CREAT = 64;
var O_EXCL = 128;
var UV_FS_O_FILEMAP = 0;
var O_NOCTTY = 256;
var O_TRUNC = 512;
var O_APPEND = 1024;
var O_DIRECTORY = 65536;
var O_NOATIME = 262144;
var O_NOFOLLOW = 131072;
var O_SYNC = 1052672;
var O_DSYNC = 4096;
var O_DIRECT = 16384;
var O_NONBLOCK = 2048;
var S_IRWXU = 448;
var S_IRUSR = 256;
var S_IWUSR = 128;
var S_IXUSR = 64;
var S_IRWXG = 56;
var S_IRGRP = 32;
var S_IWGRP = 16;
var S_IXGRP = 8;
var S_IRWXO = 7;
var S_IROTH = 4;
var S_IWOTH = 2;
var S_IXOTH = 1;
var F_OK = 0;
var R_OK = 4;
var W_OK = 2;
var X_OK = 1;
var UV_FS_COPYFILE_EXCL = 1;
var COPYFILE_EXCL = 1;
var UV_FS_COPYFILE_FICLONE = 2;
var COPYFILE_FICLONE = 2;
var UV_FS_COPYFILE_FICLONE_FORCE = 4;
var COPYFILE_FICLONE_FORCE = 4;

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/constants.mjs
var { RTLD_LAZY, RTLD_NOW, RTLD_GLOBAL, RTLD_LOCAL, RTLD_DEEPBIND } = dlopen2;
var { E2BIG, EACCES, EADDRINUSE, EADDRNOTAVAIL, EAFNOSUPPORT, EAGAIN, EALREADY, EBADF, EBADMSG, EBUSY, ECANCELED, ECHILD, ECONNABORTED, ECONNREFUSED, ECONNRESET, EDEADLK, EDESTADDRREQ, EDOM, EDQUOT, EEXIST, EFAULT, EFBIG, EHOSTUNREACH, EIDRM, EILSEQ, EINPROGRESS, EINTR, EINVAL, EIO, EISCONN, EISDIR, ELOOP, EMFILE, EMLINK, EMSGSIZE, EMULTIHOP, ENAMETOOLONG, ENETDOWN, ENETRESET, ENETUNREACH, ENFILE, ENOBUFS, ENODATA, ENODEV, ENOENT, ENOEXEC, ENOLCK, ENOLINK, ENOMEM, ENOMSG, ENOPROTOOPT, ENOSPC, ENOSR, ENOSTR, ENOSYS, ENOTCONN, ENOTDIR, ENOTEMPTY, ENOTSOCK, ENOTSUP, ENOTTY, ENXIO, EOPNOTSUPP, EOVERFLOW, EPERM, EPIPE, EPROTO, EPROTONOSUPPORT, EPROTOTYPE, ERANGE, EROFS, ESPIPE, ESRCH, ESTALE, ETIME, ETIMEDOUT, ETXTBSY, EWOULDBLOCK, EXDEV } = errno;
var { PRIORITY_LOW, PRIORITY_BELOW_NORMAL, PRIORITY_NORMAL, PRIORITY_ABOVE_NORMAL, PRIORITY_HIGH, PRIORITY_HIGHEST } = priority;
var { SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGIOT, SIGBUS, SIGFPE, SIGKILL, SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGCHLD, SIGSTKFLT, SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF, SIGWINCH, SIGIO, SIGPOLL, SIGPWR, SIGSYS } = signals;
var constants_default = {
  OPENSSL_VERSION_NUMBER,
  SSL_OP_ALL,
  SSL_OP_ALLOW_NO_DHE_KEX,
  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION,
  SSL_OP_CIPHER_SERVER_PREFERENCE,
  SSL_OP_CISCO_ANYCONNECT,
  SSL_OP_COOKIE_EXCHANGE,
  SSL_OP_CRYPTOPRO_TLSEXT_BUG,
  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS,
  SSL_OP_LEGACY_SERVER_CONNECT,
  SSL_OP_NO_COMPRESSION,
  SSL_OP_NO_ENCRYPT_THEN_MAC,
  SSL_OP_NO_QUERY_MTU,
  SSL_OP_NO_RENEGOTIATION,
  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION,
  SSL_OP_NO_SSLv2,
  SSL_OP_NO_SSLv3,
  SSL_OP_NO_TICKET,
  SSL_OP_NO_TLSv1,
  SSL_OP_NO_TLSv1_1,
  SSL_OP_NO_TLSv1_2,
  SSL_OP_NO_TLSv1_3,
  SSL_OP_PRIORITIZE_CHACHA,
  SSL_OP_TLS_ROLLBACK_BUG,
  ENGINE_METHOD_RSA,
  ENGINE_METHOD_DSA,
  ENGINE_METHOD_DH,
  ENGINE_METHOD_RAND,
  ENGINE_METHOD_EC,
  ENGINE_METHOD_CIPHERS,
  ENGINE_METHOD_DIGESTS,
  ENGINE_METHOD_PKEY_METHS,
  ENGINE_METHOD_PKEY_ASN1_METHS,
  ENGINE_METHOD_ALL,
  ENGINE_METHOD_NONE,
  DH_CHECK_P_NOT_SAFE_PRIME,
  DH_CHECK_P_NOT_PRIME,
  DH_UNABLE_TO_CHECK_GENERATOR,
  DH_NOT_SUITABLE_GENERATOR,
  RSA_PKCS1_PADDING,
  RSA_NO_PADDING,
  RSA_PKCS1_OAEP_PADDING,
  RSA_X931_PADDING,
  RSA_PKCS1_PSS_PADDING,
  RSA_PSS_SALTLEN_DIGEST,
  RSA_PSS_SALTLEN_MAX_SIGN,
  RSA_PSS_SALTLEN_AUTO,
  defaultCoreCipherList,
  TLS1_VERSION,
  TLS1_1_VERSION,
  TLS1_2_VERSION,
  TLS1_3_VERSION,
  POINT_CONVERSION_COMPRESSED,
  POINT_CONVERSION_UNCOMPRESSED,
  POINT_CONVERSION_HYBRID,
  UV_FS_SYMLINK_DIR,
  UV_FS_SYMLINK_JUNCTION,
  O_RDONLY,
  O_WRONLY,
  O_RDWR,
  UV_DIRENT_UNKNOWN,
  UV_DIRENT_FILE,
  UV_DIRENT_DIR,
  UV_DIRENT_LINK,
  UV_DIRENT_FIFO,
  UV_DIRENT_SOCKET,
  UV_DIRENT_CHAR,
  UV_DIRENT_BLOCK,
  EXTENSIONLESS_FORMAT_JAVASCRIPT,
  EXTENSIONLESS_FORMAT_WASM,
  S_IFMT,
  S_IFREG,
  S_IFDIR,
  S_IFCHR,
  S_IFBLK,
  S_IFIFO,
  S_IFLNK,
  S_IFSOCK,
  O_CREAT,
  O_EXCL,
  UV_FS_O_FILEMAP,
  O_NOCTTY,
  O_TRUNC,
  O_APPEND,
  O_DIRECTORY,
  O_NOATIME,
  O_NOFOLLOW,
  O_SYNC,
  O_DSYNC,
  O_DIRECT,
  O_NONBLOCK,
  S_IRWXU,
  S_IRUSR,
  S_IWUSR,
  S_IXUSR,
  S_IRWXG,
  S_IRGRP,
  S_IWGRP,
  S_IXGRP,
  S_IRWXO,
  S_IROTH,
  S_IWOTH,
  S_IXOTH,
  F_OK,
  R_OK,
  W_OK,
  X_OK,
  UV_FS_COPYFILE_EXCL,
  COPYFILE_EXCL,
  UV_FS_COPYFILE_FICLONE,
  COPYFILE_FICLONE,
  UV_FS_COPYFILE_FICLONE_FORCE,
  COPYFILE_FICLONE_FORCE,
  E2BIG,
  EACCES,
  EADDRINUSE,
  EADDRNOTAVAIL,
  EAFNOSUPPORT,
  EAGAIN,
  EALREADY,
  EBADF,
  EBADMSG,
  EBUSY,
  ECANCELED,
  ECHILD,
  ECONNABORTED,
  ECONNREFUSED,
  ECONNRESET,
  EDEADLK,
  EDESTADDRREQ,
  EDOM,
  EDQUOT,
  EEXIST,
  EFAULT,
  EFBIG,
  EHOSTUNREACH,
  EIDRM,
  EILSEQ,
  EINPROGRESS,
  EINTR,
  EINVAL,
  EIO,
  EISCONN,
  EISDIR,
  ELOOP,
  EMFILE,
  EMLINK,
  EMSGSIZE,
  EMULTIHOP,
  ENAMETOOLONG,
  ENETDOWN,
  ENETRESET,
  ENETUNREACH,
  ENFILE,
  ENOBUFS,
  ENODATA,
  ENODEV,
  ENOENT,
  ENOEXEC,
  ENOLCK,
  ENOLINK,
  ENOMEM,
  ENOMSG,
  ENOPROTOOPT,
  ENOSPC,
  ENOSR,
  ENOSTR,
  ENOSYS,
  ENOTCONN,
  ENOTDIR,
  ENOTEMPTY,
  ENOTSOCK,
  ENOTSUP,
  ENOTTY,
  ENXIO,
  EOPNOTSUPP,
  EOVERFLOW,
  EPERM,
  EPIPE,
  EPROTO,
  EPROTONOSUPPORT,
  EPROTOTYPE,
  ERANGE,
  EROFS,
  ESPIPE,
  ESRCH,
  ESTALE,
  ETIME,
  ETIMEDOUT,
  ETXTBSY,
  EWOULDBLOCK,
  EXDEV,
  RTLD_LAZY,
  RTLD_NOW,
  RTLD_GLOBAL,
  RTLD_LOCAL,
  RTLD_DEEPBIND,
  PRIORITY_LOW,
  PRIORITY_BELOW_NORMAL,
  PRIORITY_NORMAL,
  PRIORITY_ABOVE_NORMAL,
  PRIORITY_HIGH,
  PRIORITY_HIGHEST,
  SIGHUP,
  SIGINT,
  SIGQUIT,
  SIGILL,
  SIGTRAP,
  SIGABRT,
  SIGIOT,
  SIGBUS,
  SIGFPE,
  SIGKILL,
  SIGUSR1,
  SIGSEGV,
  SIGUSR2,
  SIGPIPE,
  SIGALRM,
  SIGTERM,
  SIGCHLD,
  SIGSTKFLT,
  SIGCONT,
  SIGSTOP,
  SIGTSTP,
  SIGTTIN,
  SIGTTOU,
  SIGURG,
  SIGXCPU,
  SIGXFSZ,
  SIGVTALRM,
  SIGPROF,
  SIGWINCH,
  SIGIO,
  SIGPOLL,
  SIGPWR,
  SIGSYS
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/bundles/utilsBundleImpl.js
import require$$63 from "node:stream";
import require$$53 from "node:assert";
import require$$0$32 from "node:events";

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/os.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
var constants3 = {
  UV_UDP_REUSEADDR,
  dlopen: dlopen2,
  errno,
  signals,
  priority
};
var NUM_CPUS = 8;
var availableParallelism = /* @__PURE__ */ __name(() => NUM_CPUS, "availableParallelism");
var arch2 = /* @__PURE__ */ __name(() => "", "arch");
var machine = /* @__PURE__ */ __name(() => "", "machine");
var endianness = /* @__PURE__ */ __name(() => "LE", "endianness");
var cpus = /* @__PURE__ */ __name(() => {
  const info3 = {
    model: "",
    speed: 0,
    times: {
      user: 0,
      nice: 0,
      sys: 0,
      idle: 0,
      irq: 0
    }
  };
  return Array.from({ length: NUM_CPUS }, () => info3);
}, "cpus");
var getPriority = /* @__PURE__ */ __name(() => 0, "getPriority");
var setPriority = /* @__PURE__ */ notImplemented("os.setPriority");
var homedir = /* @__PURE__ */ __name(() => "/", "homedir");
var tmpdir = /* @__PURE__ */ __name(() => "/tmp", "tmpdir");
var devNull = "/dev/null";
var freemem = /* @__PURE__ */ __name(() => 0, "freemem");
var totalmem = /* @__PURE__ */ __name(() => 0, "totalmem");
var loadavg = /* @__PURE__ */ __name(() => [
  0,
  0,
  0
], "loadavg");
var uptime2 = /* @__PURE__ */ __name(() => 0, "uptime");
var hostname = /* @__PURE__ */ __name(() => "", "hostname");
var networkInterfaces = /* @__PURE__ */ __name(() => {
  return { lo0: [
    {
      address: "127.0.0.1",
      netmask: "255.0.0.0",
      family: "IPv4",
      mac: "00:00:00:00:00:00",
      internal: true,
      cidr: "127.0.0.1/8"
    },
    {
      address: "::1",
      netmask: "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
      family: "IPv6",
      mac: "00:00:00:00:00:00",
      internal: true,
      cidr: "::1/128",
      scopeid: 0
    },
    {
      address: "fe80::1",
      netmask: "ffff:ffff:ffff:ffff::",
      family: "IPv6",
      mac: "00:00:00:00:00:00",
      internal: true,
      cidr: "fe80::1/64",
      scopeid: 1
    }
  ] };
}, "networkInterfaces");
var platform2 = /* @__PURE__ */ __name(() => "linux", "platform");
var type = /* @__PURE__ */ __name(() => "Linux", "type");
var release2 = /* @__PURE__ */ __name(() => "", "release");
var version2 = /* @__PURE__ */ __name(() => "", "version");
var userInfo = /* @__PURE__ */ __name((opts) => {
  const encode = /* @__PURE__ */ __name((str) => {
    if (opts?.encoding) {
      const buff = Buffer.from(str);
      return opts.encoding === "buffer" ? buff : buff.toString(opts.encoding);
    }
    return str;
  }, "encode");
  return {
    gid: 1e3,
    uid: 1e3,
    homedir: encode("/"),
    shell: encode("/bin/sh"),
    username: encode("root")
  };
}, "userInfo");
var EOL = "\n";
var os_default = {
  arch: arch2,
  availableParallelism,
  constants: constants3,
  cpus,
  EOL,
  endianness,
  devNull,
  freemem,
  getPriority,
  homedir,
  hostname,
  loadavg,
  machine,
  networkInterfaces,
  platform: platform2,
  release: release2,
  setPriority,
  tmpdir,
  totalmem,
  type,
  uptime: uptime2,
  userInfo,
  version: version2
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/bundles/utilsBundleImpl.js
import url from "node:url";
import net from "node:net";

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/tls.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/tls.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tls/server.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
import { Server as _Server } from "node:net";
var Server = class extends _Server {
  static {
    __name(this, "Server");
  }
  constructor(arg1, arg2) {
    super(arg1, arg2);
  }
  addContext(hostname2, context2) {
  }
  setSecureContext(options2) {
  }
  setTicketKeys(_keys) {
    throw createNotImplementedError("Server.setTicketKeys");
  }
  getTicketKeys() {
    throw createNotImplementedError("Server.getTicketKeys");
  }
};

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tls/constants.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CLIENT_RENEG_LIMIT = 3;
var CLIENT_RENEG_WINDOW = 600;
var DEFAULT_CIPHERS = "";
var DEFAULT_ECDH_CURVE = "auto";
var DEFAULT_MIN_VERSION = "TLSv1.2";
var DEFAULT_MAX_VERSION = "TLSv1.3";

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/tls.mjs
var createServer = /* @__PURE__ */ __name(function createServer2() {
  return new Server();
}, "createServer");
var createSecurePair = /* @__PURE__ */ notImplemented("tls.createSecurePair");
var getCiphers2 = /* @__PURE__ */ notImplemented("tls.getCiphers");
var rootCertificates = [];

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/tls.mjs
var workerdTls = process.getBuiltinModule("node:tls");
var {
  checkServerIdentity,
  connect,
  createSecureContext,
  // @ts-expect-error @types/node does not provide this function
  convertALPNProtocols,
  // @ts-expect-error Node typings wrongly declare `SecureContext` as an interface
  SecureContext,
  TLSSocket
} = workerdTls;
var tls_default = {
  CLIENT_RENEG_LIMIT,
  CLIENT_RENEG_WINDOW,
  DEFAULT_CIPHERS,
  DEFAULT_ECDH_CURVE,
  DEFAULT_MAX_VERSION,
  DEFAULT_MIN_VERSION,
  // @ts-expect-error
  SecureContext,
  Server,
  TLSSocket,
  checkServerIdentity,
  connect,
  convertALPNProtocols,
  createSecureContext,
  createSecurePair,
  createServer,
  getCiphers: getCiphers2,
  rootCertificates
};

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/child_process.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
var ChildProcess = /* @__PURE__ */ notImplementedClass("child_process.ChildProcess");
var _forkChild = /* @__PURE__ */ notImplemented("child_process.ChildProcess");
var exec = /* @__PURE__ */ notImplemented("child_process.exec");
var execFile = /* @__PURE__ */ notImplemented("child_process.execFile");
var execFileSync = /* @__PURE__ */ notImplemented("child_process.execFileSync");
var execSync = /* @__PURE__ */ notImplemented("child_process.execSyn");
var fork = /* @__PURE__ */ notImplemented("child_process.fork");
var spawn = /* @__PURE__ */ notImplemented("child_process.spawn");
var spawnSync = /* @__PURE__ */ notImplemented("child_process.spawnSync");
var child_process_default = {
  ChildProcess,
  _forkChild,
  exec,
  execFile,
  execFileSync,
  execSync,
  fork,
  spawn,
  spawnSync
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/bundles/pngjs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import require$$62 from "node:stream";
import require$$0$12 from "node:buffer";
import require$$52 from "node:assert";
var png = {};
var parserAsync = { exports: {} };
var lib2 = {};
var binding2 = {};
var zstream;
var hasRequiredZstream;
function requireZstream() {
  if (hasRequiredZstream) return zstream;
  hasRequiredZstream = 1;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  __name(ZStream, "ZStream");
  zstream = ZStream;
  return zstream;
}
__name(requireZstream, "requireZstream");
var deflate = {};
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  (function(exports) {
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    __name(_has, "_has");
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source7 = sources.shift();
        if (!source7) {
          continue;
        }
        if (typeof source7 !== "object") {
          throw new TypeError(source7 + "must be non-object");
        }
        for (var p in source7) {
          if (_has(source7, p)) {
            obj[p] = source7[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: /* @__PURE__ */ __name(function(dest, src2, src_offs, len, dest_offs) {
        if (src2.subarray && dest.subarray) {
          dest.set(src2.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src2[src_offs + i];
        }
      }, "arraySet"),
      // Join array of chunks to single array.
      flattenChunks: /* @__PURE__ */ __name(function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }, "flattenChunks")
    };
    var fnUntyped = {
      arraySet: /* @__PURE__ */ __name(function(dest, src2, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src2[src_offs + i];
        }
      }, "arraySet"),
      // Join array of chunks to single array.
      flattenChunks: /* @__PURE__ */ __name(function(chunks) {
        return [].concat.apply([], chunks);
      }, "flattenChunks")
    };
    exports.setTyped = function(on2) {
      if (on2) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  })(common);
  return common;
}
__name(requireCommon, "requireCommon");
var trees = {};
var hasRequiredTrees;
function requireTrees() {
  if (hasRequiredTrees) return trees;
  hasRequiredTrees = 1;
  var utils2 = requireCommon();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  __name(zero, "zero");
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  );
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  __name(StaticTreeDesc, "StaticTreeDesc");
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  __name(TreeDesc, "TreeDesc");
  function d_code(dist2) {
    return dist2 < 256 ? _dist_code[dist2] : _dist_code[256 + (dist2 >>> 7)];
  }
  __name(d_code, "d_code");
  function put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  __name(put_short, "put_short");
  function send_bits(s, value, length) {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  }
  __name(send_bits, "send_bits");
  function send_code(s, c, tree) {
    send_bits(
      s,
      tree[c * 2],
      tree[c * 2 + 1]
      /*.Len*/
    );
  }
  __name(send_code, "send_code");
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  __name(bi_reverse, "bi_reverse");
  function bi_flush(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  __name(bi_flush, "bi_flush");
  function gen_bitlen(s, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n, m;
    var bits;
    var xbits;
    var f;
    var overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  }
  __name(gen_bitlen, "gen_bitlen");
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      var len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  __name(gen_codes, "gen_codes");
  function tr_static_init() {
    var n;
    var bits;
    var length;
    var code;
    var dist2;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n = 0; n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist2 = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist2;
      for (n = 0; n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist2++] = code;
      }
    }
    dist2 >>= 7;
    for (; code < D_CODES; code++) {
      base_dist[code] = dist2 << 7;
      for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist2++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n = 0; n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  __name(tr_static_init, "tr_static_init");
  function init_block(s) {
    var n;
    for (n = 0; n < L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  __name(init_block, "init_block");
  function bi_windup(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  __name(bi_windup, "bi_windup");
  function copy_block(s, buf, len, header) {
    bi_windup(s);
    {
      put_short(s, len);
      put_short(s, ~len);
    }
    utils2.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
  }
  __name(copy_block, "copy_block");
  function smaller(tree, n, m, depth) {
    var _n2 = n * 2;
    var _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  __name(smaller, "smaller");
  function pqdownheap(s, tree, k) {
    var v = s.heap[k];
    var j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  __name(pqdownheap, "pqdownheap");
  function compress_block(s, ltree, dtree) {
    var dist2;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s.last_lit !== 0) {
      do {
        dist2 = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist2 === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist2--;
          code = d_code(dist2);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist2 -= base_dist[code];
            send_bits(s, dist2, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    send_code(s, END_BLOCK, ltree);
  }
  __name(compress_block, "compress_block");
  function build_tree(s, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m;
    var max_code = -1;
    var node2;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node2 = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node2 * 2] = 1;
      s.depth[node2] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node2 * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node2 = elems;
    do {
      n = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[
        1
        /*SMALLEST*/
      ] = s.heap[s.heap_len--];
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
      m = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node2 * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node2] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node2;
      s.heap[
        1
        /*SMALLEST*/
      ] = node2++;
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  }
  __name(build_tree, "build_tree");
  function scan_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count3 = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count3 < max_count && curlen === nextlen) {
        continue;
      } else if (count3 < min_count) {
        s.bl_tree[curlen * 2] += count3;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count3 <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count3 = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  __name(scan_tree, "scan_tree");
  function send_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count3 = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count3 < max_count && curlen === nextlen) {
        continue;
      } else if (count3 < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count3 !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count3--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count3 - 3, 2);
      } else if (count3 <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count3 - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count3 - 11, 7);
      }
      count3 = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  __name(send_tree, "send_tree");
  function build_bl_tree(s) {
    var max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  __name(build_bl_tree, "build_bl_tree");
  function send_all_trees(s, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  __name(send_all_trees, "send_all_trees");
  function detect_data_type(s) {
    var black_mask = 4093624447;
    var n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32; n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  }
  __name(detect_data_type, "detect_data_type");
  var static_init_done = false;
  function _tr_init(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  }
  __name(_tr_init, "_tr_init");
  function _tr_stored_block(s, buf, stored_len, last) {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len);
  }
  __name(_tr_stored_block, "_tr_stored_block");
  function _tr_align(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  }
  __name(_tr_align, "_tr_align");
  function _tr_flush_block(s, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  }
  __name(_tr_flush_block, "_tr_flush_block");
  function _tr_tally(s, dist2, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist2 >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist2 & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist2 === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist2--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist2) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
  __name(_tr_tally, "_tr_tally");
  trees._tr_init = _tr_init;
  trees._tr_stored_block = _tr_stored_block;
  trees._tr_flush_block = _tr_flush_block;
  trees._tr_tally = _tr_tally;
  trees._tr_align = _tr_align;
  return trees;
}
__name(requireTrees, "requireTrees");
var adler32_1;
var hasRequiredAdler32;
function requireAdler32() {
  if (hasRequiredAdler32) return adler32_1;
  hasRequiredAdler32 = 1;
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  __name(adler32, "adler32");
  adler32_1 = adler32;
  return adler32_1;
}
__name(requireAdler32, "requireAdler32");
var crc32_1;
var hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32) return crc32_1;
  hasRequiredCrc32 = 1;
  function makeTable() {
    var c, table3 = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table3[n] = c;
    }
    return table3;
  }
  __name(makeTable, "makeTable");
  var crcTable = makeTable();
  function crc32(crc2, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc2 ^= -1;
    for (var i = pos; i < end; i++) {
      crc2 = crc2 >>> 8 ^ t[(crc2 ^ buf[i]) & 255];
    }
    return crc2 ^ -1;
  }
  __name(crc32, "crc32");
  crc32_1 = crc32;
  return crc32_1;
}
__name(requireCrc32, "requireCrc32");
var messages;
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages) return messages;
  hasRequiredMessages = 1;
  messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  return messages;
}
__name(requireMessages, "requireMessages");
var hasRequiredDeflate;
function requireDeflate() {
  if (hasRequiredDeflate) return deflate;
  hasRequiredDeflate = 1;
  var utils2 = requireCommon();
  var trees2 = requireTrees();
  var adler32 = requireAdler32();
  var crc32 = requireCrc32();
  var msg = requireMessages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  __name(err, "err");
  function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  __name(rank, "rank");
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  __name(zero, "zero");
  function flush_pending(strm) {
    var s = strm.state;
    var len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils2.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  __name(flush_pending, "flush_pending");
  function flush_block_only(s, last) {
    trees2._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  }
  __name(flush_block_only, "flush_block_only");
  function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  __name(put_byte, "put_byte");
  function putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  __name(putShortMSB, "putShortMSB");
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils2.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  __name(read_buf, "read_buf");
  function longest_match(s, cur_match) {
    var chain_length = s.max_chain_length;
    var scan = s.strstart;
    var match;
    var len;
    var best_len = s.prev_length;
    var nice_match = s.nice_match;
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s.window;
    var wmask = s.w_mask;
    var prev = s.prev;
    var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  __name(longest_match, "longest_match");
  function fill_window(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils2.arraySet(s.window, s.window, _w_size, _w_size, 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
        while (s.insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  __name(fill_window, "fill_window");
  function deflate_stored(s, flush) {
    var max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        fill_window(s);
        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      var max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  __name(deflate_stored, "deflate_stored");
  function deflate_fast(s, flush) {
    var hash_head;
    var bflush;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees2._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
        }
      } else {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  __name(deflate_fast, "deflate_fast");
  function deflate_slow(s, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = trees2._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = trees2._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  __name(deflate_slow, "deflate_slow");
  function deflate_rle(s, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s.window;
    for (; ; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees2._tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  __name(deflate_rle, "deflate_rle");
  function deflate_huff(s, flush) {
    var bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  __name(deflate_huff, "deflate_huff");
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  __name(Config, "Config");
  var configuration_table;
  configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  function lm_init(s) {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  __name(lm_init, "lm_init");
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils2.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils2.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils2.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils2.Buf16(MAX_BITS + 1);
    this.heap = new utils2.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils2.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  __name(DeflateState, "DeflateState");
  function deflateResetKeep(strm) {
    var s;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;
    trees2._tr_init(s);
    return Z_OK;
  }
  __name(deflateResetKeep, "deflateResetKeep");
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  }
  __name(deflateReset, "deflateReset");
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  }
  __name(deflateSetHeader, "deflateSetHeader");
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils2.Buf8(s.w_size * 2);
    s.head = new utils2.Buf16(s.hash_size);
    s.prev = new utils2.Buf16(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new utils2.Buf8(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  }
  __name(deflateInit2, "deflateInit2");
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }
  __name(deflateInit, "deflateInit");
  function deflate$1(strm, flush) {
    var old_flush, s;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s.strm = strm;
    old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
        s.status = NAME_STATE;
      }
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
        s.status = COMMENT_STATE;
      }
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
        s.status = HCRC_STATE;
      }
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees2._tr_align(s);
        } else if (flush !== Z_BLOCK) {
          trees2._tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  }
  __name(deflate$1, "deflate$1");
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }
  __name(deflateEnd, "deflateEnd");
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s = strm.state;
    wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      tmpDict = new utils2.Buf8(s.w_size);
      utils2.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      str = s.strstart;
      n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  }
  __name(deflateSetDictionary, "deflateSetDictionary");
  deflate.deflateInit = deflateInit;
  deflate.deflateInit2 = deflateInit2;
  deflate.deflateReset = deflateReset;
  deflate.deflateResetKeep = deflateResetKeep;
  deflate.deflateSetHeader = deflateSetHeader;
  deflate.deflate = deflate$1;
  deflate.deflateEnd = deflateEnd;
  deflate.deflateSetDictionary = deflateSetDictionary;
  deflate.deflateInfo = "pako deflate (from Nodeca project)";
  return deflate;
}
__name(requireDeflate, "requireDeflate");
var inflate = {};
var inffast;
var hasRequiredInffast;
function requireInffast() {
  if (hasRequiredInffast) return inffast;
  hasRequiredInffast = 1;
  var BAD = 30;
  var TYPE = 12;
  inffast = /* @__PURE__ */ __name(function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist2;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist2 = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist2 += hold & (1 << op) - 1;
                    if (dist2 > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist2 > op) {
                      op = dist2 - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist2;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist2;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }, "inflate_fast");
  return inffast;
}
__name(requireInffast, "requireInffast");
var inftrees;
var hasRequiredInftrees;
function requireInftrees() {
  if (hasRequiredInftrees) return inftrees;
  hasRequiredInftrees = 1;
  var utils2 = requireCommon();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  inftrees = /* @__PURE__ */ __name(function inflate_table(type2, lens, lens_index, codes, table3, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0, max = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count3 = new utils2.Buf16(MAXBITS + 1);
    var offs = new utils2.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count3[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count3[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count3[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table3[table_index++] = 1 << 24 | 64 << 16 | 0;
      table3[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count3[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count3[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type2 === CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count3[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type2 === CODES) {
      base = extra = work;
      end = 19;
    } else if (type2 === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table3[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count3[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count3[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table3[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table3[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }, "inflate_table");
  return inftrees;
}
__name(requireInftrees, "requireInftrees");
var hasRequiredInflate;
function requireInflate() {
  if (hasRequiredInflate) return inflate;
  hasRequiredInflate = 1;
  var utils2 = requireCommon();
  var adler32 = requireAdler32();
  var crc32 = requireCrc32();
  var inflate_fast = requireInffast();
  var inflate_table = requireInftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  __name(zswap32, "zswap32");
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils2.Buf16(320);
    this.work = new utils2.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  __name(InflateState, "InflateState");
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils2.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils2.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  }
  __name(inflateResetKeep, "inflateResetKeep");
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  __name(inflateReset, "inflateReset");
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  __name(inflateReset2, "inflateReset2");
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state = new InflateState();
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  __name(inflateInit2, "inflateInit2");
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  __name(inflateInit, "inflateInit");
  var virgin = true;
  var lenfix, distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils2.Buf32(512);
      distfix = new utils2.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  __name(fixedtables, "fixedtables");
  function updatewindow(strm, src2, end, copy) {
    var dist2;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils2.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils2.arraySet(state.window, src2, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist2 = state.wsize - state.wnext;
      if (dist2 > copy) {
        dist2 = copy;
      }
      utils2.arraySet(state.window, src2, end - copy, dist2, state.wnext);
      copy -= dist2;
      if (copy) {
        utils2.arraySet(state.window, src2, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist2;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist2;
        }
      }
    }
    return 0;
  }
  __name(updatewindow, "updatewindow");
  function inflate$1(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils2.Buf8(4);
    var opts;
    var n;
    var order = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          /* falls through */
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          /* falls through */
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          /* falls through */
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          /* falls through */
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils2.arraySet(
                    state.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          /* falls through */
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          /* falls through */
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          /* falls through */
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          /* falls through */
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          /* falls through */
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case COPY_:
            state.mode = COPY;
          /* falls through */
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils2.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          /* falls through */
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          /* falls through */
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case LEN_:
            state.mode = LEN;
          /* falls through */
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          /* falls through */
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          /* falls through */
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          /* falls through */
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          /* falls through */
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          /* falls through */
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          /* falls through */
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          /* falls through */
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  }
  __name(inflate$1, "inflate$1");
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  }
  __name(inflateEnd, "inflateEnd");
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  }
  __name(inflateGetHeader, "inflateGetHeader");
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  }
  __name(inflateSetDictionary, "inflateSetDictionary");
  inflate.inflateReset = inflateReset;
  inflate.inflateReset2 = inflateReset2;
  inflate.inflateResetKeep = inflateResetKeep;
  inflate.inflateInit = inflateInit;
  inflate.inflateInit2 = inflateInit2;
  inflate.inflate = inflate$1;
  inflate.inflateEnd = inflateEnd;
  inflate.inflateGetHeader = inflateGetHeader;
  inflate.inflateSetDictionary = inflateSetDictionary;
  inflate.inflateInfo = "pako inflate (from Nodeca project)";
  return inflate;
}
__name(requireInflate, "requireInflate");
var constants$12;
var hasRequiredConstants$12;
function requireConstants$12() {
  if (hasRequiredConstants$12) return constants$12;
  hasRequiredConstants$12 = 1;
  constants$12 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return constants$12;
}
__name(requireConstants$12, "requireConstants$1");
var hasRequiredBinding;
function requireBinding() {
  if (hasRequiredBinding) return binding2;
  hasRequiredBinding = 1;
  (function(exports) {
    var assert4 = require$$52;
    var Zstream = requireZstream();
    var zlib_deflate = requireDeflate();
    var zlib_inflate = requireInflate();
    var constants8 = requireConstants$12();
    for (var key in constants8) {
      exports[key] = constants8[key];
    }
    exports.NONE = 0;
    exports.DEFLATE = 1;
    exports.INFLATE = 2;
    exports.GZIP = 3;
    exports.GUNZIP = 4;
    exports.DEFLATERAW = 5;
    exports.INFLATERAW = 6;
    exports.UNZIP = 7;
    var GZIP_HEADER_ID1 = 31;
    var GZIP_HEADER_ID2 = 139;
    function Zlib(mode) {
      if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
        throw new TypeError("Bad argument");
      }
      this.dictionary = null;
      this.err = 0;
      this.flush = 0;
      this.init_done = false;
      this.level = 0;
      this.memLevel = 0;
      this.mode = mode;
      this.strategy = 0;
      this.windowBits = 0;
      this.write_in_progress = false;
      this.pending_close = false;
      this.gzip_id_bytes_read = 0;
    }
    __name(Zlib, "Zlib");
    Zlib.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      this.pending_close = false;
      assert4(this.init_done, "close before init");
      assert4(this.mode <= exports.UNZIP);
      if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
        zlib_deflate.deflateEnd(this.strm);
      } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
        zlib_inflate.inflateEnd(this.strm);
      }
      this.mode = exports.NONE;
      this.dictionary = null;
    };
    Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
      return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
      return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
      assert4.equal(arguments.length, 8);
      assert4(this.init_done, "write before init");
      assert4(this.mode !== exports.NONE, "already finalized");
      assert4.equal(false, this.write_in_progress, "write already in progress");
      assert4.equal(false, this.pending_close, "close is pending");
      this.write_in_progress = true;
      assert4.equal(false, flush === void 0, "must provide flush value");
      this.write_in_progress = true;
      if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
        throw new Error("Invalid flush value");
      }
      if (input == null) {
        input = Buffer.alloc(0);
        in_len = 0;
        in_off = 0;
      }
      this.strm.avail_in = in_len;
      this.strm.input = input;
      this.strm.next_in = in_off;
      this.strm.avail_out = out_len;
      this.strm.output = out;
      this.strm.next_out = out_off;
      this.flush = flush;
      if (!async) {
        this._process();
        if (this._checkError()) {
          return this._afterSync();
        }
        return;
      }
      var self2 = this;
      process.nextTick(function() {
        self2._process();
        self2._after();
      });
      return this;
    };
    Zlib.prototype._afterSync = function() {
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      return [avail_in, avail_out];
    };
    Zlib.prototype._process = function() {
      var next_expected_header_byte = null;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflate(this.strm, this.flush);
          break;
        case exports.UNZIP:
          if (this.strm.avail_in > 0) {
            next_expected_header_byte = this.strm.next_in;
          }
          switch (this.gzip_id_bytes_read) {
            case 0:
              if (next_expected_header_byte === null) {
                break;
              }
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                this.gzip_id_bytes_read = 1;
                next_expected_header_byte++;
                if (this.strm.avail_in === 1) {
                  break;
                }
              } else {
                this.mode = exports.INFLATE;
                break;
              }
            // fallthrough
            case 1:
              if (next_expected_header_byte === null) {
                break;
              }
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                this.gzip_id_bytes_read = 2;
                this.mode = exports.GUNZIP;
              } else {
                this.mode = exports.INFLATE;
              }
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        // fallthrough
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
          this.err = zlib_inflate.inflate(
            this.strm,
            this.flush
            // If data was encoded with dictionary
          );
          if (this.err === exports.Z_NEED_DICT && this.dictionary) {
            this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
            if (this.err === exports.Z_OK) {
              this.err = zlib_inflate.inflate(this.strm, this.flush);
            } else if (this.err === exports.Z_DATA_ERROR) {
              this.err = exports.Z_NEED_DICT;
            }
          }
          while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
            this.reset();
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          }
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    };
    Zlib.prototype._checkError = function() {
      switch (this.err) {
        case exports.Z_OK:
        case exports.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
            this._error("unexpected end of file");
            return false;
          }
          break;
        case exports.Z_STREAM_END:
          break;
        case exports.Z_NEED_DICT:
          if (this.dictionary == null) {
            this._error("Missing dictionary");
          } else {
            this._error("Bad dictionary");
          }
          return false;
        default:
          this._error("Zlib error");
          return false;
      }
      return true;
    };
    Zlib.prototype._after = function() {
      if (!this._checkError()) {
        return;
      }
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      this.callback(avail_in, avail_out);
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype._error = function(message) {
      if (this.strm.msg) {
        message = this.strm.msg;
      }
      this.onerror(
        message,
        this.err
        // no hope of rescue.
      );
      this.write_in_progress = false;
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
      assert4(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
      assert4(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
      assert4(level >= -1 && level <= 9, "invalid compression level");
      assert4(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
      assert4(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
      this._init(level, windowBits, memLevel, strategy, dictionary);
      this._setDictionary();
    };
    Zlib.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    };
    Zlib.prototype.reset = function() {
      this._reset();
      this._setDictionary();
    };
    Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
      this.level = level;
      this.windowBits = windowBits;
      this.memLevel = memLevel;
      this.strategy = strategy;
      this.flush = exports.Z_NO_FLUSH;
      this.err = exports.Z_OK;
      if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
        this.windowBits += 16;
      }
      if (this.mode === exports.UNZIP) {
        this.windowBits += 32;
      }
      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
        this.windowBits = -1 * this.windowBits;
      }
      this.strm = new Zstream();
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
        case exports.UNZIP:
          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (this.err !== exports.Z_OK) {
        this._error("Init error");
      }
      this.dictionary = dictionary;
      this.write_in_progress = false;
      this.init_done = true;
    };
    Zlib.prototype._setDictionary = function() {
      if (this.dictionary == null) {
        return;
      }
      this.err = exports.Z_OK;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
          break;
      }
      if (this.err !== exports.Z_OK) {
        this._error("Failed to set dictionary");
      }
    };
    Zlib.prototype._reset = function() {
      this.err = exports.Z_OK;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
        case exports.GZIP:
          this.err = zlib_deflate.deflateReset(this.strm);
          break;
        case exports.INFLATE:
        case exports.INFLATERAW:
        case exports.GUNZIP:
          this.err = zlib_inflate.inflateReset(this.strm);
          break;
      }
      if (this.err !== exports.Z_OK) {
        this._error("Failed to reset stream");
      }
    };
    exports.Zlib = Zlib;
  })(binding2);
  return binding2;
}
__name(requireBinding, "requireBinding");
var hasRequiredLib2;
function requireLib2() {
  if (hasRequiredLib2) return lib2;
  hasRequiredLib2 = 1;
  (function(exports) {
    var Buffer2 = require$$0$12.Buffer;
    var Transform2 = require$$62.Transform;
    var binding3 = requireBinding();
    var util3 = util_default;
    var assert4 = require$$52.ok;
    var kMaxLength = require$$0$12.kMaxLength;
    var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
    binding3.Z_MIN_WINDOWBITS = 8;
    binding3.Z_MAX_WINDOWBITS = 15;
    binding3.Z_DEFAULT_WINDOWBITS = 15;
    binding3.Z_MIN_CHUNK = 64;
    binding3.Z_MAX_CHUNK = Infinity;
    binding3.Z_DEFAULT_CHUNK = 16 * 1024;
    binding3.Z_MIN_MEMLEVEL = 1;
    binding3.Z_MAX_MEMLEVEL = 9;
    binding3.Z_DEFAULT_MEMLEVEL = 8;
    binding3.Z_MIN_LEVEL = -1;
    binding3.Z_MAX_LEVEL = 9;
    binding3.Z_DEFAULT_LEVEL = binding3.Z_DEFAULT_COMPRESSION;
    var bkeys = Object.keys(binding3);
    for (var bk = 0; bk < bkeys.length; bk++) {
      var bkey = bkeys[bk];
      if (bkey.match(/^Z/)) {
        Object.defineProperty(exports, bkey, {
          enumerable: true,
          value: binding3[bkey],
          writable: false
        });
      }
    }
    var codes = {
      Z_OK: binding3.Z_OK,
      Z_STREAM_END: binding3.Z_STREAM_END,
      Z_NEED_DICT: binding3.Z_NEED_DICT,
      Z_ERRNO: binding3.Z_ERRNO,
      Z_STREAM_ERROR: binding3.Z_STREAM_ERROR,
      Z_DATA_ERROR: binding3.Z_DATA_ERROR,
      Z_MEM_ERROR: binding3.Z_MEM_ERROR,
      Z_BUF_ERROR: binding3.Z_BUF_ERROR,
      Z_VERSION_ERROR: binding3.Z_VERSION_ERROR
    };
    var ckeys = Object.keys(codes);
    for (var ck = 0; ck < ckeys.length; ck++) {
      var ckey = ckeys[ck];
      codes[codes[ckey]] = ckey;
    }
    Object.defineProperty(exports, "codes", {
      enumerable: true,
      value: Object.freeze(codes),
      writable: false
    });
    exports.Deflate = Deflate;
    exports.Inflate = Inflate;
    exports.Gzip = Gzip;
    exports.Gunzip = Gunzip;
    exports.DeflateRaw = DeflateRaw;
    exports.InflateRaw = InflateRaw;
    exports.Unzip = Unzip;
    exports.createDeflate = function(o) {
      return new Deflate(o);
    };
    exports.createInflate = function(o) {
      return new Inflate(o);
    };
    exports.createDeflateRaw = function(o) {
      return new DeflateRaw(o);
    };
    exports.createInflateRaw = function(o) {
      return new InflateRaw(o);
    };
    exports.createGzip = function(o) {
      return new Gzip(o);
    };
    exports.createGunzip = function(o) {
      return new Gunzip(o);
    };
    exports.createUnzip = function(o) {
      return new Unzip(o);
    };
    exports.deflate = function(buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Deflate(opts), buffer2, callback);
    };
    exports.deflateSync = function(buffer2, opts) {
      return zlibBufferSync(new Deflate(opts), buffer2);
    };
    exports.gzip = function(buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gzip(opts), buffer2, callback);
    };
    exports.gzipSync = function(buffer2, opts) {
      return zlibBufferSync(new Gzip(opts), buffer2);
    };
    exports.deflateRaw = function(buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new DeflateRaw(opts), buffer2, callback);
    };
    exports.deflateRawSync = function(buffer2, opts) {
      return zlibBufferSync(new DeflateRaw(opts), buffer2);
    };
    exports.unzip = function(buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Unzip(opts), buffer2, callback);
    };
    exports.unzipSync = function(buffer2, opts) {
      return zlibBufferSync(new Unzip(opts), buffer2);
    };
    exports.inflate = function(buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Inflate(opts), buffer2, callback);
    };
    exports.inflateSync = function(buffer2, opts) {
      return zlibBufferSync(new Inflate(opts), buffer2);
    };
    exports.gunzip = function(buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gunzip(opts), buffer2, callback);
    };
    exports.gunzipSync = function(buffer2, opts) {
      return zlibBufferSync(new Gunzip(opts), buffer2);
    };
    exports.inflateRaw = function(buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new InflateRaw(opts), buffer2, callback);
    };
    exports.inflateRawSync = function(buffer2, opts) {
      return zlibBufferSync(new InflateRaw(opts), buffer2);
    };
    function zlibBuffer(engine, buffer2, callback) {
      var buffers = [];
      var nread = 0;
      engine.on("error", onError);
      engine.on("end", onEnd);
      engine.end(buffer2);
      flow();
      function flow() {
        var chunk;
        while (null !== (chunk = engine.read())) {
          buffers.push(chunk);
          nread += chunk.length;
        }
        engine.once("readable", flow);
      }
      __name(flow, "flow");
      function onError(err) {
        engine.removeListener("end", onEnd);
        engine.removeListener("readable", flow);
        callback(err);
      }
      __name(onError, "onError");
      function onEnd() {
        var buf;
        var err = null;
        if (nread >= kMaxLength) {
          err = new RangeError(kRangeErrorMessage);
        } else {
          buf = Buffer2.concat(buffers, nread);
        }
        buffers = [];
        engine.close();
        callback(err, buf);
      }
      __name(onEnd, "onEnd");
    }
    __name(zlibBuffer, "zlibBuffer");
    function zlibBufferSync(engine, buffer2) {
      if (typeof buffer2 === "string") buffer2 = Buffer2.from(buffer2);
      if (!Buffer2.isBuffer(buffer2)) throw new TypeError("Not a string or buffer");
      var flushFlag = engine._finishFlushFlag;
      return engine._processChunk(buffer2, flushFlag);
    }
    __name(zlibBufferSync, "zlibBufferSync");
    function Deflate(opts) {
      if (!(this instanceof Deflate)) return new Deflate(opts);
      Zlib.call(this, opts, binding3.DEFLATE);
    }
    __name(Deflate, "Deflate");
    function Inflate(opts) {
      if (!(this instanceof Inflate)) return new Inflate(opts);
      Zlib.call(this, opts, binding3.INFLATE);
    }
    __name(Inflate, "Inflate");
    function Gzip(opts) {
      if (!(this instanceof Gzip)) return new Gzip(opts);
      Zlib.call(this, opts, binding3.GZIP);
    }
    __name(Gzip, "Gzip");
    function Gunzip(opts) {
      if (!(this instanceof Gunzip)) return new Gunzip(opts);
      Zlib.call(this, opts, binding3.GUNZIP);
    }
    __name(Gunzip, "Gunzip");
    function DeflateRaw(opts) {
      if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
      Zlib.call(this, opts, binding3.DEFLATERAW);
    }
    __name(DeflateRaw, "DeflateRaw");
    function InflateRaw(opts) {
      if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
      Zlib.call(this, opts, binding3.INFLATERAW);
    }
    __name(InflateRaw, "InflateRaw");
    function Unzip(opts) {
      if (!(this instanceof Unzip)) return new Unzip(opts);
      Zlib.call(this, opts, binding3.UNZIP);
    }
    __name(Unzip, "Unzip");
    function isValidFlushFlag(flag) {
      return flag === binding3.Z_NO_FLUSH || flag === binding3.Z_PARTIAL_FLUSH || flag === binding3.Z_SYNC_FLUSH || flag === binding3.Z_FULL_FLUSH || flag === binding3.Z_FINISH || flag === binding3.Z_BLOCK;
    }
    __name(isValidFlushFlag, "isValidFlushFlag");
    function Zlib(opts, mode) {
      var _this = this;
      this._opts = opts = opts || {};
      this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
      Transform2.call(this, opts);
      if (opts.flush && !isValidFlushFlag(opts.flush)) {
        throw new Error("Invalid flush flag: " + opts.flush);
      }
      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
        throw new Error("Invalid flush flag: " + opts.finishFlush);
      }
      this._flushFlag = opts.flush || binding3.Z_NO_FLUSH;
      this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding3.Z_FINISH;
      if (opts.chunkSize) {
        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
          throw new Error("Invalid chunk size: " + opts.chunkSize);
        }
      }
      if (opts.windowBits) {
        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
          throw new Error("Invalid windowBits: " + opts.windowBits);
        }
      }
      if (opts.level) {
        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
          throw new Error("Invalid compression level: " + opts.level);
        }
      }
      if (opts.memLevel) {
        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
          throw new Error("Invalid memLevel: " + opts.memLevel);
        }
      }
      if (opts.strategy) {
        if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
          throw new Error("Invalid strategy: " + opts.strategy);
        }
      }
      if (opts.dictionary) {
        if (!Buffer2.isBuffer(opts.dictionary)) {
          throw new Error("Invalid dictionary: it should be a Buffer instance");
        }
      }
      this._handle = new binding3.Zlib(mode);
      var self2 = this;
      this._hadError = false;
      this._handle.onerror = function(message, errno2) {
        _close(self2);
        self2._hadError = true;
        var error4 = new Error(message);
        error4.errno = errno2;
        error4.code = exports.codes[errno2];
        self2.emit("error", error4);
      };
      var level = exports.Z_DEFAULT_COMPRESSION;
      if (typeof opts.level === "number") level = opts.level;
      var strategy = exports.Z_DEFAULT_STRATEGY;
      if (typeof opts.strategy === "number") strategy = opts.strategy;
      this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
      this._buffer = Buffer2.allocUnsafe(this._chunkSize);
      this._offset = 0;
      this._level = level;
      this._strategy = strategy;
      this.once("end", this.close);
      Object.defineProperty(this, "_closed", {
        get: /* @__PURE__ */ __name(function() {
          return !_this._handle;
        }, "get"),
        configurable: true,
        enumerable: true
      });
    }
    __name(Zlib, "Zlib");
    util3.inherits(Zlib, Transform2);
    Zlib.prototype.params = function(level, strategy, callback) {
      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
        throw new RangeError("Invalid compression level: " + level);
      }
      if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new TypeError("Invalid strategy: " + strategy);
      }
      if (this._level !== level || this._strategy !== strategy) {
        var self2 = this;
        this.flush(binding3.Z_SYNC_FLUSH, function() {
          assert4(self2._handle, "zlib binding closed");
          self2._handle.params(level, strategy);
          if (!self2._hadError) {
            self2._level = level;
            self2._strategy = strategy;
            if (callback) callback();
          }
        });
      } else {
        process.nextTick(callback);
      }
    };
    Zlib.prototype.reset = function() {
      assert4(this._handle, "zlib binding closed");
      return this._handle.reset();
    };
    Zlib.prototype._flush = function(callback) {
      this._transform(Buffer2.alloc(0), "", callback);
    };
    Zlib.prototype.flush = function(kind, callback) {
      var _this2 = this;
      var ws3 = this._writableState;
      if (typeof kind === "function" || kind === void 0 && !callback) {
        callback = kind;
        kind = binding3.Z_FULL_FLUSH;
      }
      if (ws3.ended) {
        if (callback) process.nextTick(callback);
      } else if (ws3.ending) {
        if (callback) this.once("end", callback);
      } else if (ws3.needDrain) {
        if (callback) {
          this.once("drain", function() {
            return _this2.flush(kind, callback);
          });
        }
      } else {
        this._flushFlag = kind;
        this.write(Buffer2.alloc(0), "", callback);
      }
    };
    Zlib.prototype.close = function(callback) {
      _close(this, callback);
      process.nextTick(emitCloseNT, this);
    };
    function _close(engine, callback) {
      if (callback) process.nextTick(callback);
      if (!engine._handle) return;
      engine._handle.close();
      engine._handle = null;
    }
    __name(_close, "_close");
    function emitCloseNT(self2) {
      self2.emit("close");
    }
    __name(emitCloseNT, "emitCloseNT");
    Zlib.prototype._transform = function(chunk, encoding2, cb) {
      var flushFlag;
      var ws3 = this._writableState;
      var ending = ws3.ending || ws3.ended;
      var last = ending && (!chunk || ws3.length === chunk.length);
      if (chunk !== null && !Buffer2.isBuffer(chunk)) return cb(new Error("invalid input"));
      if (!this._handle) return cb(new Error("zlib binding closed"));
      if (last) flushFlag = this._finishFlushFlag;
      else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws3.length) {
          this._flushFlag = this._opts.flush || binding3.Z_NO_FLUSH;
        }
      }
      this._processChunk(chunk, flushFlag, cb);
    };
    Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var inOff = 0;
      var self2 = this;
      var async = typeof cb === "function";
      if (!async) {
        var buffers = [];
        var nread = 0;
        var error4;
        this.on("error", function(er) {
          error4 = er;
        });
        assert4(this._handle, "zlib binding closed");
        do {
          var res = this._handle.writeSync(
            flushFlag,
            chunk,
            // in
            inOff,
            // in_off
            availInBefore,
            // in_len
            this._buffer,
            // out
            this._offset,
            //out_off
            availOutBefore
          );
        } while (!this._hadError && callback(res[0], res[1]));
        if (this._hadError) {
          throw error4;
        }
        if (nread >= kMaxLength) {
          _close(this);
          throw new RangeError(kRangeErrorMessage);
        }
        var buf = Buffer2.concat(buffers, nread);
        _close(this);
        return buf;
      }
      assert4(this._handle, "zlib binding closed");
      var req = this._handle.write(
        flushFlag,
        chunk,
        // in
        inOff,
        // in_off
        availInBefore,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        availOutBefore
      );
      req.buffer = chunk;
      req.callback = callback;
      function callback(availInAfter, availOutAfter) {
        if (this) {
          this.buffer = null;
          this.callback = null;
        }
        if (self2._hadError) return;
        var have = availOutBefore - availOutAfter;
        assert4(have >= 0, "have should not go down");
        if (have > 0) {
          var out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (async) {
            self2.push(out);
          } else {
            buffers.push(out);
            nread += out.length;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer2.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          if (!async) return true;
          var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
          newReq.callback = callback;
          newReq.buffer = chunk;
          return;
        }
        if (!async) return false;
        cb();
      }
      __name(callback, "callback");
    };
    util3.inherits(Deflate, Zlib);
    util3.inherits(Inflate, Zlib);
    util3.inherits(Gzip, Zlib);
    util3.inherits(Gunzip, Zlib);
    util3.inherits(DeflateRaw, Zlib);
    util3.inherits(InflateRaw, Zlib);
    util3.inherits(Unzip, Zlib);
  })(lib2);
  return lib2;
}
__name(requireLib2, "requireLib");
var chunkstream = { exports: {} };
var hasRequiredChunkstream;
function requireChunkstream() {
  if (hasRequiredChunkstream) return chunkstream.exports;
  hasRequiredChunkstream = 1;
  let util3 = util_default;
  let Stream2 = require$$62;
  let ChunkStream = chunkstream.exports = function() {
    Stream2.call(this);
    this._buffers = [];
    this._buffered = 0;
    this._reads = [];
    this._paused = false;
    this._encoding = "utf8";
    this.writable = true;
  };
  util3.inherits(ChunkStream, Stream2);
  ChunkStream.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      // if length < 0 then at most this length
      allowLess: length < 0,
      func: callback
    });
    process.nextTick(
      function() {
        this._process();
        if (this._paused && this._reads && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this)
    );
  };
  ChunkStream.prototype.write = function(data, encoding2) {
    if (!this.writable) {
      this.emit("error", new Error("Stream not writable"));
      return false;
    }
    let dataBuffer;
    if (Buffer.isBuffer(data)) {
      dataBuffer = data;
    } else {
      dataBuffer = Buffer.from(data, encoding2 || this._encoding);
    }
    this._buffers.push(dataBuffer);
    this._buffered += dataBuffer.length;
    this._process();
    if (this._reads && this._reads.length === 0) {
      this._paused = true;
    }
    return this.writable && !this._paused;
  };
  ChunkStream.prototype.end = function(data, encoding2) {
    if (data) {
      this.write(data, encoding2);
    }
    this.writable = false;
    if (!this._buffers) {
      return;
    }
    if (this._buffers.length === 0) {
      this._end();
    } else {
      this._buffers.push(null);
      this._process();
    }
  };
  ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
  ChunkStream.prototype._end = function() {
    if (this._reads.length > 0) {
      this.emit("error", new Error("Unexpected end of input"));
    }
    this.destroy();
  };
  ChunkStream.prototype.destroy = function() {
    if (!this._buffers) {
      return;
    }
    this.writable = false;
    this._reads = null;
    this._buffers = null;
    this.emit("close");
  };
  ChunkStream.prototype._processReadAllowingLess = function(read2) {
    this._reads.shift();
    let smallerBuf = this._buffers[0];
    if (smallerBuf.length > read2.length) {
      this._buffered -= read2.length;
      this._buffers[0] = smallerBuf.slice(read2.length);
      read2.func.call(this, smallerBuf.slice(0, read2.length));
    } else {
      this._buffered -= smallerBuf.length;
      this._buffers.shift();
      read2.func.call(this, smallerBuf);
    }
  };
  ChunkStream.prototype._processRead = function(read2) {
    this._reads.shift();
    let pos = 0;
    let count3 = 0;
    let data = Buffer.alloc(read2.length);
    while (pos < read2.length) {
      let buf = this._buffers[count3++];
      let len = Math.min(buf.length, read2.length - pos);
      buf.copy(data, pos, 0, len);
      pos += len;
      if (len !== buf.length) {
        this._buffers[--count3] = buf.slice(len);
      }
    }
    if (count3 > 0) {
      this._buffers.splice(0, count3);
    }
    this._buffered -= read2.length;
    read2.func.call(this, data);
  };
  ChunkStream.prototype._process = function() {
    try {
      while (this._buffered > 0 && this._reads && this._reads.length > 0) {
        let read2 = this._reads[0];
        if (read2.allowLess) {
          this._processReadAllowingLess(read2);
        } else if (this._buffered >= read2.length) {
          this._processRead(read2);
        } else {
          break;
        }
      }
      if (this._buffers && !this.writable) {
        this._end();
      }
    } catch (ex) {
      this.emit("error", ex);
    }
  };
  return chunkstream.exports;
}
__name(requireChunkstream, "requireChunkstream");
var filterParseAsync = { exports: {} };
var filterParse = { exports: {} };
var interlace = {};
var hasRequiredInterlace;
function requireInterlace() {
  if (hasRequiredInterlace) return interlace;
  hasRequiredInterlace = 1;
  let imagePasses = [
    {
      // pass 1 - 1px
      x: [0],
      y: [0]
    },
    {
      // pass 2 - 1px
      x: [4],
      y: [0]
    },
    {
      // pass 3 - 2px
      x: [0, 4],
      y: [4]
    },
    {
      // pass 4 - 4px
      x: [2, 6],
      y: [0, 4]
    },
    {
      // pass 5 - 8px
      x: [0, 2, 4, 6],
      y: [2, 6]
    },
    {
      // pass 6 - 16px
      x: [1, 3, 5, 7],
      y: [0, 2, 4, 6]
    },
    {
      // pass 7 - 32px
      x: [0, 1, 2, 3, 4, 5, 6, 7],
      y: [1, 3, 5, 7]
    }
  ];
  interlace.getImagePasses = function(width, height) {
    let images = [];
    let xLeftOver = width % 8;
    let yLeftOver = height % 8;
    let xRepeats = (width - xLeftOver) / 8;
    let yRepeats = (height - yLeftOver) / 8;
    for (let i = 0; i < imagePasses.length; i++) {
      let pass = imagePasses[i];
      let passWidth = xRepeats * pass.x.length;
      let passHeight = yRepeats * pass.y.length;
      for (let j = 0; j < pass.x.length; j++) {
        if (pass.x[j] < xLeftOver) {
          passWidth++;
        } else {
          break;
        }
      }
      for (let j = 0; j < pass.y.length; j++) {
        if (pass.y[j] < yLeftOver) {
          passHeight++;
        } else {
          break;
        }
      }
      if (passWidth > 0 && passHeight > 0) {
        images.push({ width: passWidth, height: passHeight, index: i });
      }
    }
    return images;
  };
  interlace.getInterlaceIterator = function(width) {
    return function(x, y, pass) {
      let outerXLeftOver = x % imagePasses[pass].x.length;
      let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
      let outerYLeftOver = y % imagePasses[pass].y.length;
      let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
      return outerX * 4 + outerY * width * 4;
    };
  };
  return interlace;
}
__name(requireInterlace, "requireInterlace");
var paethPredictor;
var hasRequiredPaethPredictor;
function requirePaethPredictor() {
  if (hasRequiredPaethPredictor) return paethPredictor;
  hasRequiredPaethPredictor = 1;
  paethPredictor = /* @__PURE__ */ __name(function paethPredictor2(left, above, upLeft) {
    let paeth = left + above - upLeft;
    let pLeft = Math.abs(paeth - left);
    let pAbove = Math.abs(paeth - above);
    let pUpLeft = Math.abs(paeth - upLeft);
    if (pLeft <= pAbove && pLeft <= pUpLeft) {
      return left;
    }
    if (pAbove <= pUpLeft) {
      return above;
    }
    return upLeft;
  }, "paethPredictor");
  return paethPredictor;
}
__name(requirePaethPredictor, "requirePaethPredictor");
var hasRequiredFilterParse;
function requireFilterParse() {
  if (hasRequiredFilterParse) return filterParse.exports;
  hasRequiredFilterParse = 1;
  let interlaceUtils = requireInterlace();
  let paethPredictor2 = requirePaethPredictor();
  function getByteWidth(width, bpp, depth) {
    let byteWidth = width * bpp;
    if (depth !== 8) {
      byteWidth = Math.ceil(byteWidth / (8 / depth));
    }
    return byteWidth;
  }
  __name(getByteWidth, "getByteWidth");
  let Filter = filterParse.exports = function(bitmapInfo, dependencies) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let interlace2 = bitmapInfo.interlace;
    let bpp = bitmapInfo.bpp;
    let depth = bitmapInfo.depth;
    this.read = dependencies.read;
    this.write = dependencies.write;
    this.complete = dependencies.complete;
    this._imageIndex = 0;
    this._images = [];
    if (interlace2) {
      let passes = interlaceUtils.getImagePasses(width, height);
      for (let i = 0; i < passes.length; i++) {
        this._images.push({
          byteWidth: getByteWidth(passes[i].width, bpp, depth),
          height: passes[i].height,
          lineIndex: 0
        });
      }
    } else {
      this._images.push({
        byteWidth: getByteWidth(width, bpp, depth),
        height,
        lineIndex: 0
      });
    }
    if (depth === 8) {
      this._xComparison = bpp;
    } else if (depth === 16) {
      this._xComparison = bpp * 2;
    } else {
      this._xComparison = 1;
    }
  };
  Filter.prototype.start = function() {
    this.read(
      this._images[this._imageIndex].byteWidth + 1,
      this._reverseFilterLine.bind(this)
    );
  };
  Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    for (let x = 0; x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      unfilteredLine[x] = rawByte + f1Left;
    }
  };
  Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
    let lastLine = this._lastLine;
    for (let x = 0; x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f2Up = lastLine ? lastLine[x] : 0;
      unfilteredLine[x] = rawByte + f2Up;
    }
  };
  Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0; x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f3Up = lastLine ? lastLine[x] : 0;
      let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f3Add = Math.floor((f3Left + f3Up) / 2);
      unfilteredLine[x] = rawByte + f3Add;
    }
  };
  Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0; x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f4Up = lastLine ? lastLine[x] : 0;
      let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
      let f4Add = paethPredictor2(f4Left, f4Up, f4UpLeft);
      unfilteredLine[x] = rawByte + f4Add;
    }
  };
  Filter.prototype._reverseFilterLine = function(rawData) {
    let filter = rawData[0];
    let unfilteredLine;
    let currentImage = this._images[this._imageIndex];
    let byteWidth = currentImage.byteWidth;
    if (filter === 0) {
      unfilteredLine = rawData.slice(1, byteWidth + 1);
    } else {
      unfilteredLine = Buffer.alloc(byteWidth);
      switch (filter) {
        case 1:
          this._unFilterType1(rawData, unfilteredLine, byteWidth);
          break;
        case 2:
          this._unFilterType2(rawData, unfilteredLine, byteWidth);
          break;
        case 3:
          this._unFilterType3(rawData, unfilteredLine, byteWidth);
          break;
        case 4:
          this._unFilterType4(rawData, unfilteredLine, byteWidth);
          break;
        default:
          throw new Error("Unrecognised filter type - " + filter);
      }
    }
    this.write(unfilteredLine);
    currentImage.lineIndex++;
    if (currentImage.lineIndex >= currentImage.height) {
      this._lastLine = null;
      this._imageIndex++;
      currentImage = this._images[this._imageIndex];
    } else {
      this._lastLine = unfilteredLine;
    }
    if (currentImage) {
      this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
    } else {
      this._lastLine = null;
      this.complete();
    }
  };
  return filterParse.exports;
}
__name(requireFilterParse, "requireFilterParse");
var hasRequiredFilterParseAsync;
function requireFilterParseAsync() {
  if (hasRequiredFilterParseAsync) return filterParseAsync.exports;
  hasRequiredFilterParseAsync = 1;
  let util3 = util_default;
  let ChunkStream = requireChunkstream();
  let Filter = requireFilterParse();
  let FilterAsync = filterParseAsync.exports = function(bitmapInfo) {
    ChunkStream.call(this);
    let buffers = [];
    let that = this;
    this._filter = new Filter(bitmapInfo, {
      read: this.read.bind(this),
      write: /* @__PURE__ */ __name(function(buffer2) {
        buffers.push(buffer2);
      }, "write"),
      complete: /* @__PURE__ */ __name(function() {
        that.emit("complete", Buffer.concat(buffers));
      }, "complete")
    });
    this._filter.start();
  };
  util3.inherits(FilterAsync, ChunkStream);
  return filterParseAsync.exports;
}
__name(requireFilterParseAsync, "requireFilterParseAsync");
var parser = { exports: {} };
var constants4;
var hasRequiredConstants2;
function requireConstants2() {
  if (hasRequiredConstants2) return constants4;
  hasRequiredConstants2 = 1;
  constants4 = {
    PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
    TYPE_IHDR: 1229472850,
    TYPE_IEND: 1229278788,
    TYPE_IDAT: 1229209940,
    TYPE_PLTE: 1347179589,
    TYPE_tRNS: 1951551059,
    // eslint-disable-line camelcase
    TYPE_gAMA: 1732332865,
    // eslint-disable-line camelcase
    // color-type bits
    COLORTYPE_GRAYSCALE: 0,
    COLORTYPE_PALETTE: 1,
    COLORTYPE_COLOR: 2,
    COLORTYPE_ALPHA: 4,
    // e.g. grayscale and alpha
    // color-type combinations
    COLORTYPE_PALETTE_COLOR: 3,
    COLORTYPE_COLOR_ALPHA: 6,
    COLORTYPE_TO_BPP_MAP: {
      0: 1,
      2: 3,
      3: 1,
      4: 2,
      6: 4
    },
    GAMMA_DIVISION: 1e5
  };
  return constants4;
}
__name(requireConstants2, "requireConstants");
var crc = { exports: {} };
var hasRequiredCrc;
function requireCrc() {
  if (hasRequiredCrc) return crc.exports;
  hasRequiredCrc = 1;
  let crcTable = [];
  (function() {
    for (let i = 0; i < 256; i++) {
      let currentCrc = i;
      for (let j = 0; j < 8; j++) {
        if (currentCrc & 1) {
          currentCrc = 3988292384 ^ currentCrc >>> 1;
        } else {
          currentCrc = currentCrc >>> 1;
        }
      }
      crcTable[i] = currentCrc;
    }
  })();
  let CrcCalculator = crc.exports = function() {
    this._crc = -1;
  };
  CrcCalculator.prototype.write = function(data) {
    for (let i = 0; i < data.length; i++) {
      this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
    }
    return true;
  };
  CrcCalculator.prototype.crc32 = function() {
    return this._crc ^ -1;
  };
  CrcCalculator.crc32 = function(buf) {
    let crc2 = -1;
    for (let i = 0; i < buf.length; i++) {
      crc2 = crcTable[(crc2 ^ buf[i]) & 255] ^ crc2 >>> 8;
    }
    return crc2 ^ -1;
  };
  return crc.exports;
}
__name(requireCrc, "requireCrc");
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser.exports;
  hasRequiredParser = 1;
  let constants8 = requireConstants2();
  let CrcCalculator = requireCrc();
  let Parser2 = parser.exports = function(options2, dependencies) {
    this._options = options2;
    options2.checkCRC = options2.checkCRC !== false;
    this._hasIHDR = false;
    this._hasIEND = false;
    this._emittedHeadersFinished = false;
    this._palette = [];
    this._colorType = 0;
    this._chunks = {};
    this._chunks[constants8.TYPE_IHDR] = this._handleIHDR.bind(this);
    this._chunks[constants8.TYPE_IEND] = this._handleIEND.bind(this);
    this._chunks[constants8.TYPE_IDAT] = this._handleIDAT.bind(this);
    this._chunks[constants8.TYPE_PLTE] = this._handlePLTE.bind(this);
    this._chunks[constants8.TYPE_tRNS] = this._handleTRNS.bind(this);
    this._chunks[constants8.TYPE_gAMA] = this._handleGAMA.bind(this);
    this.read = dependencies.read;
    this.error = dependencies.error;
    this.metadata = dependencies.metadata;
    this.gamma = dependencies.gamma;
    this.transColor = dependencies.transColor;
    this.palette = dependencies.palette;
    this.parsed = dependencies.parsed;
    this.inflateData = dependencies.inflateData;
    this.finished = dependencies.finished;
    this.simpleTransparency = dependencies.simpleTransparency;
    this.headersFinished = dependencies.headersFinished || function() {
    };
  };
  Parser2.prototype.start = function() {
    this.read(constants8.PNG_SIGNATURE.length, this._parseSignature.bind(this));
  };
  Parser2.prototype._parseSignature = function(data) {
    let signature = constants8.PNG_SIGNATURE;
    for (let i = 0; i < signature.length; i++) {
      if (data[i] !== signature[i]) {
        this.error(new Error("Invalid file signature"));
        return;
      }
    }
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser2.prototype._parseChunkBegin = function(data) {
    let length = data.readUInt32BE(0);
    let type2 = data.readUInt32BE(4);
    let name = "";
    for (let i = 4; i < 8; i++) {
      name += String.fromCharCode(data[i]);
    }
    let ancillary = Boolean(data[4] & 32);
    if (!this._hasIHDR && type2 !== constants8.TYPE_IHDR) {
      this.error(new Error("Expected IHDR on beggining"));
      return;
    }
    this._crc = new CrcCalculator();
    this._crc.write(Buffer.from(name));
    if (this._chunks[type2]) {
      return this._chunks[type2](length);
    }
    if (!ancillary) {
      this.error(new Error("Unsupported critical chunk type " + name));
      return;
    }
    this.read(length + 4, this._skipChunk.bind(this));
  };
  Parser2.prototype._skipChunk = function() {
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser2.prototype._handleChunkEnd = function() {
    this.read(4, this._parseChunkEnd.bind(this));
  };
  Parser2.prototype._parseChunkEnd = function(data) {
    let fileCrc = data.readInt32BE(0);
    let calcCrc = this._crc.crc32();
    if (this._options.checkCRC && calcCrc !== fileCrc) {
      this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
      return;
    }
    if (!this._hasIEND) {
      this.read(8, this._parseChunkBegin.bind(this));
    }
  };
  Parser2.prototype._handleIHDR = function(length) {
    this.read(length, this._parseIHDR.bind(this));
  };
  Parser2.prototype._parseIHDR = function(data) {
    this._crc.write(data);
    let width = data.readUInt32BE(0);
    let height = data.readUInt32BE(4);
    let depth = data[8];
    let colorType = data[9];
    let compr = data[10];
    let filter = data[11];
    let interlace2 = data[12];
    if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
      this.error(new Error("Unsupported bit depth " + depth));
      return;
    }
    if (!(colorType in constants8.COLORTYPE_TO_BPP_MAP)) {
      this.error(new Error("Unsupported color type"));
      return;
    }
    if (compr !== 0) {
      this.error(new Error("Unsupported compression method"));
      return;
    }
    if (filter !== 0) {
      this.error(new Error("Unsupported filter method"));
      return;
    }
    if (interlace2 !== 0 && interlace2 !== 1) {
      this.error(new Error("Unsupported interlace method"));
      return;
    }
    this._colorType = colorType;
    let bpp = constants8.COLORTYPE_TO_BPP_MAP[this._colorType];
    this._hasIHDR = true;
    this.metadata({
      width,
      height,
      depth,
      interlace: Boolean(interlace2),
      palette: Boolean(colorType & constants8.COLORTYPE_PALETTE),
      color: Boolean(colorType & constants8.COLORTYPE_COLOR),
      alpha: Boolean(colorType & constants8.COLORTYPE_ALPHA),
      bpp,
      colorType
    });
    this._handleChunkEnd();
  };
  Parser2.prototype._handlePLTE = function(length) {
    this.read(length, this._parsePLTE.bind(this));
  };
  Parser2.prototype._parsePLTE = function(data) {
    this._crc.write(data);
    let entries = Math.floor(data.length / 3);
    for (let i = 0; i < entries; i++) {
      this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 255]);
    }
    this.palette(this._palette);
    this._handleChunkEnd();
  };
  Parser2.prototype._handleTRNS = function(length) {
    this.simpleTransparency();
    this.read(length, this._parseTRNS.bind(this));
  };
  Parser2.prototype._parseTRNS = function(data) {
    this._crc.write(data);
    if (this._colorType === constants8.COLORTYPE_PALETTE_COLOR) {
      if (this._palette.length === 0) {
        this.error(new Error("Transparency chunk must be after palette"));
        return;
      }
      if (data.length > this._palette.length) {
        this.error(new Error("More transparent colors than palette size"));
        return;
      }
      for (let i = 0; i < data.length; i++) {
        this._palette[i][3] = data[i];
      }
      this.palette(this._palette);
    }
    if (this._colorType === constants8.COLORTYPE_GRAYSCALE) {
      this.transColor([data.readUInt16BE(0)]);
    }
    if (this._colorType === constants8.COLORTYPE_COLOR) {
      this.transColor([
        data.readUInt16BE(0),
        data.readUInt16BE(2),
        data.readUInt16BE(4)
      ]);
    }
    this._handleChunkEnd();
  };
  Parser2.prototype._handleGAMA = function(length) {
    this.read(length, this._parseGAMA.bind(this));
  };
  Parser2.prototype._parseGAMA = function(data) {
    this._crc.write(data);
    this.gamma(data.readUInt32BE(0) / constants8.GAMMA_DIVISION);
    this._handleChunkEnd();
  };
  Parser2.prototype._handleIDAT = function(length) {
    if (!this._emittedHeadersFinished) {
      this._emittedHeadersFinished = true;
      this.headersFinished();
    }
    this.read(-length, this._parseIDAT.bind(this, length));
  };
  Parser2.prototype._parseIDAT = function(length, data) {
    this._crc.write(data);
    if (this._colorType === constants8.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
      throw new Error("Expected palette not found");
    }
    this.inflateData(data);
    let leftOverLength = length - data.length;
    if (leftOverLength > 0) {
      this._handleIDAT(leftOverLength);
    } else {
      this._handleChunkEnd();
    }
  };
  Parser2.prototype._handleIEND = function(length) {
    this.read(length, this._parseIEND.bind(this));
  };
  Parser2.prototype._parseIEND = function(data) {
    this._crc.write(data);
    this._hasIEND = true;
    this._handleChunkEnd();
    if (this.finished) {
      this.finished();
    }
  };
  return parser.exports;
}
__name(requireParser, "requireParser");
var bitmapper = {};
var hasRequiredBitmapper;
function requireBitmapper() {
  if (hasRequiredBitmapper) return bitmapper;
  hasRequiredBitmapper = 1;
  let interlaceUtils = requireInterlace();
  let pixelBppMapper = [
    // 0 - dummy entry
    function() {
    },
    // 1 - L
    // 0: 0, 1: 0, 2: 0, 3: 0xff
    function(pxData, data, pxPos, rawPos) {
      if (rawPos === data.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = 255;
    },
    // 2 - LA
    // 0: 0, 1: 0, 2: 0, 3: 1
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 1 >= data.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = data[rawPos + 1];
    },
    // 3 - RGB
    // 0: 0, 1: 1, 2: 2, 3: 0xff
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 2 >= data.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data[rawPos];
      pxData[pxPos + 1] = data[rawPos + 1];
      pxData[pxPos + 2] = data[rawPos + 2];
      pxData[pxPos + 3] = 255;
    },
    // 4 - RGBA
    // 0: 0, 1: 1, 2: 2, 3: 3
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 3 >= data.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data[rawPos];
      pxData[pxPos + 1] = data[rawPos + 1];
      pxData[pxPos + 2] = data[rawPos + 2];
      pxData[pxPos + 3] = data[rawPos + 3];
    }
  ];
  let pixelBppCustomMapper = [
    // 0 - dummy entry
    function() {
    },
    // 1 - L
    // 0: 0, 1: 0, 2: 0, 3: 0xff
    function(pxData, pixelData, pxPos, maxBit) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = maxBit;
    },
    // 2 - LA
    // 0: 0, 1: 0, 2: 0, 3: 1
    function(pxData, pixelData, pxPos) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = pixelData[1];
    },
    // 3 - RGB
    // 0: 0, 1: 1, 2: 2, 3: 0xff
    function(pxData, pixelData, pxPos, maxBit) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = maxBit;
    },
    // 4 - RGBA
    // 0: 0, 1: 1, 2: 2, 3: 3
    function(pxData, pixelData, pxPos) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = pixelData[3];
    }
  ];
  function bitRetriever(data, depth) {
    let leftOver = [];
    let i = 0;
    function split() {
      if (i === data.length) {
        throw new Error("Ran out of data");
      }
      let byte = data[i];
      i++;
      let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
      switch (depth) {
        default:
          throw new Error("unrecognised depth");
        case 16:
          byte2 = data[i];
          i++;
          leftOver.push((byte << 8) + byte2);
          break;
        case 4:
          byte2 = byte & 15;
          byte1 = byte >> 4;
          leftOver.push(byte1, byte2);
          break;
        case 2:
          byte4 = byte & 3;
          byte3 = byte >> 2 & 3;
          byte2 = byte >> 4 & 3;
          byte1 = byte >> 6 & 3;
          leftOver.push(byte1, byte2, byte3, byte4);
          break;
        case 1:
          byte8 = byte & 1;
          byte7 = byte >> 1 & 1;
          byte6 = byte >> 2 & 1;
          byte5 = byte >> 3 & 1;
          byte4 = byte >> 4 & 1;
          byte3 = byte >> 5 & 1;
          byte2 = byte >> 6 & 1;
          byte1 = byte >> 7 & 1;
          leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
          break;
      }
    }
    __name(split, "split");
    return {
      get: /* @__PURE__ */ __name(function(count3) {
        while (leftOver.length < count3) {
          split();
        }
        let returner = leftOver.slice(0, count3);
        leftOver = leftOver.slice(count3);
        return returner;
      }, "get"),
      resetAfterLine: /* @__PURE__ */ __name(function() {
        leftOver.length = 0;
      }, "resetAfterLine"),
      end: /* @__PURE__ */ __name(function() {
        if (i !== data.length) {
          throw new Error("extra data found");
        }
      }, "end")
    };
  }
  __name(bitRetriever, "bitRetriever");
  function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
    let imageWidth = image.width;
    let imageHeight = image.height;
    let imagePass = image.index;
    for (let y = 0; y < imageHeight; y++) {
      for (let x = 0; x < imageWidth; x++) {
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
        rawPos += bpp;
      }
    }
    return rawPos;
  }
  __name(mapImage8Bit, "mapImage8Bit");
  function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
    let imageWidth = image.width;
    let imageHeight = image.height;
    let imagePass = image.index;
    for (let y = 0; y < imageHeight; y++) {
      for (let x = 0; x < imageWidth; x++) {
        let pixelData = bits.get(bpp);
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
      }
      bits.resetAfterLine();
    }
  }
  __name(mapImageCustomBit, "mapImageCustomBit");
  bitmapper.dataToBitMap = function(data, bitmapInfo) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let depth = bitmapInfo.depth;
    let bpp = bitmapInfo.bpp;
    let interlace2 = bitmapInfo.interlace;
    let bits;
    if (depth !== 8) {
      bits = bitRetriever(data, depth);
    }
    let pxData;
    if (depth <= 8) {
      pxData = Buffer.alloc(width * height * 4);
    } else {
      pxData = new Uint16Array(width * height * 4);
    }
    let maxBit = Math.pow(2, depth) - 1;
    let rawPos = 0;
    let images;
    let getPxPos;
    if (interlace2) {
      images = interlaceUtils.getImagePasses(width, height);
      getPxPos = interlaceUtils.getInterlaceIterator(width, height);
    } else {
      let nonInterlacedPxPos = 0;
      getPxPos = /* @__PURE__ */ __name(function() {
        let returner = nonInterlacedPxPos;
        nonInterlacedPxPos += 4;
        return returner;
      }, "getPxPos");
      images = [{ width, height }];
    }
    for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
      if (depth === 8) {
        rawPos = mapImage8Bit(
          images[imageIndex],
          pxData,
          getPxPos,
          bpp,
          data,
          rawPos
        );
      } else {
        mapImageCustomBit(
          images[imageIndex],
          pxData,
          getPxPos,
          bpp,
          bits,
          maxBit
        );
      }
    }
    if (depth === 8) {
      if (rawPos !== data.length) {
        throw new Error("extra data found");
      }
    } else {
      bits.end();
    }
    return pxData;
  };
  return bitmapper;
}
__name(requireBitmapper, "requireBitmapper");
var formatNormaliser;
var hasRequiredFormatNormaliser;
function requireFormatNormaliser() {
  if (hasRequiredFormatNormaliser) return formatNormaliser;
  hasRequiredFormatNormaliser = 1;
  function dePalette(indata, outdata, width, height, palette) {
    let pxPos = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let color = palette[indata[pxPos]];
        if (!color) {
          throw new Error("index " + indata[pxPos] + " not in palette");
        }
        for (let i = 0; i < 4; i++) {
          outdata[pxPos + i] = color[i];
        }
        pxPos += 4;
      }
    }
  }
  __name(dePalette, "dePalette");
  function replaceTransparentColor(indata, outdata, width, height, transColor) {
    let pxPos = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let makeTrans = false;
        if (transColor.length === 1) {
          if (transColor[0] === indata[pxPos]) {
            makeTrans = true;
          }
        } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
          makeTrans = true;
        }
        if (makeTrans) {
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = 0;
          }
        }
        pxPos += 4;
      }
    }
  }
  __name(replaceTransparentColor, "replaceTransparentColor");
  function scaleDepth(indata, outdata, width, height, depth) {
    let maxOutSample = 255;
    let maxInSample = Math.pow(2, depth) - 1;
    let pxPos = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        for (let i = 0; i < 4; i++) {
          outdata[pxPos + i] = Math.floor(
            indata[pxPos + i] * maxOutSample / maxInSample + 0.5
          );
        }
        pxPos += 4;
      }
    }
  }
  __name(scaleDepth, "scaleDepth");
  formatNormaliser = /* @__PURE__ */ __name(function(indata, imageData, skipRescale = false) {
    let depth = imageData.depth;
    let width = imageData.width;
    let height = imageData.height;
    let colorType = imageData.colorType;
    let transColor = imageData.transColor;
    let palette = imageData.palette;
    let outdata = indata;
    if (colorType === 3) {
      dePalette(indata, outdata, width, height, palette);
    } else {
      if (transColor) {
        replaceTransparentColor(indata, outdata, width, height, transColor);
      }
      if (depth !== 8 && !skipRescale) {
        if (depth === 16) {
          outdata = Buffer.alloc(width * height * 4);
        }
        scaleDepth(indata, outdata, width, height, depth);
      }
    }
    return outdata;
  }, "formatNormaliser");
  return formatNormaliser;
}
__name(requireFormatNormaliser, "requireFormatNormaliser");
var hasRequiredParserAsync;
function requireParserAsync() {
  if (hasRequiredParserAsync) return parserAsync.exports;
  hasRequiredParserAsync = 1;
  let util3 = util_default;
  let zlib2 = requireLib2();
  let ChunkStream = requireChunkstream();
  let FilterAsync = requireFilterParseAsync();
  let Parser2 = requireParser();
  let bitmapper2 = requireBitmapper();
  let formatNormaliser2 = requireFormatNormaliser();
  let ParserAsync = parserAsync.exports = function(options2) {
    ChunkStream.call(this);
    this._parser = new Parser2(options2, {
      read: this.read.bind(this),
      error: this._handleError.bind(this),
      metadata: this._handleMetaData.bind(this),
      gamma: this.emit.bind(this, "gamma"),
      palette: this._handlePalette.bind(this),
      transColor: this._handleTransColor.bind(this),
      finished: this._finished.bind(this),
      inflateData: this._inflateData.bind(this),
      simpleTransparency: this._simpleTransparency.bind(this),
      headersFinished: this._headersFinished.bind(this)
    });
    this._options = options2;
    this.writable = true;
    this._parser.start();
  };
  util3.inherits(ParserAsync, ChunkStream);
  ParserAsync.prototype._handleError = function(err) {
    this.emit("error", err);
    this.writable = false;
    this.destroy();
    if (this._inflate && this._inflate.destroy) {
      this._inflate.destroy();
    }
    if (this._filter) {
      this._filter.destroy();
      this._filter.on("error", function() {
      });
    }
    this.errord = true;
  };
  ParserAsync.prototype._inflateData = function(data) {
    if (!this._inflate) {
      if (this._bitmapInfo.interlace) {
        this._inflate = zlib2.createInflate();
        this._inflate.on("error", this.emit.bind(this, "error"));
        this._filter.on("complete", this._complete.bind(this));
        this._inflate.pipe(this._filter);
      } else {
        let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
        let imageSize = rowSize * this._bitmapInfo.height;
        let chunkSize = Math.max(imageSize, zlib2.Z_MIN_CHUNK);
        this._inflate = zlib2.createInflate({ chunkSize });
        let leftToInflate = imageSize;
        let emitError = this.emit.bind(this, "error");
        this._inflate.on("error", function(err) {
          if (!leftToInflate) {
            return;
          }
          emitError(err);
        });
        this._filter.on("complete", this._complete.bind(this));
        let filterWrite = this._filter.write.bind(this._filter);
        this._inflate.on("data", function(chunk) {
          if (!leftToInflate) {
            return;
          }
          if (chunk.length > leftToInflate) {
            chunk = chunk.slice(0, leftToInflate);
          }
          leftToInflate -= chunk.length;
          filterWrite(chunk);
        });
        this._inflate.on("end", this._filter.end.bind(this._filter));
      }
    }
    this._inflate.write(data);
  };
  ParserAsync.prototype._handleMetaData = function(metaData) {
    this._metaData = metaData;
    this._bitmapInfo = Object.create(metaData);
    this._filter = new FilterAsync(this._bitmapInfo);
  };
  ParserAsync.prototype._handleTransColor = function(transColor) {
    this._bitmapInfo.transColor = transColor;
  };
  ParserAsync.prototype._handlePalette = function(palette) {
    this._bitmapInfo.palette = palette;
  };
  ParserAsync.prototype._simpleTransparency = function() {
    this._metaData.alpha = true;
  };
  ParserAsync.prototype._headersFinished = function() {
    this.emit("metadata", this._metaData);
  };
  ParserAsync.prototype._finished = function() {
    if (this.errord) {
      return;
    }
    if (!this._inflate) {
      this.emit("error", "No Inflate block");
    } else {
      this._inflate.end();
    }
  };
  ParserAsync.prototype._complete = function(filteredData) {
    if (this.errord) {
      return;
    }
    let normalisedBitmapData;
    try {
      let bitmapData = bitmapper2.dataToBitMap(filteredData, this._bitmapInfo);
      normalisedBitmapData = formatNormaliser2(
        bitmapData,
        this._bitmapInfo,
        this._options.skipRescale
      );
      bitmapData = null;
    } catch (ex) {
      this._handleError(ex);
      return;
    }
    this.emit("parsed", normalisedBitmapData);
  };
  return parserAsync.exports;
}
__name(requireParserAsync, "requireParserAsync");
var packerAsync = { exports: {} };
var packer = { exports: {} };
var bitpacker;
var hasRequiredBitpacker;
function requireBitpacker() {
  if (hasRequiredBitpacker) return bitpacker;
  hasRequiredBitpacker = 1;
  let constants8 = requireConstants2();
  bitpacker = /* @__PURE__ */ __name(function(dataIn, width, height, options2) {
    let outHasAlpha = [constants8.COLORTYPE_COLOR_ALPHA, constants8.COLORTYPE_ALPHA].indexOf(
      options2.colorType
    ) !== -1;
    if (options2.colorType === options2.inputColorType) {
      let bigEndian = function() {
        let buffer2 = new ArrayBuffer(2);
        new DataView(buffer2).setInt16(
          0,
          256,
          true
          /* littleEndian */
        );
        return new Int16Array(buffer2)[0] !== 256;
      }();
      if (options2.bitDepth === 8 || options2.bitDepth === 16 && bigEndian) {
        return dataIn;
      }
    }
    let data = options2.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
    let maxValue = 255;
    let inBpp = constants8.COLORTYPE_TO_BPP_MAP[options2.inputColorType];
    if (inBpp === 4 && !options2.inputHasAlpha) {
      inBpp = 3;
    }
    let outBpp = constants8.COLORTYPE_TO_BPP_MAP[options2.colorType];
    if (options2.bitDepth === 16) {
      maxValue = 65535;
      outBpp *= 2;
    }
    let outData = Buffer.alloc(width * height * outBpp);
    let inIndex = 0;
    let outIndex = 0;
    let bgColor = options2.bgColor || {};
    if (bgColor.red === void 0) {
      bgColor.red = maxValue;
    }
    if (bgColor.green === void 0) {
      bgColor.green = maxValue;
    }
    if (bgColor.blue === void 0) {
      bgColor.blue = maxValue;
    }
    function getRGBA() {
      let red;
      let green;
      let blue;
      let alpha = maxValue;
      switch (options2.inputColorType) {
        case constants8.COLORTYPE_COLOR_ALPHA:
          alpha = data[inIndex + 3];
          red = data[inIndex];
          green = data[inIndex + 1];
          blue = data[inIndex + 2];
          break;
        case constants8.COLORTYPE_COLOR:
          red = data[inIndex];
          green = data[inIndex + 1];
          blue = data[inIndex + 2];
          break;
        case constants8.COLORTYPE_ALPHA:
          alpha = data[inIndex + 1];
          red = data[inIndex];
          green = red;
          blue = red;
          break;
        case constants8.COLORTYPE_GRAYSCALE:
          red = data[inIndex];
          green = red;
          blue = red;
          break;
        default:
          throw new Error(
            "input color type:" + options2.inputColorType + " is not supported at present"
          );
      }
      if (options2.inputHasAlpha) {
        if (!outHasAlpha) {
          alpha /= maxValue;
          red = Math.min(
            Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0),
            maxValue
          );
          green = Math.min(
            Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0),
            maxValue
          );
          blue = Math.min(
            Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0),
            maxValue
          );
        }
      }
      return { red, green, blue, alpha };
    }
    __name(getRGBA, "getRGBA");
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let rgba = getRGBA();
        switch (options2.colorType) {
          case constants8.COLORTYPE_COLOR_ALPHA:
          case constants8.COLORTYPE_COLOR:
            if (options2.bitDepth === 8) {
              outData[outIndex] = rgba.red;
              outData[outIndex + 1] = rgba.green;
              outData[outIndex + 2] = rgba.blue;
              if (outHasAlpha) {
                outData[outIndex + 3] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(rgba.red, outIndex);
              outData.writeUInt16BE(rgba.green, outIndex + 2);
              outData.writeUInt16BE(rgba.blue, outIndex + 4);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 6);
              }
            }
            break;
          case constants8.COLORTYPE_ALPHA:
          case constants8.COLORTYPE_GRAYSCALE: {
            let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
            if (options2.bitDepth === 8) {
              outData[outIndex] = grayscale;
              if (outHasAlpha) {
                outData[outIndex + 1] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(grayscale, outIndex);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 2);
              }
            }
            break;
          }
          default:
            throw new Error("unrecognised color Type " + options2.colorType);
        }
        inIndex += inBpp;
        outIndex += outBpp;
      }
    }
    return outData;
  }, "bitpacker");
  return bitpacker;
}
__name(requireBitpacker, "requireBitpacker");
var filterPack;
var hasRequiredFilterPack;
function requireFilterPack() {
  if (hasRequiredFilterPack) return filterPack;
  hasRequiredFilterPack = 1;
  let paethPredictor2 = requirePaethPredictor();
  function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0; x < byteWidth; x++) {
      rawData[rawPos + x] = pxData[pxPos + x];
    }
  }
  __name(filterNone, "filterNone");
  function filterSumNone(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let i = pxPos; i < length; i++) {
      sum += Math.abs(pxData[i]);
    }
    return sum;
  }
  __name(filterSumNone, "filterSumNone");
  function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      rawData[rawPos + x] = val;
    }
  }
  __name(filterSub, "filterSub");
  function filterSumSub(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      sum += Math.abs(val);
    }
    return sum;
  }
  __name(filterSumSub, "filterSumSub");
  function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0; x < byteWidth; x++) {
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - up;
      rawData[rawPos + x] = val;
    }
  }
  __name(filterUp, "filterUp");
  function filterSumUp(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let x = pxPos; x < length; x++) {
      let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
      let val = pxData[x] - up;
      sum += Math.abs(val);
    }
    return sum;
  }
  __name(filterSumUp, "filterSumUp");
  function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      rawData[rawPos + x] = val;
    }
  }
  __name(filterAvg, "filterAvg");
  function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      sum += Math.abs(val);
    }
    return sum;
  }
  __name(filterSumAvg, "filterSumAvg");
  function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor2(left, up, upleft);
      rawData[rawPos + x] = val;
    }
  }
  __name(filterPaeth, "filterPaeth");
  function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor2(left, up, upleft);
      sum += Math.abs(val);
    }
    return sum;
  }
  __name(filterSumPaeth, "filterSumPaeth");
  let filters = {
    0: filterNone,
    1: filterSub,
    2: filterUp,
    3: filterAvg,
    4: filterPaeth
  };
  let filterSums = {
    0: filterSumNone,
    1: filterSumSub,
    2: filterSumUp,
    3: filterSumAvg,
    4: filterSumPaeth
  };
  filterPack = /* @__PURE__ */ __name(function(pxData, width, height, options2, bpp) {
    let filterTypes;
    if (!("filterType" in options2) || options2.filterType === -1) {
      filterTypes = [0, 1, 2, 3, 4];
    } else if (typeof options2.filterType === "number") {
      filterTypes = [options2.filterType];
    } else {
      throw new Error("unrecognised filter types");
    }
    if (options2.bitDepth === 16) {
      bpp *= 2;
    }
    let byteWidth = width * bpp;
    let rawPos = 0;
    let pxPos = 0;
    let rawData = Buffer.alloc((byteWidth + 1) * height);
    let sel = filterTypes[0];
    for (let y = 0; y < height; y++) {
      if (filterTypes.length > 1) {
        let min = Infinity;
        for (let i = 0; i < filterTypes.length; i++) {
          let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
          if (sum < min) {
            sel = filterTypes[i];
            min = sum;
          }
        }
      }
      rawData[rawPos] = sel;
      rawPos++;
      filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
      rawPos += byteWidth;
      pxPos += byteWidth;
    }
    return rawData;
  }, "filterPack");
  return filterPack;
}
__name(requireFilterPack, "requireFilterPack");
var hasRequiredPacker;
function requirePacker() {
  if (hasRequiredPacker) return packer.exports;
  hasRequiredPacker = 1;
  let constants8 = requireConstants2();
  let CrcStream = requireCrc();
  let bitPacker = requireBitpacker();
  let filter = requireFilterPack();
  let zlib2 = requireLib2();
  let Packer = packer.exports = function(options2) {
    this._options = options2;
    options2.deflateChunkSize = options2.deflateChunkSize || 32 * 1024;
    options2.deflateLevel = options2.deflateLevel != null ? options2.deflateLevel : 9;
    options2.deflateStrategy = options2.deflateStrategy != null ? options2.deflateStrategy : 3;
    options2.inputHasAlpha = options2.inputHasAlpha != null ? options2.inputHasAlpha : true;
    options2.deflateFactory = options2.deflateFactory || zlib2.createDeflate;
    options2.bitDepth = options2.bitDepth || 8;
    options2.colorType = typeof options2.colorType === "number" ? options2.colorType : constants8.COLORTYPE_COLOR_ALPHA;
    options2.inputColorType = typeof options2.inputColorType === "number" ? options2.inputColorType : constants8.COLORTYPE_COLOR_ALPHA;
    if ([
      constants8.COLORTYPE_GRAYSCALE,
      constants8.COLORTYPE_COLOR,
      constants8.COLORTYPE_COLOR_ALPHA,
      constants8.COLORTYPE_ALPHA
    ].indexOf(options2.colorType) === -1) {
      throw new Error(
        "option color type:" + options2.colorType + " is not supported at present"
      );
    }
    if ([
      constants8.COLORTYPE_GRAYSCALE,
      constants8.COLORTYPE_COLOR,
      constants8.COLORTYPE_COLOR_ALPHA,
      constants8.COLORTYPE_ALPHA
    ].indexOf(options2.inputColorType) === -1) {
      throw new Error(
        "option input color type:" + options2.inputColorType + " is not supported at present"
      );
    }
    if (options2.bitDepth !== 8 && options2.bitDepth !== 16) {
      throw new Error(
        "option bit depth:" + options2.bitDepth + " is not supported at present"
      );
    }
  };
  Packer.prototype.getDeflateOptions = function() {
    return {
      chunkSize: this._options.deflateChunkSize,
      level: this._options.deflateLevel,
      strategy: this._options.deflateStrategy
    };
  };
  Packer.prototype.createDeflate = function() {
    return this._options.deflateFactory(this.getDeflateOptions());
  };
  Packer.prototype.filterData = function(data, width, height) {
    let packedData = bitPacker(data, width, height, this._options);
    let bpp = constants8.COLORTYPE_TO_BPP_MAP[this._options.colorType];
    let filteredData = filter(packedData, width, height, this._options, bpp);
    return filteredData;
  };
  Packer.prototype._packChunk = function(type2, data) {
    let len = data ? data.length : 0;
    let buf = Buffer.alloc(len + 12);
    buf.writeUInt32BE(len, 0);
    buf.writeUInt32BE(type2, 4);
    if (data) {
      data.copy(buf, 8);
    }
    buf.writeInt32BE(
      CrcStream.crc32(buf.slice(4, buf.length - 4)),
      buf.length - 4
    );
    return buf;
  };
  Packer.prototype.packGAMA = function(gamma) {
    let buf = Buffer.alloc(4);
    buf.writeUInt32BE(Math.floor(gamma * constants8.GAMMA_DIVISION), 0);
    return this._packChunk(constants8.TYPE_gAMA, buf);
  };
  Packer.prototype.packIHDR = function(width, height) {
    let buf = Buffer.alloc(13);
    buf.writeUInt32BE(width, 0);
    buf.writeUInt32BE(height, 4);
    buf[8] = this._options.bitDepth;
    buf[9] = this._options.colorType;
    buf[10] = 0;
    buf[11] = 0;
    buf[12] = 0;
    return this._packChunk(constants8.TYPE_IHDR, buf);
  };
  Packer.prototype.packIDAT = function(data) {
    return this._packChunk(constants8.TYPE_IDAT, data);
  };
  Packer.prototype.packIEND = function() {
    return this._packChunk(constants8.TYPE_IEND, null);
  };
  return packer.exports;
}
__name(requirePacker, "requirePacker");
var hasRequiredPackerAsync;
function requirePackerAsync() {
  if (hasRequiredPackerAsync) return packerAsync.exports;
  hasRequiredPackerAsync = 1;
  let util3 = util_default;
  let Stream2 = require$$62;
  let constants8 = requireConstants2();
  let Packer = requirePacker();
  let PackerAsync = packerAsync.exports = function(opt) {
    Stream2.call(this);
    let options2 = opt || {};
    this._packer = new Packer(options2);
    this._deflate = this._packer.createDeflate();
    this.readable = true;
  };
  util3.inherits(PackerAsync, Stream2);
  PackerAsync.prototype.pack = function(data, width, height, gamma) {
    this.emit("data", Buffer.from(constants8.PNG_SIGNATURE));
    this.emit("data", this._packer.packIHDR(width, height));
    if (gamma) {
      this.emit("data", this._packer.packGAMA(gamma));
    }
    let filteredData = this._packer.filterData(data, width, height);
    this._deflate.on("error", this.emit.bind(this, "error"));
    this._deflate.on(
      "data",
      function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this)
    );
    this._deflate.on(
      "end",
      function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this)
    );
    this._deflate.end(filteredData);
  };
  return packerAsync.exports;
}
__name(requirePackerAsync, "requirePackerAsync");
var pngSync = {};
var syncInflate = { exports: {} };
var hasRequiredSyncInflate;
function requireSyncInflate() {
  if (hasRequiredSyncInflate) return syncInflate.exports;
  hasRequiredSyncInflate = 1;
  (function(module, exports) {
    let assert4 = require$$52.ok;
    let zlib2 = requireLib2();
    let util3 = util_default;
    let kMaxLength = require$$0$12.kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib2.Z_MIN_CHUNK) {
        opts.chunkSize = zlib2.Z_MIN_CHUNK;
      }
      zlib2.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    __name(Inflate, "Inflate");
    function createInflate2(opts) {
      return new Inflate(opts);
    }
    __name(createInflate2, "createInflate");
    function _close(engine, callback) {
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    __name(_close, "_close");
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib2.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      let self2 = this;
      let availInBefore = chunk && chunk.length;
      let availOutBefore = this._chunkSize - this._offset;
      let leftToInflate = this._maxLength;
      let inOff = 0;
      let buffers = [];
      let nread = 0;
      let error4;
      this.on("error", function(err) {
        error4 = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        let have = availOutBefore - availOutAfter;
        assert4(have >= 0, "have should not go down");
        if (have > 0) {
          let out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      __name(handleChunk, "handleChunk");
      assert4(this._handle, "zlib binding closed");
      let res;
      do {
        res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error4;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError(
          "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes"
        );
      }
      let buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util3.inherits(Inflate, zlib2.Inflate);
    function zlibBufferSync(engine, buffer2) {
      if (typeof buffer2 === "string") {
        buffer2 = Buffer.from(buffer2);
      }
      if (!(buffer2 instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      let flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib2.Z_FINISH;
      }
      return engine._processChunk(buffer2, flushFlag);
    }
    __name(zlibBufferSync, "zlibBufferSync");
    function inflateSync(buffer2, opts) {
      return zlibBufferSync(new Inflate(opts), buffer2);
    }
    __name(inflateSync, "inflateSync");
    module.exports = exports = inflateSync;
    exports.Inflate = Inflate;
    exports.createInflate = createInflate2;
    exports.inflateSync = inflateSync;
  })(syncInflate, syncInflate.exports);
  return syncInflate.exports;
}
__name(requireSyncInflate, "requireSyncInflate");
var syncReader = { exports: {} };
var hasRequiredSyncReader;
function requireSyncReader() {
  if (hasRequiredSyncReader) return syncReader.exports;
  hasRequiredSyncReader = 1;
  let SyncReader = syncReader.exports = function(buffer2) {
    this._buffer = buffer2;
    this._reads = [];
  };
  SyncReader.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      // if length < 0 then at most this length
      allowLess: length < 0,
      func: callback
    });
  };
  SyncReader.prototype.process = function() {
    while (this._reads.length > 0 && this._buffer.length) {
      let read2 = this._reads[0];
      if (this._buffer.length && (this._buffer.length >= read2.length || read2.allowLess)) {
        this._reads.shift();
        let buf = this._buffer;
        this._buffer = buf.slice(read2.length);
        read2.func.call(this, buf.slice(0, read2.length));
      } else {
        break;
      }
    }
    if (this._reads.length > 0) {
      throw new Error("There are some read requests waitng on finished stream");
    }
    if (this._buffer.length > 0) {
      throw new Error("unrecognised content at end of stream");
    }
  };
  return syncReader.exports;
}
__name(requireSyncReader, "requireSyncReader");
var filterParseSync = {};
var hasRequiredFilterParseSync;
function requireFilterParseSync() {
  if (hasRequiredFilterParseSync) return filterParseSync;
  hasRequiredFilterParseSync = 1;
  let SyncReader = requireSyncReader();
  let Filter = requireFilterParse();
  filterParseSync.process = function(inBuffer, bitmapInfo) {
    let outBuffers = [];
    let reader = new SyncReader(inBuffer);
    let filter = new Filter(bitmapInfo, {
      read: reader.read.bind(reader),
      write: /* @__PURE__ */ __name(function(bufferPart) {
        outBuffers.push(bufferPart);
      }, "write"),
      complete: /* @__PURE__ */ __name(function() {
      }, "complete")
    });
    filter.start();
    reader.process();
    return Buffer.concat(outBuffers);
  };
  return filterParseSync;
}
__name(requireFilterParseSync, "requireFilterParseSync");
var parserSync;
var hasRequiredParserSync;
function requireParserSync() {
  if (hasRequiredParserSync) return parserSync;
  hasRequiredParserSync = 1;
  let hasSyncZlib = true;
  let zlib2 = requireLib2();
  let inflateSync = requireSyncInflate();
  if (!zlib2.deflateSync) {
    hasSyncZlib = false;
  }
  let SyncReader = requireSyncReader();
  let FilterSync = requireFilterParseSync();
  let Parser2 = requireParser();
  let bitmapper2 = requireBitmapper();
  let formatNormaliser2 = requireFormatNormaliser();
  parserSync = /* @__PURE__ */ __name(function(buffer2, options2) {
    if (!hasSyncZlib) {
      throw new Error(
        "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
      );
    }
    let err;
    function handleError(_err_) {
      err = _err_;
    }
    __name(handleError, "handleError");
    let metaData;
    function handleMetaData(_metaData_) {
      metaData = _metaData_;
    }
    __name(handleMetaData, "handleMetaData");
    function handleTransColor(transColor) {
      metaData.transColor = transColor;
    }
    __name(handleTransColor, "handleTransColor");
    function handlePalette(palette) {
      metaData.palette = palette;
    }
    __name(handlePalette, "handlePalette");
    function handleSimpleTransparency() {
      metaData.alpha = true;
    }
    __name(handleSimpleTransparency, "handleSimpleTransparency");
    let gamma;
    function handleGamma(_gamma_) {
      gamma = _gamma_;
    }
    __name(handleGamma, "handleGamma");
    let inflateDataList = [];
    function handleInflateData(inflatedData2) {
      inflateDataList.push(inflatedData2);
    }
    __name(handleInflateData, "handleInflateData");
    let reader = new SyncReader(buffer2);
    let parser2 = new Parser2(options2, {
      read: reader.read.bind(reader),
      error: handleError,
      metadata: handleMetaData,
      gamma: handleGamma,
      palette: handlePalette,
      transColor: handleTransColor,
      inflateData: handleInflateData,
      simpleTransparency: handleSimpleTransparency
    });
    parser2.start();
    reader.process();
    if (err) {
      throw err;
    }
    let inflateData = Buffer.concat(inflateDataList);
    inflateDataList.length = 0;
    let inflatedData;
    if (metaData.interlace) {
      inflatedData = zlib2.inflateSync(inflateData);
    } else {
      let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
      let imageSize = rowSize * metaData.height;
      inflatedData = inflateSync(inflateData, {
        chunkSize: imageSize,
        maxLength: imageSize
      });
    }
    inflateData = null;
    if (!inflatedData || !inflatedData.length) {
      throw new Error("bad png - invalid inflate data response");
    }
    let unfilteredData = FilterSync.process(inflatedData, metaData);
    inflateData = null;
    let bitmapData = bitmapper2.dataToBitMap(unfilteredData, metaData);
    unfilteredData = null;
    let normalisedBitmapData = formatNormaliser2(
      bitmapData,
      metaData,
      options2.skipRescale
    );
    metaData.data = normalisedBitmapData;
    metaData.gamma = gamma || 0;
    return metaData;
  }, "parserSync");
  return parserSync;
}
__name(requireParserSync, "requireParserSync");
var packerSync;
var hasRequiredPackerSync;
function requirePackerSync() {
  if (hasRequiredPackerSync) return packerSync;
  hasRequiredPackerSync = 1;
  let hasSyncZlib = true;
  let zlib2 = requireLib2();
  if (!zlib2.deflateSync) {
    hasSyncZlib = false;
  }
  let constants8 = requireConstants2();
  let Packer = requirePacker();
  packerSync = /* @__PURE__ */ __name(function(metaData, opt) {
    if (!hasSyncZlib) {
      throw new Error(
        "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
      );
    }
    let options2 = opt || {};
    let packer2 = new Packer(options2);
    let chunks = [];
    chunks.push(Buffer.from(constants8.PNG_SIGNATURE));
    chunks.push(packer2.packIHDR(metaData.width, metaData.height));
    if (metaData.gamma) {
      chunks.push(packer2.packGAMA(metaData.gamma));
    }
    let filteredData = packer2.filterData(
      metaData.data,
      metaData.width,
      metaData.height
    );
    let compressedData = zlib2.deflateSync(
      filteredData,
      packer2.getDeflateOptions()
    );
    filteredData = null;
    if (!compressedData || !compressedData.length) {
      throw new Error("bad png - invalid compressed data response");
    }
    chunks.push(packer2.packIDAT(compressedData));
    chunks.push(packer2.packIEND());
    return Buffer.concat(chunks);
  }, "packerSync");
  return packerSync;
}
__name(requirePackerSync, "requirePackerSync");
var hasRequiredPngSync;
function requirePngSync() {
  if (hasRequiredPngSync) return pngSync;
  hasRequiredPngSync = 1;
  let parse2 = requireParserSync();
  let pack = requirePackerSync();
  pngSync.read = function(buffer2, options2) {
    return parse2(buffer2, options2 || {});
  };
  pngSync.write = function(png2, options2) {
    return pack(png2, options2);
  };
  return pngSync;
}
__name(requirePngSync, "requirePngSync");
var hasRequiredPng;
function requirePng() {
  if (hasRequiredPng) return png;
  hasRequiredPng = 1;
  let util3 = util_default;
  let Stream2 = require$$62;
  let Parser2 = requireParserAsync();
  let Packer = requirePackerAsync();
  let PNGSync = requirePngSync();
  let PNG3 = png.PNG = function(options2) {
    Stream2.call(this);
    options2 = options2 || {};
    this.width = options2.width | 0;
    this.height = options2.height | 0;
    this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
    if (options2.fill && this.data) {
      this.data.fill(0);
    }
    this.gamma = 0;
    this.readable = this.writable = true;
    this._parser = new Parser2(options2);
    this._parser.on("error", this.emit.bind(this, "error"));
    this._parser.on("close", this._handleClose.bind(this));
    this._parser.on("metadata", this._metadata.bind(this));
    this._parser.on("gamma", this._gamma.bind(this));
    this._parser.on(
      "parsed",
      function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this)
    );
    this._packer = new Packer(options2);
    this._packer.on("data", this.emit.bind(this, "data"));
    this._packer.on("end", this.emit.bind(this, "end"));
    this._parser.on("close", this._handleClose.bind(this));
    this._packer.on("error", this.emit.bind(this, "error"));
  };
  util3.inherits(PNG3, Stream2);
  PNG3.sync = PNGSync;
  PNG3.prototype.pack = function() {
    if (!this.data || !this.data.length) {
      this.emit("error", "No data provided");
      return this;
    }
    process.nextTick(
      function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this)
    );
    return this;
  };
  PNG3.prototype.parse = function(data, callback) {
    if (callback) {
      let onParsed, onError;
      onParsed = function(parsedData) {
        this.removeListener("error", onError);
        this.data = parsedData;
        callback(null, this);
      }.bind(this);
      onError = function(err) {
        this.removeListener("parsed", onParsed);
        callback(err, null);
      }.bind(this);
      this.once("parsed", onParsed);
      this.once("error", onError);
    }
    this.end(data);
    return this;
  };
  PNG3.prototype.write = function(data) {
    this._parser.write(data);
    return true;
  };
  PNG3.prototype.end = function(data) {
    this._parser.end(data);
  };
  PNG3.prototype._metadata = function(metadata) {
    this.width = metadata.width;
    this.height = metadata.height;
    this.emit("metadata", metadata);
  };
  PNG3.prototype._gamma = function(gamma) {
    this.gamma = gamma;
  };
  PNG3.prototype._handleClose = function() {
    if (!this._parser.writable && !this._packer.readable) {
      this.emit("close");
    }
  };
  PNG3.bitblt = function(src2, dst, srcX, srcY, width, height, deltaX, deltaY) {
    srcX |= 0;
    srcY |= 0;
    width |= 0;
    height |= 0;
    deltaX |= 0;
    deltaY |= 0;
    if (srcX > src2.width || srcY > src2.height || srcX + width > src2.width || srcY + height > src2.height) {
      throw new Error("bitblt reading outside image");
    }
    if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
      throw new Error("bitblt writing outside image");
    }
    for (let y = 0; y < height; y++) {
      src2.data.copy(
        dst.data,
        (deltaY + y) * dst.width + deltaX << 2,
        (srcY + y) * src2.width + srcX << 2,
        (srcY + y) * src2.width + srcX + width << 2
      );
    }
  };
  PNG3.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
    PNG3.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
    return this;
  };
  PNG3.adjustGamma = function(src2) {
    if (src2.gamma) {
      for (let y = 0; y < src2.height; y++) {
        for (let x = 0; x < src2.width; x++) {
          let idx = src2.width * y + x << 2;
          for (let i = 0; i < 3; i++) {
            let sample = src2.data[idx + i] / 255;
            sample = Math.pow(sample, 1 / 2.2 / src2.gamma);
            src2.data[idx + i] = Math.round(sample * 255);
          }
        }
      }
      src2.gamma = 0;
    }
  };
  PNG3.prototype.adjustGamma = function() {
    PNG3.adjustGamma(this);
  };
  return png;
}
__name(requirePng, "requirePng");
var pngExports = requirePng();
var PNG = pngExports.PNG;

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/bundles/utilsBundleImpl.js
import require$$0$8 from "node:dns";
import require$$0$13 from "node:buffer";
var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
var lockfile$1 = {};
var polyfills;
var hasRequiredPolyfills;
function requirePolyfills() {
  if (hasRequiredPolyfills) return polyfills;
  hasRequiredPolyfills = 1;
  var constants22 = constants_default;
  var origCwd = process.cwd;
  var cwd2 = null;
  var platform4 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd2)
      cwd2 = origCwd.call(process);
    return cwd2;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    var chdir2 = process.chdir;
    process.chdir = function(d) {
      cwd2 = null;
      chdir2.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir2);
  }
  polyfills = patch;
  function patch(fs2) {
    if (constants22.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs2);
    }
    if (!fs2.lutimes) {
      patchLutimes(fs2);
    }
    fs2.chown = chownFix(fs2.chown);
    fs2.fchown = chownFix(fs2.fchown);
    fs2.lchown = chownFix(fs2.lchown);
    fs2.chmod = chmodFix(fs2.chmod);
    fs2.fchmod = chmodFix(fs2.fchmod);
    fs2.lchmod = chmodFix(fs2.lchmod);
    fs2.chownSync = chownFixSync(fs2.chownSync);
    fs2.fchownSync = chownFixSync(fs2.fchownSync);
    fs2.lchownSync = chownFixSync(fs2.lchownSync);
    fs2.chmodSync = chmodFixSync(fs2.chmodSync);
    fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
    fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
    fs2.stat = statFix(fs2.stat);
    fs2.fstat = statFix(fs2.fstat);
    fs2.lstat = statFix(fs2.lstat);
    fs2.statSync = statFixSync(fs2.statSync);
    fs2.fstatSync = statFixSync(fs2.fstatSync);
    fs2.lstatSync = statFixSync(fs2.lstatSync);
    if (fs2.chmod && !fs2.lchmod) {
      fs2.lchmod = function(path31, mode, cb) {
        if (cb) process.nextTick(cb);
      };
      fs2.lchmodSync = function() {
      };
    }
    if (fs2.chown && !fs2.lchown) {
      fs2.lchown = function(path31, uid, gid, cb) {
        if (cb) process.nextTick(cb);
      };
      fs2.lchownSync = function() {
      };
    }
    if (platform4 === "win32") {
      fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
        function rename2(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, /* @__PURE__ */ __name(function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs2.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb) cb(er);
          }, "CB"));
        }
        __name(rename2, "rename");
        if (Object.setPrototypeOf) Object.setPrototypeOf(rename2, fs$rename);
        return rename2;
      }(fs2.rename);
    }
    fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
      function read2(fd, buffer2, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = /* @__PURE__ */ __name(function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          }, "callback");
        }
        return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
      }
      __name(read2, "read");
      if (Object.setPrototypeOf) Object.setPrototypeOf(read2, fs$read);
      return read2;
    }(fs2.read);
    fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
      return function(fd, buffer2, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs2.readSync);
    function patchLchmod(fs22) {
      fs22.lchmod = function(path31, mode, callback) {
        fs22.open(
          path31,
          constants22.O_WRONLY | constants22.O_SYMLINK,
          mode,
          function(err, fd) {
            if (err) {
              if (callback) callback(err);
              return;
            }
            fs22.fchmod(fd, mode, function(err2) {
              fs22.close(fd, function(err22) {
                if (callback) callback(err2 || err22);
              });
            });
          }
        );
      };
      fs22.lchmodSync = function(path31, mode) {
        var fd = fs22.openSync(path31, constants22.O_WRONLY | constants22.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs22.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs22.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs22.closeSync(fd);
          }
        }
        return ret;
      };
    }
    __name(patchLchmod, "patchLchmod");
    function patchLutimes(fs22) {
      if (constants22.hasOwnProperty("O_SYMLINK") && fs22.futimes) {
        fs22.lutimes = function(path31, at, mt, cb) {
          fs22.open(path31, constants22.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb) cb(er);
              return;
            }
            fs22.futimes(fd, at, mt, function(er2) {
              fs22.close(fd, function(er22) {
                if (cb) cb(er2 || er22);
              });
            });
          });
        };
        fs22.lutimesSync = function(path31, at, mt) {
          var fd = fs22.openSync(path31, constants22.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs22.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs22.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs22.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs22.futimes) {
        fs22.lutimes = function(_a, _b, _c, cb) {
          if (cb) process.nextTick(cb);
        };
        fs22.lutimesSync = function() {
        };
      }
    }
    __name(patchLutimes, "patchLutimes");
    function chmodFix(orig) {
      if (!orig) return orig;
      return function(target, mode, cb) {
        return orig.call(fs2, target, mode, function(er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    __name(chmodFix, "chmodFix");
    function chmodFixSync(orig) {
      if (!orig) return orig;
      return function(target, mode) {
        try {
          return orig.call(fs2, target, mode);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    __name(chmodFixSync, "chmodFixSync");
    function chownFix(orig) {
      if (!orig) return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs2, target, uid, gid, function(er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    __name(chownFix, "chownFix");
    function chownFixSync(orig) {
      if (!orig) return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs2, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    __name(chownFixSync, "chownFixSync");
    function statFix(orig) {
      if (!orig) return orig;
      return function(target, options2, cb) {
        if (typeof options2 === "function") {
          cb = options2;
          options2 = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          if (cb) cb.apply(this, arguments);
        }
        __name(callback, "callback");
        return options2 ? orig.call(fs2, target, options2, callback) : orig.call(fs2, target, callback);
      };
    }
    __name(statFix, "statFix");
    function statFixSync(orig) {
      if (!orig) return orig;
      return function(target, options2) {
        var stats = options2 ? orig.call(fs2, target, options2) : orig.call(fs2, target);
        if (stats) {
          if (stats.uid < 0) stats.uid += 4294967296;
          if (stats.gid < 0) stats.gid += 4294967296;
        }
        return stats;
      };
    }
    __name(statFixSync, "statFixSync");
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
    __name(chownErOk, "chownErOk");
  }
  __name(patch, "patch");
  return polyfills;
}
__name(requirePolyfills, "requirePolyfills");
var legacyStreams;
var hasRequiredLegacyStreams;
function requireLegacyStreams() {
  if (hasRequiredLegacyStreams) return legacyStreams;
  hasRequiredLegacyStreams = 1;
  var Stream2 = require$$63.Stream;
  legacyStreams = legacy;
  function legacy(fs2) {
    return {
      ReadStream: ReadStream3,
      WriteStream: WriteStream3
    };
    function ReadStream3(path31, options2) {
      if (!(this instanceof ReadStream3)) return new ReadStream3(path31, options2);
      Stream2.call(this);
      var self2 = this;
      this.path = path31;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options2 = options2 || {};
      var keys = Object.keys(options2);
      for (var index2 = 0, length = keys.length; index2 < length; index2++) {
        var key = keys[index2];
        this[key] = options2[key];
      }
      if (this.encoding) this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if ("number" !== typeof this.start) {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if ("number" !== typeof this.end) {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs2.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    __name(ReadStream3, "ReadStream");
    function WriteStream3(path31, options2) {
      if (!(this instanceof WriteStream3)) return new WriteStream3(path31, options2);
      Stream2.call(this);
      this.path = path31;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options2 = options2 || {};
      var keys = Object.keys(options2);
      for (var index2 = 0, length = keys.length; index2 < length; index2++) {
        var key = keys[index2];
        this[key] = options2[key];
      }
      if (this.start !== void 0) {
        if ("number" !== typeof this.start) {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs2.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
    __name(WriteStream3, "WriteStream");
  }
  __name(legacy, "legacy");
  return legacyStreams;
}
__name(requireLegacyStreams, "requireLegacyStreams");
var clone_1;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone_1;
  hasRequiredClone = 1;
  clone_1 = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = { __proto__: getPrototypeOf(obj) };
    else
      var copy = /* @__PURE__ */ Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
  __name(clone, "clone");
  return clone_1;
}
__name(requireClone, "requireClone");
var gracefulFs;
var hasRequiredGracefulFs;
function requireGracefulFs() {
  if (hasRequiredGracefulFs) return gracefulFs;
  hasRequiredGracefulFs = 1;
  var fs$1 = fs;
  var polyfills2 = requirePolyfills();
  var legacy = requireLegacyStreams();
  var clone = requireClone();
  var util22 = util_default;
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {
  }
  __name(noop, "noop");
  function publishQueue(context2, queue2) {
    Object.defineProperty(context2, gracefulQueue, {
      get: /* @__PURE__ */ __name(function() {
        return queue2;
      }, "get")
    });
  }
  __name(publishQueue, "publishQueue");
  var debug22 = noop;
  if (util22.debuglog)
    debug22 = util22.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug22 = /* @__PURE__ */ __name(function() {
      var m = util22.format.apply(util22, arguments);
      m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
      console.error(m);
    }, "debug2");
  if (!fs$1[gracefulQueue]) {
    var queue = commonjsGlobal2[gracefulQueue] || [];
    publishQueue(fs$1, queue);
    fs$1.close = function(fs$close) {
      function close3(fd, cb) {
        return fs$close.call(fs$1, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      __name(close3, "close");
      Object.defineProperty(close3, previousSymbol, {
        value: fs$close
      });
      return close3;
    }(fs$1.close);
    fs$1.closeSync = function(fs$closeSync) {
      function closeSync2(fd) {
        fs$closeSync.apply(fs$1, arguments);
        resetQueue();
      }
      __name(closeSync2, "closeSync");
      Object.defineProperty(closeSync2, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync2;
    }(fs$1.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug22(fs$1[gracefulQueue]);
        require$$53.equal(fs$1[gracefulQueue].length, 0);
      });
    }
  }
  if (!commonjsGlobal2[gracefulQueue]) {
    publishQueue(commonjsGlobal2, fs$1[gracefulQueue]);
  }
  gracefulFs = patch(clone(fs$1));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$1.__patched) {
    gracefulFs = patch(fs$1);
    fs$1.__patched = true;
  }
  function patch(fs2) {
    polyfills2(fs2);
    fs2.gracefulify = patch;
    fs2.createReadStream = createReadStream2;
    fs2.createWriteStream = createWriteStream2;
    var fs$readFile = fs2.readFile;
    fs2.readFile = readFile2;
    function readFile2(path31, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = null;
      return go$readFile(path31, options2, cb);
      function go$readFile(path210, options22, cb2, startTime) {
        return fs$readFile(path210, options22, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path210, options22, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
      __name(go$readFile, "go$readFile");
    }
    __name(readFile2, "readFile");
    var fs$writeFile = fs2.writeFile;
    fs2.writeFile = writeFile2;
    function writeFile2(path31, data, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = null;
      return go$writeFile(path31, data, options2, cb);
      function go$writeFile(path210, data2, options22, cb2, startTime) {
        return fs$writeFile(path210, data2, options22, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path210, data2, options22, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
      __name(go$writeFile, "go$writeFile");
    }
    __name(writeFile2, "writeFile");
    var fs$appendFile = fs2.appendFile;
    if (fs$appendFile)
      fs2.appendFile = appendFile2;
    function appendFile2(path31, data, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = null;
      return go$appendFile(path31, data, options2, cb);
      function go$appendFile(path210, data2, options22, cb2, startTime) {
        return fs$appendFile(path210, data2, options22, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path210, data2, options22, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
      __name(go$appendFile, "go$appendFile");
    }
    __name(appendFile2, "appendFile");
    var fs$copyFile = fs2.copyFile;
    if (fs$copyFile)
      fs2.copyFile = copyFile2;
    function copyFile2(src2, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src2, dest, flags, cb);
      function go$copyFile(src3, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src3, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src3, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
      __name(go$copyFile, "go$copyFile");
    }
    __name(copyFile2, "copyFile");
    var fs$readdir = fs2.readdir;
    fs2.readdir = readdir2;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir2(path31, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? /* @__PURE__ */ __name(function go$readdir2(path210, options22, cb2, startTime) {
        return fs$readdir(path210, fs$readdirCallback(
          path210,
          options22,
          cb2,
          startTime
        ));
      }, "go$readdir2") : /* @__PURE__ */ __name(function go$readdir2(path210, options22, cb2, startTime) {
        return fs$readdir(path210, options22, fs$readdirCallback(
          path210,
          options22,
          cb2,
          startTime
        ));
      }, "go$readdir2");
      return go$readdir(path31, options2, cb);
      function fs$readdirCallback(path210, options22, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path210, options22, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
      __name(fs$readdirCallback, "fs$readdirCallback");
    }
    __name(readdir2, "readdir");
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs2);
      ReadStream3 = legStreams.ReadStream;
      WriteStream3 = legStreams.WriteStream;
    }
    var fs$ReadStream = fs2.ReadStream;
    if (fs$ReadStream) {
      ReadStream3.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream3.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs2.WriteStream;
    if (fs$WriteStream) {
      WriteStream3.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream3.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs2, "ReadStream", {
      get: /* @__PURE__ */ __name(function() {
        return ReadStream3;
      }, "get"),
      set: /* @__PURE__ */ __name(function(val) {
        ReadStream3 = val;
      }, "set"),
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs2, "WriteStream", {
      get: /* @__PURE__ */ __name(function() {
        return WriteStream3;
      }, "get"),
      set: /* @__PURE__ */ __name(function(val) {
        WriteStream3 = val;
      }, "set"),
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream3;
    Object.defineProperty(fs2, "FileReadStream", {
      get: /* @__PURE__ */ __name(function() {
        return FileReadStream;
      }, "get"),
      set: /* @__PURE__ */ __name(function(val) {
        FileReadStream = val;
      }, "set"),
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream3;
    Object.defineProperty(fs2, "FileWriteStream", {
      get: /* @__PURE__ */ __name(function() {
        return FileWriteStream;
      }, "get"),
      set: /* @__PURE__ */ __name(function(val) {
        FileWriteStream = val;
      }, "set"),
      enumerable: true,
      configurable: true
    });
    function ReadStream3(path31, options2) {
      if (this instanceof ReadStream3)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream3.apply(Object.create(ReadStream3.prototype), arguments);
    }
    __name(ReadStream3, "ReadStream");
    function ReadStream$open() {
      var that = this;
      open22(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    __name(ReadStream$open, "ReadStream$open");
    function WriteStream3(path31, options2) {
      if (this instanceof WriteStream3)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream3.apply(Object.create(WriteStream3.prototype), arguments);
    }
    __name(WriteStream3, "WriteStream");
    function WriteStream$open() {
      var that = this;
      open22(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    __name(WriteStream$open, "WriteStream$open");
    function createReadStream2(path31, options2) {
      return new fs2.ReadStream(path31, options2);
    }
    __name(createReadStream2, "createReadStream");
    function createWriteStream2(path31, options2) {
      return new fs2.WriteStream(path31, options2);
    }
    __name(createWriteStream2, "createWriteStream");
    var fs$open = fs2.open;
    fs2.open = open22;
    function open22(path31, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path31, flags, mode, cb);
      function go$open(path210, flags2, mode2, cb2, startTime) {
        return fs$open(path210, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path210, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
      __name(go$open, "go$open");
    }
    __name(open22, "open2");
    return fs2;
  }
  __name(patch, "patch");
  function enqueue(elem) {
    debug22("ENQUEUE", elem[0].name, elem[1]);
    fs$1[gracefulQueue].push(elem);
    retry2();
  }
  __name(enqueue, "enqueue");
  var retryTimer;
  function resetQueue() {
    var now = Date.now();
    for (var i = 0; i < fs$1[gracefulQueue].length; ++i) {
      if (fs$1[gracefulQueue][i].length > 2) {
        fs$1[gracefulQueue][i][3] = now;
        fs$1[gracefulQueue][i][4] = now;
      }
    }
    retry2();
  }
  __name(resetQueue, "resetQueue");
  function retry2() {
    clearTimeout(retryTimer);
    retryTimer = void 0;
    if (fs$1[gracefulQueue].length === 0)
      return;
    var elem = fs$1[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === void 0) {
      debug22("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 6e4) {
      debug22("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug22("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs$1[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === void 0) {
      retryTimer = setTimeout(retry2, 0);
    }
  }
  __name(retry2, "retry2");
  return gracefulFs;
}
__name(requireGracefulFs, "requireGracefulFs");
var retry$1 = {};
var retry_operation;
var hasRequiredRetry_operation;
function requireRetry_operation() {
  if (hasRequiredRetry_operation) return retry_operation;
  hasRequiredRetry_operation = 1;
  function RetryOperation(timeouts, options2) {
    if (typeof options2 === "boolean") {
      options2 = { forever: options2 };
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options2 || {};
    this._maxRetryTime = options2 && options2.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  __name(RetryOperation, "RetryOperation");
  retry_operation = RetryOperation;
  RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts;
  };
  RetryOperation.prototype.stop = function() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
  };
  RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (!err) {
      return false;
    }
    var currentTime = (/* @__PURE__ */ new Date()).getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.unshift(new Error("RetryOperation timeout occurred"));
      return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === void 0) {
      if (this._cachedTimeouts) {
        this._errors.splice(this._errors.length - 1, this._errors.length);
        this._timeouts = this._cachedTimeouts.slice(0);
        timeout = this._timeouts.shift();
      } else {
        return false;
      }
    }
    var self2 = this;
    var timer = setTimeout(function() {
      self2._attempts++;
      if (self2._operationTimeoutCb) {
        self2._timeout = setTimeout(function() {
          self2._operationTimeoutCb(self2._attempts);
        }, self2._operationTimeout);
        if (self2._options.unref) {
          self2._timeout.unref();
        }
      }
      self2._fn(self2._attempts);
    }, timeout);
    if (this._options.unref) {
      timer.unref();
    }
    return true;
  };
  RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }
    var self2 = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function() {
        self2._operationTimeoutCb();
      }, self2._operationTimeout);
    }
    this._operationStart = (/* @__PURE__ */ new Date()).getTime();
    this._fn(this._attempts);
  };
  RetryOperation.prototype.try = function(fn) {
    console.log("Using RetryOperation.try() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = function(fn) {
    console.log("Using RetryOperation.start() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = RetryOperation.prototype.try;
  RetryOperation.prototype.errors = function() {
    return this._errors;
  };
  RetryOperation.prototype.attempts = function() {
    return this._attempts;
  };
  RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
      return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for (var i = 0; i < this._errors.length; i++) {
      var error22 = this._errors[i];
      var message = error22.message;
      var count3 = (counts[message] || 0) + 1;
      counts[message] = count3;
      if (count3 >= mainErrorCount) {
        mainError = error22;
        mainErrorCount = count3;
      }
    }
    return mainError;
  };
  return retry_operation;
}
__name(requireRetry_operation, "requireRetry_operation");
var hasRequiredRetry$1;
function requireRetry$1() {
  if (hasRequiredRetry$1) return retry$1;
  hasRequiredRetry$1 = 1;
  (function(exports) {
    var RetryOperation = requireRetry_operation();
    exports.operation = function(options2) {
      var timeouts = exports.timeouts(options2);
      return new RetryOperation(timeouts, {
        forever: options2 && options2.forever,
        unref: options2 && options2.unref,
        maxRetryTime: options2 && options2.maxRetryTime
      });
    };
    exports.timeouts = function(options2) {
      if (options2 instanceof Array) {
        return [].concat(options2);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options2) {
        opts[key] = options2[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options2 && options2.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random2 = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random2 * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options2, methods) {
      if (options2 instanceof Array) {
        methods = options2;
        options2 = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {
          var op = exports.operation(options2);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }, "retryWrapper")).bind(obj, original);
        obj[method].options = options2;
      }
    };
  })(retry$1);
  return retry$1;
}
__name(requireRetry$1, "requireRetry$1");
var retry;
var hasRequiredRetry;
function requireRetry() {
  if (hasRequiredRetry) return retry;
  hasRequiredRetry = 1;
  retry = requireRetry$1();
  return retry;
}
__name(requireRetry, "requireRetry");
var signalExit = { exports: {} };
var signals2 = { exports: {} };
var hasRequiredSignals;
function requireSignals() {
  if (hasRequiredSignals) return signals2.exports;
  hasRequiredSignals = 1;
  (function(module) {
    module.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  })(signals2);
  return signals2.exports;
}
__name(requireSignals, "requireSignals");
var hasRequiredSignalExit;
function requireSignalExit() {
  if (hasRequiredSignalExit) return signalExit.exports;
  hasRequiredSignalExit = 1;
  var process2 = commonjsGlobal2.process;
  const processOk = /* @__PURE__ */ __name(function(process3) {
    return process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
  }, "processOk");
  if (!processOk(process2)) {
    signalExit.exports = function() {
      return function() {
      };
    };
  } else {
    var assert4 = require$$53;
    var signals22 = requireSignals();
    var isWin2 = /^win/i.test(process2.platform);
    var EE = require$$0$32;
    if (typeof EE !== "function") {
      EE = EE.EventEmitter;
    }
    var emitter;
    if (process2.__signal_exit_emitter__) {
      emitter = process2.__signal_exit_emitter__;
    } else {
      emitter = process2.__signal_exit_emitter__ = new EE();
      emitter.count = 0;
      emitter.emitted = {};
    }
    if (!emitter.infinite) {
      emitter.setMaxListeners(Infinity);
      emitter.infinite = true;
    }
    signalExit.exports = function(cb, opts) {
      if (!processOk(commonjsGlobal2.process)) {
        return function() {
        };
      }
      assert4.equal(typeof cb, "function", "a callback must be provided for exit handler");
      if (loaded === false) {
        load();
      }
      var ev = "exit";
      if (opts && opts.alwaysLast) {
        ev = "afterexit";
      }
      var remove = /* @__PURE__ */ __name(function() {
        emitter.removeListener(ev, cb);
        if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
          unload();
        }
      }, "remove");
      emitter.on(ev, cb);
      return remove;
    };
    var unload = /* @__PURE__ */ __name(function unload2() {
      if (!loaded || !processOk(commonjsGlobal2.process)) {
        return;
      }
      loaded = false;
      signals22.forEach(function(sig) {
        try {
          process2.removeListener(sig, sigListeners[sig]);
        } catch (er) {
        }
      });
      process2.emit = originalProcessEmit;
      process2.reallyExit = originalProcessReallyExit;
      emitter.count -= 1;
    }, "unload2");
    signalExit.exports.unload = unload;
    var emit2 = /* @__PURE__ */ __name(function emit22(event, code, signal) {
      if (emitter.emitted[event]) {
        return;
      }
      emitter.emitted[event] = true;
      emitter.emit(event, code, signal);
    }, "emit2");
    var sigListeners = {};
    signals22.forEach(function(sig) {
      sigListeners[sig] = /* @__PURE__ */ __name(function listener() {
        if (!processOk(commonjsGlobal2.process)) {
          return;
        }
        var listeners2 = process2.listeners(sig);
        if (listeners2.length === emitter.count) {
          unload();
          emit2("exit", null, sig);
          emit2("afterexit", null, sig);
          if (isWin2 && sig === "SIGHUP") {
            sig = "SIGINT";
          }
          process2.kill(process2.pid, sig);
        }
      }, "listener");
    });
    signalExit.exports.signals = function() {
      return signals22;
    };
    var loaded = false;
    var load = /* @__PURE__ */ __name(function load2() {
      if (loaded || !processOk(commonjsGlobal2.process)) {
        return;
      }
      loaded = true;
      emitter.count += 1;
      signals22 = signals22.filter(function(sig) {
        try {
          process2.on(sig, sigListeners[sig]);
          return true;
        } catch (er) {
          return false;
        }
      });
      process2.emit = processEmit;
      process2.reallyExit = processReallyExit;
    }, "load2");
    signalExit.exports.load = load;
    var originalProcessReallyExit = process2.reallyExit;
    var processReallyExit = /* @__PURE__ */ __name(function processReallyExit2(code) {
      if (!processOk(commonjsGlobal2.process)) {
        return;
      }
      process2.exitCode = code || /* istanbul ignore next */
      0;
      emit2("exit", process2.exitCode, null);
      emit2("afterexit", process2.exitCode, null);
      originalProcessReallyExit.call(process2, process2.exitCode);
    }, "processReallyExit2");
    var originalProcessEmit = process2.emit;
    var processEmit = /* @__PURE__ */ __name(function processEmit2(ev, arg) {
      if (ev === "exit" && processOk(commonjsGlobal2.process)) {
        if (arg !== void 0) {
          process2.exitCode = arg;
        }
        var ret = originalProcessEmit.apply(this, arguments);
        emit2("exit", process2.exitCode, null);
        emit2("afterexit", process2.exitCode, null);
        return ret;
      } else {
        return originalProcessEmit.apply(this, arguments);
      }
    }, "processEmit2");
  }
  return signalExit.exports;
}
__name(requireSignalExit, "requireSignalExit");
var hasRequiredLockfile;
function requireLockfile() {
  if (hasRequiredLockfile) return lockfile$1;
  hasRequiredLockfile = 1;
  const path$1 = path2;
  const fs2 = requireGracefulFs();
  const retry2 = requireRetry();
  const onExit = requireSignalExit();
  const locks = {};
  const cacheSymbol = Symbol();
  function probe(file, fs22, callback) {
    const cachedPrecision = fs22[cacheSymbol];
    if (cachedPrecision) {
      return fs22.stat(file, (err, stat2) => {
        if (err) {
          return callback(err);
        }
        callback(null, stat2.mtime, cachedPrecision);
      });
    }
    const mtime = new Date(Math.ceil(Date.now() / 1e3) * 1e3 + 5);
    fs22.utimes(file, mtime, mtime, (err) => {
      if (err) {
        return callback(err);
      }
      fs22.stat(file, (err2, stat2) => {
        if (err2) {
          return callback(err2);
        }
        const precision = stat2.mtime.getTime() % 1e3 === 0 ? "s" : "ms";
        Object.defineProperty(fs22, cacheSymbol, { value: precision });
        callback(null, stat2.mtime, precision);
      });
    });
  }
  __name(probe, "probe");
  function getMtime(precision) {
    let now = Date.now();
    if (precision === "s") {
      now = Math.ceil(now / 1e3) * 1e3;
    }
    return new Date(now);
  }
  __name(getMtime, "getMtime");
  function getLockFile(file, options2) {
    return options2.lockfilePath || `${file}.lock`;
  }
  __name(getLockFile, "getLockFile");
  function resolveCanonicalPath(file, options2, callback) {
    if (!options2.realpath) {
      return callback(null, path$1.resolve(file));
    }
    options2.fs.realpath(file, callback);
  }
  __name(resolveCanonicalPath, "resolveCanonicalPath");
  function acquireLock(file, options2, callback) {
    const lockfilePath = getLockFile(file, options2);
    options2.fs.mkdir(lockfilePath, (err) => {
      if (!err) {
        return probe(lockfilePath, options2.fs, (err2, mtime, mtimePrecision) => {
          if (err2) {
            options2.fs.rmdir(lockfilePath, () => {
            });
            return callback(err2);
          }
          callback(null, mtime, mtimePrecision);
        });
      }
      if (err.code !== "EEXIST") {
        return callback(err);
      }
      if (options2.stale <= 0) {
        return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
      }
      options2.fs.stat(lockfilePath, (err2, stat2) => {
        if (err2) {
          if (err2.code === "ENOENT") {
            return acquireLock(file, { ...options2, stale: 0 }, callback);
          }
          return callback(err2);
        }
        if (!isLockStale(stat2, options2)) {
          return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
        }
        removeLock(file, options2, (err3) => {
          if (err3) {
            return callback(err3);
          }
          acquireLock(file, { ...options2, stale: 0 }, callback);
        });
      });
    });
  }
  __name(acquireLock, "acquireLock");
  function isLockStale(stat2, options2) {
    return stat2.mtime.getTime() < Date.now() - options2.stale;
  }
  __name(isLockStale, "isLockStale");
  function removeLock(file, options2, callback) {
    options2.fs.rmdir(getLockFile(file, options2), (err) => {
      if (err && err.code !== "ENOENT") {
        return callback(err);
      }
      callback();
    });
  }
  __name(removeLock, "removeLock");
  function updateLock(file, options2) {
    const lock2 = locks[file];
    if (lock2.updateTimeout) {
      return;
    }
    lock2.updateDelay = lock2.updateDelay || options2.update;
    lock2.updateTimeout = setTimeout(() => {
      lock2.updateTimeout = null;
      options2.fs.stat(lock2.lockfilePath, (err, stat2) => {
        const isOverThreshold = lock2.lastUpdate + options2.stale < Date.now();
        if (err) {
          if (err.code === "ENOENT" || isOverThreshold) {
            return setLockAsCompromised(file, lock2, Object.assign(err, { code: "ECOMPROMISED" }));
          }
          lock2.updateDelay = 1e3;
          return updateLock(file, options2);
        }
        const isMtimeOurs = lock2.mtime.getTime() === stat2.mtime.getTime();
        if (!isMtimeOurs) {
          return setLockAsCompromised(
            file,
            lock2,
            Object.assign(
              new Error("Unable to update lock within the stale threshold"),
              { code: "ECOMPROMISED" }
            )
          );
        }
        const mtime = getMtime(lock2.mtimePrecision);
        options2.fs.utimes(lock2.lockfilePath, mtime, mtime, (err2) => {
          const isOverThreshold2 = lock2.lastUpdate + options2.stale < Date.now();
          if (lock2.released) {
            return;
          }
          if (err2) {
            if (err2.code === "ENOENT" || isOverThreshold2) {
              return setLockAsCompromised(file, lock2, Object.assign(err2, { code: "ECOMPROMISED" }));
            }
            lock2.updateDelay = 1e3;
            return updateLock(file, options2);
          }
          lock2.mtime = mtime;
          lock2.lastUpdate = Date.now();
          lock2.updateDelay = null;
          updateLock(file, options2);
        });
      });
    }, lock2.updateDelay);
    if (lock2.updateTimeout.unref) {
      lock2.updateTimeout.unref();
    }
  }
  __name(updateLock, "updateLock");
  function setLockAsCompromised(file, lock2, err) {
    lock2.released = true;
    if (lock2.updateTimeout) {
      clearTimeout(lock2.updateTimeout);
    }
    if (locks[file] === lock2) {
      delete locks[file];
    }
    lock2.options.onCompromised(err);
  }
  __name(setLockAsCompromised, "setLockAsCompromised");
  function lock(file, options2, callback) {
    options2 = {
      stale: 1e4,
      update: null,
      realpath: true,
      retries: 0,
      fs: fs2,
      onCompromised: /* @__PURE__ */ __name((err) => {
        throw err;
      }, "onCompromised"),
      ...options2
    };
    options2.retries = options2.retries || 0;
    options2.retries = typeof options2.retries === "number" ? { retries: options2.retries } : options2.retries;
    options2.stale = Math.max(options2.stale || 0, 2e3);
    options2.update = options2.update == null ? options2.stale / 2 : options2.update || 0;
    options2.update = Math.max(Math.min(options2.update, options2.stale / 2), 1e3);
    resolveCanonicalPath(file, options2, (err, file2) => {
      if (err) {
        return callback(err);
      }
      const operation = retry2.operation(options2.retries);
      operation.attempt(() => {
        acquireLock(file2, options2, (err2, mtime, mtimePrecision) => {
          if (operation.retry(err2)) {
            return;
          }
          if (err2) {
            return callback(operation.mainError());
          }
          const lock2 = locks[file2] = {
            lockfilePath: getLockFile(file2, options2),
            mtime,
            mtimePrecision,
            options: options2,
            lastUpdate: Date.now()
          };
          updateLock(file2, options2);
          callback(null, (releasedCallback) => {
            if (lock2.released) {
              return releasedCallback && releasedCallback(Object.assign(new Error("Lock is already released"), { code: "ERELEASED" }));
            }
            unlock(file2, { ...options2, realpath: false }, releasedCallback);
          });
        });
      });
    });
  }
  __name(lock, "lock");
  function unlock(file, options2, callback) {
    options2 = {
      fs: fs2,
      realpath: true,
      ...options2
    };
    resolveCanonicalPath(file, options2, (err, file2) => {
      if (err) {
        return callback(err);
      }
      const lock2 = locks[file2];
      if (!lock2) {
        return callback(Object.assign(new Error("Lock is not acquired/owned by you"), { code: "ENOTACQUIRED" }));
      }
      lock2.updateTimeout && clearTimeout(lock2.updateTimeout);
      lock2.released = true;
      delete locks[file2];
      removeLock(file2, options2, callback);
    });
  }
  __name(unlock, "unlock");
  function toPromise(method) {
    return (...args) => new Promise((resolve, reject) => {
      args.push((err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
      method(...args);
    });
  }
  __name(toPromise, "toPromise");
  let cleanupInitialized = false;
  function ensureCleanup() {
    if (cleanupInitialized) {
      return;
    }
    cleanupInitialized = true;
    onExit(() => {
      for (const file in locks) {
        const options2 = locks[file].options;
        try {
          options2.fs.rmdirSync(getLockFile(file, options2));
        } catch (e) {
        }
      }
    });
  }
  __name(ensureCleanup, "ensureCleanup");
  lockfile$1.lock = async (file, options2) => {
    ensureCleanup();
    const release3 = await toPromise(lock)(file, options2);
    return toPromise(release3);
  };
  return lockfile$1;
}
__name(requireLockfile, "requireLockfile");
var safe = { exports: {} };
var colors$1 = { exports: {} };
var styles = { exports: {} };
var hasRequiredStyles;
function requireStyles() {
  if (hasRequiredStyles) return styles.exports;
  hasRequiredStyles = 1;
  (function(module) {
    var styles2 = {};
    module["exports"] = styles2;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles2[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  })(styles);
  return styles.exports;
}
__name(requireStyles, "requireStyles");
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = /* @__PURE__ */ __name(function(flag, argv2) {
    argv2 = argv2 || process.argv;
    var terminatorPos = argv2.indexOf("--");
    var prefix = /^-{1,2}/.test(flag) ? "" : "--";
    var pos = argv2.indexOf(prefix + flag);
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  }, "hasFlag");
  return hasFlag;
}
__name(requireHasFlag, "requireHasFlag");
var supportsColors;
var hasRequiredSupportsColors;
function requireSupportsColors() {
  if (hasRequiredSupportsColors) return supportsColors;
  hasRequiredSupportsColors = 1;
  var os$1 = os_default;
  var hasFlag2 = requireHasFlag();
  var env3 = process.env;
  var forceColor = void 0;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false")) {
    forceColor = false;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env3) {
    forceColor = env3.FORCE_COLOR.length === 0 || parseInt(env3.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  __name(translateLevel, "translateLevel");
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    var min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      var osRelease2 = os$1.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease2[0]) >= 10 && Number(osRelease2[2]) >= 10586) {
        return Number(osRelease2[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env3) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign2) {
        return sign2 in env3;
      }) || env3.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env3) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env3.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("TERM_PROGRAM" in env3) {
      var version22 = parseInt((env3.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env3.TERM_PROGRAM) {
        case "iTerm.app":
          return version22 >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env3.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env3.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env3) {
      return 1;
    }
    if (env3.TERM === "dumb") {
      return min;
    }
    return min;
  }
  __name(supportsColor, "supportsColor");
  function getSupportLevel(stream) {
    var level = supportsColor(stream);
    return translateLevel(level);
  }
  __name(getSupportLevel, "getSupportLevel");
  supportsColors = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
  return supportsColors;
}
__name(requireSupportsColors, "requireSupportsColors");
var trap = { exports: {} };
var hasRequiredTrap;
function requireTrap() {
  if (hasRequiredTrap) return trap.exports;
  hasRequiredTrap = 1;
  (function(module) {
    module["exports"] = /* @__PURE__ */ __name(function runTheTrap(text, options2) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap2 = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap2[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap2[c] !== "undefined") {
          result += trap2[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    }, "runTheTrap");
  })(trap);
  return trap.exports;
}
__name(requireTrap, "requireTrap");
var zalgo = { exports: {} };
var hasRequiredZalgo;
function requireZalgo() {
  if (hasRequiredZalgo) return zalgo.exports;
  hasRequiredZalgo = 1;
  (function(module) {
    module["exports"] = /* @__PURE__ */ __name(function zalgo2(text, options2) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      __name(randomNumber, "randomNumber");
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      __name(isChar, "isChar");
      function heComes(text2, options22) {
        var result = "";
        var counts;
        var l;
        options22 = options22 || {};
        options22["up"] = typeof options22["up"] !== "undefined" ? options22["up"] : true;
        options22["mid"] = typeof options22["mid"] !== "undefined" ? options22["mid"] : true;
        options22["down"] = typeof options22["down"] !== "undefined" ? options22["down"] : true;
        options22["size"] = typeof options22["size"] !== "undefined" ? options22["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options22.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index2 = arr[d];
            for (var i = 0; i <= counts[index2]; i++) {
              if (options22[index2]) {
                result = result + soul[index2][randomNumber(soul[index2].length)];
              }
            }
          }
        }
        return result;
      }
      __name(heComes, "heComes");
      return heComes(text, options2);
    }, "zalgo2");
  })(zalgo);
  return zalgo.exports;
}
__name(requireZalgo, "requireZalgo");
var america = { exports: {} };
var hasRequiredAmerica;
function requireAmerica() {
  if (hasRequiredAmerica) return america.exports;
  hasRequiredAmerica = 1;
  (function(module) {
    module["exports"] = function(colors22) {
      return function(letter2, i, exploded) {
        if (letter2 === " ") return letter2;
        switch (i % 3) {
          case 0:
            return colors22.red(letter2);
          case 1:
            return colors22.white(letter2);
          case 2:
            return colors22.blue(letter2);
        }
      };
    };
  })(america);
  return america.exports;
}
__name(requireAmerica, "requireAmerica");
var zebra = { exports: {} };
var hasRequiredZebra;
function requireZebra() {
  if (hasRequiredZebra) return zebra.exports;
  hasRequiredZebra = 1;
  (function(module) {
    module["exports"] = function(colors22) {
      return function(letter2, i, exploded) {
        return i % 2 === 0 ? letter2 : colors22.inverse(letter2);
      };
    };
  })(zebra);
  return zebra.exports;
}
__name(requireZebra, "requireZebra");
var rainbow = { exports: {} };
var hasRequiredRainbow;
function requireRainbow() {
  if (hasRequiredRainbow) return rainbow.exports;
  hasRequiredRainbow = 1;
  (function(module) {
    module["exports"] = function(colors22) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter2, i, exploded) {
        if (letter2 === " ") {
          return letter2;
        } else {
          return colors22[rainbowColors[i++ % rainbowColors.length]](letter2);
        }
      };
    };
  })(rainbow);
  return rainbow.exports;
}
__name(requireRainbow, "requireRainbow");
var random = { exports: {} };
var hasRequiredRandom;
function requireRandom() {
  if (hasRequiredRandom) return random.exports;
  hasRequiredRandom = 1;
  (function(module) {
    module["exports"] = function(colors22) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter2, i, exploded) {
        return letter2 === " " ? letter2 : colors22[available[Math.round(Math.random() * (available.length - 2))]](letter2);
      };
    };
  })(random);
  return random.exports;
}
__name(requireRandom, "requireRandom");
var hasRequiredColors;
function requireColors() {
  if (hasRequiredColors) return colors$1.exports;
  hasRequiredColors = 1;
  (function(module) {
    var colors22 = {};
    module["exports"] = colors22;
    colors22.themes = {};
    var util22 = util_default;
    var ansiStyles = colors22.styles = requireStyles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors22.supportsColor = requireSupportsColors().supportsColor;
    if (typeof colors22.enabled === "undefined") {
      colors22.enabled = colors22.supportsColor() !== false;
    }
    colors22.enable = function() {
      colors22.enabled = true;
    };
    colors22.disable = function() {
      colors22.enabled = false;
    };
    colors22.stripColors = colors22.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    colors22.stylize = /* @__PURE__ */ __name(function stylize(str, style) {
      if (!colors22.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors22) {
        return colors22[style](str);
      }
      return styleMap.open + str + styleMap.close;
    }, "stylize");
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = /* @__PURE__ */ __name(function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    }, "escapeStringRegexp");
    function build2(_styles) {
      var builder = /* @__PURE__ */ __name(function builder2() {
        return applyStyle2.apply(builder2, arguments);
      }, "builder2");
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    __name(build2, "build2");
    var styles2 = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: /* @__PURE__ */ __name(function() {
            return build2(this._styles.concat(key));
          }, "get")
        };
      });
      return ret;
    }();
    var proto = defineProps(/* @__PURE__ */ __name(function colors3() {
    }, "colors3"), styles2);
    function applyStyle2() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util22.inspect(arg);
        }
      }).join(" ");
      if (!colors22.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    __name(applyStyle2, "applyStyle");
    colors22.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors22[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors22[theme[style2][i]](out);
              }
              return out;
            }
            return colors22[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles2).forEach(function(name) {
        ret[name] = {
          get: /* @__PURE__ */ __name(function() {
            return build2([name]);
          }, "get")
        };
      });
      return ret;
    }
    __name(init, "init");
    var sequencer = /* @__PURE__ */ __name(function sequencer2(map3, str) {
      var exploded = str.split("");
      exploded = exploded.map(map3);
      return exploded.join("");
    }, "sequencer2");
    colors22.trap = requireTrap();
    colors22.zalgo = requireZalgo();
    colors22.maps = {};
    colors22.maps.america = requireAmerica()(colors22);
    colors22.maps.zebra = requireZebra()(colors22);
    colors22.maps.rainbow = requireRainbow()(colors22);
    colors22.maps.random = requireRandom()(colors22);
    for (var map2 in colors22.maps) {
      (function(map3) {
        colors22[map3] = function(str) {
          return sequencer(colors22.maps[map3], str);
        };
      })(map2);
    }
    defineProps(colors22, init());
  })(colors$1);
  return colors$1.exports;
}
__name(requireColors, "requireColors");
var hasRequiredSafe;
function requireSafe() {
  if (hasRequiredSafe) return safe.exports;
  hasRequiredSafe = 1;
  (function(module) {
    var colors22 = requireColors();
    module["exports"] = colors22;
  })(safe);
  return safe.exports;
}
__name(requireSafe, "requireSafe");
var safeExports = requireSafe();
var colorsLibrary = /* @__PURE__ */ getDefaultExportFromCjs(safeExports);
var browser$1 = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = /* @__PURE__ */ __name(function(val, options2) {
    options2 = options2 || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  }, "ms");
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  __name(parse2, "parse2");
  function fmtShort(ms22) {
    var msAbs = Math.abs(ms22);
    if (msAbs >= d) {
      return Math.round(ms22 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms22 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms22 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms22 / s) + "s";
    }
    return ms22 + "ms";
  }
  __name(fmtShort, "fmtShort");
  function fmtLong(ms22) {
    var msAbs = Math.abs(ms22);
    if (msAbs >= d) {
      return plural(ms22, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms22, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms22, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms22, msAbs, s, "second");
    }
    return ms22 + " ms";
  }
  __name(fmtLong, "fmtLong");
  function plural(ms22, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms22 / n) + " " + name + (isPlural ? "s" : "");
  }
  __name(plural, "plural");
  return ms;
}
__name(requireMs, "requireMs");
var common$1;
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  function setup(env3) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env3).forEach((key) => {
      createDebug[key] = env3[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    __name(selectColor, "selectColor");
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug22(...args) {
        if (!debug22.enabled) {
          return;
        }
        const self2 = debug22;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms22 = curr - (prevTime || curr);
        self2.diff = ms22;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      __name(debug22, "debug2");
      debug22.namespace = namespace;
      debug22.useColors = createDebug.useColors();
      debug22.color = createDebug.selectColor(namespace);
      debug22.extend = extend;
      debug22.destroy = createDebug.destroy;
      Object.defineProperty(debug22, "enabled", {
        enumerable: true,
        configurable: false,
        get: /* @__PURE__ */ __name(() => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        }, "get"),
        set: /* @__PURE__ */ __name((v) => {
          enableOverride = v;
        }, "set")
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug22);
      }
      return debug22;
    }
    __name(createDebug, "createDebug");
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    __name(extend, "extend");
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    __name(enable, "enable");
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    __name(disable, "disable");
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    __name(enabled, "enabled");
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    __name(toNamespace, "toNamespace");
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    __name(coerce, "coerce");
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    __name(destroy, "destroy");
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  __name(setup, "setup");
  common$1 = setup;
  return common$1;
}
__name(requireCommon$1, "requireCommon$1");
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$1.exports;
  hasRequiredBrowser$1 = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error22) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error22) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error22) {
      }
    }
    __name(localstorage, "localstorage");
    module.exports = requireCommon$1()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error22) {
        return "[UnexpectedJSONParseError]: " + error22.message;
      }
    };
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}
__name(requireBrowser$1, "requireBrowser$1");
var browserExports$1 = requireBrowser$1();
var debugLibrary = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
function Diff() {
}
__name(Diff, "Diff");
Diff.prototype = {
  diff: /* @__PURE__ */ __name(function diff(oldString, newString) {
    var _options$timeout;
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options2.callback;
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    var self2 = this;
    function done(value) {
      value = self2.postProcess(value, options2);
      if (callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }
    __name(done, "done");
    oldString = this.castInput(oldString, options2);
    newString = this.castInput(newString, options2);
    oldString = this.removeEmpty(this.tokenize(oldString, options2));
    newString = this.removeEmpty(this.tokenize(newString, options2));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    if (options2.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options2.maxEditLength);
    }
    var maxExecutionTime = (_options$timeout = options2.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: void 0
    }];
    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0, options2);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(buildValues(self2, bestPath[0].lastComponent, newString, oldString, self2.useLongestToken));
    }
    var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0;
        var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = false;
        if (addPath) {
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        var canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = self2.addToPath(addPath, true, false, 0, options2);
        } else {
          basePath = self2.addToPath(removePath, false, true, 1, options2);
        }
        newPos = self2.extractCommon(basePath, newString, oldString, diagonalPath, options2);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(buildValues(self2, basePath.lastComponent, newString, oldString, self2.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    }
    __name(execEditLength, "execEditLength");
    if (callback) {
      (/* @__PURE__ */ __name(function exec2() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }
          if (!execEditLength()) {
            exec2();
          }
        }, 0);
      }, "exec"))();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  }, "diff"),
  addToPath: /* @__PURE__ */ __name(function addToPath(path31, added, removed, oldPosInc, options2) {
    var last = path31.lastComponent;
    if (last && !options2.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path31.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added,
          removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path31.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added,
          removed,
          previousComponent: last
        }
      };
    }
  }, "addToPath"),
  extractCommon: /* @__PURE__ */ __name(function extractCommon(basePath, newString, oldString, diagonalPath, options2) {
    var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldString[oldPos + 1], newString[newPos + 1], options2)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options2.oneChangePerToken) {
        basePath.lastComponent = {
          count: 1,
          previousComponent: basePath.lastComponent,
          added: false,
          removed: false
        };
      }
    }
    if (commonCount && !options2.oneChangePerToken) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent,
        added: false,
        removed: false
      };
    }
    basePath.oldPos = oldPos;
    return newPos;
  }, "extractCommon"),
  equals: /* @__PURE__ */ __name(function equals(left, right, options2) {
    if (options2.comparator) {
      return options2.comparator(left, right);
    } else {
      return left === right || options2.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  }, "equals"),
  removeEmpty: /* @__PURE__ */ __name(function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  }, "removeEmpty"),
  castInput: /* @__PURE__ */ __name(function castInput(value) {
    return value;
  }, "castInput"),
  tokenize: /* @__PURE__ */ __name(function tokenize(value) {
    return Array.from(value);
  }, "tokenize"),
  join: /* @__PURE__ */ __name(function join(chars) {
    return chars.join("");
  }, "join"),
  postProcess: /* @__PURE__ */ __name(function postProcess(changeObjects) {
    return changeObjects;
  }, "postProcess")
};
function buildValues(diff32, lastComponent, newString, oldString, useLongestToken) {
  var components = [];
  var nextComponent;
  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }
  components.reverse();
  var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff32.join(value);
      } else {
        component.value = diff32.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff32.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
    }
  }
  return components;
}
__name(buildValues, "buildValues");
var characterDiff = new Diff();
function diffChars(oldStr, newStr, options2) {
  return characterDiff.diff(oldStr, newStr, options2);
}
__name(diffChars, "diffChars");
function longestCommonPrefix(str1, str2) {
  var i;
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[i] != str2[i]) {
      return str1.slice(0, i);
    }
  }
  return str1.slice(0, i);
}
__name(longestCommonPrefix, "longestCommonPrefix");
function longestCommonSuffix(str1, str2) {
  var i;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {
    return "";
  }
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {
      return str1.slice(-i);
    }
  }
  return str1.slice(-i);
}
__name(longestCommonSuffix, "longestCommonSuffix");
function replacePrefix(string2, oldPrefix, newPrefix) {
  if (string2.slice(0, oldPrefix.length) != oldPrefix) {
    throw Error("string ".concat(JSON.stringify(string2), " doesn't start with prefix ").concat(JSON.stringify(oldPrefix), "; this is a bug"));
  }
  return newPrefix + string2.slice(oldPrefix.length);
}
__name(replacePrefix, "replacePrefix");
function replaceSuffix(string2, oldSuffix, newSuffix) {
  if (!oldSuffix) {
    return string2 + newSuffix;
  }
  if (string2.slice(-oldSuffix.length) != oldSuffix) {
    throw Error("string ".concat(JSON.stringify(string2), " doesn't end with suffix ").concat(JSON.stringify(oldSuffix), "; this is a bug"));
  }
  return string2.slice(0, -oldSuffix.length) + newSuffix;
}
__name(replaceSuffix, "replaceSuffix");
function removePrefix(string2, oldPrefix) {
  return replacePrefix(string2, oldPrefix, "");
}
__name(removePrefix, "removePrefix");
function removeSuffix(string2, oldSuffix) {
  return replaceSuffix(string2, oldSuffix, "");
}
__name(removeSuffix, "removeSuffix");
function maximumOverlap(string1, string2) {
  return string2.slice(0, overlapCount(string1, string2));
}
__name(maximumOverlap, "maximumOverlap");
function overlapCount(a, b) {
  var startA = 0;
  if (a.length > b.length) {
    startA = a.length - b.length;
  }
  var endB = b.length;
  if (a.length < b.length) {
    endB = a.length;
  }
  var map2 = Array(endB);
  var k = 0;
  map2[0] = 0;
  for (var j = 1; j < endB; j++) {
    if (b[j] == b[k]) {
      map2[j] = map2[k];
    } else {
      map2[j] = k;
    }
    while (k > 0 && b[j] != b[k]) {
      k = map2[k];
    }
    if (b[j] == b[k]) {
      k++;
    }
  }
  k = 0;
  for (var i = startA; i < a.length; i++) {
    while (k > 0 && a[i] != b[k]) {
      k = map2[k];
    }
    if (a[i] == b[k]) {
      k++;
    }
  }
  return k;
}
__name(overlapCount, "overlapCount");
function hasOnlyWinLineEndings(string2) {
  return string2.includes("\r\n") && !string2.startsWith("\n") && !string2.match(/[^\r]\n/);
}
__name(hasOnlyWinLineEndings, "hasOnlyWinLineEndings");
function hasOnlyUnixLineEndings(string2) {
  return !string2.includes("\r\n") && string2.includes("\n");
}
__name(hasOnlyUnixLineEndings, "hasOnlyUnixLineEndings");
var extendedWordChars = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var tokenizeIncludingWhitespace = new RegExp("[".concat(extendedWordChars, "]+|\\s+|[^").concat(extendedWordChars, "]"), "ug");
var wordDiff = new Diff();
wordDiff.equals = function(left, right, options2) {
  if (options2.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left.trim() === right.trim();
};
wordDiff.tokenize = function(value) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var parts;
  if (options2.intlSegmenter) {
    if (options2.intlSegmenter.resolvedOptions().granularity != "word") {
      throw new Error('The segmenter passed must have a granularity of "word"');
    }
    parts = Array.from(options2.intlSegmenter.segment(value), function(segment) {
      return segment.segment;
    });
  } else {
    parts = value.match(tokenizeIncludingWhitespace) || [];
  }
  var tokens = [];
  var prevPart = null;
  parts.forEach(function(part) {
    if (/\s/.test(part)) {
      if (prevPart == null) {
        tokens.push(part);
      } else {
        tokens.push(tokens.pop() + part);
      }
    } else if (/\s/.test(prevPart)) {
      if (tokens[tokens.length - 1] == prevPart) {
        tokens.push(tokens.pop() + part);
      } else {
        tokens.push(prevPart + part);
      }
    } else {
      tokens.push(part);
    }
    prevPart = part;
  });
  return tokens;
};
wordDiff.join = function(tokens) {
  return tokens.map(function(token, i) {
    if (i == 0) {
      return token;
    } else {
      return token.replace(/^\s+/, "");
    }
  }).join("");
};
wordDiff.postProcess = function(changes, options2) {
  if (!changes || options2.oneChangePerToken) {
    return changes;
  }
  var lastKeep = null;
  var insertion = null;
  var deletion = null;
  changes.forEach(function(change) {
    if (change.added) {
      insertion = change;
    } else if (change.removed) {
      deletion = change;
    } else {
      if (insertion || deletion) {
        dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
      }
      lastKeep = change;
      insertion = null;
      deletion = null;
    }
  });
  if (insertion || deletion) {
    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
  }
  return changes;
};
function diffWords(oldStr, newStr, options2) {
  if ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreWhitespace) != null && !options2.ignoreWhitespace) {
    return diffWordsWithSpace(oldStr, newStr, options2);
  }
  return wordDiff.diff(oldStr, newStr, options2);
}
__name(diffWords, "diffWords");
function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  if (deletion && insertion) {
    var oldWsPrefix = deletion.value.match(/^\s*/)[0];
    var oldWsSuffix = deletion.value.match(/\s*$/)[0];
    var newWsPrefix = insertion.value.match(/^\s*/)[0];
    var newWsSuffix = insertion.value.match(/\s*$/)[0];
    if (startKeep) {
      var commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);
      deletion.value = removePrefix(deletion.value, commonWsPrefix);
      insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      var commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value = removeSuffix(deletion.value, commonWsSuffix);
      insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    if (startKeep) {
      insertion.value = insertion.value.replace(/^\s*/, "");
    }
    if (endKeep) {
      endKeep.value = endKeep.value.replace(/^\s*/, "");
    }
  } else if (startKeep && endKeep) {
    var newWsFull = endKeep.value.match(/^\s*/)[0], delWsStart = deletion.value.match(/^\s*/)[0], delWsEnd = deletion.value.match(/\s*$/)[0];
    var newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    var newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);
    deletion.value = removeSuffix(deletion.value, newWsEnd);
    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);
    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    var endKeepWsPrefix = endKeep.value.match(/^\s*/)[0];
    var deletionWsSuffix = deletion.value.match(/\s*$/)[0];
    var overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    var startKeepWsSuffix = startKeep.value.match(/\s*$/)[0];
    var deletionWsPrefix = deletion.value.match(/^\s*/)[0];
    var _overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, _overlap);
  }
}
__name(dedupeWhitespaceInChangeObjects, "dedupeWhitespaceInChangeObjects");
var wordWithSpaceDiff = new Diff();
wordWithSpaceDiff.tokenize = function(value) {
  var regex = new RegExp("(\\r?\\n)|[".concat(extendedWordChars, "]+|[^\\S\\n\\r]+|[^").concat(extendedWordChars, "]"), "ug");
  return value.match(regex) || [];
};
function diffWordsWithSpace(oldStr, newStr, options2) {
  return wordWithSpaceDiff.diff(oldStr, newStr, options2);
}
__name(diffWordsWithSpace, "diffWordsWithSpace");
function generateOptions(options2, defaults) {
  if (typeof options2 === "function") {
    defaults.callback = options2;
  } else if (options2) {
    for (var name in options2) {
      if (options2.hasOwnProperty(name)) {
        defaults[name] = options2[name];
      }
    }
  }
  return defaults;
}
__name(generateOptions, "generateOptions");
var lineDiff = new Diff();
lineDiff.tokenize = function(value, options2) {
  if (options2.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];
    if (i % 2 && !options2.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
};
lineDiff.equals = function(left, right, options2) {
  if (options2.ignoreWhitespace) {
    if (!options2.newlineIsToken || !left.includes("\n")) {
      left = left.trim();
    }
    if (!options2.newlineIsToken || !right.includes("\n")) {
      right = right.trim();
    }
  } else if (options2.ignoreNewlineAtEof && !options2.newlineIsToken) {
    if (left.endsWith("\n")) {
      left = left.slice(0, -1);
    }
    if (right.endsWith("\n")) {
      right = right.slice(0, -1);
    }
  }
  return Diff.prototype.equals.call(this, left, right, options2);
};
function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
__name(diffLines, "diffLines");
function diffTrimmedLines(oldStr, newStr, callback) {
  var options2 = generateOptions(callback, {
    ignoreWhitespace: true
  });
  return lineDiff.diff(oldStr, newStr, options2);
}
__name(diffTrimmedLines, "diffTrimmedLines");
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
function diffSentences(oldStr, newStr, callback) {
  return sentenceDiff.diff(oldStr, newStr, callback);
}
__name(diffSentences, "diffSentences");
var cssDiff = new Diff();
cssDiff.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};
function diffCss(oldStr, newStr, callback) {
  return cssDiff.diff(oldStr, newStr, callback);
}
__name(diffCss, "diffCss");
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys2, "ownKeys");
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread2, "_objectSpread2");
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive, "_toPrimitive");
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
__name(_toPropertyKey, "_toPropertyKey");
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
__name(_typeof, "_typeof");
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty, "_defineProperty");
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
__name(_toConsumableArray, "_toConsumableArray");
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
__name(_arrayWithoutHoles, "_arrayWithoutHoles");
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
__name(_iterableToArray, "_iterableToArray");
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
__name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
__name(_arrayLikeToArray, "_arrayLikeToArray");
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread, "_nonIterableSpread");
var jsonDiff = new Diff();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value, options2) {
  var undefinedReplacement = options2.undefinedReplacement, _options$stringifyRep = options2.stringifyReplacer, stringifyReplacer = _options$stringifyRep === void 0 ? function(k, v) {
    return typeof v === "undefined" ? undefinedReplacement : v;
  } : _options$stringifyRep;
  return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right, options2) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"), options2);
};
function diffJson(oldObj, newObj, options2) {
  return jsonDiff.diff(oldObj, newObj, options2);
}
__name(diffJson, "diffJson");
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key, obj);
  }
  var i;
  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === Object.prototype.toString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, _key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
__name(canonicalize, "canonicalize");
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value) {
  return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
  return value;
};
function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}
__name(diffArrays, "diffArrays");
function unixToWin(patch) {
  if (Array.isArray(patch)) {
    return patch.map(unixToWin);
  }
  return _objectSpread2(_objectSpread2({}, patch), {}, {
    hunks: patch.hunks.map(function(hunk) {
      return _objectSpread2(_objectSpread2({}, hunk), {}, {
        lines: hunk.lines.map(function(line, i) {
          var _hunk$lines;
          return line.startsWith("\\") || line.endsWith("\r") || (_hunk$lines = hunk.lines[i + 1]) !== null && _hunk$lines !== void 0 && _hunk$lines.startsWith("\\") ? line : line + "\r";
        })
      });
    })
  });
}
__name(unixToWin, "unixToWin");
function winToUnix(patch) {
  if (Array.isArray(patch)) {
    return patch.map(winToUnix);
  }
  return _objectSpread2(_objectSpread2({}, patch), {}, {
    hunks: patch.hunks.map(function(hunk) {
      return _objectSpread2(_objectSpread2({}, hunk), {}, {
        lines: hunk.lines.map(function(line) {
          return line.endsWith("\r") ? line.substring(0, line.length - 1) : line;
        })
      });
    })
  });
}
__name(winToUnix, "winToUnix");
function isUnix(patch) {
  if (!Array.isArray(patch)) {
    patch = [patch];
  }
  return !patch.some(function(index2) {
    return index2.hunks.some(function(hunk) {
      return hunk.lines.some(function(line) {
        return !line.startsWith("\\") && line.endsWith("\r");
      });
    });
  });
}
__name(isUnix, "isUnix");
function isWin(patch) {
  if (!Array.isArray(patch)) {
    patch = [patch];
  }
  return patch.some(function(index2) {
    return index2.hunks.some(function(hunk) {
      return hunk.lines.some(function(line) {
        return line.endsWith("\r");
      });
    });
  }) && patch.every(function(index2) {
    return index2.hunks.every(function(hunk) {
      return hunk.lines.every(function(line, i) {
        var _hunk$lines2;
        return line.startsWith("\\") || line.endsWith("\r") || ((_hunk$lines2 = hunk.lines[i + 1]) === null || _hunk$lines2 === void 0 ? void 0 : _hunk$lines2.startsWith("\\"));
      });
    });
  });
}
__name(isWin, "isWin");
function parsePatch(uniDiff) {
  var diffstr = uniDiff.split(/\n/), list = [], i = 0;
  function parseIndex() {
    var index2 = {};
    list.push(index2);
    while (i < diffstr.length) {
      var line = diffstr[i];
      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
        break;
      }
      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
      if (header) {
        index2.index = header[1];
      }
      i++;
    }
    parseFileHeader(index2);
    parseFileHeader(index2);
    index2.hunks = [];
    while (i < diffstr.length) {
      var _line = diffstr[i];
      if (/^(Index:\s|diff\s|\-\-\-\s|\+\+\+\s|===================================================================)/.test(_line)) {
        break;
      } else if (/^@@/.test(_line)) {
        index2.hunks.push(parseHunk());
      } else if (_line) {
        throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(_line));
      } else {
        i++;
      }
    }
  }
  __name(parseIndex, "parseIndex");
  function parseFileHeader(index2) {
    var fileHeader = /^(---|\+\+\+)\s+(.*)\r?$/.exec(diffstr[i]);
    if (fileHeader) {
      var keyPrefix = fileHeader[1] === "---" ? "old" : "new";
      var data = fileHeader[2].split("	", 2);
      var fileName = data[0].replace(/\\\\/g, "\\");
      if (/^".*"$/.test(fileName)) {
        fileName = fileName.substr(1, fileName.length - 2);
      }
      index2[keyPrefix + "FileName"] = fileName;
      index2[keyPrefix + "Header"] = (data[1] || "").trim();
      i++;
    }
  }
  __name(parseFileHeader, "parseFileHeader");
  function parseHunk() {
    var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
    var hunk = {
      oldStart: +chunkHeader[1],
      oldLines: typeof chunkHeader[2] === "undefined" ? 1 : +chunkHeader[2],
      newStart: +chunkHeader[3],
      newLines: typeof chunkHeader[4] === "undefined" ? 1 : +chunkHeader[4],
      lines: []
    };
    if (hunk.oldLines === 0) {
      hunk.oldStart += 1;
    }
    if (hunk.newLines === 0) {
      hunk.newStart += 1;
    }
    var addCount = 0, removeCount = 0;
    for (; i < diffstr.length && (removeCount < hunk.oldLines || addCount < hunk.newLines || (_diffstr$i = diffstr[i]) !== null && _diffstr$i !== void 0 && _diffstr$i.startsWith("\\")); i++) {
      var _diffstr$i;
      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
      if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
        hunk.lines.push(diffstr[i]);
        if (operation === "+") {
          addCount++;
        } else if (operation === "-") {
          removeCount++;
        } else if (operation === " ") {
          addCount++;
          removeCount++;
        }
      } else {
        throw new Error("Hunk at line ".concat(chunkHeaderIndex + 1, " contained invalid line ").concat(diffstr[i]));
      }
    }
    if (!addCount && hunk.newLines === 1) {
      hunk.newLines = 0;
    }
    if (!removeCount && hunk.oldLines === 1) {
      hunk.oldLines = 0;
    }
    if (addCount !== hunk.newLines) {
      throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
    }
    if (removeCount !== hunk.oldLines) {
      throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
    }
    return hunk;
  }
  __name(parseHunk, "parseHunk");
  while (i < diffstr.length) {
    parseIndex();
  }
  return list;
}
__name(parsePatch, "parsePatch");
function distanceIterator(start, minLine, maxLine) {
  var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
  return /* @__PURE__ */ __name(function iterator() {
    if (wantForward && !forwardExhausted) {
      if (backwardExhausted) {
        localOffset++;
      } else {
        wantForward = false;
      }
      if (start + localOffset <= maxLine) {
        return start + localOffset;
      }
      forwardExhausted = true;
    }
    if (!backwardExhausted) {
      if (!forwardExhausted) {
        wantForward = true;
      }
      if (minLine <= start - localOffset) {
        return start - localOffset++;
      }
      backwardExhausted = true;
      return iterator();
    }
  }, "iterator");
}
__name(distanceIterator, "distanceIterator");
function applyPatch(source7, uniDiff) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof uniDiff === "string") {
    uniDiff = parsePatch(uniDiff);
  }
  if (Array.isArray(uniDiff)) {
    if (uniDiff.length > 1) {
      throw new Error("applyPatch only works with a single input.");
    }
    uniDiff = uniDiff[0];
  }
  if (options2.autoConvertLineEndings || options2.autoConvertLineEndings == null) {
    if (hasOnlyWinLineEndings(source7) && isUnix(uniDiff)) {
      uniDiff = unixToWin(uniDiff);
    } else if (hasOnlyUnixLineEndings(source7) && isWin(uniDiff)) {
      uniDiff = winToUnix(uniDiff);
    }
  }
  var lines = source7.split("\n"), hunks = uniDiff.hunks, compareLine = options2.compareLine || function(lineNumber, line2, operation, patchContent) {
    return line2 === patchContent;
  }, fuzzFactor = options2.fuzzFactor || 0, minLine = 0;
  if (fuzzFactor < 0 || !Number.isInteger(fuzzFactor)) {
    throw new Error("fuzzFactor must be a non-negative integer");
  }
  if (!hunks.length) {
    return source7;
  }
  var prevLine = "", removeEOFNL = false, addEOFNL = false;
  for (var i = 0; i < hunks[hunks.length - 1].lines.length; i++) {
    var line = hunks[hunks.length - 1].lines[i];
    if (line[0] == "\\") {
      if (prevLine[0] == "+") {
        removeEOFNL = true;
      } else if (prevLine[0] == "-") {
        addEOFNL = true;
      }
    }
    prevLine = line;
  }
  if (removeEOFNL) {
    if (addEOFNL) {
      if (!fuzzFactor && lines[lines.length - 1] == "") {
        return false;
      }
    } else if (lines[lines.length - 1] == "") {
      lines.pop();
    } else if (!fuzzFactor) {
      return false;
    }
  } else if (addEOFNL) {
    if (lines[lines.length - 1] != "") {
      lines.push("");
    } else if (!fuzzFactor) {
      return false;
    }
  }
  function applyHunk(hunkLines, toPos2, maxErrors2) {
    var hunkLinesI = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    var lastContextLineMatched = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var patchedLines = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
    var patchedLinesLength = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;
    var nConsecutiveOldContextLines = 0;
    var nextContextLineMustMatch = false;
    for (; hunkLinesI < hunkLines.length; hunkLinesI++) {
      var hunkLine = hunkLines[hunkLinesI], operation = hunkLine.length > 0 ? hunkLine[0] : " ", content = hunkLine.length > 0 ? hunkLine.substr(1) : hunkLine;
      if (operation === "-") {
        if (compareLine(toPos2 + 1, lines[toPos2], operation, content)) {
          toPos2++;
          nConsecutiveOldContextLines = 0;
        } else {
          if (!maxErrors2 || lines[toPos2] == null) {
            return null;
          }
          patchedLines[patchedLinesLength] = lines[toPos2];
          return applyHunk(hunkLines, toPos2 + 1, maxErrors2 - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1);
        }
      }
      if (operation === "+") {
        if (!lastContextLineMatched) {
          return null;
        }
        patchedLines[patchedLinesLength] = content;
        patchedLinesLength++;
        nConsecutiveOldContextLines = 0;
        nextContextLineMustMatch = true;
      }
      if (operation === " ") {
        nConsecutiveOldContextLines++;
        patchedLines[patchedLinesLength] = lines[toPos2];
        if (compareLine(toPos2 + 1, lines[toPos2], operation, content)) {
          patchedLinesLength++;
          lastContextLineMatched = true;
          nextContextLineMustMatch = false;
          toPos2++;
        } else {
          if (nextContextLineMustMatch || !maxErrors2) {
            return null;
          }
          return lines[toPos2] && (applyHunk(hunkLines, toPos2 + 1, maxErrors2 - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength + 1) || applyHunk(hunkLines, toPos2 + 1, maxErrors2 - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1)) || applyHunk(hunkLines, toPos2, maxErrors2 - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength);
        }
      }
    }
    patchedLinesLength -= nConsecutiveOldContextLines;
    toPos2 -= nConsecutiveOldContextLines;
    patchedLines.length = patchedLinesLength;
    return {
      patchedLines,
      oldLineLastI: toPos2 - 1
    };
  }
  __name(applyHunk, "applyHunk");
  var resultLines = [];
  var prevHunkOffset = 0;
  for (var _i = 0; _i < hunks.length; _i++) {
    var hunk = hunks[_i];
    var hunkResult = void 0;
    var maxLine = lines.length - hunk.oldLines + fuzzFactor;
    var toPos = void 0;
    for (var maxErrors = 0; maxErrors <= fuzzFactor; maxErrors++) {
      toPos = hunk.oldStart + prevHunkOffset - 1;
      var iterator = distanceIterator(toPos, minLine, maxLine);
      for (; toPos !== void 0; toPos = iterator()) {
        hunkResult = applyHunk(hunk.lines, toPos, maxErrors);
        if (hunkResult) {
          break;
        }
      }
      if (hunkResult) {
        break;
      }
    }
    if (!hunkResult) {
      return false;
    }
    for (var _i2 = minLine; _i2 < toPos; _i2++) {
      resultLines.push(lines[_i2]);
    }
    for (var _i3 = 0; _i3 < hunkResult.patchedLines.length; _i3++) {
      var _line = hunkResult.patchedLines[_i3];
      resultLines.push(_line);
    }
    minLine = hunkResult.oldLineLastI + 1;
    prevHunkOffset = toPos + 1 - hunk.oldStart;
  }
  for (var _i4 = minLine; _i4 < lines.length; _i4++) {
    resultLines.push(lines[_i4]);
  }
  return resultLines.join("\n");
}
__name(applyPatch, "applyPatch");
function applyPatches(uniDiff, options2) {
  if (typeof uniDiff === "string") {
    uniDiff = parsePatch(uniDiff);
  }
  var currentIndex = 0;
  function processIndex() {
    var index2 = uniDiff[currentIndex++];
    if (!index2) {
      return options2.complete();
    }
    options2.loadFile(index2, function(err, data) {
      if (err) {
        return options2.complete(err);
      }
      var updatedContent = applyPatch(data, index2, options2);
      options2.patched(index2, updatedContent, function(err2) {
        if (err2) {
          return options2.complete(err2);
        }
        processIndex();
      });
    });
  }
  __name(processIndex, "processIndex");
  processIndex();
}
__name(applyPatches, "applyPatches");
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options2) {
  if (!options2) {
    options2 = {};
  }
  if (typeof options2 === "function") {
    options2 = {
      callback: options2
    };
  }
  if (typeof options2.context === "undefined") {
    options2.context = 4;
  }
  if (options2.newlineIsToken) {
    throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");
  }
  if (!options2.callback) {
    return diffLinesResultToPatch(diffLines(oldStr, newStr, options2));
  } else {
    var _options = options2, _callback = _options.callback;
    diffLines(oldStr, newStr, _objectSpread2(_objectSpread2({}, options2), {}, {
      callback: /* @__PURE__ */ __name(function callback(diff32) {
        var patch = diffLinesResultToPatch(diff32);
        _callback(patch);
      }, "callback")
    }));
  }
  function diffLinesResultToPatch(diff32) {
    if (!diff32) {
      return;
    }
    diff32.push({
      value: "",
      lines: []
    });
    function contextLines(lines) {
      return lines.map(function(entry) {
        return " " + entry;
      });
    }
    __name(contextLines, "contextLines");
    var hunks = [];
    var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
    var _loop = /* @__PURE__ */ __name(function _loop2() {
      var current = diff32[i], lines = current.lines || splitLines$1(current.value);
      current.lines = lines;
      if (current.added || current.removed) {
        var _curRange;
        if (!oldRangeStart) {
          var prev = diff32[i - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;
          if (prev) {
            curRange = options2.context > 0 ? contextLines(prev.lines.slice(-options2.context)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        }
        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
          return (current.added ? "+" : "-") + entry;
        })));
        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        if (oldRangeStart) {
          if (lines.length <= options2.context * 2 && i < diff32.length - 2) {
            var _curRange2;
            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
          } else {
            var _curRange3;
            var contextSize = Math.min(lines.length, options2.context);
            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
            var _hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            hunks.push(_hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }
        oldLine += lines.length;
        newLine += lines.length;
      }
    }, "_loop2");
    for (var i = 0; i < diff32.length; i++) {
      _loop();
    }
    for (var _i = 0, _hunks = hunks; _i < _hunks.length; _i++) {
      var hunk = _hunks[_i];
      for (var _i2 = 0; _i2 < hunk.lines.length; _i2++) {
        if (hunk.lines[_i2].endsWith("\n")) {
          hunk.lines[_i2] = hunk.lines[_i2].slice(0, -1);
        } else {
          hunk.lines.splice(_i2 + 1, 0, "\\ No newline at end of file");
          _i2++;
        }
      }
    }
    return {
      oldFileName,
      newFileName,
      oldHeader,
      newHeader,
      hunks
    };
  }
  __name(diffLinesResultToPatch, "diffLinesResultToPatch");
}
__name(structuredPatch, "structuredPatch");
function formatPatch(diff32) {
  if (Array.isArray(diff32)) {
    return diff32.map(formatPatch).join("\n");
  }
  var ret = [];
  if (diff32.oldFileName == diff32.newFileName) {
    ret.push("Index: " + diff32.oldFileName);
  }
  ret.push("===================================================================");
  ret.push("--- " + diff32.oldFileName + (typeof diff32.oldHeader === "undefined" ? "" : "	" + diff32.oldHeader));
  ret.push("+++ " + diff32.newFileName + (typeof diff32.newHeader === "undefined" ? "" : "	" + diff32.newHeader));
  for (var i = 0; i < diff32.hunks.length; i++) {
    var hunk = diff32.hunks[i];
    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }
    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }
    ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
    ret.push.apply(ret, hunk.lines);
  }
  return ret.join("\n") + "\n";
}
__name(formatPatch, "formatPatch");
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options2) {
  var _options2;
  if (typeof options2 === "function") {
    options2 = {
      callback: options2
    };
  }
  if (!((_options2 = options2) !== null && _options2 !== void 0 && _options2.callback)) {
    var patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options2);
    if (!patchObj) {
      return;
    }
    return formatPatch(patchObj);
  } else {
    var _options3 = options2, _callback2 = _options3.callback;
    structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, _objectSpread2(_objectSpread2({}, options2), {}, {
      callback: /* @__PURE__ */ __name(function callback(patchObj2) {
        if (!patchObj2) {
          _callback2();
        } else {
          _callback2(formatPatch(patchObj2));
        }
      }, "callback")
    }));
  }
}
__name(createTwoFilesPatch, "createTwoFilesPatch");
function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options2) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options2);
}
__name(createPatch, "createPatch");
function splitLines$1(text) {
  var hasTrailingNl = text.endsWith("\n");
  var result = text.split("\n").map(function(line) {
    return line + "\n";
  });
  if (hasTrailingNl) {
    result.pop();
  } else {
    result.push(result.pop().slice(0, -1));
  }
  return result;
}
__name(splitLines$1, "splitLines$1");
function arrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  return arrayStartsWith(a, b);
}
__name(arrayEqual, "arrayEqual");
function arrayStartsWith(array, start) {
  if (start.length > array.length) {
    return false;
  }
  for (var i = 0; i < start.length; i++) {
    if (start[i] !== array[i]) {
      return false;
    }
  }
  return true;
}
__name(arrayStartsWith, "arrayStartsWith");
function calcLineCount(hunk) {
  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
  if (oldLines !== void 0) {
    hunk.oldLines = oldLines;
  } else {
    delete hunk.oldLines;
  }
  if (newLines !== void 0) {
    hunk.newLines = newLines;
  } else {
    delete hunk.newLines;
  }
}
__name(calcLineCount, "calcLineCount");
function merge$1(mine, theirs, base) {
  mine = loadPatch(mine, base);
  theirs = loadPatch(theirs, base);
  var ret = {};
  if (mine.index || theirs.index) {
    ret.index = mine.index || theirs.index;
  }
  if (mine.newFileName || theirs.newFileName) {
    if (!fileNameChanged(mine)) {
      ret.oldFileName = theirs.oldFileName || mine.oldFileName;
      ret.newFileName = theirs.newFileName || mine.newFileName;
      ret.oldHeader = theirs.oldHeader || mine.oldHeader;
      ret.newHeader = theirs.newHeader || mine.newHeader;
    } else if (!fileNameChanged(theirs)) {
      ret.oldFileName = mine.oldFileName;
      ret.newFileName = mine.newFileName;
      ret.oldHeader = mine.oldHeader;
      ret.newHeader = mine.newHeader;
    } else {
      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
    }
  }
  ret.hunks = [];
  var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
    var mineCurrent = mine.hunks[mineIndex] || {
      oldStart: Infinity
    }, theirsCurrent = theirs.hunks[theirsIndex] || {
      oldStart: Infinity
    };
    if (hunkBefore(mineCurrent, theirsCurrent)) {
      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
      mineIndex++;
      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
    } else if (hunkBefore(theirsCurrent, mineCurrent)) {
      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
      theirsIndex++;
      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
    } else {
      var mergedHunk = {
        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
        oldLines: 0,
        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
        newLines: 0,
        lines: []
      };
      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
      theirsIndex++;
      mineIndex++;
      ret.hunks.push(mergedHunk);
    }
  }
  return ret;
}
__name(merge$1, "merge$1");
function loadPatch(param, base) {
  if (typeof param === "string") {
    if (/^@@/m.test(param) || /^Index:/m.test(param)) {
      return parsePatch(param)[0];
    }
    if (!base) {
      throw new Error("Must provide a base reference or pass in a patch");
    }
    return structuredPatch(void 0, void 0, base, param);
  }
  return param;
}
__name(loadPatch, "loadPatch");
function fileNameChanged(patch) {
  return patch.newFileName && patch.newFileName !== patch.oldFileName;
}
__name(fileNameChanged, "fileNameChanged");
function selectField(index2, mine, theirs) {
  if (mine === theirs) {
    return mine;
  } else {
    index2.conflict = true;
    return {
      mine,
      theirs
    };
  }
}
__name(selectField, "selectField");
function hunkBefore(test, check) {
  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
}
__name(hunkBefore, "hunkBefore");
function cloneHunk(hunk, offset) {
  return {
    oldStart: hunk.oldStart,
    oldLines: hunk.oldLines,
    newStart: hunk.newStart + offset,
    newLines: hunk.newLines,
    lines: hunk.lines
  };
}
__name(cloneHunk, "cloneHunk");
function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
  var mine = {
    offset: mineOffset,
    lines: mineLines,
    index: 0
  }, their = {
    offset: theirOffset,
    lines: theirLines,
    index: 0
  };
  insertLeading(hunk, mine, their);
  insertLeading(hunk, their, mine);
  while (mine.index < mine.lines.length && their.index < their.lines.length) {
    var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
    if ((mineCurrent[0] === "-" || mineCurrent[0] === "+") && (theirCurrent[0] === "-" || theirCurrent[0] === "+")) {
      mutualChange(hunk, mine, their);
    } else if (mineCurrent[0] === "+" && theirCurrent[0] === " ") {
      var _hunk$lines;
      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
    } else if (theirCurrent[0] === "+" && mineCurrent[0] === " ") {
      var _hunk$lines2;
      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
    } else if (mineCurrent[0] === "-" && theirCurrent[0] === " ") {
      removal(hunk, mine, their);
    } else if (theirCurrent[0] === "-" && mineCurrent[0] === " ") {
      removal(hunk, their, mine, true);
    } else if (mineCurrent === theirCurrent) {
      hunk.lines.push(mineCurrent);
      mine.index++;
      their.index++;
    } else {
      conflict(hunk, collectChange(mine), collectChange(their));
    }
  }
  insertTrailing(hunk, mine);
  insertTrailing(hunk, their);
  calcLineCount(hunk);
}
__name(mergeLines, "mergeLines");
function mutualChange(hunk, mine, their) {
  var myChanges = collectChange(mine), theirChanges = collectChange(their);
  if (allRemoves(myChanges) && allRemoves(theirChanges)) {
    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
      var _hunk$lines3;
      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));
      return;
    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
      var _hunk$lines4;
      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));
      return;
    }
  } else if (arrayEqual(myChanges, theirChanges)) {
    var _hunk$lines5;
    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));
    return;
  }
  conflict(hunk, myChanges, theirChanges);
}
__name(mutualChange, "mutualChange");
function removal(hunk, mine, their, swap) {
  var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
  if (theirChanges.merged) {
    var _hunk$lines6;
    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
  } else {
    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
  }
}
__name(removal, "removal");
function conflict(hunk, mine, their) {
  hunk.conflict = true;
  hunk.lines.push({
    conflict: true,
    mine,
    theirs: their
  });
}
__name(conflict, "conflict");
function insertLeading(hunk, insert, their) {
  while (insert.offset < their.offset && insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
    insert.offset++;
  }
}
__name(insertLeading, "insertLeading");
function insertTrailing(hunk, insert) {
  while (insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
  }
}
__name(insertTrailing, "insertTrailing");
function collectChange(state) {
  var ret = [], operation = state.lines[state.index][0];
  while (state.index < state.lines.length) {
    var line = state.lines[state.index];
    if (operation === "-" && line[0] === "+") {
      operation = "+";
    }
    if (operation === line[0]) {
      ret.push(line);
      state.index++;
    } else {
      break;
    }
  }
  return ret;
}
__name(collectChange, "collectChange");
function collectContext(state, matchChanges) {
  var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
  while (matchIndex < matchChanges.length && state.index < state.lines.length) {
    var change = state.lines[state.index], match = matchChanges[matchIndex];
    if (match[0] === "+") {
      break;
    }
    contextChanges = contextChanges || change[0] !== " ";
    merged.push(match);
    matchIndex++;
    if (change[0] === "+") {
      conflicted = true;
      while (change[0] === "+") {
        changes.push(change);
        change = state.lines[++state.index];
      }
    }
    if (match.substr(1) === change.substr(1)) {
      changes.push(change);
      state.index++;
    } else {
      conflicted = true;
    }
  }
  if ((matchChanges[matchIndex] || "")[0] === "+" && contextChanges) {
    conflicted = true;
  }
  if (conflicted) {
    return changes;
  }
  while (matchIndex < matchChanges.length) {
    merged.push(matchChanges[matchIndex++]);
  }
  return {
    merged,
    changes
  };
}
__name(collectContext, "collectContext");
function allRemoves(changes) {
  return changes.reduce(function(prev, change) {
    return prev && change[0] === "-";
  }, true);
}
__name(allRemoves, "allRemoves");
function skipRemoveSuperset(state, removeChanges, delta) {
  for (var i = 0; i < delta; i++) {
    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
    if (state.lines[state.index + i] !== " " + changeContent) {
      return false;
    }
  }
  state.index += delta;
  return true;
}
__name(skipRemoveSuperset, "skipRemoveSuperset");
function calcOldNewLineCount(lines) {
  var oldLines = 0;
  var newLines = 0;
  lines.forEach(function(line) {
    if (typeof line !== "string") {
      var myCount = calcOldNewLineCount(line.mine);
      var theirCount = calcOldNewLineCount(line.theirs);
      if (oldLines !== void 0) {
        if (myCount.oldLines === theirCount.oldLines) {
          oldLines += myCount.oldLines;
        } else {
          oldLines = void 0;
        }
      }
      if (newLines !== void 0) {
        if (myCount.newLines === theirCount.newLines) {
          newLines += myCount.newLines;
        } else {
          newLines = void 0;
        }
      }
    } else {
      if (newLines !== void 0 && (line[0] === "+" || line[0] === " ")) {
        newLines++;
      }
      if (oldLines !== void 0 && (line[0] === "-" || line[0] === " ")) {
        oldLines++;
      }
    }
  });
  return {
    oldLines,
    newLines
  };
}
__name(calcOldNewLineCount, "calcOldNewLineCount");
function reversePatch(structuredPatch2) {
  if (Array.isArray(structuredPatch2)) {
    return structuredPatch2.map(reversePatch).reverse();
  }
  return _objectSpread2(_objectSpread2({}, structuredPatch2), {}, {
    oldFileName: structuredPatch2.newFileName,
    oldHeader: structuredPatch2.newHeader,
    newFileName: structuredPatch2.oldFileName,
    newHeader: structuredPatch2.oldHeader,
    hunks: structuredPatch2.hunks.map(function(hunk) {
      return {
        oldLines: hunk.newLines,
        oldStart: hunk.newStart,
        newLines: hunk.oldLines,
        newStart: hunk.oldStart,
        lines: hunk.lines.map(function(l) {
          if (l.startsWith("-")) {
            return "+".concat(l.slice(1));
          }
          if (l.startsWith("+")) {
            return "-".concat(l.slice(1));
          }
          return l;
        })
      };
    })
  });
}
__name(reversePatch, "reversePatch");
function convertChangesToDMP(changes) {
  var ret = [], change, operation;
  for (var i = 0; i < changes.length; i++) {
    change = changes[i];
    if (change.added) {
      operation = 1;
    } else if (change.removed) {
      operation = -1;
    } else {
      operation = 0;
    }
    ret.push([operation, change.value]);
  }
  return ret;
}
__name(convertChangesToDMP, "convertChangesToDMP");
function convertChangesToXML(changes) {
  var ret = [];
  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];
    if (change.added) {
      ret.push("<ins>");
    } else if (change.removed) {
      ret.push("<del>");
    }
    ret.push(escapeHTML(change.value));
    if (change.added) {
      ret.push("</ins>");
    } else if (change.removed) {
      ret.push("</del>");
    }
  }
  return ret.join("");
}
__name(convertChangesToXML, "convertChangesToXML");
function escapeHTML(s) {
  var n = s;
  n = n.replace(/&/g, "&amp;");
  n = n.replace(/</g, "&lt;");
  n = n.replace(/>/g, "&gt;");
  n = n.replace(/"/g, "&quot;");
  return n;
}
__name(escapeHTML, "escapeHTML");
var diffLibrary = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Diff,
  applyPatch,
  applyPatches,
  canonicalize,
  convertChangesToDMP,
  convertChangesToXML,
  createPatch,
  createTwoFilesPatch,
  diffArrays,
  diffChars,
  diffCss,
  diffJson,
  diffLines,
  diffSentences,
  diffTrimmedLines,
  diffWords,
  diffWordsWithSpace,
  formatPatch,
  merge: merge$1,
  parsePatch,
  reversePatch,
  structuredPatch
}, Symbol.toStringTag, { value: "Module" }));
var main = { exports: {} };
var version3 = "16.4.5";
var require$$4 = {
  version: version3
};
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main.exports;
  hasRequiredMain = 1;
  const fs$1 = fs;
  const path$1 = path2;
  const os$1 = os_default;
  const crypto$1 = crypto_default;
  const packageJson = require$$4;
  const version22 = packageJson.version;
  const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse2(src2) {
    const obj = {};
    let lines = src2.toString();
    lines = lines.replace(/\r\n?/mg, "\n");
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, "\n");
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  __name(parse2, "parse2");
  function _parseVault(options2) {
    const vaultPath = _vaultPath(options2);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options2).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0; i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error22) {
        if (i + 1 >= length) {
          throw error22;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  __name(_parseVault, "_parseVault");
  function _log(message) {
    console.log(`[dotenv@${version22}][INFO] ${message}`);
  }
  __name(_log, "_log");
  function _warn(message) {
    console.log(`[dotenv@${version22}][WARN] ${message}`);
  }
  __name(_warn, "_warn");
  function _debug(message) {
    console.log(`[dotenv@${version22}][DEBUG] ${message}`);
  }
  __name(_debug, "_debug");
  function _dotenvKey(options2) {
    if (options2 && options2.DOTENV_KEY && options2.DOTENV_KEY.length > 0) {
      return options2.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  __name(_dotenvKey, "_dotenvKey");
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error22) {
      if (error22.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error22;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  __name(_instructions, "_instructions");
  function _vaultPath(options2) {
    let possibleVaultPath = null;
    if (options2 && options2.path && options2.path.length > 0) {
      if (Array.isArray(options2.path)) {
        for (const filepath of options2.path) {
          if (fs$1.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options2.path.endsWith(".vault") ? options2.path : `${options2.path}.vault`;
      }
    } else {
      possibleVaultPath = path$1.resolve(process.cwd(), ".env.vault");
    }
    if (fs$1.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  __name(_vaultPath, "_vaultPath");
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path$1.join(os$1.homedir(), envPath.slice(1)) : envPath;
  }
  __name(_resolveHome, "_resolveHome");
  function _configVault(options2) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options2);
    let processEnv = process.env;
    if (options2 && options2.processEnv != null) {
      processEnv = options2.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options2);
    return { parsed };
  }
  __name(_configVault, "_configVault");
  function configDotenv(options2) {
    const dotenvPath = path$1.resolve(process.cwd(), ".env");
    let encoding2 = "utf8";
    const debug22 = Boolean(options2 && options2.debug);
    if (options2 && options2.encoding) {
      encoding2 = options2.encoding;
    } else {
      if (debug22) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options2 && options2.path) {
      if (!Array.isArray(options2.path)) {
        optionPaths = [_resolveHome(options2.path)];
      } else {
        optionPaths = [];
        for (const filepath of options2.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path210 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs$1.readFileSync(path210, { encoding: encoding2 }));
        DotenvModule.populate(parsedAll, parsed, options2);
      } catch (e) {
        if (debug22) {
          _debug(`Failed to load ${path210} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options2 && options2.processEnv != null) {
      processEnv = options2.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options2);
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  __name(configDotenv, "configDotenv");
  function config2(options2) {
    if (_dotenvKey(options2).length === 0) {
      return DotenvModule.configDotenv(options2);
    }
    const vaultPath = _vaultPath(options2);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options2);
    }
    return DotenvModule._configVault(options2);
  }
  __name(config2, "config");
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto$1.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error22) {
      const isRange = error22 instanceof RangeError;
      const invalidKeyLength = error22.message === "Invalid key length";
      const decryptionFailed = error22.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error22;
      }
    }
  }
  __name(decrypt, "decrypt");
  function populate(processEnv, parsed, options2 = {}) {
    const debug22 = Boolean(options2 && options2.debug);
    const override = Boolean(options2 && options2.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug22) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  }
  __name(populate, "populate");
  const DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config: config2,
    decrypt,
    parse: parse2,
    populate
  };
  main.exports.configDotenv = DotenvModule.configDotenv;
  main.exports._configVault = DotenvModule._configVault;
  main.exports._parseVault = DotenvModule._parseVault;
  main.exports.config = DotenvModule.config;
  main.exports.decrypt = DotenvModule.decrypt;
  main.exports.parse = DotenvModule.parse;
  main.exports.populate = DotenvModule.populate;
  main.exports = DotenvModule;
  return main.exports;
}
__name(requireMain, "requireMain");
var mainExports = requireMain();
var dotenvLibrary = /* @__PURE__ */ getDefaultExportFromCjs(mainExports);
var proxyFromEnv = {};
var hasRequiredProxyFromEnv;
function requireProxyFromEnv() {
  if (hasRequiredProxyFromEnv) return proxyFromEnv;
  hasRequiredProxyFromEnv = 1;
  var parseUrl = url.parse;
  var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
  };
  function getProxyForUrl22(url4) {
    var parsedUrl = typeof url4 === "string" ? parseUrl(url4) : url4 || {};
    var proto = parsedUrl.protocol;
    var hostname2 = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname2 !== "string" || !hostname2 || typeof proto !== "string") {
      return "";
    }
    proto = proto.split(":", 1)[0];
    hostname2 = hostname2.replace(/:\d*$/, "");
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname2, port)) {
      return "";
    }
    var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
    if (proxy && proxy.indexOf("://") === -1) {
      proxy = proto + "://" + proxy;
    }
    return proxy;
  }
  __name(getProxyForUrl22, "getProxyForUrl2");
  function shouldProxy(hostname2, port) {
    var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
    if (!NO_PROXY) {
      return true;
    }
    if (NO_PROXY === "*") {
      return false;
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
      if (!proxy) {
        return true;
      }
      var parsedProxy = proxy.match(/^(.+):(\d+)$/);
      var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
      var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
      if (parsedProxyPort && parsedProxyPort !== port) {
        return true;
      }
      if (!/^[.*]/.test(parsedProxyHostname)) {
        return hostname2 !== parsedProxyHostname;
      }
      if (parsedProxyHostname.charAt(0) === "*") {
        parsedProxyHostname = parsedProxyHostname.slice(1);
      }
      return !stringEndsWith.call(hostname2, parsedProxyHostname);
    });
  }
  __name(shouldProxy, "shouldProxy");
  function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
  }
  __name(getEnv, "getEnv");
  proxyFromEnv.getProxyForUrl = getProxyForUrl22;
  return proxyFromEnv;
}
__name(requireProxyFromEnv, "requireProxyFromEnv");
var proxyFromEnvExports = requireProxyFromEnv();
var agent$1 = {};
var promisify2 = {};
var hasRequiredPromisify;
function requirePromisify() {
  if (hasRequiredPromisify) return promisify2;
  hasRequiredPromisify = 1;
  Object.defineProperty(promisify2, "__esModule", { value: true });
  function promisify$1(fn) {
    return function(req, opts) {
      return new Promise((resolve, reject) => {
        fn.call(this, req, opts, (err, rtn) => {
          if (err) {
            reject(err);
          } else {
            resolve(rtn);
          }
        });
      });
    };
  }
  __name(promisify$1, "promisify$1");
  promisify2.default = promisify$1;
  return promisify2;
}
__name(requirePromisify, "requirePromisify");
var src;
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src;
  hasRequiredSrc = 1;
  var __importDefault2 = src && src.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  const events_1 = require$$0$32;
  const debug_1 = __importDefault2(requireBrowser$1());
  const promisify_1 = __importDefault2(requirePromisify());
  const debug22 = debug_1.default("agent-base");
  function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === "function";
  }
  __name(isAgent, "isAgent");
  function isSecureEndpoint() {
    const { stack } = new Error();
    if (typeof stack !== "string")
      return false;
    return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
  }
  __name(isSecureEndpoint, "isSecureEndpoint");
  function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
  }
  __name(createAgent, "createAgent");
  (function(createAgent2) {
    class Agent3 extends events_1.EventEmitter {
      static {
        __name(this, "Agent");
      }
      constructor(callback, _opts) {
        super();
        let opts = _opts;
        if (typeof callback === "function") {
          this.callback = callback;
        } else if (callback) {
          opts = callback;
        }
        this.timeout = null;
        if (opts && typeof opts.timeout === "number") {
          this.timeout = opts.timeout;
        }
        this.maxFreeSockets = 1;
        this.maxSockets = 1;
        this.maxTotalSockets = Infinity;
        this.sockets = {};
        this.freeSockets = {};
        this.requests = {};
        this.options = {};
      }
      get defaultPort() {
        if (typeof this.explicitDefaultPort === "number") {
          return this.explicitDefaultPort;
        }
        return isSecureEndpoint() ? 443 : 80;
      }
      set defaultPort(v) {
        this.explicitDefaultPort = v;
      }
      get protocol() {
        if (typeof this.explicitProtocol === "string") {
          return this.explicitProtocol;
        }
        return isSecureEndpoint() ? "https:" : "http:";
      }
      set protocol(v) {
        this.explicitProtocol = v;
      }
      callback(req, opts, fn) {
        throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
      }
      /**
       * Called by node-core's "_http_client.js" module when creating
       * a new HTTP request with this Agent instance.
       *
       * @api public
       */
      addRequest(req, _opts) {
        const opts = Object.assign({}, _opts);
        if (typeof opts.secureEndpoint !== "boolean") {
          opts.secureEndpoint = isSecureEndpoint();
        }
        if (opts.host == null) {
          opts.host = "localhost";
        }
        if (opts.port == null) {
          opts.port = opts.secureEndpoint ? 443 : 80;
        }
        if (opts.protocol == null) {
          opts.protocol = opts.secureEndpoint ? "https:" : "http:";
        }
        if (opts.host && opts.path) {
          delete opts.path;
        }
        delete opts.agent;
        delete opts.hostname;
        delete opts._defaultAgent;
        delete opts.defaultPort;
        delete opts.createConnection;
        req._last = true;
        req.shouldKeepAlive = false;
        let timedOut = false;
        let timeoutId = null;
        const timeoutMs = opts.timeout || this.timeout;
        const onerror = /* @__PURE__ */ __name((err) => {
          if (req._hadError)
            return;
          req.emit("error", err);
          req._hadError = true;
        }, "onerror");
        const ontimeout = /* @__PURE__ */ __name(() => {
          timeoutId = null;
          timedOut = true;
          const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
          err.code = "ETIMEOUT";
          onerror(err);
        }, "ontimeout");
        const callbackError = /* @__PURE__ */ __name((err) => {
          if (timedOut)
            return;
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          onerror(err);
        }, "callbackError");
        const onsocket = /* @__PURE__ */ __name((socket) => {
          if (timedOut)
            return;
          if (timeoutId != null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          if (isAgent(socket)) {
            debug22("Callback returned another Agent instance %o", socket.constructor.name);
            socket.addRequest(req, opts);
            return;
          }
          if (socket) {
            socket.once("free", () => {
              this.freeSocket(socket, opts);
            });
            req.onSocket(socket);
            return;
          }
          const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
          onerror(err);
        }, "onsocket");
        if (typeof this.callback !== "function") {
          onerror(new Error("`callback` is not defined"));
          return;
        }
        if (!this.promisifiedCallback) {
          if (this.callback.length >= 3) {
            debug22("Converting legacy callback function to promise");
            this.promisifiedCallback = promisify_1.default(this.callback);
          } else {
            this.promisifiedCallback = this.callback;
          }
        }
        if (typeof timeoutMs === "number" && timeoutMs > 0) {
          timeoutId = setTimeout(ontimeout, timeoutMs);
        }
        if ("port" in opts && typeof opts.port !== "number") {
          opts.port = Number(opts.port);
        }
        try {
          debug22("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
          Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
        } catch (err) {
          Promise.reject(err).catch(callbackError);
        }
      }
      freeSocket(socket, opts) {
        debug22("Freeing socket %o %o", socket.constructor.name, opts);
        socket.destroy();
      }
      destroy() {
        debug22("Destroying agent %o", this.constructor.name);
      }
    }
    createAgent2.Agent = Agent3;
    createAgent2.prototype = createAgent2.Agent.prototype;
  })(createAgent || (createAgent = {}));
  src = createAgent;
  return src;
}
__name(requireSrc, "requireSrc");
var parseProxyResponse = {};
var hasRequiredParseProxyResponse;
function requireParseProxyResponse() {
  if (hasRequiredParseProxyResponse) return parseProxyResponse;
  hasRequiredParseProxyResponse = 1;
  var __importDefault2 = parseProxyResponse && parseProxyResponse.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(parseProxyResponse, "__esModule", { value: true });
  const debug_1 = __importDefault2(requireBrowser$1());
  const debug22 = debug_1.default("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse$1(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read2() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read2);
      }
      __name(read2, "read");
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("close", onclose);
        socket.removeListener("readable", read2);
      }
      __name(cleanup, "cleanup");
      function onclose(err) {
        debug22("onclose had error %o", err);
      }
      __name(onclose, "onclose");
      function onend() {
        debug22("onend");
      }
      __name(onend, "onend");
      function onerror(err) {
        cleanup();
        debug22("onerror %o", err);
        reject(err);
      }
      __name(onerror, "onerror");
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf("\r\n\r\n");
        if (endOfHeaders === -1) {
          debug22("have not received end of HTTP headers yet...");
          read2();
          return;
        }
        const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
        const statusCode = +firstLine.split(" ")[1];
        debug22("got proxy server response: %o", firstLine);
        resolve({
          statusCode,
          buffered
        });
      }
      __name(ondata, "ondata");
      socket.on("error", onerror);
      socket.on("close", onclose);
      socket.on("end", onend);
      read2();
    });
  }
  __name(parseProxyResponse$1, "parseProxyResponse$1");
  parseProxyResponse.default = parseProxyResponse$1;
  return parseProxyResponse;
}
__name(requireParseProxyResponse, "requireParseProxyResponse");
var hasRequiredAgent$1;
function requireAgent$1() {
  if (hasRequiredAgent$1) return agent$1;
  hasRequiredAgent$1 = 1;
  var __awaiter2 = agent$1 && agent$1.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    __name(adopt, "adopt");
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step");
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = agent$1 && agent$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(agent$1, "__esModule", { value: true });
  const net_1 = __importDefault2(net);
  const tls_1 = __importDefault2(tls_default);
  const url_1 = __importDefault2(url);
  const assert_1 = __importDefault2(require$$53);
  const debug_1 = __importDefault2(requireBrowser$1());
  const agent_base_1 = requireSrc();
  const parse_proxy_response_1 = __importDefault2(requireParseProxyResponse());
  const debug22 = debug_1.default("https-proxy-agent:agent");
  class HttpsProxyAgent22 extends agent_base_1.Agent {
    static {
      __name(this, "HttpsProxyAgent2");
    }
    constructor(_opts) {
      let opts;
      if (typeof _opts === "string") {
        opts = url_1.default.parse(_opts);
      } else {
        opts = _opts;
      }
      if (!opts) {
        throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      }
      debug22("creating new HttpsProxyAgent instance: %o", opts);
      super(opts);
      const proxy = Object.assign({}, opts);
      this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
      proxy.host = proxy.hostname || proxy.host;
      if (typeof proxy.port === "string") {
        proxy.port = parseInt(proxy.port, 10);
      }
      if (!proxy.port && proxy.host) {
        proxy.port = this.secureProxy ? 443 : 80;
      }
      if (this.secureProxy && !("ALPNProtocols" in proxy)) {
        proxy.ALPNProtocols = ["http 1.1"];
      }
      if (proxy.host && proxy.path) {
        delete proxy.path;
        delete proxy.pathname;
      }
      this.proxy = proxy;
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     *
     * @api protected
     */
    callback(req, opts) {
      return __awaiter2(this, void 0, void 0, function* () {
        const { proxy, secureProxy } = this;
        let socket;
        if (secureProxy) {
          debug22("Creating `tls.Socket`: %o", proxy);
          socket = tls_1.default.connect(proxy);
        } else {
          debug22("Creating `net.Socket`: %o", proxy);
          socket = net_1.default.connect(proxy);
        }
        const headers = Object.assign({}, proxy.headers);
        const hostname2 = `${opts.host}:${opts.port}`;
        let payload = `CONNECT ${hostname2} HTTP/1.1\r
`;
        if (proxy.auth) {
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
        }
        let { host, port, secureEndpoint } = opts;
        if (!isDefaultPort(port, secureEndpoint)) {
          host += `:${port}`;
        }
        headers.Host = host;
        headers.Connection = "close";
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = parse_proxy_response_1.default(socket);
        socket.write(`${payload}\r
`);
        const { statusCode, buffered } = yield proxyResponsePromise;
        if (statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            debug22("Upgrading socket connection to TLS");
            const servername = opts.servername || opts.host;
            return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
              socket,
              servername
            }));
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net_1.default.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug22("replaying proxy buffer for failed request");
          assert_1.default(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      });
    }
  }
  agent$1.default = HttpsProxyAgent22;
  function resume(socket) {
    socket.resume();
  }
  __name(resume, "resume");
  function isDefaultPort(port, secure) {
    return Boolean(!secure && port === 80 || secure && port === 443);
  }
  __name(isDefaultPort, "isDefaultPort");
  function isHTTPS(protocol) {
    return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
  }
  __name(isHTTPS, "isHTTPS");
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
  __name(omit, "omit");
  return agent$1;
}
__name(requireAgent$1, "requireAgent$1");
var dist$1;
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$1;
  hasRequiredDist$1 = 1;
  var __importDefault2 = dist$1 && dist$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  const agent_1 = __importDefault2(requireAgent$1());
  function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
  }
  __name(createHttpsProxyAgent, "createHttpsProxyAgent");
  (function(createHttpsProxyAgent2) {
    createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent2.prototype = agent_1.default.prototype;
  })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
  dist$1 = createHttpsProxyAgent;
  return dist$1;
}
__name(requireDist$1, "requireDist$1");
var distExports$1 = requireDist$1();
var encoder = { exports: {} };
var hasRequiredEncoder;
function requireEncoder() {
  if (hasRequiredEncoder) return encoder.exports;
  hasRequiredEncoder = 1;
  (function(module) {
    function JPEGEncoder(quality) {
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i = 0; i < 64; i++) {
          var t = ffloor((YQT[i] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      __name(initQuantTables, "initQuantTables");
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      __name(computeHuffmanTbl, "computeHuffmanTbl");
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      __name(initHuffmanTbl, "initHuffmanTbl");
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      __name(initCategoryNumber, "initCategoryNumber");
      function initRGBYUVTable() {
        for (var i = 0; i < 256; i++) {
          RGB_YUV_TABLE[i] = 19595 * i;
          RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
          RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
          RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
          RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
          RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
          RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
          RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
        }
      }
      __name(initRGBYUVTable, "initRGBYUVTable");
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      __name(writeBits, "writeBits");
      function writeByte(value) {
        byteout.push(value);
      }
      __name(writeByte, "writeByte");
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      __name(writeWord, "writeWord");
      function fDCTQuant(data, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i;
        var I8 = 8;
        var I64 = 64;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 1];
          d2 = data[dataOff + 2];
          d3 = data[dataOff + 3];
          d4 = data[dataOff + 4];
          d5 = data[dataOff + 5];
          d6 = data[dataOff + 6];
          d7 = data[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data[dataOff] = tmp10 + tmp11;
          data[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data[dataOff + 2] = tmp13 + z1;
          data[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data[dataOff + 5] = z13 + z2;
          data[dataOff + 3] = z13 - z2;
          data[dataOff + 1] = z11 + z4;
          data[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 8];
          d2 = data[dataOff + 16];
          d3 = data[dataOff + 24];
          d4 = data[dataOff + 32];
          d5 = data[dataOff + 40];
          d6 = data[dataOff + 48];
          d7 = data[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data[dataOff] = tmp10p2 + tmp11p2;
          data[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data[dataOff + 16] = tmp13p2 + z1p2;
          data[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data[dataOff + 40] = z13p2 + z2p2;
          data[dataOff + 24] = z13p2 - z2p2;
          data[dataOff + 8] = z11p2 + z4p2;
          data[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i = 0; i < I64; ++i) {
          fDCTQuant2 = data[i] * fdtbl[i];
          outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      __name(fDCTQuant, "fDCTQuant");
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      __name(writeAPP0, "writeAPP0");
      function writeAPP1(exifBuffer) {
        if (!exifBuffer) return;
        writeWord(65505);
        if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
          writeWord(exifBuffer.length + 2);
        } else {
          writeWord(exifBuffer.length + 5 + 2);
          writeByte(69);
          writeByte(120);
          writeByte(105);
          writeByte(102);
          writeByte(0);
        }
        for (var i = 0; i < exifBuffer.length; i++) {
          writeByte(exifBuffer[i]);
        }
      }
      __name(writeAPP1, "writeAPP1");
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      __name(writeSOF0, "writeSOF0");
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i = 0; i < 64; i++) {
          writeByte(YTable[i]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      __name(writeDQT, "writeDQT");
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i = 0; i < 16; i++) {
          writeByte(std_dc_luminance_nrcodes[i + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      __name(writeDHT, "writeDHT");
      function writeCOM(comments) {
        if (typeof comments === "undefined" || comments.constructor !== Array) return;
        comments.forEach((e) => {
          if (typeof e !== "string") return;
          writeWord(65534);
          var l = e.length;
          writeWord(l + 2);
          var i;
          for (i = 0; i < l; i++)
            writeByte(e.charCodeAt(i));
        });
      }
      __name(writeCOM, "writeCOM");
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      __name(writeSOS, "writeSOS");
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff2 = DU[0] - DC;
        DC = DU[0];
        if (Diff2 == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff2;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i = 1;
        var lng;
        while (i <= end0pos) {
          var startpos = i;
          for (; DU[i] == 0 && i <= end0pos; ++i) {
          }
          var nrzeroes = i - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      __name(processDU, "processDU");
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i = 0; i < 256; i++) {
          clt[i] = sfcc(i);
        }
      }
      __name(initCharLookupTable, "initCharLookupTable");
      this.encode = function(image, quality2) {
        (/* @__PURE__ */ new Date()).getTime();
        if (quality2) setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeCOM(image.comments);
        writeAPP1(image.exifBuffer);
        writeDQT();
        writeSOF0(image.width, image.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image.data;
        var width = image.width;
        var height = image.height;
        var quadWidth = width * 4;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        return Buffer.from(byteout);
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2) return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      __name(setQuality, "setQuality");
      function init() {
        var time_start = (/* @__PURE__ */ new Date()).getTime();
        if (!quality) quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        (/* @__PURE__ */ new Date()).getTime() - time_start;
      }
      __name(init, "init");
      init();
    }
    __name(JPEGEncoder, "JPEGEncoder");
    {
      module.exports = encode;
    }
    function encode(imgData, qu) {
      if (typeof qu === "undefined") qu = 50;
      var encoder2 = new JPEGEncoder(qu);
      var data = encoder2.encode(imgData, qu);
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    }
    __name(encode, "encode");
  })(encoder);
  return encoder.exports;
}
__name(requireEncoder, "requireEncoder");
var decoder = { exports: {} };
var hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder) return decoder.exports;
  hasRequiredDecoder = 1;
  (function(module) {
    var JpegImage = (/* @__PURE__ */ __name(function jpegImage() {
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      __name(constructor, "constructor");
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p = code[0], q;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q = { children: [], index: 0 });
              p.children[p.index] = q.children;
              p = q;
            }
            k++;
          }
          if (i + 1 < length) {
            code.push(q = { children: [], index: 0 });
            p.children[p.index] = q.children;
            p = q;
          }
        }
        return code[0].children;
      }
      __name(buildHuffmanTable, "buildHuffmanTable");
      function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
        frame.precision;
        frame.samplesPerLine;
        frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        frame.maxH;
        frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 255) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        __name(readBit, "readBit");
        function decodeHuffman(tree) {
          var node2 = tree, bit;
          while ((bit = readBit()) !== null) {
            node2 = node2[bit];
            if (typeof node2 === "number")
              return node2;
            if (typeof node2 !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        __name(decodeHuffman, "decodeHuffman");
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null) return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        __name(receive, "receive");
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        __name(receiveAndExtend, "receiveAndExtend");
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff32 = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff32;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s);
            k2++;
          }
        }
        __name(decodeBaseline, "decodeBaseline");
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff32 = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff32;
        }
        __name(decodeDCFirst, "decodeDCFirst");
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        __name(decodeDCSuccessive, "decodeDCSuccessive");
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s) * (1 << successive);
            k2++;
          }
        }
        __name(decodeACFirst, "decodeACFirst");
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            var direction = zz[z] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              // skipping r zero items
              case 2:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        __name(decodeACSuccessive, "decodeACSuccessive");
        function decodeMcu(component2, decode2, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        __name(decodeMcu, "decodeMcu");
        function decodeBlock(component2, decode2, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        __name(decodeBlock, "decodeBlock");
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval) resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected) break;
            }
          }
          if (mcu === mcuExpected) {
            do {
              if (data[offset] === 255) {
                if (data[offset + 1] !== 0) {
                  break;
                }
              }
              offset += 1;
            } while (offset < data.length - 2);
          }
          bitsCount = 0;
          marker = data[offset] << 8 | data[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      __name(decodeScan, "decodeScan");
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i2;
          for (i2 = 0; i2 < 64; i2++)
            p[i2] = zz[i2] * qt[i2];
          for (i2 = 0; i2 < 8; ++i2) {
            var row = 8 * i2;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            var col = i2;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i2 = 0; i2 < 64; ++i2) {
            var sample2 = 128 + (p[i2] + 8 >> 4);
            dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        __name(quantizeAndInverse, "quantizeAndInverse");
        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
      __name(buildComponentData, "buildComponentData");
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      __name(clampTo8bit, "clampTo8bit");
      constructor.prototype = {
        load: /* @__PURE__ */ __name(function load(path31) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path31, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        }, "load"),
        parse: /* @__PURE__ */ __name(function parse2(data) {
          var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
          var offset = 0;
          data.length;
          function readUint16() {
            var value = data[offset] << 8 | data[offset + 1];
            offset += 2;
            return value;
          }
          __name(readUint16, "readUint16");
          function readDataBlock() {
            var length = readUint16();
            var array = data.subarray(offset, offset + length - 2);
            offset += array.length;
            return array;
          }
          __name(readDataBlock, "readDataBlock");
          function prepareComponents(frame2) {
            var maxH = 1, maxV = 1;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH < component2.h) maxH = component2.h;
                if (maxV < component2.v) maxV = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                var blocks = [];
                requestMemoryAllocation(blocksToAllocate * 256);
                for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH;
            frame2.maxV = maxV;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          __name(prepareComponents, "prepareComponents");
          var jfif = null;
          var adobe = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          var malformedDataOffset = -1;
          this.comments = [];
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i, j;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              // APP0 (Application Specific)
              case 65505:
              // APP1
              case 65506:
              // APP2
              case 65507:
              // APP3
              case 65508:
              // APP4
              case 65509:
              // APP5
              case 65510:
              // APP6
              case 65511:
              // APP7
              case 65512:
              // APP8
              case 65513:
              // APP9
              case 65514:
              // APP10
              case 65515:
              // APP11
              case 65516:
              // APP12
              case 65517:
              // APP13
              case 65518:
              // APP14
              case 65519:
              // APP15
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65534) {
                  var comment2 = String.fromCharCode.apply(null, appData);
                  this.comments.push(comment2);
                }
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65505) {
                  if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                    this.exifBuffer = appData.subarray(5, appData.length);
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  requestMemoryAllocation(64 * 4);
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              // SOF0 (Start of Frame, Baseline DCT)
              case 65473:
              // SOF1 (Start of Frame, Extended DCT)
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                if (pixelsInFrame > maxResolutionInPixels) {
                  var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                }
                var componentsCount = data[offset++], componentId;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data[offset];
                  var h = data[offset + 1] >> 4;
                  var v = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  if (h <= 0 || v <= 0) {
                    throw new Error("Invalid sampling factor, expected values above 0");
                  }
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength; ) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++) {
                    codeLengthSum += codeLengths[j] = data[offset];
                  }
                  requestMemoryAllocation(16 + codeLengthSum);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data[offset];
                  i += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65500:
                readUint16();
                readUint16();
                break;
              case 65498:
                readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(
                  data,
                  offset,
                  frame,
                  components,
                  resetInterval,
                  spectralStart,
                  spectralEnd,
                  successiveApproximation >> 4,
                  successiveApproximation & 15,
                  this.opts
                );
                offset += processed;
                break;
              case 65535:
                if (data[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                } else if (fileMarker === 224 || fileMarker == 225) {
                  if (malformedDataOffset !== -1) {
                    throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                  }
                  malformedDataOffset = offset - 1;
                  const nextOffset = readUint16();
                  if (data[offset + nextOffset - 2] === 255) {
                    offset += nextOffset - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i = 0; i < frames.length; i++) {
            var cp2 = frames[i].components;
            for (var j in cp2) {
              cp2[j].quantizationTable = quantizationTables[cp2[j].quantizationIdx];
              delete cp2[j].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        }, "parse2"),
        getData: /* @__PURE__ */ __name(function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          requestMemoryAllocation(dataLength);
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = R;
                  data[offset++] = G;
                  data[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = 255 - C;
                  data[offset++] = 255 - M;
                  data[offset++] = 255 - Ye;
                  data[offset++] = 255 - K;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data;
        }, "getData"),
        copyToImageData: /* @__PURE__ */ __name(function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data[i++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data[i++];
                  G = data[i++];
                  B = data[i++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data[i++];
                  M = data[i++];
                  Y = data[i++];
                  K = data[i++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }, "copyToImageData")
      };
      var totalBytesAllocated = 0;
      var maxMemoryUsageBytes = 0;
      function requestMemoryAllocation(increaseAmount = 0) {
        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
          var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
        }
        totalBytesAllocated = totalMemoryImpactBytes;
      }
      __name(requestMemoryAllocation, "requestMemoryAllocation");
      constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
        totalBytesAllocated = 0;
        maxMemoryUsageBytes = maxMemoryUsageBytes_;
      };
      constructor.getBytesAllocated = function() {
        return totalBytesAllocated;
      };
      constructor.requestMemoryAllocation = requestMemoryAllocation;
      return constructor;
    }, "jpegImage"))();
    {
      module.exports = decode;
    }
    function decode(jpegData, userOpts = {}) {
      var defaultOpts = {
        // "undefined" means "Choose whether to transform colors based on the images color model."
        colorTransform: void 0,
        useTArray: false,
        formatAsRGBA: true,
        tolerantDecoding: true,
        maxResolutionInMP: 100,
        // Don't decode more than 100 megapixels
        maxMemoryUsageInMB: 512
        // Don't decode if memory footprint is more than 512MB
      };
      var opts = { ...defaultOpts, ...userOpts };
      var arr = new Uint8Array(jpegData);
      var decoder2 = new JpegImage();
      decoder2.opts = opts;
      JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
      decoder2.parse(arr);
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder2.width * decoder2.height * channels;
      try {
        JpegImage.requestMemoryAllocation(bytesNeeded);
        var image = {
          width: decoder2.width,
          height: decoder2.height,
          exifBuffer: decoder2.exifBuffer,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
        };
        if (decoder2.comments.length > 0) {
          image["comments"] = decoder2.comments;
        }
      } catch (err) {
        if (err instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        }
        if (err instanceof ReferenceError) {
          if (err.message === "Buffer is not defined") {
            throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
          }
        }
        throw err;
      }
      decoder2.copyToImageData(image, opts.formatAsRGBA);
      return image;
    }
    __name(decode, "decode");
  })(decoder);
  return decoder.exports;
}
__name(requireDecoder, "requireDecoder");
var jpegJs;
var hasRequiredJpegJs;
function requireJpegJs() {
  if (hasRequiredJpegJs) return jpegJs;
  hasRequiredJpegJs = 1;
  var encode = requireEncoder(), decode = requireDecoder();
  jpegJs = {
    encode,
    decode
  };
  return jpegJs;
}
__name(requireJpegJs, "requireJpegJs");
var jpegJsExports = requireJpegJs();
var jpegLibrary = /* @__PURE__ */ getDefaultExportFromCjs(jpegJsExports);
var Mime_1;
var hasRequiredMime$1;
function requireMime$1() {
  if (hasRequiredMime$1) return Mime_1;
  hasRequiredMime$1 = 1;
  function Mime() {
    this._types = /* @__PURE__ */ Object.create(null);
    this._extensions = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < arguments.length; i++) {
      this.define(arguments[i]);
    }
    this.define = this.define.bind(this);
    this.getType = this.getType.bind(this);
    this.getExtension = this.getExtension.bind(this);
  }
  __name(Mime, "Mime");
  Mime.prototype.define = function(typeMap, force) {
    for (let type2 in typeMap) {
      let extensions = typeMap[type2].map(function(t) {
        return t.toLowerCase();
      });
      type2 = type2.toLowerCase();
      for (let i = 0; i < extensions.length; i++) {
        const ext = extensions[i];
        if (ext[0] === "*") {
          continue;
        }
        if (!force && ext in this._types) {
          throw new Error(
            'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type2 + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type2 + '".'
          );
        }
        this._types[ext] = type2;
      }
      if (force || !this._extensions[type2]) {
        const ext = extensions[0];
        this._extensions[type2] = ext[0] !== "*" ? ext : ext.substr(1);
      }
    }
  };
  Mime.prototype.getType = function(path31) {
    path31 = String(path31);
    let last = path31.replace(/^.*[/\\]/, "").toLowerCase();
    let ext = last.replace(/^.*\./, "").toLowerCase();
    let hasPath = last.length < path31.length;
    let hasDot = ext.length < last.length - 1;
    return (hasDot || !hasPath) && this._types[ext] || null;
  };
  Mime.prototype.getExtension = function(type2) {
    type2 = /^\s*([^;\s]*)/.test(type2) && RegExp.$1;
    return type2 && this._extensions[type2.toLowerCase()] || null;
  };
  Mime_1 = Mime;
  return Mime_1;
}
__name(requireMime$1, "requireMime$1");
var standard;
var hasRequiredStandard;
function requireStandard() {
  if (hasRequiredStandard) return standard;
  hasRequiredStandard = 1;
  standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  return standard;
}
__name(requireStandard, "requireStandard");
var other;
var hasRequiredOther;
function requireOther() {
  if (hasRequiredOther) return other;
  hasRequiredOther = 1;
  other = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  return other;
}
__name(requireOther, "requireOther");
var mime$1;
var hasRequiredMime;
function requireMime() {
  if (hasRequiredMime) return mime$1;
  hasRequiredMime = 1;
  let Mime = requireMime$1();
  mime$1 = new Mime(requireStandard(), requireOther());
  return mime$1;
}
__name(requireMime, "requireMime");
var mimeExports = requireMime();
var mimeLibrary = /* @__PURE__ */ getDefaultExportFromCjs(mimeExports);
var concatMap;
var hasRequiredConcatMap;
function requireConcatMap() {
  if (hasRequiredConcatMap) return concatMap;
  hasRequiredConcatMap = 1;
  concatMap = /* @__PURE__ */ __name(function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray2(x)) res.push.apply(res, x);
      else res.push(x);
    }
    return res;
  }, "concatMap");
  var isArray2 = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
  return concatMap;
}
__name(requireConcatMap, "requireConcatMap");
var balancedMatch;
var hasRequiredBalancedMatch;
function requireBalancedMatch() {
  if (hasRequiredBalancedMatch) return balancedMatch;
  hasRequiredBalancedMatch = 1;
  balancedMatch = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp) a = maybeMatch(a, str);
    if (b instanceof RegExp) b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  __name(balanced, "balanced");
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  __name(maybeMatch, "maybeMatch");
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
  __name(range, "range");
  return balancedMatch;
}
__name(requireBalancedMatch, "requireBalancedMatch");
var braceExpansion;
var hasRequiredBraceExpansion;
function requireBraceExpansion() {
  if (hasRequiredBraceExpansion) return braceExpansion;
  hasRequiredBraceExpansion = 1;
  var concatMap2 = requireConcatMap();
  var balanced = requireBalancedMatch();
  braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  __name(numeric, "numeric");
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  __name(escapeBraces, "escapeBraces");
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  __name(unescapeBraces, "unescapeBraces");
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  __name(parseCommaParts, "parseCommaParts");
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  __name(expandTop, "expandTop");
  function embrace(str) {
    return "{" + str + "}";
  }
  __name(embrace, "embrace");
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  __name(isPadded, "isPadded");
  function lte(i, y) {
    return i <= y;
  }
  __name(lte, "lte");
  function gte(i, y) {
    return i >= y;
  }
  __name(gte, "gte");
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre)) return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap2(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
  __name(expand, "expand");
  return braceExpansion;
}
__name(requireBraceExpansion, "requireBraceExpansion");
var minimatch_1;
var hasRequiredMinimatch;
function requireMinimatch() {
  if (hasRequiredMinimatch) return minimatch_1;
  hasRequiredMinimatch = 1;
  minimatch_1 = minimatch22;
  minimatch22.Minimatch = Minimatch;
  var path31 = function() {
    try {
      return require_path();
    } catch (e) {
    }
  }() || {
    sep: "/"
  };
  minimatch22.sep = path31.sep;
  var GLOBSTAR = minimatch22.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = requireBraceExpansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set2, c) {
      set2[c] = true;
      return set2;
    }, {});
  }
  __name(charSet, "charSet");
  var slashSplit = /\/+/;
  minimatch22.filter = filter;
  function filter(pattern, options2) {
    options2 = options2 || {};
    return function(p, i, list) {
      return minimatch22(p, pattern, options2);
    };
  }
  __name(filter, "filter");
  function ext(a, b) {
    b = b || {};
    var t = {};
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    return t;
  }
  __name(ext, "ext");
  minimatch22.defaults = function(def) {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch22;
    }
    var orig = minimatch22;
    var m = /* @__PURE__ */ __name(function minimatch3(p, pattern, options2) {
      return orig(p, pattern, ext(def, options2));
    }, "minimatch3");
    m.Minimatch = /* @__PURE__ */ __name(function Minimatch2(pattern, options2) {
      return new orig.Minimatch(pattern, ext(def, options2));
    }, "Minimatch2");
    m.Minimatch.defaults = /* @__PURE__ */ __name(function defaults(options2) {
      return orig.defaults(ext(def, options2)).Minimatch;
    }, "defaults");
    m.filter = /* @__PURE__ */ __name(function filter2(pattern, options2) {
      return orig.filter(pattern, ext(def, options2));
    }, "filter2");
    m.defaults = /* @__PURE__ */ __name(function defaults(options2) {
      return orig.defaults(ext(def, options2));
    }, "defaults");
    m.makeRe = /* @__PURE__ */ __name(function makeRe2(pattern, options2) {
      return orig.makeRe(pattern, ext(def, options2));
    }, "makeRe2");
    m.braceExpand = /* @__PURE__ */ __name(function braceExpand2(pattern, options2) {
      return orig.braceExpand(pattern, ext(def, options2));
    }, "braceExpand2");
    m.match = function(list, pattern, options2) {
      return orig.match(list, pattern, ext(def, options2));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    return minimatch22.defaults(def).Minimatch;
  };
  function minimatch22(p, pattern, options2) {
    assertValidPattern(pattern);
    if (!options2) options2 = {};
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options2).match(p);
  }
  __name(minimatch22, "minimatch2");
  function Minimatch(pattern, options2) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options2);
    }
    assertValidPattern(pattern);
    if (!options2) options2 = {};
    pattern = pattern.trim();
    if (!options2.allowWindowsEscape && path31.sep !== "/") {
      pattern = pattern.split(path31.sep).join("/");
    }
    this.options = options2;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options2.partial;
    this.make();
  }
  __name(Minimatch, "Minimatch");
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    var pattern = this.pattern;
    var options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set2 = this.globSet = this.braceExpand();
    if (options2.debug) this.debug = /* @__PURE__ */ __name(function debug22() {
      console.error.apply(console, arguments);
    }, "debug2");
    this.debug(this.pattern, set2);
    set2 = this.globParts = set2.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set2);
    set2 = set2.map(function(s, si, set3) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set2);
    set2 = set2.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set2);
    this.set = set2;
  }
  __name(make, "make");
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options2 = this.options;
    var negateOffset = 0;
    if (options2.nonegate) return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset) this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  __name(parseNegate, "parseNegate");
  minimatch22.braceExpand = function(pattern, options2) {
    return braceExpand(pattern, options2);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options2) {
    if (!options2) {
      if (this instanceof Minimatch) {
        options2 = this.options;
      } else {
        options2 = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    assertValidPattern(pattern);
    if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  }
  __name(braceExpand, "braceExpand");
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = /* @__PURE__ */ __name(function(pattern) {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  }, "assertValidPattern");
  Minimatch.prototype.parse = parse2;
  var SUBPARSE = {};
  function parse2(pattern, isSub) {
    assertValidPattern(pattern);
    var options2 = this.options;
    if (pattern === "**") {
      if (!options2.noglobstar)
        return GLOBSTAR;
      else
        pattern = "*";
    }
    if (pattern === "") return "";
    var re2 = "";
    var hasMagic = !!options2.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re2 += star;
            hasMagic = true;
            break;
          case "?":
            re2 += qmark;
            hasMagic = true;
            break;
          default:
            re2 += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re2);
        stateChar = false;
      }
    }
    __name(clearStateChar, "clearStateChar");
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re2, c);
      if (escaping && reSpecials[c]) {
        re2 += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        /* istanbul ignore next */
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        // the various stateChar values
        // for the "extglob" stuff.
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re2, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1) c = "^";
            re2 += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options2.noext) clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re2 += "(";
            continue;
          }
          if (!stateChar) {
            re2 += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re2.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re2 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re2);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re2 += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re2 += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re2.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re2 += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re2 += "|";
          continue;
        // these are mostly the same in regexp and glob
        case "[":
          clearStateChar();
          if (inClass) {
            re2 += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re2.length;
          re2 += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re2 += "\\" + c;
            escaping = false;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp("[" + cs + "]");
          } catch (er) {
            var sp = this.parse(cs, SUBPARSE);
            re2 = re2.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
          hasMagic = true;
          inClass = false;
          re2 += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re2 += "\\";
          }
          re2 += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re2 = re2.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re2.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re2, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re2);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re2 = re2.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re2 += "\\\\";
    }
    var addPatternStart = false;
    switch (re2.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re2.slice(0, nl.reStart);
      var nlFirst = re2.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re2.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re2.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re2 = newRe;
    }
    if (re2 !== "" && hasMagic) {
      re2 = "(?=.)" + re2;
    }
    if (addPatternStart) {
      re2 = patternStart + re2;
    }
    if (isSub === SUBPARSE) {
      return [re2, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options2.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re2 + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re2;
    return regExp;
  }
  __name(parse2, "parse2");
  minimatch22.makeRe = function(pattern, options2) {
    return new Minimatch(pattern, options2 || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false) return this.regexp;
    var set2 = this.set;
    if (!set2.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options2 = this.options;
    var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
    var flags = options2.nocase ? "i" : "";
    var re2 = set2.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re2 = "^(?:" + re2 + ")$";
    if (this.negate) re2 = "^(?!" + re2 + ").*$";
    try {
      this.regexp = new RegExp(re2, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  __name(makeRe, "makeRe");
  minimatch22.match = function(list, pattern, options2) {
    options2 = options2 || {};
    var mm = new Minimatch(pattern, options2);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = /* @__PURE__ */ __name(function match(f, partial) {
    if (typeof partial === "undefined") partial = this.partial;
    this.debug("match", f, this.pattern);
    if (this.comment) return false;
    if (this.empty) return f === "";
    if (f === "/" && partial) return true;
    var options2 = this.options;
    if (path31.sep !== "/") {
      f = f.split(path31.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set2 = this.set;
    this.debug(this.pattern, "set", set2);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename) break;
    }
    for (i = 0; i < set2.length; i++) {
      var pattern = set2[i];
      var file = f;
      if (options2.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options2.flipNegate) return true;
        return !this.negate;
      }
    }
    if (options2.flipNegate) return false;
    return this.negate;
  }, "match");
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options2 = this.options;
    this.debug(
      "matchOne",
      { "this": this, file, pattern }
    );
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".") return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit) return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  __name(globUnescape, "globUnescape");
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  __name(regExpEscape, "regExpEscape");
  return minimatch_1;
}
__name(requireMinimatch, "requireMinimatch");
var minimatchExports = requireMinimatch();
var minimatchLibrary = /* @__PURE__ */ getDefaultExportFromCjs(minimatchExports);
var isWsl = { exports: {} };
var isDocker_1;
var hasRequiredIsDocker;
function requireIsDocker() {
  if (hasRequiredIsDocker) return isDocker_1;
  hasRequiredIsDocker = 1;
  const fs$1 = fs;
  let isDocker;
  function hasDockerEnv() {
    try {
      fs$1.statSync("/.dockerenv");
      return true;
    } catch (_) {
      return false;
    }
  }
  __name(hasDockerEnv, "hasDockerEnv");
  function hasDockerCGroup() {
    try {
      return fs$1.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
    } catch (_) {
      return false;
    }
  }
  __name(hasDockerCGroup, "hasDockerCGroup");
  isDocker_1 = /* @__PURE__ */ __name(() => {
    if (isDocker === void 0) {
      isDocker = hasDockerEnv() || hasDockerCGroup();
    }
    return isDocker;
  }, "isDocker_1");
  return isDocker_1;
}
__name(requireIsDocker, "requireIsDocker");
var hasRequiredIsWsl;
function requireIsWsl() {
  if (hasRequiredIsWsl) return isWsl.exports;
  hasRequiredIsWsl = 1;
  const os$1 = os_default;
  const fs$1 = fs;
  const isDocker = requireIsDocker();
  const isWsl$1 = /* @__PURE__ */ __name(() => {
    if (process.platform !== "linux") {
      return false;
    }
    if (os$1.release().toLowerCase().includes("microsoft")) {
      if (isDocker()) {
        return false;
      }
      return true;
    }
    try {
      return fs$1.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
    } catch (_) {
      return false;
    }
  }, "isWsl$1");
  if (process.env.__IS_WSL_TEST__) {
    isWsl.exports = isWsl$1;
  } else {
    isWsl.exports = isWsl$1();
  }
  return isWsl.exports;
}
__name(requireIsWsl, "requireIsWsl");
var defineLazyProp;
var hasRequiredDefineLazyProp;
function requireDefineLazyProp() {
  if (hasRequiredDefineLazyProp) return defineLazyProp;
  hasRequiredDefineLazyProp = 1;
  defineLazyProp = /* @__PURE__ */ __name((object, propertyName, fn) => {
    const define = /* @__PURE__ */ __name((value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true }), "define");
    Object.defineProperty(object, propertyName, {
      configurable: true,
      enumerable: true,
      get() {
        const result = fn();
        define(result);
        return result;
      },
      set(value) {
        define(value);
      }
    });
    return object;
  }, "defineLazyProp");
  return defineLazyProp;
}
__name(requireDefineLazyProp, "requireDefineLazyProp");
var open_1;
var hasRequiredOpen;
function requireOpen() {
  if (hasRequiredOpen) return open_1;
  hasRequiredOpen = 1;
  const path$1 = path2;
  const childProcess = child_process_default;
  const { promises: fs$1, constants: fsConstants } = fs;
  const isWsl2 = requireIsWsl();
  const isDocker = requireIsDocker();
  const defineLazyProperty = requireDefineLazyProp();
  const localXdgOpenPath = path$1.join("/home/runner/work/playwright/playwright/packages/playwright-cloudflare", "xdg-open");
  const { platform: platform4, arch: arch3 } = process;
  const getWslDrivesMountPoint = /* @__PURE__ */ (() => {
    const defaultMountPoint = "/mnt/";
    let mountPoint;
    return async function() {
      if (mountPoint) {
        return mountPoint;
      }
      const configFilePath = "/etc/wsl.conf";
      let isConfigFileExists = false;
      try {
        await fs$1.access(configFilePath, fsConstants.F_OK);
        isConfigFileExists = true;
      } catch {
      }
      if (!isConfigFileExists) {
        return defaultMountPoint;
      }
      const configContent = await fs$1.readFile(configFilePath, { encoding: "utf8" });
      const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
      if (!configMountPoint) {
        return defaultMountPoint;
      }
      mountPoint = configMountPoint.groups.mountPoint.trim();
      mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
      return mountPoint;
    };
  })();
  const pTryEach = /* @__PURE__ */ __name(async (array, mapper) => {
    let latestError;
    for (const item of array) {
      try {
        return await mapper(item);
      } catch (error22) {
        latestError = error22;
      }
    }
    throw latestError;
  }, "pTryEach");
  const baseOpen = /* @__PURE__ */ __name(async (options2) => {
    options2 = {
      wait: false,
      background: false,
      newInstance: false,
      allowNonzeroExitCode: false,
      ...options2
    };
    if (Array.isArray(options2.app)) {
      return pTryEach(options2.app, (singleApp) => baseOpen({
        ...options2,
        app: singleApp
      }));
    }
    let { name: app, arguments: appArguments = [] } = options2.app || {};
    appArguments = [...appArguments];
    if (Array.isArray(app)) {
      return pTryEach(app, (appName) => baseOpen({
        ...options2,
        app: {
          name: appName,
          arguments: appArguments
        }
      }));
    }
    let command2;
    const cliArguments = [];
    const childProcessOptions = {};
    if (platform4 === "darwin") {
      command2 = "open";
      if (options2.wait) {
        cliArguments.push("--wait-apps");
      }
      if (options2.background) {
        cliArguments.push("--background");
      }
      if (options2.newInstance) {
        cliArguments.push("--new");
      }
      if (app) {
        cliArguments.push("-a", app);
      }
    } else if (platform4 === "win32" || isWsl2 && !isDocker()) {
      const mountPoint = await getWslDrivesMountPoint();
      command2 = isWsl2 ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
      cliArguments.push(
        "-NoProfile",
        "-NonInteractive",
        "\u2013ExecutionPolicy",
        "Bypass",
        "-EncodedCommand"
      );
      if (!isWsl2) {
        childProcessOptions.windowsVerbatimArguments = true;
      }
      const encodedArguments = ["Start"];
      if (options2.wait) {
        encodedArguments.push("-Wait");
      }
      if (app) {
        encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
        if (options2.target) {
          appArguments.unshift(options2.target);
        }
      } else if (options2.target) {
        encodedArguments.push(`"${options2.target}"`);
      }
      if (appArguments.length > 0) {
        appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
        encodedArguments.push(appArguments.join(","));
      }
      options2.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
    } else {
      if (app) {
        command2 = app;
      } else {
        const isBundled = false;
        let exeLocalXdgOpen = false;
        try {
          await fs$1.access(localXdgOpenPath, fsConstants.X_OK);
          exeLocalXdgOpen = true;
        } catch {
        }
        const useSystemXdgOpen = process.versions.electron || platform4 === "android" || isBundled || !exeLocalXdgOpen;
        command2 = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
      }
      if (appArguments.length > 0) {
        cliArguments.push(...appArguments);
      }
      if (!options2.wait) {
        childProcessOptions.stdio = "ignore";
        childProcessOptions.detached = true;
      }
    }
    if (options2.target) {
      cliArguments.push(options2.target);
    }
    if (platform4 === "darwin" && appArguments.length > 0) {
      cliArguments.push("--args", ...appArguments);
    }
    const subprocess = childProcess.spawn(command2, cliArguments, childProcessOptions);
    if (options2.wait) {
      return new Promise((resolve, reject) => {
        subprocess.once("error", reject);
        subprocess.once("close", (exitCode2) => {
          if (options2.allowNonzeroExitCode && exitCode2 > 0) {
            reject(new Error(`Exited with code ${exitCode2}`));
            return;
          }
          resolve(subprocess);
        });
      });
    }
    subprocess.unref();
    return subprocess;
  }, "baseOpen");
  const open22 = /* @__PURE__ */ __name((target, options2) => {
    if (typeof target !== "string") {
      throw new TypeError("Expected a `target`");
    }
    return baseOpen({
      ...options2,
      target
    });
  }, "open2");
  const openApp = /* @__PURE__ */ __name((name, options2) => {
    if (typeof name !== "string") {
      throw new TypeError("Expected a `name`");
    }
    const { arguments: appArguments = [] } = options2 || {};
    if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
      throw new TypeError("Expected `appArguments` as Array type");
    }
    return baseOpen({
      ...options2,
      app: {
        name,
        arguments: appArguments
      }
    });
  }, "openApp");
  function detectArchBinary(binary2) {
    if (typeof binary2 === "string" || Array.isArray(binary2)) {
      return binary2;
    }
    const { [arch3]: archBinary } = binary2;
    if (!archBinary) {
      throw new Error(`${arch3} is not supported`);
    }
    return archBinary;
  }
  __name(detectArchBinary, "detectArchBinary");
  function detectPlatformBinary({ [platform4]: platformBinary }, { wsl }) {
    if (wsl && isWsl2) {
      return detectArchBinary(wsl);
    }
    if (!platformBinary) {
      throw new Error(`${platform4} is not supported`);
    }
    return detectArchBinary(platformBinary);
  }
  __name(detectPlatformBinary, "detectPlatformBinary");
  const apps = {};
  defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
    darwin: "google chrome",
    win32: "chrome",
    linux: ["google-chrome", "google-chrome-stable", "chromium"]
  }, {
    wsl: {
      ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
      x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
    }
  }));
  defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
    darwin: "firefox",
    win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
    linux: "firefox"
  }, {
    wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
  }));
  defineLazyProperty(apps, "edge", () => detectPlatformBinary({
    darwin: "microsoft edge",
    win32: "msedge",
    linux: ["microsoft-edge", "microsoft-edge-dev"]
  }, {
    wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
  }));
  open22.apps = apps;
  open22.openApp = openApp;
  open_1 = open22;
  return open_1;
}
__name(requireOpen, "requireOpen");
var openExports = requireOpen();
var openLibrary = /* @__PURE__ */ getDefaultExportFromCjs(openExports);
var commander = { exports: {} };
var argument = {};
var error3 = {};
var hasRequiredError;
function requireError() {
  if (hasRequiredError) return error3;
  hasRequiredError = 1;
  class CommanderError extends Error {
    static {
      __name(this, "CommanderError");
    }
    /**
     * Constructs the CommanderError class
     * @param {number} exitCode suggested exit code which could be used with process.exit
     * @param {string} code an id string representing the error
     * @param {string} message human-readable description of the error
     * @constructor
     */
    constructor(exitCode2, code, message) {
      super(message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
      this.code = code;
      this.exitCode = exitCode2;
      this.nestedError = void 0;
    }
  }
  class InvalidArgumentError extends CommanderError {
    static {
      __name(this, "InvalidArgumentError");
    }
    /**
     * Constructs the InvalidArgumentError class
     * @param {string} [message] explanation of why argument is invalid
     * @constructor
     */
    constructor(message) {
      super(1, "commander.invalidArgument", message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
    }
  }
  error3.CommanderError = CommanderError;
  error3.InvalidArgumentError = InvalidArgumentError;
  return error3;
}
__name(requireError, "requireError");
var hasRequiredArgument;
function requireArgument() {
  if (hasRequiredArgument) return argument;
  hasRequiredArgument = 1;
  const { InvalidArgumentError } = requireError();
  class Argument {
    static {
      __name(this, "Argument");
    }
    /**
     * Initialize a new command argument with the given name and description.
     * The default is that the argument is required, and you can explicitly
     * indicate this with <> around the name. Put [] around the name for an optional argument.
     *
     * @param {string} name
     * @param {string} [description]
     */
    constructor(name, description) {
      this.description = description || "";
      this.variadic = false;
      this.parseArg = void 0;
      this.defaultValue = void 0;
      this.defaultValueDescription = void 0;
      this.argChoices = void 0;
      switch (name[0]) {
        case "<":
          this.required = true;
          this._name = name.slice(1, -1);
          break;
        case "[":
          this.required = false;
          this._name = name.slice(1, -1);
          break;
        default:
          this.required = true;
          this._name = name;
          break;
      }
      if (this._name.length > 3 && this._name.slice(-3) === "...") {
        this.variadic = true;
        this._name = this._name.slice(0, -3);
      }
    }
    /**
     * Return argument name.
     *
     * @return {string}
     */
    name() {
      return this._name;
    }
    /**
     * @api private
     */
    _concatValue(value, previous) {
      if (previous === this.defaultValue || !Array.isArray(previous)) {
        return [value];
      }
      return previous.concat(value);
    }
    /**
     * Set the default value, and optionally supply the description to be displayed in the help.
     *
     * @param {any} value
     * @param {string} [description]
     * @return {Argument}
     */
    default(value, description) {
      this.defaultValue = value;
      this.defaultValueDescription = description;
      return this;
    }
    /**
     * Set the custom handler for processing CLI command arguments into argument values.
     *
     * @param {Function} [fn]
     * @return {Argument}
     */
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    /**
     * Only allow option value to be one of choices.
     *
     * @param {string[]} values
     * @return {Argument}
     */
    choices(values) {
      this.argChoices = values;
      this.parseArg = (arg, previous) => {
        if (!values.includes(arg)) {
          throw new InvalidArgumentError(`Allowed choices are ${values.join(", ")}.`);
        }
        if (this.variadic) {
          return this._concatValue(arg, previous);
        }
        return arg;
      };
      return this;
    }
    /**
     * Make option-argument required.
     */
    argRequired() {
      this.required = true;
      return this;
    }
    /**
     * Make option-argument optional.
     */
    argOptional() {
      this.required = false;
      return this;
    }
  }
  function humanReadableArgName(arg) {
    const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
    return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
  }
  __name(humanReadableArgName, "humanReadableArgName");
  argument.Argument = Argument;
  argument.humanReadableArgName = humanReadableArgName;
  return argument;
}
__name(requireArgument, "requireArgument");
var command = {};
var help = {};
var hasRequiredHelp;
function requireHelp() {
  if (hasRequiredHelp) return help;
  hasRequiredHelp = 1;
  const { humanReadableArgName } = requireArgument();
  class Help {
    static {
      __name(this, "Help");
    }
    constructor() {
      this.helpWidth = void 0;
      this.sortSubcommands = false;
      this.sortOptions = false;
    }
    /**
     * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
     *
     * @param {Command} cmd
     * @returns {Command[]}
     */
    visibleCommands(cmd) {
      const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
      if (cmd._hasImplicitHelpCommand()) {
        const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
        const helpCommand = cmd.createCommand(helpName).helpOption(false);
        helpCommand.description(cmd._helpCommandDescription);
        if (helpArgs) helpCommand.arguments(helpArgs);
        visibleCommands.push(helpCommand);
      }
      if (this.sortSubcommands) {
        visibleCommands.sort((a, b) => {
          return a.name().localeCompare(b.name());
        });
      }
      return visibleCommands;
    }
    /**
     * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
     *
     * @param {Command} cmd
     * @returns {Option[]}
     */
    visibleOptions(cmd) {
      const visibleOptions = cmd.options.filter((option2) => !option2.hidden);
      const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
      const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
      if (showShortHelpFlag || showLongHelpFlag) {
        let helpOption;
        if (!showShortHelpFlag) {
          helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
        } else if (!showLongHelpFlag) {
          helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
        } else {
          helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
        }
        visibleOptions.push(helpOption);
      }
      if (this.sortOptions) {
        const getSortKey = /* @__PURE__ */ __name((option2) => {
          return option2.short ? option2.short.replace(/^-/, "") : option2.long.replace(/^--/, "");
        }, "getSortKey");
        visibleOptions.sort((a, b) => {
          return getSortKey(a).localeCompare(getSortKey(b));
        });
      }
      return visibleOptions;
    }
    /**
     * Get an array of the arguments if any have a description.
     *
     * @param {Command} cmd
     * @returns {Argument[]}
     */
    visibleArguments(cmd) {
      if (cmd._argsDescription) {
        cmd._args.forEach((argument2) => {
          argument2.description = argument2.description || cmd._argsDescription[argument2.name()] || "";
        });
      }
      if (cmd._args.find((argument2) => argument2.description)) {
        return cmd._args;
      }
      return [];
    }
    /**
     * Get the command term to show in the list of subcommands.
     *
     * @param {Command} cmd
     * @returns {string}
     */
    subcommandTerm(cmd) {
      const args = cmd._args.map((arg) => humanReadableArgName(arg)).join(" ");
      return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + // simplistic check for non-help option
      (args ? " " + args : "");
    }
    /**
     * Get the option term to show in the list of options.
     *
     * @param {Option} option
     * @returns {string}
     */
    optionTerm(option2) {
      return option2.flags;
    }
    /**
     * Get the argument term to show in the list of arguments.
     *
     * @param {Argument} argument
     * @returns {string}
     */
    argumentTerm(argument2) {
      return argument2.name();
    }
    /**
     * Get the longest command term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    longestSubcommandTermLength(cmd, helper2) {
      return helper2.visibleCommands(cmd).reduce((max, command2) => {
        return Math.max(max, helper2.subcommandTerm(command2).length);
      }, 0);
    }
    /**
     * Get the longest option term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    longestOptionTermLength(cmd, helper2) {
      return helper2.visibleOptions(cmd).reduce((max, option2) => {
        return Math.max(max, helper2.optionTerm(option2).length);
      }, 0);
    }
    /**
     * Get the longest argument term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    longestArgumentTermLength(cmd, helper2) {
      return helper2.visibleArguments(cmd).reduce((max, argument2) => {
        return Math.max(max, helper2.argumentTerm(argument2).length);
      }, 0);
    }
    /**
     * Get the command usage to be displayed at the top of the built-in help.
     *
     * @param {Command} cmd
     * @returns {string}
     */
    commandUsage(cmd) {
      let cmdName = cmd._name;
      if (cmd._aliases[0]) {
        cmdName = cmdName + "|" + cmd._aliases[0];
      }
      let parentCmdNames = "";
      for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
        parentCmdNames = parentCmd.name() + " " + parentCmdNames;
      }
      return parentCmdNames + cmdName + " " + cmd.usage();
    }
    /**
     * Get the description for the command.
     *
     * @param {Command} cmd
     * @returns {string}
     */
    commandDescription(cmd) {
      return cmd.description();
    }
    /**
     * Get the command description to show in the list of subcommands.
     *
     * @param {Command} cmd
     * @returns {string}
     */
    subcommandDescription(cmd) {
      return cmd.description();
    }
    /**
     * Get the option description to show in the list of options.
     *
     * @param {Option} option
     * @return {string}
     */
    optionDescription(option2) {
      const extraInfo = [];
      if (option2.argChoices && !option2.negate) {
        extraInfo.push(
          // use stringify to match the display of the default value
          `choices: ${option2.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
        );
      }
      if (option2.defaultValue !== void 0 && !option2.negate) {
        extraInfo.push(`default: ${option2.defaultValueDescription || JSON.stringify(option2.defaultValue)}`);
      }
      if (option2.envVar !== void 0) {
        extraInfo.push(`env: ${option2.envVar}`);
      }
      if (extraInfo.length > 0) {
        return `${option2.description} (${extraInfo.join(", ")})`;
      }
      return option2.description;
    }
    /**
     * Get the argument description to show in the list of arguments.
     *
     * @param {Argument} argument
     * @return {string}
     */
    argumentDescription(argument2) {
      const extraInfo = [];
      if (argument2.argChoices) {
        extraInfo.push(
          // use stringify to match the display of the default value
          `choices: ${argument2.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
        );
      }
      if (argument2.defaultValue !== void 0) {
        extraInfo.push(`default: ${argument2.defaultValueDescription || JSON.stringify(argument2.defaultValue)}`);
      }
      if (extraInfo.length > 0) {
        const extraDescripton = `(${extraInfo.join(", ")})`;
        if (argument2.description) {
          return `${argument2.description} ${extraDescripton}`;
        }
        return extraDescripton;
      }
      return argument2.description;
    }
    /**
     * Generate the built-in help text.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {string}
     */
    formatHelp(cmd, helper2) {
      const termWidth = helper2.padWidth(cmd, helper2);
      const helpWidth = helper2.helpWidth || 80;
      const itemIndentWidth = 2;
      const itemSeparatorWidth = 2;
      function formatItem(term, description) {
        if (description) {
          const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
          return helper2.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
        }
        return term;
      }
      __name(formatItem, "formatItem");
      function formatList(textArray) {
        return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
      }
      __name(formatList, "formatList");
      let output = [`Usage: ${helper2.commandUsage(cmd)}`, ""];
      const commandDescription = helper2.commandDescription(cmd);
      if (commandDescription.length > 0) {
        output = output.concat([commandDescription, ""]);
      }
      const argumentList = helper2.visibleArguments(cmd).map((argument2) => {
        return formatItem(helper2.argumentTerm(argument2), helper2.argumentDescription(argument2));
      });
      if (argumentList.length > 0) {
        output = output.concat(["Arguments:", formatList(argumentList), ""]);
      }
      const optionList = helper2.visibleOptions(cmd).map((option2) => {
        return formatItem(helper2.optionTerm(option2), helper2.optionDescription(option2));
      });
      if (optionList.length > 0) {
        output = output.concat(["Options:", formatList(optionList), ""]);
      }
      const commandList = helper2.visibleCommands(cmd).map((cmd2) => {
        return formatItem(helper2.subcommandTerm(cmd2), helper2.subcommandDescription(cmd2));
      });
      if (commandList.length > 0) {
        output = output.concat(["Commands:", formatList(commandList), ""]);
      }
      return output.join("\n");
    }
    /**
     * Calculate the pad width from the maximum term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    padWidth(cmd, helper2) {
      return Math.max(
        helper2.longestOptionTermLength(cmd, helper2),
        helper2.longestSubcommandTermLength(cmd, helper2),
        helper2.longestArgumentTermLength(cmd, helper2)
      );
    }
    /**
     * Wrap the given string to width characters per line, with lines after the first indented.
     * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
     *
     * @param {string} str
     * @param {number} width
     * @param {number} indent
     * @param {number} [minColumnWidth=40]
     * @return {string}
     *
     */
    wrap(str, width, indent, minColumnWidth = 40) {
      if (str.match(/[\n]\s+/)) return str;
      const columnWidth = width - indent;
      if (columnWidth < minColumnWidth) return str;
      const leadingStr = str.substr(0, indent);
      const columnText = str.substr(indent);
      const indentString = " ".repeat(indent);
      const regex = new RegExp(".{1," + (columnWidth - 1) + "}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)", "g");
      const lines = columnText.match(regex) || [];
      return leadingStr + lines.map((line, i) => {
        if (line.slice(-1) === "\n") {
          line = line.slice(0, line.length - 1);
        }
        return (i > 0 ? indentString : "") + line.trimRight();
      }).join("\n");
    }
  }
  help.Help = Help;
  return help;
}
__name(requireHelp, "requireHelp");
var option = {};
var hasRequiredOption;
function requireOption() {
  if (hasRequiredOption) return option;
  hasRequiredOption = 1;
  const { InvalidArgumentError } = requireError();
  class Option {
    static {
      __name(this, "Option");
    }
    /**
     * Initialize a new `Option` with the given `flags` and `description`.
     *
     * @param {string} flags
     * @param {string} [description]
     */
    constructor(flags, description) {
      this.flags = flags;
      this.description = description || "";
      this.required = flags.includes("<");
      this.optional = flags.includes("[");
      this.variadic = /\w\.\.\.[>\]]$/.test(flags);
      this.mandatory = false;
      const optionFlags = splitOptionFlags(flags);
      this.short = optionFlags.shortFlag;
      this.long = optionFlags.longFlag;
      this.negate = false;
      if (this.long) {
        this.negate = this.long.startsWith("--no-");
      }
      this.defaultValue = void 0;
      this.defaultValueDescription = void 0;
      this.envVar = void 0;
      this.parseArg = void 0;
      this.hidden = false;
      this.argChoices = void 0;
    }
    /**
     * Set the default value, and optionally supply the description to be displayed in the help.
     *
     * @param {any} value
     * @param {string} [description]
     * @return {Option}
     */
    default(value, description) {
      this.defaultValue = value;
      this.defaultValueDescription = description;
      return this;
    }
    /**
     * Set environment variable to check for option value.
     * Priority order of option values is default < env < cli
     *
     * @param {string} name
     * @return {Option}
     */
    env(name) {
      this.envVar = name;
      return this;
    }
    /**
     * Set the custom handler for processing CLI option arguments into option values.
     *
     * @param {Function} [fn]
     * @return {Option}
     */
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    /**
     * Whether the option is mandatory and must have a value after parsing.
     *
     * @param {boolean} [mandatory=true]
     * @return {Option}
     */
    makeOptionMandatory(mandatory = true) {
      this.mandatory = !!mandatory;
      return this;
    }
    /**
     * Hide option in help.
     *
     * @param {boolean} [hide=true]
     * @return {Option}
     */
    hideHelp(hide = true) {
      this.hidden = !!hide;
      return this;
    }
    /**
     * @api private
     */
    _concatValue(value, previous) {
      if (previous === this.defaultValue || !Array.isArray(previous)) {
        return [value];
      }
      return previous.concat(value);
    }
    /**
     * Only allow option value to be one of choices.
     *
     * @param {string[]} values
     * @return {Option}
     */
    choices(values) {
      this.argChoices = values;
      this.parseArg = (arg, previous) => {
        if (!values.includes(arg)) {
          throw new InvalidArgumentError(`Allowed choices are ${values.join(", ")}.`);
        }
        if (this.variadic) {
          return this._concatValue(arg, previous);
        }
        return arg;
      };
      return this;
    }
    /**
     * Return option name.
     *
     * @return {string}
     */
    name() {
      if (this.long) {
        return this.long.replace(/^--/, "");
      }
      return this.short.replace(/^-/, "");
    }
    /**
     * Return option name, in a camelcase format that can be used
     * as a object attribute key.
     *
     * @return {string}
     * @api private
     */
    attributeName() {
      return camelcase(this.name().replace(/^no-/, ""));
    }
    /**
     * Check if `arg` matches the short or long flag.
     *
     * @param {string} arg
     * @return {boolean}
     * @api private
     */
    is(arg) {
      return this.short === arg || this.long === arg;
    }
  }
  function camelcase(str) {
    return str.split("-").reduce((str2, word) => {
      return str2 + word[0].toUpperCase() + word.slice(1);
    });
  }
  __name(camelcase, "camelcase");
  function splitOptionFlags(flags) {
    let shortFlag;
    let longFlag;
    const flagParts = flags.split(/[ |,]+/);
    if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();
    longFlag = flagParts.shift();
    if (!shortFlag && /^-[^-]$/.test(longFlag)) {
      shortFlag = longFlag;
      longFlag = void 0;
    }
    return { shortFlag, longFlag };
  }
  __name(splitOptionFlags, "splitOptionFlags");
  option.Option = Option;
  option.splitOptionFlags = splitOptionFlags;
  return option;
}
__name(requireOption, "requireOption");
var suggestSimilar = {};
var hasRequiredSuggestSimilar;
function requireSuggestSimilar() {
  if (hasRequiredSuggestSimilar) return suggestSimilar;
  hasRequiredSuggestSimilar = 1;
  const maxDistance = 3;
  function editDistance(a, b) {
    if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);
    const d = [];
    for (let i = 0; i <= a.length; i++) {
      d[i] = [i];
    }
    for (let j = 0; j <= b.length; j++) {
      d[0][j] = j;
    }
    for (let j = 1; j <= b.length; j++) {
      for (let i = 1; i <= a.length; i++) {
        let cost = 1;
        if (a[i - 1] === b[j - 1]) {
          cost = 0;
        } else {
          cost = 1;
        }
        d[i][j] = Math.min(
          d[i - 1][j] + 1,
          // deletion
          d[i][j - 1] + 1,
          // insertion
          d[i - 1][j - 1] + cost
          // substitution
        );
        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
          d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
        }
      }
    }
    return d[a.length][b.length];
  }
  __name(editDistance, "editDistance");
  function suggestSimilar$1(word, candidates) {
    if (!candidates || candidates.length === 0) return "";
    candidates = Array.from(new Set(candidates));
    const searchingOptions = word.startsWith("--");
    if (searchingOptions) {
      word = word.slice(2);
      candidates = candidates.map((candidate) => candidate.slice(2));
    }
    let similar = [];
    let bestDistance = maxDistance;
    const minSimilarity = 0.4;
    candidates.forEach((candidate) => {
      if (candidate.length <= 1) return;
      const distance = editDistance(word, candidate);
      const length = Math.max(word.length, candidate.length);
      const similarity = (length - distance) / length;
      if (similarity > minSimilarity) {
        if (distance < bestDistance) {
          bestDistance = distance;
          similar = [candidate];
        } else if (distance === bestDistance) {
          similar.push(candidate);
        }
      }
    });
    similar.sort((a, b) => a.localeCompare(b));
    if (searchingOptions) {
      similar = similar.map((candidate) => `--${candidate}`);
    }
    if (similar.length > 1) {
      return `
(Did you mean one of ${similar.join(", ")}?)`;
    }
    if (similar.length === 1) {
      return `
(Did you mean ${similar[0]}?)`;
    }
    return "";
  }
  __name(suggestSimilar$1, "suggestSimilar$1");
  suggestSimilar.suggestSimilar = suggestSimilar$1;
  return suggestSimilar;
}
__name(requireSuggestSimilar, "requireSuggestSimilar");
var hasRequiredCommand;
function requireCommand() {
  if (hasRequiredCommand) return command;
  hasRequiredCommand = 1;
  const EventEmitter19 = require$$0$32.EventEmitter;
  const childProcess = child_process_default;
  const path$1 = path2;
  const fs$1 = fs;
  const { Argument, humanReadableArgName } = requireArgument();
  const { CommanderError } = requireError();
  const { Help } = requireHelp();
  const { Option, splitOptionFlags } = requireOption();
  const { suggestSimilar: suggestSimilar2 } = requireSuggestSimilar();
  class Command extends EventEmitter19 {
    static {
      __name(this, "Command");
    }
    /**
     * Initialize a new `Command`.
     *
     * @param {string} [name]
     */
    constructor(name) {
      super();
      this.commands = [];
      this.options = [];
      this.parent = null;
      this._allowUnknownOption = false;
      this._allowExcessArguments = true;
      this._args = [];
      this.args = [];
      this.rawArgs = [];
      this.processedArgs = [];
      this._scriptPath = null;
      this._name = name || "";
      this._optionValues = {};
      this._optionValueSources = {};
      this._storeOptionsAsProperties = false;
      this._actionHandler = null;
      this._executableHandler = false;
      this._executableFile = null;
      this._defaultCommandName = null;
      this._exitCallback = null;
      this._aliases = [];
      this._combineFlagAndOptionalValue = true;
      this._description = "";
      this._argsDescription = void 0;
      this._enablePositionalOptions = false;
      this._passThroughOptions = false;
      this._lifeCycleHooks = {};
      this._showHelpAfterError = false;
      this._showSuggestionAfterError = false;
      this._outputConfiguration = {
        writeOut: /* @__PURE__ */ __name((str) => process.stdout.write(str), "writeOut"),
        writeErr: /* @__PURE__ */ __name((str) => process.stderr.write(str), "writeErr"),
        getOutHelpWidth: /* @__PURE__ */ __name(() => process.stdout.isTTY ? process.stdout.columns : void 0, "getOutHelpWidth"),
        getErrHelpWidth: /* @__PURE__ */ __name(() => process.stderr.isTTY ? process.stderr.columns : void 0, "getErrHelpWidth"),
        outputError: /* @__PURE__ */ __name((str, write2) => write2(str), "outputError")
      };
      this._hidden = false;
      this._hasHelpOption = true;
      this._helpFlags = "-h, --help";
      this._helpDescription = "display help for command";
      this._helpShortFlag = "-h";
      this._helpLongFlag = "--help";
      this._addImplicitHelpCommand = void 0;
      this._helpCommandName = "help";
      this._helpCommandnameAndArgs = "help [command]";
      this._helpCommandDescription = "display help for command";
      this._helpConfiguration = {};
    }
    /**
     * Copy settings that are useful to have in common across root command and subcommands.
     *
     * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
     *
     * @param {Command} sourceCommand
     * @return {Command} returns `this` for executable command
     */
    copyInheritedSettings(sourceCommand) {
      this._outputConfiguration = sourceCommand._outputConfiguration;
      this._hasHelpOption = sourceCommand._hasHelpOption;
      this._helpFlags = sourceCommand._helpFlags;
      this._helpDescription = sourceCommand._helpDescription;
      this._helpShortFlag = sourceCommand._helpShortFlag;
      this._helpLongFlag = sourceCommand._helpLongFlag;
      this._helpCommandName = sourceCommand._helpCommandName;
      this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
      this._helpCommandDescription = sourceCommand._helpCommandDescription;
      this._helpConfiguration = sourceCommand._helpConfiguration;
      this._exitCallback = sourceCommand._exitCallback;
      this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
      this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
      this._allowExcessArguments = sourceCommand._allowExcessArguments;
      this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
      this._showHelpAfterError = sourceCommand._showHelpAfterError;
      this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
      return this;
    }
    /**
     * Define a command.
     *
     * There are two styles of command: pay attention to where to put the description.
     *
     * @example
     * // Command implemented using action handler (description is supplied separately to `.command`)
     * program
     *   .command('clone <source> [destination]')
     *   .description('clone a repository into a newly created directory')
     *   .action((source, destination) => {
     *     console.log('clone command called');
     *   });
     *
     * // Command implemented using separate executable file (description is second parameter to `.command`)
     * program
     *   .command('start <service>', 'start named service')
     *   .command('stop [service]', 'stop named service, or all if no name supplied');
     *
     * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
     * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
     * @param {Object} [execOpts] - configuration options (for executable)
     * @return {Command} returns new command for action handler, or `this` for executable command
     */
    command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
      let desc = actionOptsOrExecDesc;
      let opts = execOpts;
      if (typeof desc === "object" && desc !== null) {
        opts = desc;
        desc = null;
      }
      opts = opts || {};
      const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
      const cmd = this.createCommand(name);
      if (desc) {
        cmd.description(desc);
        cmd._executableHandler = true;
      }
      if (opts.isDefault) this._defaultCommandName = cmd._name;
      cmd._hidden = !!(opts.noHelp || opts.hidden);
      cmd._executableFile = opts.executableFile || null;
      if (args) cmd.arguments(args);
      this.commands.push(cmd);
      cmd.parent = this;
      cmd.copyInheritedSettings(this);
      if (desc) return this;
      return cmd;
    }
    /**
     * Factory routine to create a new unattached command.
     *
     * See .command() for creating an attached subcommand, which uses this routine to
     * create the command. You can override createCommand to customise subcommands.
     *
     * @param {string} [name]
     * @return {Command} new command
     */
    createCommand(name) {
      return new Command(name);
    }
    /**
     * You can customise the help with a subclass of Help by overriding createHelp,
     * or by overriding Help properties using configureHelp().
     *
     * @return {Help}
     */
    createHelp() {
      return Object.assign(new Help(), this.configureHelp());
    }
    /**
     * You can customise the help by overriding Help properties using configureHelp(),
     * or with a subclass of Help by overriding createHelp().
     *
     * @param {Object} [configuration] - configuration options
     * @return {Command|Object} `this` command for chaining, or stored configuration
     */
    configureHelp(configuration) {
      if (configuration === void 0) return this._helpConfiguration;
      this._helpConfiguration = configuration;
      return this;
    }
    /**
     * The default output goes to stdout and stderr. You can customise this for special
     * applications. You can also customise the display of errors by overriding outputError.
     *
     * The configuration properties are all functions:
     *
     *     // functions to change where being written, stdout and stderr
     *     writeOut(str)
     *     writeErr(str)
     *     // matching functions to specify width for wrapping help
     *     getOutHelpWidth()
     *     getErrHelpWidth()
     *     // functions based on what is being written out
     *     outputError(str, write) // used for displaying errors, and not used for displaying help
     *
     * @param {Object} [configuration] - configuration options
     * @return {Command|Object} `this` command for chaining, or stored configuration
     */
    configureOutput(configuration) {
      if (configuration === void 0) return this._outputConfiguration;
      Object.assign(this._outputConfiguration, configuration);
      return this;
    }
    /**
     * Display the help or a custom message after an error occurs.
     *
     * @param {boolean|string} [displayHelp]
     * @return {Command} `this` command for chaining
     */
    showHelpAfterError(displayHelp = true) {
      if (typeof displayHelp !== "string") displayHelp = !!displayHelp;
      this._showHelpAfterError = displayHelp;
      return this;
    }
    /**
     * Display suggestion of similar commands for unknown commands, or options for unknown options.
     *
     * @param {boolean} [displaySuggestion]
     * @return {Command} `this` command for chaining
     */
    showSuggestionAfterError(displaySuggestion = true) {
      this._showSuggestionAfterError = !!displaySuggestion;
      return this;
    }
    /**
     * Add a prepared subcommand.
     *
     * See .command() for creating an attached subcommand which inherits settings from its parent.
     *
     * @param {Command} cmd - new subcommand
     * @param {Object} [opts] - configuration options
     * @return {Command} `this` command for chaining
     */
    addCommand(cmd, opts) {
      if (!cmd._name) throw new Error("Command passed to .addCommand() must have a name");
      function checkExplicitNames(commandArray) {
        commandArray.forEach((cmd2) => {
          if (cmd2._executableHandler && !cmd2._executableFile) {
            throw new Error(`Must specify executableFile for deeply nested executable: ${cmd2.name()}`);
          }
          checkExplicitNames(cmd2.commands);
        });
      }
      __name(checkExplicitNames, "checkExplicitNames");
      checkExplicitNames(cmd.commands);
      opts = opts || {};
      if (opts.isDefault) this._defaultCommandName = cmd._name;
      if (opts.noHelp || opts.hidden) cmd._hidden = true;
      this.commands.push(cmd);
      cmd.parent = this;
      return this;
    }
    /**
     * Factory routine to create a new unattached argument.
     *
     * See .argument() for creating an attached argument, which uses this routine to
     * create the argument. You can override createArgument to return a custom argument.
     *
     * @param {string} name
     * @param {string} [description]
     * @return {Argument} new argument
     */
    createArgument(name, description) {
      return new Argument(name, description);
    }
    /**
     * Define argument syntax for command.
     *
     * The default is that the argument is required, and you can explicitly
     * indicate this with <> around the name. Put [] around the name for an optional argument.
     *
     * @example
     * program.argument('<input-file>');
     * program.argument('[output-file]');
     *
     * @param {string} name
     * @param {string} [description]
     * @param {Function|*} [fn] - custom argument processing function
     * @param {*} [defaultValue]
     * @return {Command} `this` command for chaining
     */
    argument(name, description, fn, defaultValue) {
      const argument2 = this.createArgument(name, description);
      if (typeof fn === "function") {
        argument2.default(defaultValue).argParser(fn);
      } else {
        argument2.default(fn);
      }
      this.addArgument(argument2);
      return this;
    }
    /**
     * Define argument syntax for command, adding multiple at once (without descriptions).
     *
     * See also .argument().
     *
     * @example
     * program.arguments('<cmd> [env]');
     *
     * @param {string} names
     * @return {Command} `this` command for chaining
     */
    arguments(names) {
      names.split(/ +/).forEach((detail) => {
        this.argument(detail);
      });
      return this;
    }
    /**
     * Define argument syntax for command, adding a prepared argument.
     *
     * @param {Argument} argument
     * @return {Command} `this` command for chaining
     */
    addArgument(argument2) {
      const previousArgument = this._args.slice(-1)[0];
      if (previousArgument && previousArgument.variadic) {
        throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
      }
      if (argument2.required && argument2.defaultValue !== void 0 && argument2.parseArg === void 0) {
        throw new Error(`a default value for a required argument is never used: '${argument2.name()}'`);
      }
      this._args.push(argument2);
      return this;
    }
    /**
     * Override default decision whether to add implicit help command.
     *
     *    addHelpCommand() // force on
     *    addHelpCommand(false); // force off
     *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
     *
     * @return {Command} `this` command for chaining
     */
    addHelpCommand(enableOrNameAndArgs, description) {
      if (enableOrNameAndArgs === false) {
        this._addImplicitHelpCommand = false;
      } else {
        this._addImplicitHelpCommand = true;
        if (typeof enableOrNameAndArgs === "string") {
          this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
          this._helpCommandnameAndArgs = enableOrNameAndArgs;
        }
        this._helpCommandDescription = description || this._helpCommandDescription;
      }
      return this;
    }
    /**
     * @return {boolean}
     * @api private
     */
    _hasImplicitHelpCommand() {
      if (this._addImplicitHelpCommand === void 0) {
        return this.commands.length && !this._actionHandler && !this._findCommand("help");
      }
      return this._addImplicitHelpCommand;
    }
    /**
     * Add hook for life cycle event.
     *
     * @param {string} event
     * @param {Function} listener
     * @return {Command} `this` command for chaining
     */
    hook(event, listener) {
      const allowedValues = ["preAction", "postAction"];
      if (!allowedValues.includes(event)) {
        throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      if (this._lifeCycleHooks[event]) {
        this._lifeCycleHooks[event].push(listener);
      } else {
        this._lifeCycleHooks[event] = [listener];
      }
      return this;
    }
    /**
     * Register callback to use as replacement for calling process.exit.
     *
     * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
     * @return {Command} `this` command for chaining
     */
    exitOverride(fn) {
      if (fn) {
        this._exitCallback = fn;
      } else {
        this._exitCallback = (err) => {
          if (err.code !== "commander.executeSubCommandAsync") {
            throw err;
          }
        };
      }
      return this;
    }
    /**
     * Call process.exit, and _exitCallback if defined.
     *
     * @param {number} exitCode exit code for using with process.exit
     * @param {string} code an id string representing the error
     * @param {string} message human-readable description of the error
     * @return never
     * @api private
     */
    _exit(exitCode2, code, message) {
      if (this._exitCallback) {
        this._exitCallback(new CommanderError(exitCode2, code, message));
      }
      process.exit(exitCode2);
    }
    /**
     * Register callback `fn` for the command.
     *
     * @example
     * program
     *   .command('serve')
     *   .description('start service')
     *   .action(function() {
     *      // do work here
     *   });
     *
     * @param {Function} fn
     * @return {Command} `this` command for chaining
     */
    action(fn) {
      const listener = /* @__PURE__ */ __name((args) => {
        const expectedArgsCount = this._args.length;
        const actionArgs = args.slice(0, expectedArgsCount);
        if (this._storeOptionsAsProperties) {
          actionArgs[expectedArgsCount] = this;
        } else {
          actionArgs[expectedArgsCount] = this.opts();
        }
        actionArgs.push(this);
        return fn.apply(this, actionArgs);
      }, "listener");
      this._actionHandler = listener;
      return this;
    }
    /**
     * Factory routine to create a new unattached option.
     *
     * See .option() for creating an attached option, which uses this routine to
     * create the option. You can override createOption to return a custom option.
     *
     * @param {string} flags
     * @param {string} [description]
     * @return {Option} new option
     */
    createOption(flags, description) {
      return new Option(flags, description);
    }
    /**
     * Add an option.
     *
     * @param {Option} option
     * @return {Command} `this` command for chaining
     */
    addOption(option2) {
      const oname = option2.name();
      const name = option2.attributeName();
      let defaultValue = option2.defaultValue;
      if (option2.negate || option2.optional || option2.required || typeof defaultValue === "boolean") {
        if (option2.negate) {
          const positiveLongFlag = option2.long.replace(/^--no-/, "--");
          defaultValue = this._findOption(positiveLongFlag) ? this.getOptionValue(name) : true;
        }
        if (defaultValue !== void 0) {
          this.setOptionValueWithSource(name, defaultValue, "default");
        }
      }
      this.options.push(option2);
      const handleOptionValue = /* @__PURE__ */ __name((val, invalidValueMessage, valueSource) => {
        const oldValue = this.getOptionValue(name);
        if (val !== null && option2.parseArg) {
          try {
            val = option2.parseArg(val, oldValue === void 0 ? defaultValue : oldValue);
          } catch (err) {
            if (err.code === "commander.invalidArgument") {
              const message = `${invalidValueMessage} ${err.message}`;
              this._displayError(err.exitCode, err.code, message);
            }
            throw err;
          }
        } else if (val !== null && option2.variadic) {
          val = option2._concatValue(val, oldValue);
        }
        if (typeof oldValue === "boolean" || typeof oldValue === "undefined") {
          if (val == null) {
            this.setOptionValueWithSource(name, option2.negate ? false : defaultValue || true, valueSource);
          } else {
            this.setOptionValueWithSource(name, val, valueSource);
          }
        } else if (val !== null) {
          this.setOptionValueWithSource(name, option2.negate ? false : val, valueSource);
        }
      }, "handleOptionValue");
      this.on("option:" + oname, (val) => {
        const invalidValueMessage = `error: option '${option2.flags}' argument '${val}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, "cli");
      });
      if (option2.envVar) {
        this.on("optionEnv:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option2.flags}' value '${val}' from env '${option2.envVar}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "env");
        });
      }
      return this;
    }
    /**
     * Internal implementation shared by .option() and .requiredOption()
     *
     * @api private
     */
    _optionEx(config2, flags, description, fn, defaultValue) {
      const option2 = this.createOption(flags, description);
      option2.makeOptionMandatory(!!config2.mandatory);
      if (typeof fn === "function") {
        option2.default(defaultValue).argParser(fn);
      } else if (fn instanceof RegExp) {
        const regex = fn;
        fn = /* @__PURE__ */ __name((val, def) => {
          const m = regex.exec(val);
          return m ? m[0] : def;
        }, "fn");
        option2.default(defaultValue).argParser(fn);
      } else {
        option2.default(fn);
      }
      return this.addOption(option2);
    }
    /**
     * Define option with `flags`, `description` and optional
     * coercion `fn`.
     *
     * The `flags` string contains the short and/or long flags,
     * separated by comma, a pipe or space. The following are all valid
     * all will output this way when `--help` is used.
     *
     *     "-p, --pepper"
     *     "-p|--pepper"
     *     "-p --pepper"
     *
     * @example
     * // simple boolean defaulting to undefined
     * program.option('-p, --pepper', 'add pepper');
     *
     * program.pepper
     * // => undefined
     *
     * --pepper
     * program.pepper
     * // => true
     *
     * // simple boolean defaulting to true (unless non-negated option is also defined)
     * program.option('-C, --no-cheese', 'remove cheese');
     *
     * program.cheese
     * // => true
     *
     * --no-cheese
     * program.cheese
     * // => false
     *
     * // required argument
     * program.option('-C, --chdir <path>', 'change the working directory');
     *
     * --chdir /tmp
     * program.chdir
     * // => "/tmp"
     *
     * // optional argument
     * program.option('-c, --cheese [type]', 'add cheese [marble]');
     *
     * @param {string} flags
     * @param {string} [description]
     * @param {Function|*} [fn] - custom option processing function or default value
     * @param {*} [defaultValue]
     * @return {Command} `this` command for chaining
     */
    option(flags, description, fn, defaultValue) {
      return this._optionEx({}, flags, description, fn, defaultValue);
    }
    /**
    * Add a required option which must have a value after parsing. This usually means
    * the option must be specified on the command line. (Otherwise the same as .option().)
    *
    * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
    *
    * @param {string} flags
    * @param {string} [description]
    * @param {Function|*} [fn] - custom option processing function or default value
    * @param {*} [defaultValue]
    * @return {Command} `this` command for chaining
    */
    requiredOption(flags, description, fn, defaultValue) {
      return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
    }
    /**
     * Alter parsing of short flags with optional values.
     *
     * @example
     * // for `.option('-f,--flag [value]'):
     * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
     * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
     *
     * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
     */
    combineFlagAndOptionalValue(combine = true) {
      this._combineFlagAndOptionalValue = !!combine;
      return this;
    }
    /**
     * Allow unknown options on the command line.
     *
     * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
     * for unknown options.
     */
    allowUnknownOption(allowUnknown = true) {
      this._allowUnknownOption = !!allowUnknown;
      return this;
    }
    /**
     * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
     *
     * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
     * for excess arguments.
     */
    allowExcessArguments(allowExcess = true) {
      this._allowExcessArguments = !!allowExcess;
      return this;
    }
    /**
     * Enable positional options. Positional means global options are specified before subcommands which lets
     * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
     * The default behaviour is non-positional and global options may appear anywhere on the command line.
     *
     * @param {Boolean} [positional=true]
     */
    enablePositionalOptions(positional = true) {
      this._enablePositionalOptions = !!positional;
      return this;
    }
    /**
     * Pass through options that come after command-arguments rather than treat them as command-options,
     * so actual command-options come before command-arguments. Turning this on for a subcommand requires
     * positional options to have been enabled on the program (parent commands).
     * The default behaviour is non-positional and options may appear before or after command-arguments.
     *
     * @param {Boolean} [passThrough=true]
     * for unknown options.
     */
    passThroughOptions(passThrough = true) {
      this._passThroughOptions = !!passThrough;
      if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
        throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
      }
      return this;
    }
    /**
      * Whether to store option values as properties on command object,
      * or store separately (specify false). In both cases the option values can be accessed using .opts().
      *
      * @param {boolean} [storeAsProperties=true]
      * @return {Command} `this` command for chaining
      */
    storeOptionsAsProperties(storeAsProperties = true) {
      this._storeOptionsAsProperties = !!storeAsProperties;
      if (this.options.length) {
        throw new Error("call .storeOptionsAsProperties() before adding options");
      }
      return this;
    }
    /**
     * Retrieve option value.
     *
     * @param {string} key
     * @return {Object} value
     */
    getOptionValue(key) {
      if (this._storeOptionsAsProperties) {
        return this[key];
      }
      return this._optionValues[key];
    }
    /**
     * Store option value.
     *
     * @param {string} key
     * @param {Object} value
     * @return {Command} `this` command for chaining
     */
    setOptionValue(key, value) {
      if (this._storeOptionsAsProperties) {
        this[key] = value;
      } else {
        this._optionValues[key] = value;
      }
      return this;
    }
    /**
     * Store option value and where the value came from.
      *
      * @param {string} key
      * @param {Object} value
      * @param {string} source - expected values are default/config/env/cli
      * @return {Command} `this` command for chaining
      */
    setOptionValueWithSource(key, value, source7) {
      this.setOptionValue(key, value);
      this._optionValueSources[key] = source7;
      return this;
    }
    /**
      * Get source of option value.
      * Expected values are default | config | env | cli
      *
      * @param {string} key
      * @return {string}
      */
    getOptionValueSource(key) {
      return this._optionValueSources[key];
    }
    /**
     * Get user arguments implied or explicit arguments.
     * Side-effects: set _scriptPath if args included application, and use that to set implicit command name.
     *
     * @api private
     */
    _prepareUserArgs(argv2, parseOptions2) {
      if (argv2 !== void 0 && !Array.isArray(argv2)) {
        throw new Error("first parameter to parse must be array or undefined");
      }
      parseOptions2 = parseOptions2 || {};
      if (argv2 === void 0) {
        argv2 = process.argv;
        if (process.versions && process.versions.electron) {
          parseOptions2.from = "electron";
        }
      }
      this.rawArgs = argv2.slice();
      let userArgs;
      switch (parseOptions2.from) {
        case void 0:
        case "node":
          this._scriptPath = argv2[1];
          userArgs = argv2.slice(2);
          break;
        case "electron":
          if (process.defaultApp) {
            this._scriptPath = argv2[1];
            userArgs = argv2.slice(2);
          } else {
            userArgs = argv2.slice(1);
          }
          break;
        case "user":
          userArgs = argv2.slice(0);
          break;
        default:
          throw new Error(`unexpected parse option { from: '${parseOptions2.from}' }`);
      }
      if (!this._scriptPath && __require.main) {
        this._scriptPath = __require.main.filename;
      }
      this._name = this._name || this._scriptPath && path$1.basename(this._scriptPath, path$1.extname(this._scriptPath));
      return userArgs;
    }
    /**
     * Parse `argv`, setting options and invoking commands when defined.
     *
     * The default expectation is that the arguments are from node and have the application as argv[0]
     * and the script being run in argv[1], with user parameters after that.
     *
     * @example
     * program.parse(process.argv);
     * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
     * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
     *
     * @param {string[]} [argv] - optional, defaults to process.argv
     * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
     * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
     * @return {Command} `this` command for chaining
     */
    parse(argv2, parseOptions2) {
      const userArgs = this._prepareUserArgs(argv2, parseOptions2);
      this._parseCommand([], userArgs);
      return this;
    }
    /**
     * Parse `argv`, setting options and invoking commands when defined.
     *
     * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
     *
     * The default expectation is that the arguments are from node and have the application as argv[0]
     * and the script being run in argv[1], with user parameters after that.
     *
     * @example
     * await program.parseAsync(process.argv);
     * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
     * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
     *
     * @param {string[]} [argv]
     * @param {Object} [parseOptions]
     * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
     * @return {Promise}
     */
    async parseAsync(argv2, parseOptions2) {
      const userArgs = this._prepareUserArgs(argv2, parseOptions2);
      await this._parseCommand([], userArgs);
      return this;
    }
    /**
     * Execute a sub-command executable.
     *
     * @api private
     */
    _executeSubCommand(subcommand, args) {
      args = args.slice();
      let launchWithNode = false;
      const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
      this._checkForMissingMandatoryOptions();
      let scriptPath = this._scriptPath;
      if (!scriptPath && __require.main) {
        scriptPath = __require.main.filename;
      }
      let baseDir;
      try {
        const resolvedLink = fs$1.realpathSync(scriptPath);
        baseDir = path$1.dirname(resolvedLink);
      } catch (e) {
        baseDir = ".";
      }
      let bin = path$1.basename(scriptPath, path$1.extname(scriptPath)) + "-" + subcommand._name;
      if (subcommand._executableFile) {
        bin = subcommand._executableFile;
      }
      const localBin = path$1.join(baseDir, bin);
      if (fs$1.existsSync(localBin)) {
        bin = localBin;
      } else {
        sourceExt.forEach((ext) => {
          if (fs$1.existsSync(`${localBin}${ext}`)) {
            bin = `${localBin}${ext}`;
          }
        });
      }
      launchWithNode = sourceExt.includes(path$1.extname(bin));
      let proc;
      if (process.platform !== "win32") {
        if (launchWithNode) {
          args.unshift(bin);
          args = incrementNodeInspectorPort(process.execArgv).concat(args);
          proc = childProcess.spawn(process.argv[0], args, { stdio: "inherit" });
        } else {
          proc = childProcess.spawn(bin, args, { stdio: "inherit" });
        }
      } else {
        args.unshift(bin);
        args = incrementNodeInspectorPort(process.execArgv).concat(args);
        proc = childProcess.spawn(process.execPath, args, { stdio: "inherit" });
      }
      const signals22 = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
      signals22.forEach((signal) => {
        process.on(signal, () => {
          if (proc.killed === false && proc.exitCode === null) {
            proc.kill(signal);
          }
        });
      });
      const exitCallback = this._exitCallback;
      if (!exitCallback) {
        proc.on("close", process.exit.bind(process));
      } else {
        proc.on("close", () => {
          exitCallback(new CommanderError(process.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
        });
      }
      proc.on("error", (err) => {
        if (err.code === "ENOENT") {
          const executableMissing = `'${bin}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name`;
          throw new Error(executableMissing);
        } else if (err.code === "EACCES") {
          throw new Error(`'${bin}' not executable`);
        }
        if (!exitCallback) {
          process.exit(1);
        } else {
          const wrappedError = new CommanderError(1, "commander.executeSubCommandAsync", "(error)");
          wrappedError.nestedError = err;
          exitCallback(wrappedError);
        }
      });
      this.runningCommand = proc;
    }
    /**
     * @api private
     */
    _dispatchSubcommand(commandName, operands, unknown) {
      const subCommand = this._findCommand(commandName);
      if (!subCommand) this.help({ error: true });
      if (subCommand._executableHandler) {
        this._executeSubCommand(subCommand, operands.concat(unknown));
      } else {
        return subCommand._parseCommand(operands, unknown);
      }
    }
    /**
     * Check this.args against expected this._args.
     *
     * @api private
     */
    _checkNumberOfArguments() {
      this._args.forEach((arg, i) => {
        if (arg.required && this.args[i] == null) {
          this.missingArgument(arg.name());
        }
      });
      if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
        return;
      }
      if (this.args.length > this._args.length) {
        this._excessArguments(this.args);
      }
    }
    /**
     * Process this.args using this._args and save as this.processedArgs!
     *
     * @api private
     */
    _processArguments() {
      const myParseArg = /* @__PURE__ */ __name((argument2, value, previous) => {
        let parsedValue = value;
        if (value !== null && argument2.parseArg) {
          try {
            parsedValue = argument2.parseArg(value, previous);
          } catch (err) {
            if (err.code === "commander.invalidArgument") {
              const message = `error: command-argument value '${value}' is invalid for argument '${argument2.name()}'. ${err.message}`;
              this._displayError(err.exitCode, err.code, message);
            }
            throw err;
          }
        }
        return parsedValue;
      }, "myParseArg");
      this._checkNumberOfArguments();
      const processedArgs = [];
      this._args.forEach((declaredArg, index2) => {
        let value = declaredArg.defaultValue;
        if (declaredArg.variadic) {
          if (index2 < this.args.length) {
            value = this.args.slice(index2);
            if (declaredArg.parseArg) {
              value = value.reduce((processed, v) => {
                return myParseArg(declaredArg, v, processed);
              }, declaredArg.defaultValue);
            }
          } else if (value === void 0) {
            value = [];
          }
        } else if (index2 < this.args.length) {
          value = this.args[index2];
          if (declaredArg.parseArg) {
            value = myParseArg(declaredArg, value, declaredArg.defaultValue);
          }
        }
        processedArgs[index2] = value;
      });
      this.processedArgs = processedArgs;
    }
    /**
     * Once we have a promise we chain, but call synchronously until then.
     *
     * @param {Promise|undefined} promise
     * @param {Function} fn
     * @return {Promise|undefined}
     * @api private
     */
    _chainOrCall(promise, fn) {
      if (promise && promise.then && typeof promise.then === "function") {
        return promise.then(() => fn());
      }
      return fn();
    }
    /**
     *
     * @param {Promise|undefined} promise
     * @param {string} event
     * @return {Promise|undefined}
     * @api private
     */
    _chainOrCallHooks(promise, event) {
      let result = promise;
      const hooks = [];
      getCommandAndParents(this).reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
      if (event === "postAction") {
        hooks.reverse();
      }
      hooks.forEach((hookDetail) => {
        result = this._chainOrCall(result, () => {
          return hookDetail.callback(hookDetail.hookedCommand, this);
        });
      });
      return result;
    }
    /**
     * Process arguments in context of this command.
     * Returns action result, in case it is a promise.
     *
     * @api private
     */
    _parseCommand(operands, unknown) {
      const parsed = this.parseOptions(unknown);
      this._parseOptionsEnv();
      operands = operands.concat(parsed.operands);
      unknown = parsed.unknown;
      this.args = operands.concat(unknown);
      if (operands && this._findCommand(operands[0])) {
        return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
      }
      if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
        if (operands.length === 1) {
          this.help();
        }
        return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
      }
      if (this._defaultCommandName) {
        outputHelpIfRequested(this, unknown);
        return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
      }
      if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
        this.help({ error: true });
      }
      outputHelpIfRequested(this, parsed.unknown);
      this._checkForMissingMandatoryOptions();
      const checkForUnknownOptions = /* @__PURE__ */ __name(() => {
        if (parsed.unknown.length > 0) {
          this.unknownOption(parsed.unknown[0]);
        }
      }, "checkForUnknownOptions");
      const commandEvent = `command:${this.name()}`;
      if (this._actionHandler) {
        checkForUnknownOptions();
        this._processArguments();
        let actionResult;
        actionResult = this._chainOrCallHooks(actionResult, "preAction");
        actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
        if (this.parent) this.parent.emit(commandEvent, operands, unknown);
        actionResult = this._chainOrCallHooks(actionResult, "postAction");
        return actionResult;
      }
      if (this.parent && this.parent.listenerCount(commandEvent)) {
        checkForUnknownOptions();
        this._processArguments();
        this.parent.emit(commandEvent, operands, unknown);
      } else if (operands.length) {
        if (this._findCommand("*")) {
          return this._dispatchSubcommand("*", operands, unknown);
        }
        if (this.listenerCount("command:*")) {
          this.emit("command:*", operands, unknown);
        } else if (this.commands.length) {
          this.unknownCommand();
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      } else if (this.commands.length) {
        checkForUnknownOptions();
        this.help({ error: true });
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    }
    /**
     * Find matching command.
     *
     * @api private
     */
    _findCommand(name) {
      if (!name) return void 0;
      return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
    }
    /**
     * Return an option matching `arg` if any.
     *
     * @param {string} arg
     * @return {Option}
     * @api private
     */
    _findOption(arg) {
      return this.options.find((option2) => option2.is(arg));
    }
    /**
     * Display an error message if a mandatory option does not have a value.
     * Lazy calling after checking for help flags from leaf subcommand.
     *
     * @api private
     */
    _checkForMissingMandatoryOptions() {
      for (let cmd = this; cmd; cmd = cmd.parent) {
        cmd.options.forEach((anOption) => {
          if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
            cmd.missingMandatoryOptionValue(anOption);
          }
        });
      }
    }
    /**
     * Parse options from `argv` removing known options,
     * and return argv split into operands and unknown arguments.
     *
     * Examples:
     *
     *     argv => operands, unknown
     *     --known kkk op => [op], []
     *     op --known kkk => [op], []
     *     sub --unknown uuu op => [sub], [--unknown uuu op]
     *     sub -- --unknown uuu op => [sub --unknown uuu op], []
     *
     * @param {String[]} argv
     * @return {{operands: String[], unknown: String[]}}
     */
    parseOptions(argv2) {
      const operands = [];
      const unknown = [];
      let dest = operands;
      const args = argv2.slice();
      function maybeOption(arg) {
        return arg.length > 1 && arg[0] === "-";
      }
      __name(maybeOption, "maybeOption");
      let activeVariadicOption = null;
      while (args.length) {
        const arg = args.shift();
        if (arg === "--") {
          if (dest === unknown) dest.push(arg);
          dest.push(...args);
          break;
        }
        if (activeVariadicOption && !maybeOption(arg)) {
          this.emit(`option:${activeVariadicOption.name()}`, arg);
          continue;
        }
        activeVariadicOption = null;
        if (maybeOption(arg)) {
          const option2 = this._findOption(arg);
          if (option2) {
            if (option2.required) {
              const value = args.shift();
              if (value === void 0) this.optionMissingArgument(option2);
              this.emit(`option:${option2.name()}`, value);
            } else if (option2.optional) {
              let value = null;
              if (args.length > 0 && !maybeOption(args[0])) {
                value = args.shift();
              }
              this.emit(`option:${option2.name()}`, value);
            } else {
              this.emit(`option:${option2.name()}`);
            }
            activeVariadicOption = option2.variadic ? option2 : null;
            continue;
          }
        }
        if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
          const option2 = this._findOption(`-${arg[1]}`);
          if (option2) {
            if (option2.required || option2.optional && this._combineFlagAndOptionalValue) {
              this.emit(`option:${option2.name()}`, arg.slice(2));
            } else {
              this.emit(`option:${option2.name()}`);
              args.unshift(`-${arg.slice(2)}`);
            }
            continue;
          }
        }
        if (/^--[^=]+=/.test(arg)) {
          const index2 = arg.indexOf("=");
          const option2 = this._findOption(arg.slice(0, index2));
          if (option2 && (option2.required || option2.optional)) {
            this.emit(`option:${option2.name()}`, arg.slice(index2 + 1));
            continue;
          }
        }
        if (maybeOption(arg)) {
          dest = unknown;
        }
        if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
          if (this._findCommand(arg)) {
            operands.push(arg);
            if (args.length > 0) unknown.push(...args);
            break;
          } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
            operands.push(arg);
            if (args.length > 0) operands.push(...args);
            break;
          } else if (this._defaultCommandName) {
            unknown.push(arg);
            if (args.length > 0) unknown.push(...args);
            break;
          }
        }
        if (this._passThroughOptions) {
          dest.push(arg);
          if (args.length > 0) dest.push(...args);
          break;
        }
        dest.push(arg);
      }
      return { operands, unknown };
    }
    /**
     * Return an object containing options as key-value pairs
     *
     * @return {Object}
     */
    opts() {
      if (this._storeOptionsAsProperties) {
        const result = {};
        const len = this.options.length;
        for (let i = 0; i < len; i++) {
          const key = this.options[i].attributeName();
          result[key] = key === this._versionOptionName ? this._version : this[key];
        }
        return result;
      }
      return this._optionValues;
    }
    /**
     * Internal bottleneck for handling of parsing errors.
     *
     * @api private
     */
    _displayError(exitCode2, code, message) {
      this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
      if (typeof this._showHelpAfterError === "string") {
        this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
      } else if (this._showHelpAfterError) {
        this._outputConfiguration.writeErr("\n");
        this.outputHelp({ error: true });
      }
      this._exit(exitCode2, code, message);
    }
    /**
     * Apply any option related environment variables, if option does
     * not have a value from cli or client code.
     *
     * @api private
     */
    _parseOptionsEnv() {
      this.options.forEach((option2) => {
        if (option2.envVar && option2.envVar in process.env) {
          const optionKey = option2.attributeName();
          if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
            if (option2.required || option2.optional) {
              this.emit(`optionEnv:${option2.name()}`, process.env[option2.envVar]);
            } else {
              this.emit(`optionEnv:${option2.name()}`);
            }
          }
        }
      });
    }
    /**
     * Argument `name` is missing.
     *
     * @param {string} name
     * @api private
     */
    missingArgument(name) {
      const message = `error: missing required argument '${name}'`;
      this._displayError(1, "commander.missingArgument", message);
    }
    /**
     * `Option` is missing an argument.
     *
     * @param {Option} option
     * @api private
     */
    optionMissingArgument(option2) {
      const message = `error: option '${option2.flags}' argument missing`;
      this._displayError(1, "commander.optionMissingArgument", message);
    }
    /**
     * `Option` does not have a value, and is a mandatory option.
     *
     * @param {Option} option
     * @api private
     */
    missingMandatoryOptionValue(option2) {
      const message = `error: required option '${option2.flags}' not specified`;
      this._displayError(1, "commander.missingMandatoryOptionValue", message);
    }
    /**
     * Unknown option `flag`.
     *
     * @param {string} flag
     * @api private
     */
    unknownOption(flag) {
      if (this._allowUnknownOption) return;
      let suggestion = "";
      if (flag.startsWith("--") && this._showSuggestionAfterError) {
        let candidateFlags = [];
        let command2 = this;
        do {
          const moreFlags = command2.createHelp().visibleOptions(command2).filter((option2) => option2.long).map((option2) => option2.long);
          candidateFlags = candidateFlags.concat(moreFlags);
          command2 = command2.parent;
        } while (command2 && !command2._enablePositionalOptions);
        suggestion = suggestSimilar2(flag, candidateFlags);
      }
      const message = `error: unknown option '${flag}'${suggestion}`;
      this._displayError(1, "commander.unknownOption", message);
    }
    /**
     * Excess arguments, more than expected.
     *
     * @param {string[]} receivedArgs
     * @api private
     */
    _excessArguments(receivedArgs) {
      if (this._allowExcessArguments) return;
      const expected = this._args.length;
      const s = expected === 1 ? "" : "s";
      const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
      const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
      this._displayError(1, "commander.excessArguments", message);
    }
    /**
     * Unknown command.
     *
     * @api private
     */
    unknownCommand() {
      const unknownName = this.args[0];
      let suggestion = "";
      if (this._showSuggestionAfterError) {
        const candidateNames = [];
        this.createHelp().visibleCommands(this).forEach((command2) => {
          candidateNames.push(command2.name());
          if (command2.alias()) candidateNames.push(command2.alias());
        });
        suggestion = suggestSimilar2(unknownName, candidateNames);
      }
      const message = `error: unknown command '${unknownName}'${suggestion}`;
      this._displayError(1, "commander.unknownCommand", message);
    }
    /**
     * Set the program version to `str`.
     *
     * This method auto-registers the "-V, --version" flag
     * which will print the version number when passed.
     *
     * You can optionally supply the  flags and description to override the defaults.
     *
     * @param {string} str
     * @param {string} [flags]
     * @param {string} [description]
     * @return {this | string} `this` command for chaining, or version string if no arguments
     */
    version(str, flags, description) {
      if (str === void 0) return this._version;
      this._version = str;
      flags = flags || "-V, --version";
      description = description || "output the version number";
      const versionOption = this.createOption(flags, description);
      this._versionOptionName = versionOption.attributeName();
      this.options.push(versionOption);
      this.on("option:" + versionOption.name(), () => {
        this._outputConfiguration.writeOut(`${str}
`);
        this._exit(0, "commander.version", str);
      });
      return this;
    }
    /**
     * Set the description to `str`.
     *
     * @param {string} [str]
     * @param {Object} [argsDescription]
     * @return {string|Command}
     */
    description(str, argsDescription) {
      if (str === void 0 && argsDescription === void 0) return this._description;
      this._description = str;
      if (argsDescription) {
        this._argsDescription = argsDescription;
      }
      return this;
    }
    /**
     * Set an alias for the command.
     *
     * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
     *
     * @param {string} [alias]
     * @return {string|Command}
     */
    alias(alias) {
      if (alias === void 0) return this._aliases[0];
      let command2 = this;
      if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
        command2 = this.commands[this.commands.length - 1];
      }
      if (alias === command2._name) throw new Error("Command alias can't be the same as its name");
      command2._aliases.push(alias);
      return this;
    }
    /**
     * Set aliases for the command.
     *
     * Only the first alias is shown in the auto-generated help.
     *
     * @param {string[]} [aliases]
     * @return {string[]|Command}
     */
    aliases(aliases2) {
      if (aliases2 === void 0) return this._aliases;
      aliases2.forEach((alias) => this.alias(alias));
      return this;
    }
    /**
     * Set / get the command usage `str`.
     *
     * @param {string} [str]
     * @return {String|Command}
     */
    usage(str) {
      if (str === void 0) {
        if (this._usage) return this._usage;
        const args = this._args.map((arg) => {
          return humanReadableArgName(arg);
        });
        return [].concat(
          this.options.length || this._hasHelpOption ? "[options]" : [],
          this.commands.length ? "[command]" : [],
          this._args.length ? args : []
        ).join(" ");
      }
      this._usage = str;
      return this;
    }
    /**
     * Get or set the name of the command
     *
     * @param {string} [str]
     * @return {string|Command}
     */
    name(str) {
      if (str === void 0) return this._name;
      this._name = str;
      return this;
    }
    /**
     * Return program help documentation.
     *
     * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
     * @return {string}
     */
    helpInformation(contextOptions) {
      const helper2 = this.createHelp();
      if (helper2.helpWidth === void 0) {
        helper2.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
      }
      return helper2.formatHelp(this, helper2);
    }
    /**
     * @api private
     */
    _getHelpContext(contextOptions) {
      contextOptions = contextOptions || {};
      const context2 = { error: !!contextOptions.error };
      let write2;
      if (context2.error) {
        write2 = /* @__PURE__ */ __name((arg) => this._outputConfiguration.writeErr(arg), "write");
      } else {
        write2 = /* @__PURE__ */ __name((arg) => this._outputConfiguration.writeOut(arg), "write");
      }
      context2.write = contextOptions.write || write2;
      context2.command = this;
      return context2;
    }
    /**
     * Output help information for this command.
     *
     * Outputs built-in help, and custom text added using `.addHelpText()`.
     *
     * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
     */
    outputHelp(contextOptions) {
      let deprecatedCallback;
      if (typeof contextOptions === "function") {
        deprecatedCallback = contextOptions;
        contextOptions = void 0;
      }
      const context2 = this._getHelpContext(contextOptions);
      getCommandAndParents(this).reverse().forEach((command2) => command2.emit("beforeAllHelp", context2));
      this.emit("beforeHelp", context2);
      let helpInformation = this.helpInformation(context2);
      if (deprecatedCallback) {
        helpInformation = deprecatedCallback(helpInformation);
        if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
          throw new Error("outputHelp callback must return a string or a Buffer");
        }
      }
      context2.write(helpInformation);
      this.emit(this._helpLongFlag);
      this.emit("afterHelp", context2);
      getCommandAndParents(this).forEach((command2) => command2.emit("afterAllHelp", context2));
    }
    /**
     * You can pass in flags and a description to override the help
     * flags and help description for your command. Pass in false to
     * disable the built-in help option.
     *
     * @param {string | boolean} [flags]
     * @param {string} [description]
     * @return {Command} `this` command for chaining
     */
    helpOption(flags, description) {
      if (typeof flags === "boolean") {
        this._hasHelpOption = flags;
        return this;
      }
      this._helpFlags = flags || this._helpFlags;
      this._helpDescription = description || this._helpDescription;
      const helpFlags = splitOptionFlags(this._helpFlags);
      this._helpShortFlag = helpFlags.shortFlag;
      this._helpLongFlag = helpFlags.longFlag;
      return this;
    }
    /**
     * Output help information and exit.
     *
     * Outputs built-in help, and custom text added using `.addHelpText()`.
     *
     * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
     */
    help(contextOptions) {
      this.outputHelp(contextOptions);
      let exitCode2 = process.exitCode || 0;
      if (exitCode2 === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
        exitCode2 = 1;
      }
      this._exit(exitCode2, "commander.help", "(outputHelp)");
    }
    /**
     * Add additional text to be displayed with the built-in help.
     *
     * Position is 'before' or 'after' to affect just this command,
     * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
     *
     * @param {string} position - before or after built-in help
     * @param {string | Function} text - string to add, or a function returning a string
     * @return {Command} `this` command for chaining
     */
    addHelpText(position, text) {
      const allowedValues = ["beforeAll", "before", "after", "afterAll"];
      if (!allowedValues.includes(position)) {
        throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      const helpEvent = `${position}Help`;
      this.on(helpEvent, (context2) => {
        let helpStr;
        if (typeof text === "function") {
          helpStr = text({ error: context2.error, command: context2.command });
        } else {
          helpStr = text;
        }
        if (helpStr) {
          context2.write(`${helpStr}
`);
        }
      });
      return this;
    }
  }
  function outputHelpIfRequested(cmd, args) {
    const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
    if (helpOption) {
      cmd.outputHelp();
      cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
    }
  }
  __name(outputHelpIfRequested, "outputHelpIfRequested");
  function incrementNodeInspectorPort(args) {
    return args.map((arg) => {
      if (!arg.startsWith("--inspect")) {
        return arg;
      }
      let debugOption;
      let debugHost = "127.0.0.1";
      let debugPort2 = "9229";
      let match;
      if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
        debugOption = match[1];
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
        debugOption = match[1];
        if (/^\d+$/.test(match[3])) {
          debugPort2 = match[3];
        } else {
          debugHost = match[3];
        }
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
        debugOption = match[1];
        debugHost = match[3];
        debugPort2 = match[4];
      }
      if (debugOption && debugPort2 !== "0") {
        return `${debugOption}=${debugHost}:${parseInt(debugPort2) + 1}`;
      }
      return arg;
    });
  }
  __name(incrementNodeInspectorPort, "incrementNodeInspectorPort");
  function getCommandAndParents(startCommand) {
    const result = [];
    for (let command2 = startCommand; command2; command2 = command2.parent) {
      result.push(command2);
    }
    return result;
  }
  __name(getCommandAndParents, "getCommandAndParents");
  command.Command = Command;
  return command;
}
__name(requireCommand, "requireCommand");
var hasRequiredCommander;
function requireCommander() {
  if (hasRequiredCommander) return commander.exports;
  hasRequiredCommander = 1;
  (function(module, exports) {
    const { Argument } = requireArgument();
    const { Command } = requireCommand();
    const { CommanderError, InvalidArgumentError } = requireError();
    const { Help } = requireHelp();
    const { Option } = requireOption();
    exports = module.exports = new Command();
    exports.program = exports;
    exports.Argument = Argument;
    exports.Command = Command;
    exports.CommanderError = CommanderError;
    exports.Help = Help;
    exports.InvalidArgumentError = InvalidArgumentError;
    exports.InvalidOptionArgumentError = InvalidArgumentError;
    exports.Option = Option;
  })(commander, commander.exports);
  return commander.exports;
}
__name(requireCommander, "requireCommander");
var commanderExports = requireCommander();
var nodeProgress = { exports: {} };
var hasRequiredNodeProgress;
function requireNodeProgress() {
  if (hasRequiredNodeProgress) return nodeProgress.exports;
  hasRequiredNodeProgress = 1;
  (function(module, exports) {
    module.exports = ProgressBar;
    function ProgressBar(fmt, options2) {
      this.stream = options2.stream || process.stderr;
      if (typeof options2 == "number") {
        var total = options2;
        options2 = {};
        options2.total = total;
      } else {
        options2 = options2 || {};
        if ("string" != typeof fmt) throw new Error("format required");
        if ("number" != typeof options2.total) throw new Error("total required");
      }
      this.fmt = fmt;
      this.curr = options2.curr || 0;
      this.total = options2.total;
      this.width = options2.width || this.total;
      this.clear = options2.clear;
      this.chars = {
        complete: options2.complete || "=",
        incomplete: options2.incomplete || "-",
        head: options2.head || (options2.complete || "=")
      };
      this.renderThrottle = options2.renderThrottle !== 0 ? options2.renderThrottle || 16 : 0;
      this.lastRender = -Infinity;
      this.callback = options2.callback || function() {
      };
      this.tokens = {};
      this.lastDraw = "";
    }
    __name(ProgressBar, "ProgressBar");
    ProgressBar.prototype.tick = function(len, tokens) {
      if (len !== 0)
        len = len || 1;
      if ("object" == typeof len) tokens = len, len = 1;
      if (tokens) this.tokens = tokens;
      if (0 == this.curr) this.start = /* @__PURE__ */ new Date();
      this.curr += len;
      this.render();
      if (this.curr >= this.total) {
        this.render(void 0, true);
        this.complete = true;
        this.terminate();
        this.callback(this);
        return;
      }
    };
    ProgressBar.prototype.render = function(tokens, force) {
      force = force !== void 0 ? force : false;
      if (tokens) this.tokens = tokens;
      if (!this.stream.isTTY) return;
      var now = Date.now();
      var delta = now - this.lastRender;
      if (!force && delta < this.renderThrottle) {
        return;
      } else {
        this.lastRender = now;
      }
      var ratio = this.curr / this.total;
      ratio = Math.min(Math.max(ratio, 0), 1);
      var percent = Math.floor(ratio * 100);
      var incomplete, complete, completeLength;
      var elapsed = /* @__PURE__ */ new Date() - this.start;
      var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
      var rate = this.curr / (elapsed / 1e3);
      var str = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1e3).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1e3).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
      var availableSpace = Math.max(0, this.stream.columns - str.replace(":bar", "").length);
      if (availableSpace && process.platform === "win32") {
        availableSpace = availableSpace - 1;
      }
      var width = Math.min(this.width, availableSpace);
      completeLength = Math.round(width * ratio);
      complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
      incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
      if (completeLength > 0)
        complete = complete.slice(0, -1) + this.chars.head;
      str = str.replace(":bar", complete + incomplete);
      if (this.tokens) for (var key in this.tokens) str = str.replace(":" + key, this.tokens[key]);
      if (this.lastDraw !== str) {
        this.stream.cursorTo(0);
        this.stream.write(str);
        this.stream.clearLine(1);
        this.lastDraw = str;
      }
    };
    ProgressBar.prototype.update = function(ratio, tokens) {
      var goal = Math.floor(ratio * this.total);
      var delta = goal - this.curr;
      this.tick(delta, tokens);
    };
    ProgressBar.prototype.interrupt = function(message) {
      this.stream.clearLine();
      this.stream.cursorTo(0);
      this.stream.write(message);
      this.stream.write("\n");
      this.stream.write(this.lastDraw);
    };
    ProgressBar.prototype.terminate = function() {
      if (this.clear) {
        if (this.stream.clearLine) {
          this.stream.clearLine();
          this.stream.cursorTo(0);
        }
      } else {
        this.stream.write("\n");
      }
    };
  })(nodeProgress);
  return nodeProgress.exports;
}
__name(requireNodeProgress, "requireNodeProgress");
var progress$1;
var hasRequiredProgress;
function requireProgress() {
  if (hasRequiredProgress) return progress$1;
  hasRequiredProgress = 1;
  progress$1 = requireNodeProgress();
  return progress$1;
}
__name(requireProgress, "requireProgress");
var progressExports = requireProgress();
var progressLibrary = /* @__PURE__ */ getDefaultExportFromCjs(progressExports);
var agent = {};
var build = {};
var socksclient = {};
var smartbuffer = {};
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", { value: true });
  const buffer_1 = require$$0$13;
  const ERRORS = {
    INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
    INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
    INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
    INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
    INVALID_OFFSET: "An invalid offset value was provided.",
    INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
    INVALID_LENGTH: "An invalid length value was provided.",
    INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
    INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
    INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
    INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
    INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
  };
  utils.ERRORS = ERRORS;
  function checkEncoding(encoding2) {
    if (!buffer_1.Buffer.isEncoding(encoding2)) {
      throw new Error(ERRORS.INVALID_ENCODING);
    }
  }
  __name(checkEncoding, "checkEncoding");
  utils.checkEncoding = checkEncoding;
  function isFiniteInteger(value) {
    return typeof value === "number" && isFinite(value) && isInteger(value);
  }
  __name(isFiniteInteger, "isFiniteInteger");
  utils.isFiniteInteger = isFiniteInteger;
  function checkOffsetOrLengthValue(value, offset) {
    if (typeof value === "number") {
      if (!isFiniteInteger(value) || value < 0) {
        throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
      }
    } else {
      throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
    }
  }
  __name(checkOffsetOrLengthValue, "checkOffsetOrLengthValue");
  function checkLengthValue(length) {
    checkOffsetOrLengthValue(length, false);
  }
  __name(checkLengthValue, "checkLengthValue");
  utils.checkLengthValue = checkLengthValue;
  function checkOffsetValue(offset) {
    checkOffsetOrLengthValue(offset, true);
  }
  __name(checkOffsetValue, "checkOffsetValue");
  utils.checkOffsetValue = checkOffsetValue;
  function checkTargetOffset(offset, buff) {
    if (offset < 0 || offset > buff.length) {
      throw new Error(ERRORS.INVALID_TARGET_OFFSET);
    }
  }
  __name(checkTargetOffset, "checkTargetOffset");
  utils.checkTargetOffset = checkTargetOffset;
  function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  }
  __name(isInteger, "isInteger");
  function bigIntAndBufferInt64Check(bufferMethod) {
    if (typeof BigInt === "undefined") {
      throw new Error("Platform does not support JS BigInt type.");
    }
    if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
      throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
    }
  }
  __name(bigIntAndBufferInt64Check, "bigIntAndBufferInt64Check");
  utils.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
  return utils;
}
__name(requireUtils, "requireUtils");
var hasRequiredSmartbuffer;
function requireSmartbuffer() {
  if (hasRequiredSmartbuffer) return smartbuffer;
  hasRequiredSmartbuffer = 1;
  Object.defineProperty(smartbuffer, "__esModule", { value: true });
  const utils_1 = requireUtils();
  const DEFAULT_SMARTBUFFER_SIZE = 4096;
  const DEFAULT_SMARTBUFFER_ENCODING = "utf8";
  class SmartBuffer {
    static {
      __name(this, "SmartBuffer");
    }
    /**
     * Creates a new SmartBuffer instance.
     *
     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.
     */
    constructor(options2) {
      this.length = 0;
      this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
      this._writeOffset = 0;
      this._readOffset = 0;
      if (SmartBuffer.isSmartBufferOptions(options2)) {
        if (options2.encoding) {
          utils_1.checkEncoding(options2.encoding);
          this._encoding = options2.encoding;
        }
        if (options2.size) {
          if (utils_1.isFiniteInteger(options2.size) && options2.size > 0) {
            this._buff = Buffer.allocUnsafe(options2.size);
          } else {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
          }
        } else if (options2.buff) {
          if (Buffer.isBuffer(options2.buff)) {
            this._buff = options2.buff;
            this.length = options2.buff.length;
          } else {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
          }
        } else {
          this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
      } else {
        if (typeof options2 !== "undefined") {
          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
        }
        this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
      }
    }
    /**
     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.
     *
     * @param size { Number } The size of the internal Buffer.
     * @param encoding { String } The BufferEncoding to use for strings.
     *
     * @return { SmartBuffer }
     */
    static fromSize(size, encoding2) {
      return new this({
        size,
        encoding: encoding2
      });
    }
    /**
     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.
     *
     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.
     * @param encoding { String } The BufferEncoding to use for strings.
     *
     * @return { SmartBuffer }
     */
    static fromBuffer(buff, encoding2) {
      return new this({
        buff,
        encoding: encoding2
      });
    }
    /**
     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.
     *
     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.
     */
    static fromOptions(options2) {
      return new this(options2);
    }
    /**
     * Type checking function that determines if an object is a SmartBufferOptions object.
     */
    static isSmartBufferOptions(options2) {
      const castOptions = options2;
      return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
    }
    // Signed integers
    /**
     * Reads an Int8 value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt8(offset) {
      return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
    }
    /**
     * Reads an Int16BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt16BE(offset) {
      return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
    }
    /**
     * Reads an Int16LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt16LE(offset) {
      return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
    }
    /**
     * Reads an Int32BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt32BE(offset) {
      return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
    }
    /**
     * Reads an Int32LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt32LE(offset) {
      return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
    }
    /**
     * Reads a BigInt64BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { BigInt }
     */
    readBigInt64BE(offset) {
      utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
      return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
    }
    /**
     * Reads a BigInt64LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { BigInt }
     */
    readBigInt64LE(offset) {
      utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
      return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
    }
    /**
     * Writes an Int8 value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt8(value, offset) {
      this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
      return this;
    }
    /**
     * Inserts an Int8 value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt8(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
    }
    /**
     * Writes an Int16BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt16BE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
    }
    /**
     * Inserts an Int16BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt16BE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
    }
    /**
     * Writes an Int16LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt16LE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
    }
    /**
     * Inserts an Int16LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt16LE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
    }
    /**
     * Writes an Int32BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt32BE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
    }
    /**
     * Inserts an Int32BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt32BE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
    }
    /**
     * Writes an Int32LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt32LE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
    }
    /**
     * Inserts an Int32LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt32LE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
    }
    /**
     * Writes a BigInt64BE value to the current write position (or at optional offset).
     *
     * @param value { BigInt } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeBigInt64BE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
      return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
    }
    /**
     * Inserts a BigInt64BE value at the given offset value.
     *
     * @param value { BigInt } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertBigInt64BE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
      return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
    }
    /**
     * Writes a BigInt64LE value to the current write position (or at optional offset).
     *
     * @param value { BigInt } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeBigInt64LE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
      return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
    }
    /**
     * Inserts a Int64LE value at the given offset value.
     *
     * @param value { BigInt } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertBigInt64LE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
      return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
    }
    // Unsigned Integers
    /**
     * Reads an UInt8 value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt8(offset) {
      return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
    }
    /**
     * Reads an UInt16BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt16BE(offset) {
      return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
    }
    /**
     * Reads an UInt16LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt16LE(offset) {
      return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
    }
    /**
     * Reads an UInt32BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt32BE(offset) {
      return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
    }
    /**
     * Reads an UInt32LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt32LE(offset) {
      return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
    }
    /**
     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { BigInt }
     */
    readBigUInt64BE(offset) {
      utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
      return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
    }
    /**
     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { BigInt }
     */
    readBigUInt64LE(offset) {
      utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
      return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
    }
    /**
     * Writes an UInt8 value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt8(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
    }
    /**
     * Inserts an UInt8 value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt8(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
    }
    /**
     * Writes an UInt16BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt16BE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
    }
    /**
     * Inserts an UInt16BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt16BE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
    }
    /**
     * Writes an UInt16LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt16LE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
    }
    /**
     * Inserts an UInt16LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt16LE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
    }
    /**
     * Writes an UInt32BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt32BE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
    }
    /**
     * Inserts an UInt32BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt32BE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
    }
    /**
     * Writes an UInt32LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt32LE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
    }
    /**
     * Inserts an UInt32LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt32LE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
    }
    /**
     * Writes a BigUInt64BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeBigUInt64BE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
      return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
    }
    /**
     * Inserts a BigUInt64BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertBigUInt64BE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
      return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
    }
    /**
     * Writes a BigUInt64LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeBigUInt64LE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
      return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
    }
    /**
     * Inserts a BigUInt64LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertBigUInt64LE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
      return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
    }
    // Floating Point
    /**
     * Reads an FloatBE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readFloatBE(offset) {
      return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
    }
    /**
     * Reads an FloatLE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readFloatLE(offset) {
      return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
    }
    /**
     * Writes a FloatBE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeFloatBE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
    }
    /**
     * Inserts a FloatBE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertFloatBE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
    }
    /**
     * Writes a FloatLE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeFloatLE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
    }
    /**
     * Inserts a FloatLE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertFloatLE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
    }
    // Double Floating Point
    /**
     * Reads an DoublEBE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readDoubleBE(offset) {
      return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
    }
    /**
     * Reads an DoubleLE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readDoubleLE(offset) {
      return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
    }
    /**
     * Writes a DoubleBE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeDoubleBE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
    }
    /**
     * Inserts a DoubleBE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertDoubleBE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
    }
    /**
     * Writes a DoubleLE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeDoubleLE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
    }
    /**
     * Inserts a DoubleLE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertDoubleLE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
    }
    // Strings
    /**
     * Reads a String from the current read position.
     *
     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for
     *             the string (Defaults to instance level encoding).
     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
     *
     * @return { String }
     */
    readString(arg1, encoding2) {
      let lengthVal;
      if (typeof arg1 === "number") {
        utils_1.checkLengthValue(arg1);
        lengthVal = Math.min(arg1, this.length - this._readOffset);
      } else {
        encoding2 = arg1;
        lengthVal = this.length - this._readOffset;
      }
      if (typeof encoding2 !== "undefined") {
        utils_1.checkEncoding(encoding2);
      }
      const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding2 || this._encoding);
      this._readOffset += lengthVal;
      return value;
    }
    /**
     * Inserts a String
     *
     * @param value { String } The String value to insert.
     * @param offset { Number } The offset to insert the string at.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     *
     * @return this
     */
    insertString(value, offset, encoding2) {
      utils_1.checkOffsetValue(offset);
      return this._handleString(value, true, offset, encoding2);
    }
    /**
     * Writes a String
     *
     * @param value { String } The String value to write.
     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     *
     * @return this
     */
    writeString(value, arg2, encoding2) {
      return this._handleString(value, false, arg2, encoding2);
    }
    /**
     * Reads a null-terminated String from the current read position.
     *
     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
     *
     * @return { String }
     */
    readStringNT(encoding2) {
      if (typeof encoding2 !== "undefined") {
        utils_1.checkEncoding(encoding2);
      }
      let nullPos = this.length;
      for (let i = this._readOffset; i < this.length; i++) {
        if (this._buff[i] === 0) {
          nullPos = i;
          break;
        }
      }
      const value = this._buff.slice(this._readOffset, nullPos);
      this._readOffset = nullPos + 1;
      return value.toString(encoding2 || this._encoding);
    }
    /**
     * Inserts a null-terminated String.
     *
     * @param value { String } The String value to write.
     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     *
     * @return this
     */
    insertStringNT(value, offset, encoding2) {
      utils_1.checkOffsetValue(offset);
      this.insertString(value, offset, encoding2);
      this.insertUInt8(0, offset + value.length);
      return this;
    }
    /**
     * Writes a null-terminated String.
     *
     * @param value { String } The String value to write.
     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     *
     * @return this
     */
    writeStringNT(value, arg2, encoding2) {
      this.writeString(value, arg2, encoding2);
      this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
      return this;
    }
    // Buffers
    /**
     * Reads a Buffer from the internal read position.
     *
     * @param length { Number } The length of data to read as a Buffer.
     *
     * @return { Buffer }
     */
    readBuffer(length) {
      if (typeof length !== "undefined") {
        utils_1.checkLengthValue(length);
      }
      const lengthVal = typeof length === "number" ? length : this.length;
      const endPoint = Math.min(this.length, this._readOffset + lengthVal);
      const value = this._buff.slice(this._readOffset, endPoint);
      this._readOffset = endPoint;
      return value;
    }
    /**
     * Writes a Buffer to the current write position.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     *
     * @return this
     */
    insertBuffer(value, offset) {
      utils_1.checkOffsetValue(offset);
      return this._handleBuffer(value, true, offset);
    }
    /**
     * Writes a Buffer to the current write position.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     *
     * @return this
     */
    writeBuffer(value, offset) {
      return this._handleBuffer(value, false, offset);
    }
    /**
     * Reads a null-terminated Buffer from the current read poisiton.
     *
     * @return { Buffer }
     */
    readBufferNT() {
      let nullPos = this.length;
      for (let i = this._readOffset; i < this.length; i++) {
        if (this._buff[i] === 0) {
          nullPos = i;
          break;
        }
      }
      const value = this._buff.slice(this._readOffset, nullPos);
      this._readOffset = nullPos + 1;
      return value;
    }
    /**
     * Inserts a null-terminated Buffer.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     *
     * @return this
     */
    insertBufferNT(value, offset) {
      utils_1.checkOffsetValue(offset);
      this.insertBuffer(value, offset);
      this.insertUInt8(0, offset + value.length);
      return this;
    }
    /**
     * Writes a null-terminated Buffer.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     *
     * @return this
     */
    writeBufferNT(value, offset) {
      if (typeof offset !== "undefined") {
        utils_1.checkOffsetValue(offset);
      }
      this.writeBuffer(value, offset);
      this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
      return this;
    }
    /**
     * Clears the SmartBuffer instance to its original empty state.
     */
    clear() {
      this._writeOffset = 0;
      this._readOffset = 0;
      this.length = 0;
      return this;
    }
    /**
     * Gets the remaining data left to be read from the SmartBuffer instance.
     *
     * @return { Number }
     */
    remaining() {
      return this.length - this._readOffset;
    }
    /**
     * Gets the current read offset value of the SmartBuffer instance.
     *
     * @return { Number }
     */
    get readOffset() {
      return this._readOffset;
    }
    /**
     * Sets the read offset value of the SmartBuffer instance.
     *
     * @param offset { Number } - The offset value to set.
     */
    set readOffset(offset) {
      utils_1.checkOffsetValue(offset);
      utils_1.checkTargetOffset(offset, this);
      this._readOffset = offset;
    }
    /**
     * Gets the current write offset value of the SmartBuffer instance.
     *
     * @return { Number }
     */
    get writeOffset() {
      return this._writeOffset;
    }
    /**
     * Sets the write offset value of the SmartBuffer instance.
     *
     * @param offset { Number } - The offset value to set.
     */
    set writeOffset(offset) {
      utils_1.checkOffsetValue(offset);
      utils_1.checkTargetOffset(offset, this);
      this._writeOffset = offset;
    }
    /**
     * Gets the currently set string encoding of the SmartBuffer instance.
     *
     * @return { BufferEncoding } The string Buffer encoding currently set.
     */
    get encoding() {
      return this._encoding;
    }
    /**
     * Sets the string encoding of the SmartBuffer instance.
     *
     * @param encoding { BufferEncoding } The string Buffer encoding to set.
     */
    set encoding(encoding2) {
      utils_1.checkEncoding(encoding2);
      this._encoding = encoding2;
    }
    /**
     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)
     *
     * @return { Buffer } The Buffer value.
     */
    get internalBuffer() {
      return this._buff;
    }
    /**
     * Gets the value of the internal managed Buffer (Includes managed data only)
     *
     * @param { Buffer }
     */
    toBuffer() {
      return this._buff.slice(0, this.length);
    }
    /**
     * Gets the String value of the internal managed Buffer
     *
     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).
     */
    toString(encoding2) {
      const encodingVal = typeof encoding2 === "string" ? encoding2 : this._encoding;
      utils_1.checkEncoding(encodingVal);
      return this._buff.toString(encodingVal, 0, this.length);
    }
    /**
     * Destroys the SmartBuffer instance.
     */
    destroy() {
      this.clear();
      return this;
    }
    /**
     * Handles inserting and writing strings.
     *
     * @param value { String } The String value to insert.
     * @param isInsert { Boolean } True if inserting a string, false if writing.
     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     */
    _handleString(value, isInsert, arg3, encoding2) {
      let offsetVal = this._writeOffset;
      let encodingVal = this._encoding;
      if (typeof arg3 === "number") {
        offsetVal = arg3;
      } else if (typeof arg3 === "string") {
        utils_1.checkEncoding(arg3);
        encodingVal = arg3;
      }
      if (typeof encoding2 === "string") {
        utils_1.checkEncoding(encoding2);
        encodingVal = encoding2;
      }
      const byteLength = Buffer.byteLength(value, encodingVal);
      if (isInsert) {
        this.ensureInsertable(byteLength, offsetVal);
      } else {
        this._ensureWriteable(byteLength, offsetVal);
      }
      this._buff.write(value, offsetVal, byteLength, encodingVal);
      if (isInsert) {
        this._writeOffset += byteLength;
      } else {
        if (typeof arg3 === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
        } else {
          this._writeOffset += byteLength;
        }
      }
      return this;
    }
    /**
     * Handles writing or insert of a Buffer.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     */
    _handleBuffer(value, isInsert, offset) {
      const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
      if (isInsert) {
        this.ensureInsertable(value.length, offsetVal);
      } else {
        this._ensureWriteable(value.length, offsetVal);
      }
      value.copy(this._buff, offsetVal);
      if (isInsert) {
        this._writeOffset += value.length;
      } else {
        if (typeof offset === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
        } else {
          this._writeOffset += value.length;
        }
      }
      return this;
    }
    /**
     * Ensures that the internal Buffer is large enough to read data.
     *
     * @param length { Number } The length of the data that needs to be read.
     * @param offset { Number } The offset of the data that needs to be read.
     */
    ensureReadable(length, offset) {
      let offsetVal = this._readOffset;
      if (typeof offset !== "undefined") {
        utils_1.checkOffsetValue(offset);
        offsetVal = offset;
      }
      if (offsetVal < 0 || offsetVal + length > this.length) {
        throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
      }
    }
    /**
     * Ensures that the internal Buffer is large enough to insert data.
     *
     * @param dataLength { Number } The length of the data that needs to be written.
     * @param offset { Number } The offset of the data to be written.
     */
    ensureInsertable(dataLength, offset) {
      utils_1.checkOffsetValue(offset);
      this._ensureCapacity(this.length + dataLength);
      if (offset < this.length) {
        this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
      }
      if (offset + dataLength > this.length) {
        this.length = offset + dataLength;
      } else {
        this.length += dataLength;
      }
    }
    /**
     * Ensures that the internal Buffer is large enough to write data.
     *
     * @param dataLength { Number } The length of the data that needs to be written.
     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).
     */
    _ensureWriteable(dataLength, offset) {
      const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
      this._ensureCapacity(offsetVal + dataLength);
      if (offsetVal + dataLength > this.length) {
        this.length = offsetVal + dataLength;
      }
    }
    /**
     * Ensures that the internal Buffer is large enough to write at least the given amount of data.
     *
     * @param minLength { Number } The minimum length of the data needs to be written.
     */
    _ensureCapacity(minLength) {
      const oldLength = this._buff.length;
      if (minLength > oldLength) {
        let data = this._buff;
        let newLength = oldLength * 3 / 2 + 1;
        if (newLength < minLength) {
          newLength = minLength;
        }
        this._buff = Buffer.allocUnsafe(newLength);
        data.copy(this._buff, 0, 0, oldLength);
      }
    }
    /**
     * Reads a numeric number value using the provided function.
     *
     * @typeparam T { number | bigint } The type of the value to be read
     *
     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.
     * @param byteSize { Number } The number of bytes read.
     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.
     *
     * @returns { T } the number value
     */
    _readNumberValue(func, byteSize, offset) {
      this.ensureReadable(byteSize, offset);
      const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
      if (typeof offset === "undefined") {
        this._readOffset += byteSize;
      }
      return value;
    }
    /**
     * Inserts a numeric number value based on the given offset and value.
     *
     * @typeparam T { number | bigint } The type of the value to be written
     *
     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
     * @param byteSize { Number } The number of bytes written.
     * @param value { T } The number value to write.
     * @param offset { Number } the offset to write the number at (REQUIRED).
     *
     * @returns SmartBuffer this buffer
     */
    _insertNumberValue(func, byteSize, value, offset) {
      utils_1.checkOffsetValue(offset);
      this.ensureInsertable(byteSize, offset);
      func.call(this._buff, value, offset);
      this._writeOffset += byteSize;
      return this;
    }
    /**
     * Writes a numeric number value based on the given offset and value.
     *
     * @typeparam T { number | bigint } The type of the value to be written
     *
     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
     * @param byteSize { Number } The number of bytes written.
     * @param value { T } The number value to write.
     * @param offset { Number } the offset to write the number at (REQUIRED).
     *
     * @returns SmartBuffer this buffer
     */
    _writeNumberValue(func, byteSize, value, offset) {
      if (typeof offset === "number") {
        if (offset < 0) {
          throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
        }
        utils_1.checkOffsetValue(offset);
      }
      const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
      this._ensureWriteable(byteSize, offsetVal);
      func.call(this._buff, value, offsetVal);
      if (typeof offset === "number") {
        this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
      } else {
        this._writeOffset += byteSize;
      }
      return this;
    }
  }
  smartbuffer.SmartBuffer = SmartBuffer;
  return smartbuffer;
}
__name(requireSmartbuffer, "requireSmartbuffer");
var constants$22 = {};
var hasRequiredConstants$2;
function requireConstants$2() {
  if (hasRequiredConstants$2) return constants$22;
  hasRequiredConstants$2 = 1;
  Object.defineProperty(constants$22, "__esModule", { value: true });
  constants$22.SOCKS5_NO_ACCEPTABLE_AUTH = constants$22.SOCKS5_CUSTOM_AUTH_END = constants$22.SOCKS5_CUSTOM_AUTH_START = constants$22.SOCKS_INCOMING_PACKET_SIZES = constants$22.SocksClientState = constants$22.Socks5Response = constants$22.Socks5HostType = constants$22.Socks5Auth = constants$22.Socks4Response = constants$22.SocksCommand = constants$22.ERRORS = constants$22.DEFAULT_TIMEOUT = void 0;
  const DEFAULT_TIMEOUT3 = 3e4;
  constants$22.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT3;
  const ERRORS = {
    InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
    InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
    InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
    InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
    InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
    InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
    InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
    InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
    InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
    InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
    NegotiationError: "Negotiation error",
    SocketClosed: "Socket closed",
    ProxyConnectionTimedOut: "Proxy connection timed out",
    InternalError: "SocksClient internal error (this should not happen)",
    InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
    Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
    InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
    Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
    InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
    InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
    InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
    InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
    Socks5AuthenticationFailed: "Socks5 Authentication failed",
    InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
    InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
    InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
    Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
  };
  constants$22.ERRORS = ERRORS;
  const SOCKS_INCOMING_PACKET_SIZES = {
    Socks5InitialHandshakeResponse: 2,
    Socks5UserPassAuthenticationResponse: 2,
    // Command response + incoming connection (bind)
    Socks5ResponseHeader: 5,
    // We need at least 5 to read the hostname length, then we wait for the address+port information.
    Socks5ResponseIPv4: 10,
    // 4 header + 4 ip + 2 port
    Socks5ResponseIPv6: 22,
    // 4 header + 16 ip + 2 port
    Socks5ResponseHostname: /* @__PURE__ */ __name((hostNameLength) => hostNameLength + 7, "Socks5ResponseHostname"),
    // 4 header + 1 host length + host + 2 port
    // Command response + incoming connection (bind)
    Socks4Response: 8
    // 2 header + 2 port + 4 ip
  };
  constants$22.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
  var SocksCommand;
  (function(SocksCommand2) {
    SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
    SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
    SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
  })(SocksCommand || (constants$22.SocksCommand = SocksCommand = {}));
  var Socks4Response;
  (function(Socks4Response2) {
    Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
    Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
    Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
    Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
  })(Socks4Response || (constants$22.Socks4Response = Socks4Response = {}));
  var Socks5Auth;
  (function(Socks5Auth2) {
    Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
    Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
    Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
  })(Socks5Auth || (constants$22.Socks5Auth = Socks5Auth = {}));
  const SOCKS5_CUSTOM_AUTH_START = 128;
  constants$22.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
  const SOCKS5_CUSTOM_AUTH_END = 254;
  constants$22.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
  const SOCKS5_NO_ACCEPTABLE_AUTH = 255;
  constants$22.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
  var Socks5Response;
  (function(Socks5Response2) {
    Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
    Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
    Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
    Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
    Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
    Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
    Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
    Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
    Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
  })(Socks5Response || (constants$22.Socks5Response = Socks5Response = {}));
  var Socks5HostType;
  (function(Socks5HostType2) {
    Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
    Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
    Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
  })(Socks5HostType || (constants$22.Socks5HostType = Socks5HostType = {}));
  var SocksClientState;
  (function(SocksClientState2) {
    SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
    SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
    SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
    SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
    SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
    SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
    SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
    SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
    SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
    SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
    SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
    SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
    SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
  })(SocksClientState || (constants$22.SocksClientState = SocksClientState = {}));
  return constants$22;
}
__name(requireConstants$2, "requireConstants$2");
var helpers$1 = {};
var util2 = {};
var hasRequiredUtil2;
function requireUtil2() {
  if (hasRequiredUtil2) return util2;
  hasRequiredUtil2 = 1;
  Object.defineProperty(util2, "__esModule", { value: true });
  util2.shuffleArray = util2.SocksClientError = void 0;
  class SocksClientError extends Error {
    static {
      __name(this, "SocksClientError");
    }
    constructor(message, options2) {
      super(message);
      this.options = options2;
    }
  }
  util2.SocksClientError = SocksClientError;
  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
  __name(shuffleArray, "shuffleArray");
  util2.shuffleArray = shuffleArray;
  return util2;
}
__name(requireUtil2, "requireUtil");
var ipAddress = {};
var ipv4 = {};
var common2 = {};
var hasRequiredCommon2;
function requireCommon2() {
  if (hasRequiredCommon2) return common2;
  hasRequiredCommon2 = 1;
  Object.defineProperty(common2, "__esModule", { value: true });
  common2.isCorrect = common2.isInSubnet = void 0;
  function isInSubnet(address) {
    if (this.subnetMask < address.subnetMask) {
      return false;
    }
    if (this.mask(address.subnetMask) === address.mask()) {
      return true;
    }
    return false;
  }
  __name(isInSubnet, "isInSubnet");
  common2.isInSubnet = isInSubnet;
  function isCorrect(defaultBits) {
    return function() {
      if (this.addressMinusSuffix !== this.correctForm()) {
        return false;
      }
      if (this.subnetMask === defaultBits && !this.parsedSubnet) {
        return true;
      }
      return this.parsedSubnet === String(this.subnetMask);
    };
  }
  __name(isCorrect, "isCorrect");
  common2.isCorrect = isCorrect;
  return common2;
}
__name(requireCommon2, "requireCommon");
var constants$13 = {};
var hasRequiredConstants$13;
function requireConstants$13() {
  if (hasRequiredConstants$13) return constants$13;
  hasRequiredConstants$13 = 1;
  Object.defineProperty(constants$13, "__esModule", { value: true });
  constants$13.RE_SUBNET_STRING = constants$13.RE_ADDRESS = constants$13.GROUPS = constants$13.BITS = void 0;
  constants$13.BITS = 32;
  constants$13.GROUPS = 4;
  constants$13.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
  constants$13.RE_SUBNET_STRING = /\/\d{1,2}$/;
  return constants$13;
}
__name(requireConstants$13, "requireConstants$1");
var addressError = {};
var hasRequiredAddressError;
function requireAddressError() {
  if (hasRequiredAddressError) return addressError;
  hasRequiredAddressError = 1;
  Object.defineProperty(addressError, "__esModule", { value: true });
  addressError.AddressError = void 0;
  class AddressError extends Error {
    static {
      __name(this, "AddressError");
    }
    constructor(message, parseMessage) {
      super(message);
      this.name = "AddressError";
      if (parseMessage !== null) {
        this.parseMessage = parseMessage;
      }
    }
  }
  addressError.AddressError = AddressError;
  return addressError;
}
__name(requireAddressError, "requireAddressError");
var jsbn$1 = { exports: {} };
var jsbn = jsbn$1.exports;
var hasRequiredJsbn;
function requireJsbn() {
  if (hasRequiredJsbn) return jsbn$1.exports;
  hasRequiredJsbn = 1;
  (function(module, exports) {
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if ("number" == typeof a) this.fromNumber(a, b, c);
          else if (b == null && "string" != typeof a) this.fromString(a, 256);
          else this.fromString(a, b);
      }
      __name(BigInteger, "BigInteger");
      function nbi() {
        return new BigInteger(null);
      }
      __name(nbi, "nbi");
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      __name(am1, "am1");
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      __name(am2, "am2");
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }
      __name(am3, "am3");
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      __name(int2char, "int2char");
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      __name(intAt, "intAt");
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      __name(bnpCopyTo, "bnpCopyTo");
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0) this[0] = x;
        else if (x < -1) this[0] = x + this.DV;
        else this.t = 0;
      }
      __name(bnpFromInt, "bnpFromInt");
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      __name(nbv, "nbv");
      function bnpFromString(s, b) {
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 256) k = 8;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-") mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x;
          else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x >> this.DB - sh;
          } else
            this[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB) sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0) this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi) BigInteger.ZERO.subTo(this, this);
      }
      __name(bnpFromString, "bnpFromString");
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) --this.t;
      }
      __name(bnpClamp, "bnpClamp");
      function bnToString(b) {
        if (this.s < 0) return "-" + this.negate().toString(b);
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this[i] & (1 << p) - 1) << k - p;
              d |= this[--i] >> (p += this.DB - k);
            } else {
              d = this[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0) m = true;
            if (m) r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      __name(bnToString, "bnToString");
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      __name(bnNegate, "bnNegate");
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      __name(bnAbs, "bnAbs");
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0) return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0) return this.s < 0 ? -r : r;
        while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
        return 0;
      }
      __name(bnCompareTo, "bnCompareTo");
      function nbits(x) {
        var r = 1, t2;
        if ((t2 = x >>> 16) != 0) {
          x = t2;
          r += 16;
        }
        if ((t2 = x >> 8) != 0) {
          x = t2;
          r += 8;
        }
        if ((t2 = x >> 4) != 0) {
          x = t2;
          r += 4;
        }
        if ((t2 = x >> 2) != 0) {
          x = t2;
          r += 2;
        }
        if ((t2 = x >> 1) != 0) {
          x = t2;
          r += 1;
        }
        return r;
      }
      __name(nbits, "nbits");
      function bnBitLength() {
        if (this.t <= 0) return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      __name(bnBitLength, "bnBitLength");
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i) r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      __name(bnpDLShiftTo, "bnpDLShiftTo");
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i) r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      __name(bnpDRShiftTo, "bnpDRShiftTo");
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i) r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      __name(bnpLShiftTo, "bnpLShiftTo");
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      __name(bnpRShiftTo, "bnpRShiftTo");
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1) r[i++] = this.DV + c;
        else if (c > 0) r[i++] = c;
        r.t = i;
        r.clamp();
      }
      __name(bnpSubTo, "bnpSubTo");
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0) r[i] = 0;
        for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
      }
      __name(bnpMultiplyTo, "bnpMultiplyTo");
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0) r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      __name(bnpSquareTo, "bnpSquareTo");
      function bnpDivRemTo(m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0) return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q != null) q.fromInt(0);
          if (r != null) this.copyTo(r);
          return;
        }
        if (r == null) r = nbi();
        var y = nbi(), ts = this.s, ms22 = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t2 = q == null ? nbi() : q;
        y.dlShiftTo(j, t2);
        if (r.compareTo(t2) >= 0) {
          r[r.t++] = 1;
          r.subTo(t2, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t2);
        t2.subTo(y, y);
        while (y.t < ys) y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t2);
            r.subTo(t2, r);
            while (r[i] < --qd) r.subTo(t2, r);
          }
        }
        if (q != null) {
          r.drShiftTo(ys, q);
          if (ts != ms22) BigInteger.ZERO.subTo(q, q);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0) r.rShiftTo(nsh, r);
        if (ts < 0) BigInteger.ZERO.subTo(r, r);
      }
      __name(bnpDivRemTo, "bnpDivRemTo");
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
        return r;
      }
      __name(bnMod, "bnMod");
      function Classic(m) {
        this.m = m;
      }
      __name(Classic, "Classic");
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
        else return x;
      }
      __name(cConvert, "cConvert");
      function cRevert(x) {
        return x;
      }
      __name(cRevert, "cRevert");
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      __name(cReduce, "cReduce");
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      __name(cMulTo, "cMulTo");
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      __name(cSqrTo, "cSqrTo");
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1) return 0;
        var x = this[0];
        if ((x & 1) == 0) return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      __name(bnpInvDigit, "bnpInvDigit");
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      __name(Montgomery, "Montgomery");
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
        return r;
      }
      __name(montConvert, "montConvert");
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      __name(montRevert, "montRevert");
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
      }
      __name(montReduce, "montReduce");
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      __name(montSqrTo, "montSqrTo");
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      __name(montMulTo, "montMulTo");
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      __name(bnpIsEven, "bnpIsEven");
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1) return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0) z2.mulTo(r2, g, r);
          else {
            var t2 = r;
            r = r2;
            r2 = t2;
          }
        }
        return z2.revert(r);
      }
      __name(bnpExp, "bnpExp");
      function bnModPowInt(e, m) {
        var z2;
        if (e < 256 || m.isEven()) z2 = new Classic(m);
        else z2 = new Montgomery(m);
        return this.exp(e, z2);
      }
      __name(bnModPowInt, "bnModPowInt");
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      __name(bnClone, "bnClone");
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1) return this[0] - this.DV;
          else if (this.t == 0) return -1;
        } else if (this.t == 1) return this[0];
        else if (this.t == 0) return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      __name(bnIntValue, "bnIntValue");
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      __name(bnByteValue, "bnByteValue");
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      __name(bnShortValue, "bnShortValue");
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      __name(bnpChunkSize, "bnpChunkSize");
      function bnSigNum() {
        if (this.s < 0) return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;
        else return 1;
      }
      __name(bnSigNum, "bnSigNum");
      function bnpToRadix(b) {
        if (b == null) b = 10;
        if (this.signum() == 0 || b < 2 || b > 36) return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      __name(bnpToRadix, "bnpToRadix");
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null) b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi) BigInteger.ZERO.subTo(this, this);
      }
      __name(bnpFromRadix, "bnpFromRadix");
      function bnpFromNumber(a, b, c) {
        if ("number" == typeof b) {
          if (a < 2) this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven()) this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t2 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t2 > 0) x[0] &= (1 << t2) - 1;
          else x[0] = 0;
          this.fromString(x, 256);
        }
      }
      __name(bnpFromNumber, "bnpFromNumber");
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0) d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128)) ++k;
            if (k > 0 || d != this.s) r[k++] = d;
          }
        }
        return r;
      }
      __name(bnToByteArray, "bnToByteArray");
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      __name(bnEquals, "bnEquals");
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      __name(bnMin, "bnMin");
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      __name(bnMax, "bnMax");
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      __name(bnpBitwiseTo, "bnpBitwiseTo");
      function op_and(x, y) {
        return x & y;
      }
      __name(op_and, "op_and");
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      __name(bnAnd, "bnAnd");
      function op_or(x, y) {
        return x | y;
      }
      __name(op_or, "op_or");
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      __name(bnOr, "bnOr");
      function op_xor(x, y) {
        return x ^ y;
      }
      __name(op_xor, "op_xor");
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      __name(bnXor, "bnXor");
      function op_andnot(x, y) {
        return x & ~y;
      }
      __name(op_andnot, "op_andnot");
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      __name(bnAndNot, "bnAndNot");
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      __name(bnNot, "bnNot");
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0) this.rShiftTo(-n, r);
        else this.lShiftTo(n, r);
        return r;
      }
      __name(bnShiftLeft, "bnShiftLeft");
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0) this.lShiftTo(-n, r);
        else this.rShiftTo(n, r);
        return r;
      }
      __name(bnShiftRight, "bnShiftRight");
      function lbit(x) {
        if (x == 0) return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0) ++r;
        return r;
      }
      __name(lbit, "lbit");
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0) return i * this.DB + lbit(this[i]);
        if (this.s < 0) return this.t * this.DB;
        return -1;
      }
      __name(bnGetLowestSetBit, "bnGetLowestSetBit");
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      __name(cbit, "cbit");
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
        return r;
      }
      __name(bnBitCount, "bnBitCount");
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      __name(bnTestBit, "bnTestBit");
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      __name(bnpChangeBit, "bnpChangeBit");
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      __name(bnSetBit, "bnSetBit");
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      __name(bnClearBit, "bnClearBit");
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      __name(bnFlipBit, "bnFlipBit");
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0) r[i++] = c;
        else if (c < -1) r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      __name(bnpAddTo, "bnpAddTo");
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      __name(bnAdd, "bnAdd");
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      __name(bnSubtract, "bnSubtract");
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      __name(bnMultiply, "bnMultiply");
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      __name(bnSquare, "bnSquare");
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      __name(bnDivide, "bnDivide");
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      __name(bnRemainder, "bnRemainder");
      function bnDivideAndRemainder(a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a, q, r);
        return new Array(q, r);
      }
      __name(bnDivideAndRemainder, "bnDivideAndRemainder");
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      __name(bnpDMultiply, "bnpDMultiply");
      function bnpDAddOffset(n, w) {
        if (n == 0) return;
        while (this.t <= w) this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t) this[this.t++] = 0;
          ++this[w];
        }
      }
      __name(bnpDAddOffset, "bnpDAddOffset");
      function NullExp() {
      }
      __name(NullExp, "NullExp");
      function nNop(x) {
        return x;
      }
      __name(nNop, "nNop");
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      __name(nMulTo, "nMulTo");
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      __name(nSqrTo, "nSqrTo");
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      __name(bnPow, "bnPow");
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0) r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      __name(bnpMultiplyLowerTo, "bnpMultiplyLowerTo");
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0) r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      __name(bnpMultiplyUpperTo, "bnpMultiplyUpperTo");
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      __name(Barrett, "Barrett");
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
        else if (x.compareTo(this.m) < 0) return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      __name(barrettConvert, "barrettConvert");
      function barrettRevert(x) {
        return x;
      }
      __name(barrettRevert, "barrettRevert");
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
      }
      __name(barrettReduce, "barrettReduce");
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      __name(barrettSqrTo, "barrettSqrTo");
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      __name(barrettMulTo, "barrettMulTo");
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z2;
        if (i <= 0) return r;
        else if (i < 18) k = 1;
        else if (i < 48) k = 3;
        else if (i < 144) k = 4;
        else if (i < 768) k = 5;
        else k = 6;
        if (i < 8)
          z2 = new Classic(m);
        else if (m.isEven())
          z2 = new Barrett(m);
        else
          z2 = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1) w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0) w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0) z2.sqrTo(r, r2);
            else {
              t2 = r;
              r = r2;
              r2 = t2;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t2 = r;
            r = r2;
            r2 = t2;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      __name(bnModPow, "bnModPow");
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t2 = x;
          x = y;
          y = t2;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0) return x;
        if (i < g) g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0) y.lShiftTo(g, y);
        return y;
      }
      __name(bnGCD, "bnGCD");
      function bnpModInt(n) {
        if (n <= 0) return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0) r = this[0] % n;
          else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
        return r;
      }
      __name(bnpModInt, "bnpModInt");
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven()) b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven()) d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac) a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac) c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
        if (d.compareTo(m) >= 0) return d.subtract(m);
        if (d.signum() < 0) d.addTo(m, d);
        else return d;
        if (d.signum() < 0) return d.add(m);
        else return d;
      }
      __name(bnModInverse, "bnModInverse");
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t2) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i]) return true;
          return false;
        }
        if (x.isEven()) return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j) if (m % lowprimes[i++] == 0) return false;
        }
        return x.millerRabin(t2);
      }
      __name(bnIsProbablePrime, "bnIsProbablePrime");
      function bnpMillerRabin(t2) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) return false;
        var r = n1.shiftRight(k);
        t2 = t2 + 1 >> 1;
        if (t2 > lowprimes.length) t2 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t2; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0) return false;
            }
            if (y.compareTo(n1) != 0) return false;
          }
        }
        return true;
      }
      __name(bnpMillerRabin, "bnpMillerRabin");
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
      }
      __name(rng_seed_int, "rng_seed_int");
      function rng_seed_time() {
        rng_seed_int((/* @__PURE__ */ new Date()).getTime());
      }
      __name(rng_seed_time, "rng_seed_time");
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t = 0; t < 32; ++t)
              rng_pool[rng_pptr++] = ua[t];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t = 0; t < z.length; ++t)
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      __name(rng_get_byte, "rng_get_byte");
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
      }
      __name(rng_get_bytes, "rng_get_bytes");
      function SecureRandom() {
      }
      __name(SecureRandom, "SecureRandom");
      SecureRandom.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      __name(Arcfour, "Arcfour");
      function ARC4init(key) {
        var i, j, t2;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key[i % key.length] & 255;
          t2 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t2;
        }
        this.i = 0;
        this.j = 0;
      }
      __name(ARC4init, "ARC4init");
      function ARC4next() {
        var t2;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t2 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t2;
        return this.S[t2 + this.S[this.i] & 255];
      }
      __name(ARC4next, "ARC4next");
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      __name(prng_newstate, "prng_newstate");
      var rng_psize = 256;
      {
        module.exports = {
          default: BigInteger,
          BigInteger,
          SecureRandom
        };
      }
    }).call(jsbn);
  })(jsbn$1);
  return jsbn$1.exports;
}
__name(requireJsbn, "requireJsbn");
var sprintf = {};
var hasRequiredSprintf;
function requireSprintf() {
  if (hasRequiredSprintf) return sprintf;
  hasRequiredSprintf = 1;
  (function(exports) {
    !function() {
      var re2 = {
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf2(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      __name(sprintf2, "sprintf2");
      function vsprintf(fmt, argv2) {
        return sprintf2.apply(null, [fmt].concat(argv2 || []));
      }
      __name(vsprintf, "vsprintf");
      function sprintf_format(parse_tree, argv2) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign2;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv2[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf2('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv2[ph.param_no];
            } else {
              arg = argv2[cursor++];
            }
            if (re2.not_type.test(ph.type) && re2.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re2.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf2("[sprintf] expecting number but found %T", arg));
            }
            if (re2.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re2.json.test(ph.type)) {
              output += arg;
            } else {
              if (re2.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign2 = is_positive ? "+" : "-";
                arg = arg.toString().replace(re2.sign, "");
              } else {
                sign2 = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign2 + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign2 + arg + pad : pad_character === "0" ? sign2 + pad + arg : pad + sign2 + arg;
            }
          }
        }
        return output;
      }
      __name(sprintf_format, "sprintf_format");
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re2.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re2.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re2.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re2.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re2.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re2.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      __name(sprintf_parse, "sprintf_parse");
      {
        exports["sprintf"] = sprintf2;
        exports["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf2;
        window["vsprintf"] = vsprintf;
      }
    }();
  })(sprintf);
  return sprintf;
}
__name(requireSprintf, "requireSprintf");
var hasRequiredIpv4;
function requireIpv4() {
  if (hasRequiredIpv4) return ipv4;
  hasRequiredIpv4 = 1;
  var __createBinding2 = ipv4 && ipv4.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
        return m[k];
      }, "get") };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = ipv4 && ipv4.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = ipv4 && ipv4.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(ipv4, "__esModule", { value: true });
  ipv4.Address4 = void 0;
  const common22 = __importStar2(requireCommon2());
  const constants22 = __importStar2(requireConstants$13());
  const address_error_1 = requireAddressError();
  const jsbn_1 = requireJsbn();
  const sprintf_js_1 = requireSprintf();
  class Address4 {
    static {
      __name(this, "Address4");
    }
    constructor(address) {
      this.groups = constants22.GROUPS;
      this.parsedAddress = [];
      this.parsedSubnet = "";
      this.subnet = "/32";
      this.subnetMask = 32;
      this.v4 = true;
      this.isCorrect = common22.isCorrect(constants22.BITS);
      this.isInSubnet = common22.isInSubnet;
      this.address = address;
      const subnet = constants22.RE_SUBNET_STRING.exec(address);
      if (subnet) {
        this.parsedSubnet = subnet[0].replace("/", "");
        this.subnetMask = parseInt(this.parsedSubnet, 10);
        this.subnet = `/${this.subnetMask}`;
        if (this.subnetMask < 0 || this.subnetMask > constants22.BITS) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        address = address.replace(constants22.RE_SUBNET_STRING, "");
      }
      this.addressMinusSuffix = address;
      this.parsedAddress = this.parse(address);
    }
    static isValid(address) {
      try {
        new Address4(address);
        return true;
      } catch (e) {
        return false;
      }
    }
    /*
     * Parses a v4 address
     */
    parse(address) {
      const groups = address.split(".");
      if (!address.match(constants22.RE_ADDRESS)) {
        throw new address_error_1.AddressError("Invalid IPv4 address.");
      }
      return groups;
    }
    /**
     * Returns the correct form of an address
     * @memberof Address4
     * @instance
     * @returns {String}
     */
    correctForm() {
      return this.parsedAddress.map((part) => parseInt(part, 10)).join(".");
    }
    /**
     * Converts a hex string to an IPv4 address object
     * @memberof Address4
     * @static
     * @param {string} hex - a hex string to convert
     * @returns {Address4}
     */
    static fromHex(hex) {
      const padded = hex.replace(/:/g, "").padStart(8, "0");
      const groups = [];
      let i;
      for (i = 0; i < 8; i += 2) {
        const h = padded.slice(i, i + 2);
        groups.push(parseInt(h, 16));
      }
      return new Address4(groups.join("."));
    }
    /**
     * Converts an integer into a IPv4 address object
     * @memberof Address4
     * @static
     * @param {integer} integer - a number to convert
     * @returns {Address4}
     */
    static fromInteger(integer) {
      return Address4.fromHex(integer.toString(16));
    }
    /**
     * Return an address from in-addr.arpa form
     * @memberof Address4
     * @static
     * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address
     * @returns {Adress4}
     * @example
     * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)
     * address.correctForm(); // '192.0.2.42'
     */
    static fromArpa(arpaFormAddress) {
      const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
      const address = leader.split(".").reverse().join(".");
      return new Address4(address);
    }
    /**
     * Converts an IPv4 address object to a hex string
     * @memberof Address4
     * @instance
     * @returns {String}
     */
    toHex() {
      return this.parsedAddress.map((part) => (0, sprintf_js_1.sprintf)("%02x", parseInt(part, 10))).join(":");
    }
    /**
     * Converts an IPv4 address object to an array of bytes
     * @memberof Address4
     * @instance
     * @returns {Array}
     */
    toArray() {
      return this.parsedAddress.map((part) => parseInt(part, 10));
    }
    /**
     * Converts an IPv4 address object to an IPv6 address group
     * @memberof Address4
     * @instance
     * @returns {String}
     */
    toGroup6() {
      const output = [];
      let i;
      for (i = 0; i < constants22.GROUPS; i += 2) {
        const hex = (0, sprintf_js_1.sprintf)("%02x%02x", parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
        output.push((0, sprintf_js_1.sprintf)("%x", parseInt(hex, 16)));
      }
      return output.join(":");
    }
    /**
     * Returns the address as a BigInteger
     * @memberof Address4
     * @instance
     * @returns {BigInteger}
     */
    bigInteger() {
      return new jsbn_1.BigInteger(this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%02x", parseInt(n, 10))).join(""), 16);
    }
    /**
     * Helper function getting start address.
     * @memberof Address4
     * @instance
     * @returns {BigInteger}
     */
    _startAddress() {
      return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants22.BITS - this.subnetMask), 2);
    }
    /**
     * The first address in the range given by this address' subnet.
     * Often referred to as the Network Address.
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */
    startAddress() {
      return Address4.fromBigInteger(this._startAddress());
    }
    /**
     * The first host address in the range given by this address's subnet ie
     * the first address after the Network Address
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */
    startAddressExclusive() {
      const adjust = new jsbn_1.BigInteger("1");
      return Address4.fromBigInteger(this._startAddress().add(adjust));
    }
    /**
     * Helper function getting end address.
     * @memberof Address4
     * @instance
     * @returns {BigInteger}
     */
    _endAddress() {
      return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants22.BITS - this.subnetMask), 2);
    }
    /**
     * The last address in the range given by this address' subnet
     * Often referred to as the Broadcast
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */
    endAddress() {
      return Address4.fromBigInteger(this._endAddress());
    }
    /**
     * The last host address in the range given by this address's subnet ie
     * the last address prior to the Broadcast Address
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */
    endAddressExclusive() {
      const adjust = new jsbn_1.BigInteger("1");
      return Address4.fromBigInteger(this._endAddress().subtract(adjust));
    }
    /**
     * Converts a BigInteger to a v4 address object
     * @memberof Address4
     * @static
     * @param {BigInteger} bigInteger - a BigInteger to convert
     * @returns {Address4}
     */
    static fromBigInteger(bigInteger) {
      return Address4.fromInteger(parseInt(bigInteger.toString(), 10));
    }
    /**
     * Returns the first n bits of the address, defaulting to the
     * subnet mask
     * @memberof Address4
     * @instance
     * @returns {String}
     */
    mask(mask) {
      if (mask === void 0) {
        mask = this.subnetMask;
      }
      return this.getBitsBase2(0, mask);
    }
    /**
     * Returns the bits in the given range as a base-2 string
     * @memberof Address4
     * @instance
     * @returns {string}
     */
    getBitsBase2(start, end) {
      return this.binaryZeroPad().slice(start, end);
    }
    /**
     * Return the reversed ip6.arpa form of the address
     * @memberof Address4
     * @param {Object} options
     * @param {boolean} options.omitSuffix - omit the "in-addr.arpa" suffix
     * @instance
     * @returns {String}
     */
    reverseForm(options2) {
      if (!options2) {
        options2 = {};
      }
      const reversed = this.correctForm().split(".").reverse().join(".");
      if (options2.omitSuffix) {
        return reversed;
      }
      return (0, sprintf_js_1.sprintf)("%s.in-addr.arpa.", reversed);
    }
    /**
     * Returns true if the given address is a multicast address
     * @memberof Address4
     * @instance
     * @returns {boolean}
     */
    isMulticast() {
      return this.isInSubnet(new Address4("224.0.0.0/4"));
    }
    /**
     * Returns a zero-padded base-2 string representation of the address
     * @memberof Address4
     * @instance
     * @returns {string}
     */
    binaryZeroPad() {
      return this.bigInteger().toString(2).padStart(constants22.BITS, "0");
    }
    /**
     * Groups an IPv4 address for inclusion at the end of an IPv6 address
     * @returns {String}
     */
    groupForV6() {
      const segments = this.parsedAddress;
      return this.address.replace(constants22.RE_ADDRESS, (0, sprintf_js_1.sprintf)('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
    }
  }
  ipv4.Address4 = Address4;
  return ipv4;
}
__name(requireIpv4, "requireIpv4");
var ipv6 = {};
var constants5 = {};
var hasRequiredConstants3;
function requireConstants3() {
  if (hasRequiredConstants3) return constants5;
  hasRequiredConstants3 = 1;
  Object.defineProperty(constants5, "__esModule", { value: true });
  constants5.RE_URL_WITH_PORT = constants5.RE_URL = constants5.RE_ZONE_STRING = constants5.RE_SUBNET_STRING = constants5.RE_BAD_ADDRESS = constants5.RE_BAD_CHARACTERS = constants5.TYPES = constants5.SCOPES = constants5.GROUPS = constants5.BITS = void 0;
  constants5.BITS = 128;
  constants5.GROUPS = 8;
  constants5.SCOPES = {
    0: "Reserved",
    1: "Interface local",
    2: "Link local",
    4: "Admin local",
    5: "Site local",
    8: "Organization local",
    14: "Global",
    15: "Reserved"
  };
  constants5.TYPES = {
    "ff01::1/128": "Multicast (All nodes on this interface)",
    "ff01::2/128": "Multicast (All routers on this interface)",
    "ff02::1/128": "Multicast (All nodes on this link)",
    "ff02::2/128": "Multicast (All routers on this link)",
    "ff05::2/128": "Multicast (All routers in this site)",
    "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
    "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
    "ff02::9/128": "Multicast (RIP routers)",
    "ff02::a/128": "Multicast (EIGRP routers)",
    "ff02::d/128": "Multicast (PIM routers)",
    "ff02::16/128": "Multicast (MLDv2 reports)",
    "ff01::fb/128": "Multicast (mDNSv6)",
    "ff02::fb/128": "Multicast (mDNSv6)",
    "ff05::fb/128": "Multicast (mDNSv6)",
    "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
    "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
    "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
    "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
    "::/128": "Unspecified",
    "::1/128": "Loopback",
    "ff00::/8": "Multicast",
    "fe80::/10": "Link-local unicast"
  };
  constants5.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
  constants5.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
  constants5.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
  constants5.RE_ZONE_STRING = /%.*$/;
  constants5.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
  constants5.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
  return constants5;
}
__name(requireConstants3, "requireConstants");
var helpers = {};
var hasRequiredHelpers$1;
function requireHelpers$1() {
  if (hasRequiredHelpers$1) return helpers;
  hasRequiredHelpers$1 = 1;
  Object.defineProperty(helpers, "__esModule", { value: true });
  helpers.simpleGroup = helpers.spanLeadingZeroes = helpers.spanAll = helpers.spanAllZeroes = void 0;
  const sprintf_js_1 = requireSprintf();
  function spanAllZeroes(s) {
    return s.replace(/(0+)/g, '<span class="zero">$1</span>');
  }
  __name(spanAllZeroes, "spanAllZeroes");
  helpers.spanAllZeroes = spanAllZeroes;
  function spanAll(s, offset = 0) {
    const letters = s.split("");
    return letters.map(
      (n, i) => (0, sprintf_js_1.sprintf)('<span class="digit value-%s position-%d">%s</span>', n, i + offset, spanAllZeroes(n))
      // XXX Use #base-2 .value-0 instead?
    ).join("");
  }
  __name(spanAll, "spanAll");
  helpers.spanAll = spanAll;
  function spanLeadingZeroesSimple(group3) {
    return group3.replace(/^(0+)/, '<span class="zero">$1</span>');
  }
  __name(spanLeadingZeroesSimple, "spanLeadingZeroesSimple");
  function spanLeadingZeroes(address) {
    const groups = address.split(":");
    return groups.map((g) => spanLeadingZeroesSimple(g)).join(":");
  }
  __name(spanLeadingZeroes, "spanLeadingZeroes");
  helpers.spanLeadingZeroes = spanLeadingZeroes;
  function simpleGroup(addressString, offset = 0) {
    const groups = addressString.split(":");
    return groups.map((g, i) => {
      if (/group-v4/.test(g)) {
        return g;
      }
      return (0, sprintf_js_1.sprintf)('<span class="hover-group group-%d">%s</span>', i + offset, spanLeadingZeroesSimple(g));
    });
  }
  __name(simpleGroup, "simpleGroup");
  helpers.simpleGroup = simpleGroup;
  return helpers;
}
__name(requireHelpers$1, "requireHelpers$1");
var regularExpressions = {};
var hasRequiredRegularExpressions;
function requireRegularExpressions() {
  if (hasRequiredRegularExpressions) return regularExpressions;
  hasRequiredRegularExpressions = 1;
  var __createBinding2 = regularExpressions && regularExpressions.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
        return m[k];
      }, "get") };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = regularExpressions && regularExpressions.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = regularExpressions && regularExpressions.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(regularExpressions, "__esModule", { value: true });
  regularExpressions.possibleElisions = regularExpressions.simpleRegularExpression = regularExpressions.ADDRESS_BOUNDARY = regularExpressions.padGroup = regularExpressions.groupPossibilities = void 0;
  const v6 = __importStar2(requireConstants3());
  const sprintf_js_1 = requireSprintf();
  function groupPossibilities(possibilities) {
    return (0, sprintf_js_1.sprintf)("(%s)", possibilities.join("|"));
  }
  __name(groupPossibilities, "groupPossibilities");
  regularExpressions.groupPossibilities = groupPossibilities;
  function padGroup(group3) {
    if (group3.length < 4) {
      return (0, sprintf_js_1.sprintf)("0{0,%d}%s", 4 - group3.length, group3);
    }
    return group3;
  }
  __name(padGroup, "padGroup");
  regularExpressions.padGroup = padGroup;
  regularExpressions.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
  function simpleRegularExpression(groups) {
    const zeroIndexes = [];
    groups.forEach((group3, i) => {
      const groupInteger = parseInt(group3, 16);
      if (groupInteger === 0) {
        zeroIndexes.push(i);
      }
    });
    const possibilities = zeroIndexes.map((zeroIndex) => groups.map((group3, i) => {
      if (i === zeroIndex) {
        const elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
        return groupPossibilities([padGroup(group3), elision]);
      }
      return padGroup(group3);
    }).join(":"));
    possibilities.push(groups.map(padGroup).join(":"));
    return groupPossibilities(possibilities);
  }
  __name(simpleRegularExpression, "simpleRegularExpression");
  regularExpressions.simpleRegularExpression = simpleRegularExpression;
  function possibleElisions(elidedGroups, moreLeft, moreRight) {
    const left = moreLeft ? "" : ":";
    const right = moreRight ? "" : ":";
    const possibilities = [];
    if (!moreLeft && !moreRight) {
      possibilities.push("::");
    }
    if (moreLeft && moreRight) {
      possibilities.push("");
    }
    if (moreRight && !moreLeft || !moreRight && moreLeft) {
      possibilities.push(":");
    }
    possibilities.push((0, sprintf_js_1.sprintf)("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
    possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
    possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
    for (let groups = 1; groups < elidedGroups - 1; groups++) {
      for (let position = 1; position < elidedGroups - groups; position++) {
        possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
      }
    }
    return groupPossibilities(possibilities);
  }
  __name(possibleElisions, "possibleElisions");
  regularExpressions.possibleElisions = possibleElisions;
  return regularExpressions;
}
__name(requireRegularExpressions, "requireRegularExpressions");
var hasRequiredIpv6;
function requireIpv6() {
  if (hasRequiredIpv6) return ipv6;
  hasRequiredIpv6 = 1;
  var __createBinding2 = ipv6 && ipv6.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
        return m[k];
      }, "get") };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = ipv6 && ipv6.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = ipv6 && ipv6.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(ipv6, "__esModule", { value: true });
  ipv6.Address6 = void 0;
  const common22 = __importStar2(requireCommon2());
  const constants42 = __importStar2(requireConstants$13());
  const constants62 = __importStar2(requireConstants3());
  const helpers2 = __importStar2(requireHelpers$1());
  const ipv4_1 = requireIpv4();
  const regular_expressions_1 = requireRegularExpressions();
  const address_error_1 = requireAddressError();
  const jsbn_1 = requireJsbn();
  const sprintf_js_1 = requireSprintf();
  function assert4(condition) {
    if (!condition) {
      throw new Error("Assertion failed.");
    }
  }
  __name(assert4, "assert");
  function addCommas(number) {
    const r = /(\d+)(\d{3})/;
    while (r.test(number)) {
      number = number.replace(r, "$1,$2");
    }
    return number;
  }
  __name(addCommas, "addCommas");
  function spanLeadingZeroes4(n) {
    n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
    n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
    return n;
  }
  __name(spanLeadingZeroes4, "spanLeadingZeroes4");
  function compact(address, slice) {
    const s1 = [];
    const s2 = [];
    let i;
    for (i = 0; i < address.length; i++) {
      if (i < slice[0]) {
        s1.push(address[i]);
      } else if (i > slice[1]) {
        s2.push(address[i]);
      }
    }
    return s1.concat(["compact"]).concat(s2);
  }
  __name(compact, "compact");
  function paddedHex(octet) {
    return (0, sprintf_js_1.sprintf)("%04x", parseInt(octet, 16));
  }
  __name(paddedHex, "paddedHex");
  function unsignByte(b) {
    return b & 255;
  }
  __name(unsignByte, "unsignByte");
  class Address6 {
    static {
      __name(this, "Address6");
    }
    constructor(address, optionalGroups) {
      this.addressMinusSuffix = "";
      this.parsedSubnet = "";
      this.subnet = "/128";
      this.subnetMask = 128;
      this.v4 = false;
      this.zone = "";
      this.isInSubnet = common22.isInSubnet;
      this.isCorrect = common22.isCorrect(constants62.BITS);
      if (optionalGroups === void 0) {
        this.groups = constants62.GROUPS;
      } else {
        this.groups = optionalGroups;
      }
      this.address = address;
      const subnet = constants62.RE_SUBNET_STRING.exec(address);
      if (subnet) {
        this.parsedSubnet = subnet[0].replace("/", "");
        this.subnetMask = parseInt(this.parsedSubnet, 10);
        this.subnet = `/${this.subnetMask}`;
        if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants62.BITS) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        address = address.replace(constants62.RE_SUBNET_STRING, "");
      } else if (/\//.test(address)) {
        throw new address_error_1.AddressError("Invalid subnet mask.");
      }
      const zone = constants62.RE_ZONE_STRING.exec(address);
      if (zone) {
        this.zone = zone[0];
        address = address.replace(constants62.RE_ZONE_STRING, "");
      }
      this.addressMinusSuffix = address;
      this.parsedAddress = this.parse(this.addressMinusSuffix);
    }
    static isValid(address) {
      try {
        new Address6(address);
        return true;
      } catch (e) {
        return false;
      }
    }
    /**
     * Convert a BigInteger to a v6 address object
     * @memberof Address6
     * @static
     * @param {BigInteger} bigInteger - a BigInteger to convert
     * @returns {Address6}
     * @example
     * var bigInteger = new BigInteger('1000000000000');
     * var address = Address6.fromBigInteger(bigInteger);
     * address.correctForm(); // '::e8:d4a5:1000'
     */
    static fromBigInteger(bigInteger) {
      const hex = bigInteger.toString(16).padStart(32, "0");
      const groups = [];
      let i;
      for (i = 0; i < constants62.GROUPS; i++) {
        groups.push(hex.slice(i * 4, (i + 1) * 4));
      }
      return new Address6(groups.join(":"));
    }
    /**
     * Convert a URL (with optional port number) to an address object
     * @memberof Address6
     * @static
     * @param {string} url - a URL with optional port number
     * @example
     * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');
     * addressAndPort.address.correctForm(); // 'ffff::'
     * addressAndPort.port; // 8080
     */
    static fromURL(url4) {
      let host;
      let port = null;
      let result;
      if (url4.indexOf("[") !== -1 && url4.indexOf("]:") !== -1) {
        result = constants62.RE_URL_WITH_PORT.exec(url4);
        if (result === null) {
          return {
            error: "failed to parse address with port",
            address: null,
            port: null
          };
        }
        host = result[1];
        port = result[2];
      } else if (url4.indexOf("/") !== -1) {
        url4 = url4.replace(/^[a-z0-9]+:\/\//, "");
        result = constants62.RE_URL.exec(url4);
        if (result === null) {
          return {
            error: "failed to parse address from URL",
            address: null,
            port: null
          };
        }
        host = result[1];
      } else {
        host = url4;
      }
      if (port) {
        port = parseInt(port, 10);
        if (port < 0 || port > 65536) {
          port = null;
        }
      } else {
        port = null;
      }
      return {
        address: new Address6(host),
        port
      };
    }
    /**
     * Create an IPv6-mapped address given an IPv4 address
     * @memberof Address6
     * @static
     * @param {string} address - An IPv4 address string
     * @returns {Address6}
     * @example
     * var address = Address6.fromAddress4('192.168.0.1');
     * address.correctForm(); // '::ffff:c0a8:1'
     * address.to4in6(); // '::ffff:192.168.0.1'
     */
    static fromAddress4(address) {
      const address4 = new ipv4_1.Address4(address);
      const mask6 = constants62.BITS - (constants42.BITS - address4.subnetMask);
      return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);
    }
    /**
     * Return an address from ip6.arpa form
     * @memberof Address6
     * @static
     * @param {string} arpaFormAddress - an 'ip6.arpa' form address
     * @returns {Adress6}
     * @example
     * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)
     * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'
     */
    static fromArpa(arpaFormAddress) {
      let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
      const semicolonAmount = 7;
      if (address.length !== 63) {
        throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
      }
      const parts = address.split(".").reverse();
      for (let i = semicolonAmount; i > 0; i--) {
        const insertIndex = i * 4;
        parts.splice(insertIndex, 0, ":");
      }
      address = parts.join("");
      return new Address6(address);
    }
    /**
     * Return the Microsoft UNC transcription of the address
     * @memberof Address6
     * @instance
     * @returns {String} the Microsoft UNC transcription of the address
     */
    microsoftTranscription() {
      return (0, sprintf_js_1.sprintf)("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
    }
    /**
     * Return the first n bits of the address, defaulting to the subnet mask
     * @memberof Address6
     * @instance
     * @param {number} [mask=subnet] - the number of bits to mask
     * @returns {String} the first n bits of the address as a string
     */
    mask(mask = this.subnetMask) {
      return this.getBitsBase2(0, mask);
    }
    /**
     * Return the number of possible subnets of a given size in the address
     * @memberof Address6
     * @instance
     * @param {number} [size=128] - the subnet size
     * @returns {String}
     */
    // TODO: probably useful to have a numeric version of this too
    possibleSubnets(subnetSize = 128) {
      const availableBits = constants62.BITS - this.subnetMask;
      const subnetBits = Math.abs(subnetSize - constants62.BITS);
      const subnetPowers = availableBits - subnetBits;
      if (subnetPowers < 0) {
        return "0";
      }
      return addCommas(new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10));
    }
    /**
     * Helper function getting start address.
     * @memberof Address6
     * @instance
     * @returns {BigInteger}
     */
    _startAddress() {
      return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants62.BITS - this.subnetMask), 2);
    }
    /**
     * The first address in the range given by this address' subnet
     * Often referred to as the Network Address.
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */
    startAddress() {
      return Address6.fromBigInteger(this._startAddress());
    }
    /**
     * The first host address in the range given by this address's subnet ie
     * the first address after the Network Address
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */
    startAddressExclusive() {
      const adjust = new jsbn_1.BigInteger("1");
      return Address6.fromBigInteger(this._startAddress().add(adjust));
    }
    /**
     * Helper function getting end address.
     * @memberof Address6
     * @instance
     * @returns {BigInteger}
     */
    _endAddress() {
      return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants62.BITS - this.subnetMask), 2);
    }
    /**
     * The last address in the range given by this address' subnet
     * Often referred to as the Broadcast
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */
    endAddress() {
      return Address6.fromBigInteger(this._endAddress());
    }
    /**
     * The last host address in the range given by this address's subnet ie
     * the last address prior to the Broadcast Address
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */
    endAddressExclusive() {
      const adjust = new jsbn_1.BigInteger("1");
      return Address6.fromBigInteger(this._endAddress().subtract(adjust));
    }
    /**
     * Return the scope of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    getScope() {
      let scope = constants62.SCOPES[this.getBits(12, 16).intValue()];
      if (this.getType() === "Global unicast" && scope !== "Link local") {
        scope = "Global";
      }
      return scope || "Unknown";
    }
    /**
     * Return the type of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    getType() {
      for (const subnet of Object.keys(constants62.TYPES)) {
        if (this.isInSubnet(new Address6(subnet))) {
          return constants62.TYPES[subnet];
        }
      }
      return "Global unicast";
    }
    /**
     * Return the bits in the given range as a BigInteger
     * @memberof Address6
     * @instance
     * @returns {BigInteger}
     */
    getBits(start, end) {
      return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
    }
    /**
     * Return the bits in the given range as a base-2 string
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    getBitsBase2(start, end) {
      return this.binaryZeroPad().slice(start, end);
    }
    /**
     * Return the bits in the given range as a base-16 string
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    getBitsBase16(start, end) {
      const length = end - start;
      if (length % 4 !== 0) {
        throw new Error("Length of bits to retrieve must be divisible by four");
      }
      return this.getBits(start, end).toString(16).padStart(length / 4, "0");
    }
    /**
     * Return the bits that are set past the subnet mask length
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    getBitsPastSubnet() {
      return this.getBitsBase2(this.subnetMask, constants62.BITS);
    }
    /**
     * Return the reversed ip6.arpa form of the address
     * @memberof Address6
     * @param {Object} options
     * @param {boolean} options.omitSuffix - omit the "ip6.arpa" suffix
     * @instance
     * @returns {String}
     */
    reverseForm(options2) {
      if (!options2) {
        options2 = {};
      }
      const characters = Math.floor(this.subnetMask / 4);
      const reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
      if (characters > 0) {
        if (options2.omitSuffix) {
          return reversed;
        }
        return (0, sprintf_js_1.sprintf)("%s.ip6.arpa.", reversed);
      }
      if (options2.omitSuffix) {
        return "";
      }
      return "ip6.arpa.";
    }
    /**
     * Return the correct form of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    correctForm() {
      let i;
      let groups = [];
      let zeroCounter = 0;
      const zeroes = [];
      for (i = 0; i < this.parsedAddress.length; i++) {
        const value = parseInt(this.parsedAddress[i], 16);
        if (value === 0) {
          zeroCounter++;
        }
        if (value !== 0 && zeroCounter > 0) {
          if (zeroCounter > 1) {
            zeroes.push([i - zeroCounter, i - 1]);
          }
          zeroCounter = 0;
        }
      }
      if (zeroCounter > 1) {
        zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
      }
      const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);
      if (zeroes.length > 0) {
        const index2 = zeroLengths.indexOf(Math.max(...zeroLengths));
        groups = compact(this.parsedAddress, zeroes[index2]);
      } else {
        groups = this.parsedAddress;
      }
      for (i = 0; i < groups.length; i++) {
        if (groups[i] !== "compact") {
          groups[i] = parseInt(groups[i], 16).toString(16);
        }
      }
      let correct = groups.join(":");
      correct = correct.replace(/^compact$/, "::");
      correct = correct.replace(/^compact|compact$/, ":");
      correct = correct.replace(/compact/, "");
      return correct;
    }
    /**
     * Return a zero-padded base-2 string representation of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     * @example
     * var address = new Address6('2001:4860:4001:803::1011');
     * address.binaryZeroPad();
     * // '0010000000000001010010000110000001000000000000010000100000000011
     * //  0000000000000000000000000000000000000000000000000001000000010001'
     */
    binaryZeroPad() {
      return this.bigInteger().toString(2).padStart(constants62.BITS, "0");
    }
    // TODO: Improve the semantics of this helper function
    parse4in6(address) {
      const groups = address.split(":");
      const lastGroup = groups.slice(-1)[0];
      const address4 = lastGroup.match(constants42.RE_ADDRESS);
      if (address4) {
        this.parsedAddress4 = address4[0];
        this.address4 = new ipv4_1.Address4(this.parsedAddress4);
        for (let i = 0; i < this.address4.groups; i++) {
          if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
            throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants42.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
          }
        }
        this.v4 = true;
        groups[groups.length - 1] = this.address4.toGroup6();
        address = groups.join(":");
      }
      return address;
    }
    // TODO: Make private?
    parse(address) {
      address = this.parse4in6(address);
      const badCharacters = address.match(constants62.RE_BAD_CHARACTERS);
      if (badCharacters) {
        throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join("")), address.replace(constants62.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
      }
      const badAddress = address.match(constants62.RE_BAD_ADDRESS);
      if (badAddress) {
        throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Address failed regex: %s", badAddress.join("")), address.replace(constants62.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
      }
      let groups = [];
      const halves = address.split("::");
      if (halves.length === 2) {
        let first = halves[0].split(":");
        let last = halves[1].split(":");
        if (first.length === 1 && first[0] === "") {
          first = [];
        }
        if (last.length === 1 && last[0] === "") {
          last = [];
        }
        const remaining = this.groups - (first.length + last.length);
        if (!remaining) {
          throw new address_error_1.AddressError("Error parsing groups");
        }
        this.elidedGroups = remaining;
        this.elisionBegin = first.length;
        this.elisionEnd = first.length + this.elidedGroups;
        groups = groups.concat(first);
        for (let i = 0; i < remaining; i++) {
          groups.push("0");
        }
        groups = groups.concat(last);
      } else if (halves.length === 1) {
        groups = address.split(":");
        this.elidedGroups = 0;
      } else {
        throw new address_error_1.AddressError("Too many :: groups found");
      }
      groups = groups.map((group3) => (0, sprintf_js_1.sprintf)("%x", parseInt(group3, 16)));
      if (groups.length !== this.groups) {
        throw new address_error_1.AddressError("Incorrect number of groups found");
      }
      return groups;
    }
    /**
     * Return the canonical form of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    canonicalForm() {
      return this.parsedAddress.map(paddedHex).join(":");
    }
    /**
     * Return the decimal form of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    decimal() {
      return this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%05d", parseInt(n, 16))).join(":");
    }
    /**
     * Return the address as a BigInteger
     * @memberof Address6
     * @instance
     * @returns {BigInteger}
     */
    bigInteger() {
      return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
    }
    /**
     * Return the last two groups of this address as an IPv4 address string
     * @memberof Address6
     * @instance
     * @returns {Address4}
     * @example
     * var address = new Address6('2001:4860:4001::1825:bf11');
     * address.to4().correctForm(); // '24.37.191.17'
     */
    to4() {
      const binary2 = this.binaryZeroPad().split("");
      return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary2.slice(96, 128).join(""), 2).toString(16));
    }
    /**
     * Return the v4-in-v6 form of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    to4in6() {
      const address4 = this.to4();
      const address6 = new Address6(this.parsedAddress.slice(0, 6).join(":"), 6);
      const correct = address6.correctForm();
      let infix = "";
      if (!/:$/.test(correct)) {
        infix = ":";
      }
      return correct + infix + address4.address;
    }
    /**
     * Return an object containing the Teredo properties of the address
     * @memberof Address6
     * @instance
     * @returns {Object}
     */
    inspectTeredo() {
      const prefix = this.getBitsBase16(0, 32);
      const udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger("ffff", 16)).toString();
      const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
      const client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger("ffffffff", 16)).toString(16));
      const flags = this.getBits(64, 80);
      const flagsBase2 = this.getBitsBase2(64, 80);
      const coneNat = flags.testBit(15);
      const reserved = flags.testBit(14);
      const groupIndividual = flags.testBit(8);
      const universalLocal = flags.testBit(9);
      const nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
      return {
        prefix: (0, sprintf_js_1.sprintf)("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
        server4: server4.address,
        client4: client4.address,
        flags: flagsBase2,
        coneNat,
        microsoft: {
          reserved,
          universalLocal,
          groupIndividual,
          nonce
        },
        udpPort
      };
    }
    /**
     * Return an object containing the 6to4 properties of the address
     * @memberof Address6
     * @instance
     * @returns {Object}
     */
    inspect6to4() {
      const prefix = this.getBitsBase16(0, 16);
      const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
      return {
        prefix: (0, sprintf_js_1.sprintf)("%s", prefix.slice(0, 4)),
        gateway: gateway.address
      };
    }
    /**
     * Return a v6 6to4 address from a v6 v4inv6 address
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */
    to6to4() {
      if (!this.is4()) {
        return null;
      }
      const addr6to4 = [
        "2002",
        this.getBitsBase16(96, 112),
        this.getBitsBase16(112, 128),
        "",
        "/16"
      ].join(":");
      return new Address6(addr6to4);
    }
    /**
     * Return a byte array
     * @memberof Address6
     * @instance
     * @returns {Array}
     */
    toByteArray() {
      const byteArray = this.bigInteger().toByteArray();
      if (byteArray.length === 17 && byteArray[0] === 0) {
        return byteArray.slice(1);
      }
      return byteArray;
    }
    /**
     * Return an unsigned byte array
     * @memberof Address6
     * @instance
     * @returns {Array}
     */
    toUnsignedByteArray() {
      return this.toByteArray().map(unsignByte);
    }
    /**
     * Convert a byte array to an Address6 object
     * @memberof Address6
     * @static
     * @returns {Address6}
     */
    static fromByteArray(bytes) {
      return this.fromUnsignedByteArray(bytes.map(unsignByte));
    }
    /**
     * Convert an unsigned byte array to an Address6 object
     * @memberof Address6
     * @static
     * @returns {Address6}
     */
    static fromUnsignedByteArray(bytes) {
      const BYTE_MAX = new jsbn_1.BigInteger("256", 10);
      let result = new jsbn_1.BigInteger("0", 10);
      let multiplier = new jsbn_1.BigInteger("1", 10);
      for (let i = bytes.length - 1; i >= 0; i--) {
        result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes[i].toString(10), 10)));
        multiplier = multiplier.multiply(BYTE_MAX);
      }
      return Address6.fromBigInteger(result);
    }
    /**
     * Returns true if the address is in the canonical form, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    isCanonical() {
      return this.addressMinusSuffix === this.canonicalForm();
    }
    /**
     * Returns true if the address is a link local address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    isLinkLocal() {
      if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
        return true;
      }
      return false;
    }
    /**
     * Returns true if the address is a multicast address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    isMulticast() {
      return this.getType() === "Multicast";
    }
    /**
     * Returns true if the address is a v4-in-v6 address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    is4() {
      return this.v4;
    }
    /**
     * Returns true if the address is a Teredo address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    isTeredo() {
      return this.isInSubnet(new Address6("2001::/32"));
    }
    /**
     * Returns true if the address is a 6to4 address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    is6to4() {
      return this.isInSubnet(new Address6("2002::/16"));
    }
    /**
     * Returns true if the address is a loopback address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    isLoopback() {
      return this.getType() === "Loopback";
    }
    // #endregion
    // #region HTML
    /**
     * @returns {String} the address in link form with a default port of 80
     */
    href(optionalPort) {
      if (optionalPort === void 0) {
        optionalPort = "";
      } else {
        optionalPort = (0, sprintf_js_1.sprintf)(":%s", optionalPort);
      }
      return (0, sprintf_js_1.sprintf)("http://[%s]%s/", this.correctForm(), optionalPort);
    }
    /**
     * @returns {String} a link suitable for conveying the address via a URL hash
     */
    link(options2) {
      if (!options2) {
        options2 = {};
      }
      if (options2.className === void 0) {
        options2.className = "";
      }
      if (options2.prefix === void 0) {
        options2.prefix = "/#address=";
      }
      if (options2.v4 === void 0) {
        options2.v4 = false;
      }
      let formFunction = this.correctForm;
      if (options2.v4) {
        formFunction = this.to4in6;
      }
      if (options2.className) {
        return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options2.prefix, formFunction.call(this), options2.className);
      }
      return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s">%2$s</a>', options2.prefix, formFunction.call(this));
    }
    /**
     * Groups an address
     * @returns {String}
     */
    group() {
      if (this.elidedGroups === 0) {
        return helpers2.simpleGroup(this.address).join(":");
      }
      assert4(typeof this.elidedGroups === "number");
      assert4(typeof this.elisionBegin === "number");
      const output = [];
      const [left, right] = this.address.split("::");
      if (left.length) {
        output.push(...helpers2.simpleGroup(left));
      } else {
        output.push("");
      }
      const classes = ["hover-group"];
      for (let i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
        classes.push((0, sprintf_js_1.sprintf)("group-%d", i));
      }
      output.push((0, sprintf_js_1.sprintf)('<span class="%s"></span>', classes.join(" ")));
      if (right.length) {
        output.push(...helpers2.simpleGroup(right, this.elisionEnd));
      } else {
        output.push("");
      }
      if (this.is4()) {
        assert4(this.address4 instanceof ipv4_1.Address4);
        output.pop();
        output.push(this.address4.groupForV6());
      }
      return output.join(":");
    }
    // #endregion
    // #region Regular expressions
    /**
     * Generate a regular expression string that can be used to find or validate
     * all variations of this address
     * @memberof Address6
     * @instance
     * @param {boolean} substringSearch
     * @returns {string}
     */
    regularExpressionString(substringSearch = false) {
      let output = [];
      const address6 = new Address6(this.correctForm());
      if (address6.elidedGroups === 0) {
        output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));
      } else if (address6.elidedGroups === constants62.GROUPS) {
        output.push((0, regular_expressions_1.possibleElisions)(constants62.GROUPS));
      } else {
        const halves = address6.address.split("::");
        if (halves[0].length) {
          output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(":")));
        }
        assert4(typeof address6.elidedGroups === "number");
        output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
        if (halves[1].length) {
          output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(":")));
        }
        output = [output.join(":")];
      }
      if (!substringSearch) {
        output = [
          "(?=^|",
          regular_expressions_1.ADDRESS_BOUNDARY,
          "|[^\\w\\:])(",
          ...output,
          ")(?=[^\\w\\:]|",
          regular_expressions_1.ADDRESS_BOUNDARY,
          "|$)"
        ];
      }
      return output.join("");
    }
    /**
     * Generate a regular expression that can be used to find or validate all
     * variations of this address.
     * @memberof Address6
     * @instance
     * @param {boolean} substringSearch
     * @returns {RegExp}
     */
    regularExpression(substringSearch = false) {
      return new RegExp(this.regularExpressionString(substringSearch), "i");
    }
  }
  ipv6.Address6 = Address6;
  return ipv6;
}
__name(requireIpv6, "requireIpv6");
var hasRequiredIpAddress;
function requireIpAddress() {
  if (hasRequiredIpAddress) return ipAddress;
  hasRequiredIpAddress = 1;
  (function(exports) {
    var __createBinding2 = ipAddress && ipAddress.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = ipAddress && ipAddress.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = ipAddress && ipAddress.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.v6 = exports.AddressError = exports.Address6 = exports.Address4 = void 0;
    const ipv4_1 = requireIpv4();
    Object.defineProperty(exports, "Address4", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ipv4_1.Address4;
    }, "get") });
    const ipv6_1 = requireIpv6();
    Object.defineProperty(exports, "Address6", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ipv6_1.Address6;
    }, "get") });
    const address_error_1 = requireAddressError();
    Object.defineProperty(exports, "AddressError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return address_error_1.AddressError;
    }, "get") });
    const helpers2 = __importStar2(requireHelpers$1());
    exports.v6 = { helpers: helpers2 };
  })(ipAddress);
  return ipAddress;
}
__name(requireIpAddress, "requireIpAddress");
var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return helpers$1;
  hasRequiredHelpers = 1;
  Object.defineProperty(helpers$1, "__esModule", { value: true });
  helpers$1.ipToBuffer = helpers$1.int32ToIpv4 = helpers$1.ipv4ToInt32 = helpers$1.validateSocksClientChainOptions = helpers$1.validateSocksClientOptions = void 0;
  const util_1 = requireUtil2();
  const constants_1 = requireConstants$2();
  const stream = require$$63;
  const ip_address_1 = requireIpAddress();
  const net$1 = net;
  function validateSocksClientOptions(options2, acceptedCommands = ["connect", "bind", "associate"]) {
    if (!constants_1.SocksCommand[options2.command]) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options2);
    }
    if (acceptedCommands.indexOf(options2.command) === -1) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options2);
    }
    if (!isValidSocksRemoteHost(options2.destination)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options2);
    }
    if (!isValidSocksProxy(options2.proxy)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options2);
    }
    validateCustomProxyAuth(options2.proxy, options2);
    if (options2.timeout && !isValidTimeoutValue(options2.timeout)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options2);
    }
    if (options2.existing_socket && !(options2.existing_socket instanceof stream.Duplex)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options2);
    }
  }
  __name(validateSocksClientOptions, "validateSocksClientOptions");
  helpers$1.validateSocksClientOptions = validateSocksClientOptions;
  function validateSocksClientChainOptions(options2) {
    if (options2.command !== "connect") {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options2);
    }
    if (!isValidSocksRemoteHost(options2.destination)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options2);
    }
    if (!(options2.proxies && Array.isArray(options2.proxies) && options2.proxies.length >= 2)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options2);
    }
    options2.proxies.forEach((proxy) => {
      if (!isValidSocksProxy(proxy)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options2);
      }
      validateCustomProxyAuth(proxy, options2);
    });
    if (options2.timeout && !isValidTimeoutValue(options2.timeout)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options2);
    }
  }
  __name(validateSocksClientChainOptions, "validateSocksClientChainOptions");
  helpers$1.validateSocksClientChainOptions = validateSocksClientChainOptions;
  function validateCustomProxyAuth(proxy, options2) {
    if (proxy.custom_auth_method !== void 0) {
      if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options2);
      }
      if (proxy.custom_auth_request_handler === void 0 || typeof proxy.custom_auth_request_handler !== "function") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options2);
      }
      if (proxy.custom_auth_response_size === void 0) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options2);
      }
      if (proxy.custom_auth_response_handler === void 0 || typeof proxy.custom_auth_response_handler !== "function") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options2);
      }
    }
  }
  __name(validateCustomProxyAuth, "validateCustomProxyAuth");
  function isValidSocksRemoteHost(remoteHost) {
    return remoteHost && typeof remoteHost.host === "string" && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
  }
  __name(isValidSocksRemoteHost, "isValidSocksRemoteHost");
  function isValidSocksProxy(proxy) {
    return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
  }
  __name(isValidSocksProxy, "isValidSocksProxy");
  function isValidTimeoutValue(value) {
    return typeof value === "number" && value > 0;
  }
  __name(isValidTimeoutValue, "isValidTimeoutValue");
  function ipv4ToInt32(ip) {
    const address = new ip_address_1.Address4(ip);
    return address.toArray().reduce((acc, part) => (acc << 8) + part, 0);
  }
  __name(ipv4ToInt32, "ipv4ToInt32");
  helpers$1.ipv4ToInt32 = ipv4ToInt32;
  function int32ToIpv4(int32) {
    const octet1 = int32 >>> 24 & 255;
    const octet2 = int32 >>> 16 & 255;
    const octet3 = int32 >>> 8 & 255;
    const octet4 = int32 & 255;
    return [octet1, octet2, octet3, octet4].join(".");
  }
  __name(int32ToIpv4, "int32ToIpv4");
  helpers$1.int32ToIpv4 = int32ToIpv4;
  function ipToBuffer(ip) {
    if (net$1.isIPv4(ip)) {
      const address = new ip_address_1.Address4(ip);
      return Buffer.from(address.toArray());
    } else if (net$1.isIPv6(ip)) {
      const address = new ip_address_1.Address6(ip);
      return Buffer.from(address.canonicalForm().split(":").map((segment) => segment.padStart(4, "0")).join(""), "hex");
    } else {
      throw new Error("Invalid IP address format");
    }
  }
  __name(ipToBuffer, "ipToBuffer");
  helpers$1.ipToBuffer = ipToBuffer;
  return helpers$1;
}
__name(requireHelpers, "requireHelpers");
var receivebuffer = {};
var hasRequiredReceivebuffer;
function requireReceivebuffer() {
  if (hasRequiredReceivebuffer) return receivebuffer;
  hasRequiredReceivebuffer = 1;
  Object.defineProperty(receivebuffer, "__esModule", { value: true });
  receivebuffer.ReceiveBuffer = void 0;
  class ReceiveBuffer {
    static {
      __name(this, "ReceiveBuffer");
    }
    constructor(size = 4096) {
      this.buffer = Buffer.allocUnsafe(size);
      this.offset = 0;
      this.originalSize = size;
    }
    get length() {
      return this.offset;
    }
    append(data) {
      if (!Buffer.isBuffer(data)) {
        throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
      }
      if (this.offset + data.length >= this.buffer.length) {
        const tmp = this.buffer;
        this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
        tmp.copy(this.buffer);
      }
      data.copy(this.buffer, this.offset);
      return this.offset += data.length;
    }
    peek(length) {
      if (length > this.offset) {
        throw new Error("Attempted to read beyond the bounds of the managed internal data.");
      }
      return this.buffer.slice(0, length);
    }
    get(length) {
      if (length > this.offset) {
        throw new Error("Attempted to read beyond the bounds of the managed internal data.");
      }
      const value = Buffer.allocUnsafe(length);
      this.buffer.slice(0, length).copy(value);
      this.buffer.copyWithin(0, length, length + this.offset - length);
      this.offset -= length;
      return value;
    }
  }
  receivebuffer.ReceiveBuffer = ReceiveBuffer;
  return receivebuffer;
}
__name(requireReceivebuffer, "requireReceivebuffer");
var hasRequiredSocksclient;
function requireSocksclient() {
  if (hasRequiredSocksclient) return socksclient;
  hasRequiredSocksclient = 1;
  (function(exports) {
    var __awaiter2 = socksclient && socksclient.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocksClientError = exports.SocksClient = void 0;
    const events_1 = require$$0$32;
    const net$1 = net;
    const smart_buffer_1 = requireSmartbuffer();
    const constants_1 = requireConstants$2();
    const helpers_1 = requireHelpers();
    const receivebuffer_1 = requireReceivebuffer();
    const util_1 = requireUtil2();
    Object.defineProperty(exports, "SocksClientError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return util_1.SocksClientError;
    }, "get") });
    const ip_address_1 = requireIpAddress();
    class SocksClient extends events_1.EventEmitter {
      static {
        __name(this, "SocksClient");
      }
      constructor(options2) {
        super();
        this.options = Object.assign({}, options2);
        (0, helpers_1.validateSocksClientOptions)(options2);
        this.setState(constants_1.SocksClientState.Created);
      }
      /**
       * Creates a new SOCKS connection.
       *
       * Note: Supports callbacks and promises. Only supports the connect command.
       * @param options { SocksClientOptions } Options.
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnection(options2, callback) {
        return new Promise((resolve, reject) => {
          try {
            (0, helpers_1.validateSocksClientOptions)(options2, ["connect"]);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          const client = new SocksClient(options2);
          client.connect(options2.existing_socket);
          client.once("established", (info3) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(null, info3);
              resolve(info3);
            } else {
              resolve(info3);
            }
          });
          client.once("error", (err) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          });
        });
      }
      /**
       * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.
       *
       * Note: Supports callbacks and promises. Only supports the connect method.
       * Note: Implemented via createConnection() factory function.
       * @param options { SocksClientChainOptions } Options
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnectionChain(options2, callback) {
        return new Promise((resolve, reject) => __awaiter2(this, void 0, void 0, function* () {
          try {
            (0, helpers_1.validateSocksClientChainOptions)(options2);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          if (options2.randomizeChain) {
            (0, util_1.shuffleArray)(options2.proxies);
          }
          try {
            let sock;
            for (let i = 0; i < options2.proxies.length; i++) {
              const nextProxy = options2.proxies[i];
              const nextDestination = i === options2.proxies.length - 1 ? options2.destination : {
                host: options2.proxies[i + 1].host || options2.proxies[i + 1].ipaddress,
                port: options2.proxies[i + 1].port
              };
              const result = yield SocksClient.createConnection({
                command: "connect",
                proxy: nextProxy,
                destination: nextDestination,
                existing_socket: sock
              });
              sock = sock || result.socket;
            }
            if (typeof callback === "function") {
              callback(null, { socket: sock });
              resolve({ socket: sock });
            } else {
              resolve({ socket: sock });
            }
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          }
        }));
      }
      /**
       * Creates a SOCKS UDP Frame.
       * @param options
       */
      static createUDPFrame(options2) {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt16BE(0);
        buff.writeUInt8(options2.frameNumber || 0);
        if (net$1.isIPv4(options2.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options2.remoteHost.host));
        } else if (net$1.isIPv6(options2.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(options2.remoteHost.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(Buffer.byteLength(options2.remoteHost.host));
          buff.writeString(options2.remoteHost.host);
        }
        buff.writeUInt16BE(options2.remoteHost.port);
        buff.writeBuffer(options2.data);
        return buff.toBuffer();
      }
      /**
       * Parses a SOCKS UDP frame.
       * @param data
       */
      static parseUDPFrame(data) {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
        buff.readOffset = 2;
        const frameNumber = buff.readUInt8();
        const hostType = buff.readUInt8();
        let remoteHost;
        if (hostType === constants_1.Socks5HostType.IPv4) {
          remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
        } else if (hostType === constants_1.Socks5HostType.IPv6) {
          remoteHost = ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();
        } else {
          remoteHost = buff.readString(buff.readUInt8());
        }
        const remotePort = buff.readUInt16BE();
        return {
          frameNumber,
          remoteHost: {
            host: remoteHost,
            port: remotePort
          },
          data: buff.readBuffer()
        };
      }
      /**
       * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.
       */
      setState(newState) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.state = newState;
        }
      }
      /**
       * Starts the connection establishment to the proxy and destination.
       * @param existingSocket Connected socket to use instead of creating a new one (internal use).
       */
      connect(existingSocket) {
        this.onDataReceived = (data) => this.onDataReceivedHandler(data);
        this.onClose = () => this.onCloseHandler();
        this.onError = (err) => this.onErrorHandler(err);
        this.onConnect = () => this.onConnectHandler();
        const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
        if (timer.unref && typeof timer.unref === "function") {
          timer.unref();
        }
        if (existingSocket) {
          this.socket = existingSocket;
        } else {
          this.socket = new net$1.Socket();
        }
        this.socket.once("close", this.onClose);
        this.socket.once("error", this.onError);
        this.socket.once("connect", this.onConnect);
        this.socket.on("data", this.onDataReceived);
        this.setState(constants_1.SocksClientState.Connecting);
        this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
        if (existingSocket) {
          this.socket.emit("connect");
        } else {
          this.socket.connect(this.getSocketOptions());
          if (this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null) {
            this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
          }
        }
        this.prependOnceListener("established", (info3) => {
          setImmediate(() => {
            if (this.receiveBuffer.length > 0) {
              const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
              info3.socket.emit("data", excessData);
            }
            info3.socket.resume();
          });
        });
      }
      // Socket options (defaults host/port to options.proxy.host/options.proxy.port)
      getSocketOptions() {
        return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
      }
      /**
       * Handles internal Socks timeout callback.
       * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.
       */
      onEstablishedTimeout() {
        if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
          this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
        }
      }
      /**
       * Handles Socket connect event.
       */
      onConnectHandler() {
        this.setState(constants_1.SocksClientState.Connected);
        if (this.options.proxy.type === 4) {
          this.sendSocks4InitialHandshake();
        } else {
          this.sendSocks5InitialHandshake();
        }
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles Socket data event.
       * @param data
       */
      onDataReceivedHandler(data) {
        this.receiveBuffer.append(data);
        this.processData();
      }
      /**
       * Handles processing of the data we have received.
       */
      processData() {
        while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
          if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4FinalHandshakeResponse();
            } else {
              this.handleInitialSocks5HandshakeResponse();
            }
          } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
            this.handleInitialSocks5AuthenticationHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
            this.handleSocks5FinalHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4IncomingConnectionResponse();
            } else {
              this.handleSocks5IncomingConnectionResponse();
            }
          } else {
            this.closeSocket(constants_1.ERRORS.InternalError);
            break;
          }
        }
      }
      /**
       * Handles Socket close event.
       * @param had_error
       */
      onCloseHandler() {
        this.closeSocket(constants_1.ERRORS.SocketClosed);
      }
      /**
       * Handles Socket error event.
       * @param err
       */
      onErrorHandler(err) {
        this.closeSocket(err.message);
      }
      /**
       * Removes internal event listeners on the underlying Socket.
       */
      removeInternalSocketHandlers() {
        this.socket.pause();
        this.socket.removeListener("data", this.onDataReceived);
        this.socket.removeListener("close", this.onClose);
        this.socket.removeListener("error", this.onError);
        this.socket.removeListener("connect", this.onConnect);
      }
      /**
       * Closes and destroys the underlying Socket. Emits an error event.
       * @param err { String } An error string to include in error event.
       */
      closeSocket(err) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.setState(constants_1.SocksClientState.Error);
          this.socket.destroy();
          this.removeInternalSocketHandlers();
          this.emit("error", new util_1.SocksClientError(err, this.options));
        }
      }
      /**
       * Sends initial Socks v4 handshake request.
       */
      sendSocks4InitialHandshake() {
        const userId = this.options.proxy.userId || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(4);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt16BE(this.options.destination.port);
        if (net$1.isIPv4(this.options.destination.host)) {
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
          buff.writeStringNT(userId);
        } else {
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(1);
          buff.writeStringNT(userId);
          buff.writeStringNT(this.options.destination.host);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
        this.socket.write(buff.toBuffer());
      }
      /**
       * Handles Socks v4 handshake response.
       * @param data
       */
      handleSocks4FinalHandshakeResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
            buff.readOffset = 2;
            const remoteHost = {
              port: buff.readUInt16BE(),
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.emit("bound", { remoteHost, socket: this.socket });
          } else {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { socket: this.socket });
          }
        }
      }
      /**
       * Handles Socks v4 incoming connection request (BIND)
       * @param data
       */
      handleSocks4IncomingConnectionResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
          };
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      /**
       * Sends initial Socks v5 handshake request.
       */
      sendSocks5InitialHandshake() {
        const buff = new smart_buffer_1.SmartBuffer();
        const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
        if (this.options.proxy.userId || this.options.proxy.password) {
          supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
        }
        if (this.options.proxy.custom_auth_method !== void 0) {
          supportedAuthMethods.push(this.options.proxy.custom_auth_method);
        }
        buff.writeUInt8(5);
        buff.writeUInt8(supportedAuthMethods.length);
        for (const authMethod of supportedAuthMethods) {
          buff.writeUInt8(authMethod);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles initial Socks v5 handshake response.
       * @param data
       */
      handleInitialSocks5HandshakeResponse() {
        const data = this.receiveBuffer.get(2);
        if (data[0] !== 5) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
        } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
        } else {
          if (data[1] === constants_1.Socks5Auth.NoAuth) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
            this.sendSocks5CommandRequest();
          } else if (data[1] === constants_1.Socks5Auth.UserPass) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
            this.sendSocks5UserPassAuthentication();
          } else if (data[1] === this.options.proxy.custom_auth_method) {
            this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
            this.sendSocks5CustomAuthentication();
          } else {
            this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
          }
        }
      }
      /**
       * Sends Socks v5 user & password auth handshake.
       *
       * Note: No auth and user/pass are currently supported.
       */
      sendSocks5UserPassAuthentication() {
        const userId = this.options.proxy.userId || "";
        const password = this.options.proxy.password || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(1);
        buff.writeUInt8(Buffer.byteLength(userId));
        buff.writeString(userId);
        buff.writeUInt8(Buffer.byteLength(password));
        buff.writeString(password);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentAuthentication);
      }
      sendSocks5CustomAuthentication() {
        return __awaiter2(this, void 0, void 0, function* () {
          this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
          this.socket.write(yield this.options.proxy.custom_auth_request_handler());
          this.setState(constants_1.SocksClientState.SentAuthentication);
        });
      }
      handleSocks5CustomAuthHandshakeResponse(data) {
        return __awaiter2(this, void 0, void 0, function* () {
          return yield this.options.proxy.custom_auth_response_handler(data);
        });
      }
      handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
        return __awaiter2(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      handleSocks5AuthenticationUserPassHandshakeResponse(data) {
        return __awaiter2(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      /**
       * Handles Socks v5 auth handshake response.
       * @param data
       */
      handleInitialSocks5AuthenticationHandshakeResponse() {
        return __awaiter2(this, void 0, void 0, function* () {
          this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
          let authResult = false;
          if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
            authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
            authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
            authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
          }
          if (!authResult) {
            this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
          } else {
            this.sendSocks5CommandRequest();
          }
        });
      }
      /**
       * Sends Socks v5 final handshake request.
       */
      sendSocks5CommandRequest() {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(5);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt8(0);
        if (net$1.isIPv4(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        } else if (net$1.isIPv6(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(this.options.destination.host.length);
          buff.writeString(this.options.destination.host);
        }
        buff.writeUInt16BE(this.options.destination.port);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentFinalHandshake);
      }
      /**
       * Handles Socks v5 final handshake response.
       * @param data
       */
      handleSocks5FinalHandshakeResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
            this.emit("bound", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", {
              remoteHost,
              socket: this.socket
            });
          }
        }
      }
      /**
       * Handles Socks v5 incoming connection request (BIND).
       */
      handleSocks5IncomingConnectionResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      get socksClientOptions() {
        return Object.assign({}, this.options);
      }
    }
    exports.SocksClient = SocksClient;
  })(socksclient);
  return socksclient;
}
__name(requireSocksclient, "requireSocksclient");
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1;
  (function(exports) {
    var __createBinding2 = build && build.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = build && build.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(requireSocksclient(), exports);
  })(build);
  return build;
}
__name(requireBuild, "requireBuild");
var hasRequiredAgent;
function requireAgent() {
  if (hasRequiredAgent) return agent;
  hasRequiredAgent = 1;
  var __awaiter2 = agent && agent.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    __name(adopt, "adopt");
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step");
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = agent && agent.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(agent, "__esModule", { value: true });
  const dns_1 = __importDefault2(require$$0$8);
  const tls_1 = __importDefault2(tls_default);
  const url_1 = __importDefault2(url);
  const debug_1 = __importDefault2(requireBrowser$1());
  const agent_base_1 = requireSrc();
  const socks_1 = requireBuild();
  const debug22 = debug_1.default("socks-proxy-agent");
  function dnsLookup(host) {
    return new Promise((resolve, reject) => {
      dns_1.default.lookup(host, (err, res) => {
        if (err) {
          reject(err);
        } else {
          resolve(res);
        }
      });
    });
  }
  __name(dnsLookup, "dnsLookup");
  function parseSocksProxy(opts) {
    let port = 0;
    let lookup = false;
    let type2 = 5;
    const host = opts.hostname || opts.host;
    if (!host) {
      throw new TypeError('No "host"');
    }
    if (typeof opts.port === "number") {
      port = opts.port;
    } else if (typeof opts.port === "string") {
      port = parseInt(opts.port, 10);
    }
    if (!port) {
      port = 1080;
    }
    if (opts.protocol) {
      switch (opts.protocol.replace(":", "")) {
        case "socks4":
          lookup = true;
        // pass through
        case "socks4a":
          type2 = 4;
          break;
        case "socks5":
          lookup = true;
        // pass through
        case "socks":
        // no version specified, default to 5h
        case "socks5h":
          type2 = 5;
          break;
        default:
          throw new TypeError(`A "socks" protocol must be specified! Got: ${opts.protocol}`);
      }
    }
    if (typeof opts.type !== "undefined") {
      if (opts.type === 4 || opts.type === 5) {
        type2 = opts.type;
      } else {
        throw new TypeError(`"type" must be 4 or 5, got: ${opts.type}`);
      }
    }
    const proxy = {
      host,
      port,
      type: type2
    };
    let userId = opts.userId || opts.username;
    let password = opts.password;
    if (opts.auth) {
      const auth = opts.auth.split(":");
      userId = auth[0];
      password = auth[1];
    }
    if (userId) {
      Object.defineProperty(proxy, "userId", {
        value: userId,
        enumerable: false
      });
    }
    if (password) {
      Object.defineProperty(proxy, "password", {
        value: password,
        enumerable: false
      });
    }
    return { lookup, proxy };
  }
  __name(parseSocksProxy, "parseSocksProxy");
  class SocksProxyAgent22 extends agent_base_1.Agent {
    static {
      __name(this, "SocksProxyAgent2");
    }
    constructor(_opts) {
      let opts;
      if (typeof _opts === "string") {
        opts = url_1.default.parse(_opts);
      } else {
        opts = _opts;
      }
      if (!opts) {
        throw new TypeError("a SOCKS proxy server `host` and `port` must be specified!");
      }
      super(opts);
      const parsedProxy = parseSocksProxy(opts);
      this.lookup = parsedProxy.lookup;
      this.proxy = parsedProxy.proxy;
      this.tlsConnectionOptions = opts.tls || {};
    }
    /**
     * Initiates a SOCKS connection to the specified SOCKS proxy server,
     * which in turn connects to the specified remote host and port.
     *
     * @api protected
     */
    callback(req, opts) {
      return __awaiter2(this, void 0, void 0, function* () {
        const { lookup, proxy } = this;
        let { host, port, timeout } = opts;
        if (!host) {
          throw new Error("No `host` defined!");
        }
        if (lookup) {
          host = yield dnsLookup(host);
        }
        const socksOpts = {
          proxy,
          destination: { host, port },
          command: "connect",
          timeout
        };
        debug22("Creating socks proxy connection: %o", socksOpts);
        const { socket } = yield socks_1.SocksClient.createConnection(socksOpts);
        debug22("Successfully created socks proxy connection");
        if (opts.secureEndpoint) {
          debug22("Upgrading socket connection to TLS");
          const servername = opts.servername || opts.host;
          return tls_1.default.connect(Object.assign(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
            socket,
            servername
          }), this.tlsConnectionOptions));
        }
        return socket;
      });
    }
  }
  agent.default = SocksProxyAgent22;
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
  __name(omit, "omit");
  return agent;
}
__name(requireAgent, "requireAgent");
var dist;
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  var __importDefault2 = dist && dist.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  const agent_1 = __importDefault2(requireAgent());
  function createSocksProxyAgent(opts) {
    return new agent_1.default(opts);
  }
  __name(createSocksProxyAgent, "createSocksProxyAgent");
  (function(createSocksProxyAgent2) {
    createSocksProxyAgent2.SocksProxyAgent = agent_1.default;
    createSocksProxyAgent2.prototype = agent_1.default.prototype;
  })(createSocksProxyAgent || (createSocksProxyAgent = {}));
  dist = createSocksProxyAgent;
  return dist;
}
__name(requireDist, "requireDist");
var distExports = requireDist();
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR$1 = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = /* @__PURE__ */ __name((node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === ALIAS, "isAlias");
var isDocument = /* @__PURE__ */ __name((node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === DOC, "isDocument");
var isMap = /* @__PURE__ */ __name((node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === MAP, "isMap");
var isPair = /* @__PURE__ */ __name((node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === PAIR, "isPair");
var isScalar$1 = /* @__PURE__ */ __name((node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === SCALAR$1, "isScalar$1");
var isSeq = /* @__PURE__ */ __name((node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === SEQ, "isSeq");
function isCollection$1(node2) {
  if (node2 && typeof node2 === "object")
    switch (node2[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
__name(isCollection$1, "isCollection$1");
function isNode(node2) {
  if (node2 && typeof node2 === "object")
    switch (node2[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR$1:
      case SEQ:
        return true;
    }
  return false;
}
__name(isNode, "isNode");
var hasAnchor = /* @__PURE__ */ __name((node2) => (isScalar$1(node2) || isCollection$1(node2)) && !!node2.anchor, "hasAnchor");
var BREAK$1 = Symbol("break visit");
var SKIP$1 = Symbol("skip children");
var REMOVE$1 = Symbol("remove node");
function visit$1(node2, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node2)) {
    const cd = visit_(null, node2.contents, visitor_, Object.freeze([node2]));
    if (cd === REMOVE$1)
      node2.contents = null;
  } else
    visit_(null, node2, visitor_, Object.freeze([]));
}
__name(visit$1, "visit$1");
visit$1.BREAK = BREAK$1;
visit$1.SKIP = SKIP$1;
visit$1.REMOVE = REMOVE$1;
function visit_(key, node2, visitor, path31) {
  const ctrl = callVisitor(key, node2, visitor, path31);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path31, ctrl);
    return visit_(key, ctrl, visitor, path31);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node2)) {
      path31 = Object.freeze(path31.concat(node2));
      for (let i = 0; i < node2.items.length; ++i) {
        const ci = visit_(i, node2.items[i], visitor, path31);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node2.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node2)) {
      path31 = Object.freeze(path31.concat(node2));
      const ck = visit_("key", node2.key, visitor, path31);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node2.key = null;
      const cv = visit_("value", node2.value, visitor, path31);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node2.value = null;
    }
  }
  return ctrl;
}
__name(visit_, "visit_");
async function visitAsync(node2, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node2)) {
    const cd = await visitAsync_(null, node2.contents, visitor_, Object.freeze([node2]));
    if (cd === REMOVE$1)
      node2.contents = null;
  } else
    await visitAsync_(null, node2, visitor_, Object.freeze([]));
}
__name(visitAsync, "visitAsync");
visitAsync.BREAK = BREAK$1;
visitAsync.SKIP = SKIP$1;
visitAsync.REMOVE = REMOVE$1;
async function visitAsync_(key, node2, visitor, path31) {
  const ctrl = await callVisitor(key, node2, visitor, path31);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path31, ctrl);
    return visitAsync_(key, ctrl, visitor, path31);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node2)) {
      path31 = Object.freeze(path31.concat(node2));
      for (let i = 0; i < node2.items.length; ++i) {
        const ci = await visitAsync_(i, node2.items[i], visitor, path31);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node2.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node2)) {
      path31 = Object.freeze(path31.concat(node2));
      const ck = await visitAsync_("key", node2.key, visitor, path31);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node2.key = null;
      const cv = await visitAsync_("value", node2.value, visitor, path31);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node2.value = null;
    }
  }
  return ctrl;
}
__name(visitAsync_, "visitAsync_");
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
__name(initVisitor, "initVisitor");
function callVisitor(key, node2, visitor, path31) {
  if (typeof visitor === "function")
    return visitor(key, node2, path31);
  if (isMap(node2))
    return visitor.Map?.(key, node2, path31);
  if (isSeq(node2))
    return visitor.Seq?.(key, node2, path31);
  if (isPair(node2))
    return visitor.Pair?.(key, node2, path31);
  if (isScalar$1(node2))
    return visitor.Scalar?.(key, node2, path31);
  if (isAlias(node2))
    return visitor.Alias?.(key, node2, path31);
  return void 0;
}
__name(callVisitor, "callVisitor");
function replaceNode(key, path31, node2) {
  const parent = path31[path31.length - 1];
  if (isCollection$1(parent)) {
    parent.items[key] = node2;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node2;
    else
      parent.value = node2;
  } else if (isDocument(parent)) {
    parent.contents = node2;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
__name(replaceNode, "replaceNode");
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = /* @__PURE__ */ __name((tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]), "escapeTagName");
var Directives = class _Directives {
  static {
    __name(this, "Directives");
  }
  constructor(yaml22, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, _Directives.defaultYaml, yaml22);
    this.tags = Object.assign({}, _Directives.defaultTags, tags);
  }
  clone() {
    const copy = new _Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new _Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: _Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, _Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, _Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version22] = parts;
        if (version22 === "1.1" || version22 === "1.2") {
          this.yaml.version = version22;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version22);
          onError(6, `Unsupported YAML version ${version22}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source7, onError) {
    if (source7 === "!")
      return "!";
    if (source7[0] !== "!") {
      onError(`Not a valid tag: ${source7}`);
      return null;
    }
    if (source7[1] === "<") {
      const verbatim = source7.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source7} is invalid.`);
        return null;
      }
      if (source7[source7.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source7.match(/^(.*!)([^!]*)$/s);
    if (!suffix)
      onError(`The ${source7} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error22) {
        onError(String(error22));
        return null;
      }
    }
    if (handle === "!")
      return source7;
    onError(`Could not resolve tag: ${source7}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit$1(doc.contents, (_key, node2) => {
        if (isNode(node2) && node2.tag)
          tags[node2.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
__name(anchorIsValid, "anchorIsValid");
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit$1(root, {
    Value(_key, node2) {
      if (node2.anchor)
        anchors.add(node2.anchor);
    }
  });
  return anchors;
}
__name(anchorNames, "anchorNames");
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
__name(findNewAnchor, "findNewAnchor");
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: /* @__PURE__ */ __name((source7) => {
      aliasObjects.push(source7);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    }, "onAnchor"),
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: /* @__PURE__ */ __name(() => {
      for (const source7 of aliasObjects) {
        const ref = sourceObjects.get(source7);
        if (typeof ref === "object" && ref.anchor && (isScalar$1(ref.node) || isCollection$1(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error22 = new Error("Failed to resolve repeated object (this should not happen)");
          error22.source = source7;
          throw error22;
        }
      }
    }, "setAnchors"),
    sourceObjects
  };
}
__name(createNodeAnchors, "createNodeAnchors");
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
__name(applyReviver, "applyReviver");
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !ctx?.keep)
    return Number(value);
  return value;
}
__name(toJS, "toJS");
var NodeBase = class {
  static {
    __name(this, "NodeBase");
  }
  constructor(type2) {
    Object.defineProperty(this, NODE_TYPE, { value: type2 });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** A plain JavaScript representation of this node. */
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count: count3, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count3);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
};
var Alias = class extends NodeBase {
  static {
    __name(this, "Alias");
  }
  constructor(source7) {
    super(ALIAS);
    this.source = source7;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found = void 0;
    visit$1(doc, {
      Node: /* @__PURE__ */ __name((_key, node2) => {
        if (node2 === this)
          return visit$1.BREAK;
        if (node2.anchor === this.source)
          found = node2;
      }, "Node")
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source7 = this.resolve(doc);
    if (!source7) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data = anchors.get(source7);
    if (!data) {
      toJS(source7, null, ctx);
      data = anchors.get(source7);
    }
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source7, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src2 = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src2} `;
    }
    return src2;
  }
};
function getAliasCount(doc, node2, anchors) {
  if (isAlias(node2)) {
    const source7 = node2.resolve(doc);
    const anchor = anchors && source7 && anchors.get(source7);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection$1(node2)) {
    let count3 = 0;
    for (const item of node2.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count3)
        count3 = c;
    }
    return count3;
  } else if (isPair(node2)) {
    const kc = getAliasCount(doc, node2.key, anchors);
    const vc = getAliasCount(doc, node2.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
__name(getAliasCount, "getAliasCount");
var isScalarValue = /* @__PURE__ */ __name((value) => !value || typeof value !== "function" && typeof value !== "object", "isScalarValue");
var Scalar = class extends NodeBase {
  static {
    __name(this, "Scalar");
  }
  constructor(value) {
    super(SCALAR$1);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = match.find((t) => !t.format) ?? match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify?.(value) && !t.format);
}
__name(findTagObject, "findTagObject");
function createNode(value, tagName, ctx) {
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema2, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema2.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node22 = new Scalar(value);
      if (ref)
        ref.node = node22;
      return node22;
    }
    tagObj = value instanceof Map ? schema2[MAP] : Symbol.iterator in Object(value) ? schema2[SEQ] : schema2[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node2 = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node2.tag = tagName;
  else if (!tagObj.default)
    node2.tag = tagObj.tag;
  if (ref)
    ref.node = node2;
  return node2;
}
__name(createNode, "createNode");
function collectionFromPath(schema2, path31, value) {
  let v = value;
  for (let i = path31.length - 1; i >= 0; --i) {
    const k = path31[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: /* @__PURE__ */ __name(() => {
      throw new Error("This should not happen, please report a bug.");
    }, "onAnchor"),
    schema: schema2,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
__name(collectionFromPath, "collectionFromPath");
var isEmptyPath = /* @__PURE__ */ __name((path31) => path31 == null || typeof path31 === "object" && !!path31[Symbol.iterator]().next().done, "isEmptyPath");
var Collection = class extends NodeBase {
  static {
    __name(this, "Collection");
  }
  constructor(type2, schema2) {
    super(type2);
    Object.defineProperty(this, "schema", {
      value: schema2,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema2) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema2)
      copy.schema = schema2;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema2) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path31, value) {
    if (isEmptyPath(path31))
      this.add(value);
    else {
      const [key, ...rest] = path31;
      const node2 = this.get(key, true);
      if (isCollection$1(node2))
        node2.addIn(rest, value);
      else if (node2 === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path31) {
    const [key, ...rest] = path31;
    if (rest.length === 0)
      return this.delete(key);
    const node2 = this.get(key, true);
    if (isCollection$1(node2))
      return node2.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path31, keepScalar) {
    const [key, ...rest] = path31;
    const node2 = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar$1(node2) ? node2.value : node2;
    else
      return isCollection$1(node2) ? node2.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node2) => {
      if (!isPair(node2))
        return false;
      const n = node2.value;
      return n == null || allowScalar && isScalar$1(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path31) {
    const [key, ...rest] = path31;
    if (rest.length === 0)
      return this.has(key);
    const node2 = this.get(key, true);
    return isCollection$1(node2) ? node2.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path31, value) {
    const [key, ...rest] = path31;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node2 = this.get(key, true);
      if (isCollection$1(node2))
        node2.setIn(rest, value);
      else if (node2 === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};
var stringifyComment = /* @__PURE__ */ __name((str) => str.replace(/^(?!$)(?: $)?/gm, "#"), "stringifyComment");
function indentComment(comment2, indent) {
  if (/^\n+$/.test(comment2))
    return comment2.substring(1);
  return indent ? comment2.replace(/^(?! *$)/gm, indent) : comment2;
}
__name(indentComment, "indentComment");
var lineComment = /* @__PURE__ */ __name((str, indent, comment2) => str.endsWith("\n") ? indentComment(comment2, indent) : comment2.includes("\n") ? "\n" + indentComment(comment2, indent) : (str.endsWith(" ") ? "" : " ") + comment2, "lineComment");
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i, indent.length);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i, indent.length);
      end = i + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
__name(foldFlowLines, "foldFlowLines");
function consumeMoreIndentedLines(text, i, indent) {
  let end = i;
  let start = i + 1;
  let ch = text[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text[++i];
    } else {
      do {
        ch = text[++i];
      } while (ch && ch !== "\n");
      end = i;
      start = i + 1;
      ch = text[start];
    }
  }
  return end;
}
__name(consumeMoreIndentedLines, "consumeMoreIndentedLines");
var getFoldOptions = /* @__PURE__ */ __name((ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
}), "getFoldOptions");
var containsDocumentMarker = /* @__PURE__ */ __name((str) => /^(%|---|\.\.\.)/m.test(str), "containsDocumentMarker");
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
__name(lineLengthOverLimit, "lineLengthOverLimit");
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
__name(doubleQuotedString, "doubleQuotedString");
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
__name(singleQuotedString, "singleQuotedString");
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
__name(quotedString, "quotedString");
var blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment: comment2, type: type2, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type2 === Scalar.BLOCK_FOLDED ? false : type2 === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment2) {
    header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));
  return `${header}
${indent}${body}`;
}
__name(blockString, "blockString");
function plainString(item, ctx, onComment, onChompKeep) {
  const { type: type2, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type2 !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = /* @__PURE__ */ __name((tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str), "test");
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || compat?.some(test))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
__name(plainString, "plainString");
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type: type2 } = item;
  if (type2 !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type2 = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = /* @__PURE__ */ __name((_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  }, "_stringify");
  let res = _stringify(type2);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
__name(stringifyString, "stringifyString");
function createStringifyContext(doc, options2) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options2);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
__name(createStringifyContext, "createStringifyContext");
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return match.find((t) => t.format === item.format) ?? match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar$1(item)) {
    obj = item.value;
    let match = tags.filter((t) => t.identify?.(obj));
    if (match.length > 1) {
      const testMatch = match.filter((t) => t.test);
      if (testMatch.length > 0)
        match = testMatch;
    }
    tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = obj?.constructor?.name ?? typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
__name(getTagObject, "getTagObject");
function stringifyProps(node2, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar$1(node2) || isCollection$1(node2)) && node2.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node2.tag ? node2.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
__name(stringifyProps, "stringifyProps");
function stringify$2(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node2 = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: /* @__PURE__ */ __name((o) => tagObj = o, "onTagObj") });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node2);
  const props = stringifyProps(node2, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node2, ctx, onComment, onChompKeep) : isScalar$1(node2) ? stringifyString(node2, ctx, onComment, onChompKeep) : node2.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar$1(node2) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}
__name(stringify$2, "stringify$2");
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection$1(key) || !isNode(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection$1(key) || (isScalar$1(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify$2(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar$1(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify$2(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws22 = " ";
  if (keyComment || vsb || vcb) {
    ws22 = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws22 += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws22 === "\n")
        ws22 = "\n\n";
    } else {
      ws22 += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection$1(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws22 = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws22 = "";
  }
  str += ws22 + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
__name(stringifyPair, "stringifyPair");
function warn3(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
__name(warn3, "warn");
var MERGE_KEY = "<<";
var merge = {
  identify: /* @__PURE__ */ __name((value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY, "identify"),
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: /* @__PURE__ */ __name(() => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }), "resolve"),
  stringify: /* @__PURE__ */ __name(() => MERGE_KEY, "stringify")
};
var isMergeKey = /* @__PURE__ */ __name((ctx, key) => (merge.identify(key) || isScalar$1(key) && (!key.type || key.type === Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default), "isMergeKey");
function addMergeToJSMap(ctx, map2, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it of value.items)
      mergeValue(ctx, map2, it);
  else if (Array.isArray(value))
    for (const it of value)
      mergeValue(ctx, map2, it);
  else
    mergeValue(ctx, map2, value);
}
__name(addMergeToJSMap, "addMergeToJSMap");
function mergeValue(ctx, map2, value) {
  const source7 = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source7))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source7.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
__name(mergeValue, "mergeValue");
function addPairToJSMap(ctx, map2, { key, value }) {
  if (isNode(key) && key.addToJSMap)
    key.addToJSMap(ctx, map2, value);
  else if (isMergeKey(ctx, key))
    addMergeToJSMap(ctx, map2, value);
  else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
__name(addPairToJSMap, "addPairToJSMap");
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx?.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node2 of ctx.anchors.keys())
      strCtx.anchors.add(node2.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn3(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
__name(stringifyKey, "stringifyKey");
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
__name(createPair, "createPair");
var Pair = class _Pair {
  static {
    __name(this, "Pair");
  }
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema2) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema2);
    if (isNode(value))
      value = value.clone(schema2);
    return new _Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};
function stringifyCollection(collection, ctx, options2) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify2(collection, ctx, options2);
}
__name(stringifyCollection, "stringifyCollection");
function stringifyBlockCollection({ comment: comment2, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment22 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment22 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify$2(item, itemCtx, () => comment22 = null, () => chompKeep = true);
    if (comment22)
      str2 += lineComment(str2, itemIndent, commentString(comment22));
    if (chompKeep && comment22)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment2) {
    str += "\n" + indentComment(commentString(comment2), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
__name(stringifyBlockCollection, "stringifyBlockCollection");
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik?.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str = stringify$2(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str += ",";
    if (comment2)
      str += lineComment(str, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
__name(stringifyFlowCollection, "stringifyFlowCollection");
function addCommentBefore({ indent, options: { commentString } }, lines, comment2, chompKeep) {
  if (comment2 && chompKeep)
    comment2 = comment2.replace(/^\n+/, "");
  if (comment2) {
    const ic = indentComment(commentString(comment2), indent);
    lines.push(ic.trimStart());
  }
}
__name(addCommentBefore, "addCommentBefore");
function findPair(items, key) {
  const k = isScalar$1(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar$1(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
__name(findPair, "findPair");
var YAMLMap = class extends Collection {
  static {
    __name(this, "YAMLMap");
  }
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema2) {
    super(MAP, schema2);
    this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(schema2, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map2 = new this(schema2);
    const add = /* @__PURE__ */ __name((key, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key, value);
      else if (Array.isArray(replacer) && !replacer.includes(key))
        return;
      if (value !== void 0 || keepUndefined)
        map2.items.push(createPair(key, value, ctx));
    }, "add");
    if (obj instanceof Map) {
      for (const [key, value] of obj)
        add(key, value);
    } else if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj))
        add(key, obj[key]);
    }
    if (typeof schema2.sortMapEntries === "function") {
      map2.items.sort(schema2.sortMapEntries);
    }
    return map2;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair?.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = this.schema?.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar$1(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node2 = it?.value;
    return (!keepScalar && isScalar$1(node2) ? node2.value : node2) ?? void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    if (ctx?.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};
var map = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode: /* @__PURE__ */ __name((schema2, obj, ctx) => YAMLMap.from(schema2, obj, ctx), "createNode")
};
var YAMLSeq = class extends Collection {
  static {
    __name(this, "YAMLSeq");
  }
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema2) {
    super(SEQ, schema2);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar$1(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar$1(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx?.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema2, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema2);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
        if (typeof replacer === "function") {
          const key = obj instanceof Set ? it : String(i++);
          it = replacer.call(obj, key, it);
        }
        seq2.items.push(createNode(it, void 0, ctx));
      }
    }
    return seq2;
  }
};
function asItemIndex(key) {
  let idx = isScalar$1(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
__name(asItemIndex, "asItemIndex");
var seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: /* @__PURE__ */ __name((schema2, obj, ctx) => YAMLSeq.from(schema2, obj, ctx), "createNode")
};
var string = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "string", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: /* @__PURE__ */ __name((str) => str, "resolve"),
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};
var nullTag = {
  identify: /* @__PURE__ */ __name((value) => value == null, "identify"),
  createNode: /* @__PURE__ */ __name(() => new Scalar(null), "createNode"),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: /* @__PURE__ */ __name(() => new Scalar(null), "resolve"),
  stringify: /* @__PURE__ */ __name(({ source: source7 }, ctx) => typeof source7 === "string" && nullTag.test.test(source7) ? source7 : ctx.options.nullStr, "stringify")
};
var boolTag = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "boolean", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: /* @__PURE__ */ __name((str) => new Scalar(str[0] === "t" || str[0] === "T"), "resolve"),
  stringify({ source: source7, value }, ctx) {
    if (source7 && boolTag.test.test(source7)) {
      const sv = source7[0] === "t" || source7[0] === "T";
      if (value === sv)
        return source7;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};
function stringifyNumber({ format: format2, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}
__name(stringifyNumber, "stringifyNumber");
var floatNaN$1 = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: /* @__PURE__ */ __name((str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, "resolve"),
  stringify: stringifyNumber
};
var floatExp$1 = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: /* @__PURE__ */ __name((str) => parseFloat(str), "resolve"),
  stringify(node2) {
    const num = Number(node2.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node2);
  }
};
var float$1 = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node2 = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node2.minFractionDigits = str.length - dot - 1;
    return node2;
  },
  stringify: stringifyNumber
};
var intIdentify$2 = /* @__PURE__ */ __name((value) => typeof value === "bigint" || Number.isInteger(value), "intIdentify$2");
var intResolve$1 = /* @__PURE__ */ __name((str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix), "intResolve$1");
function intStringify$1(node2, radix, prefix) {
  const { value } = node2;
  if (intIdentify$2(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node2);
}
__name(intStringify$1, "intStringify$1");
var intOct$1 = {
  identify: /* @__PURE__ */ __name((value) => intIdentify$2(value) && value >= 0, "identify"),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve$1(str, 2, 8, opt), "resolve"),
  stringify: /* @__PURE__ */ __name((node2) => intStringify$1(node2, 8, "0o"), "stringify")
};
var int$1 = {
  identify: intIdentify$2,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve$1(str, 0, 10, opt), "resolve"),
  stringify: stringifyNumber
};
var intHex$1 = {
  identify: /* @__PURE__ */ __name((value) => intIdentify$2(value) && value >= 0, "identify"),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve$1(str, 2, 16, opt), "resolve"),
  stringify: /* @__PURE__ */ __name((node2) => intStringify$1(node2, 16, "0x"), "stringify")
};
var schema$2 = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct$1,
  int$1,
  intHex$1,
  floatNaN$1,
  floatExp$1,
  float$1
];
function intIdentify$1(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
__name(intIdentify$1, "intIdentify$1");
var stringifyJSON = /* @__PURE__ */ __name(({ value }) => JSON.stringify(value), "stringifyJSON");
var jsonScalars = [
  {
    identify: /* @__PURE__ */ __name((value) => typeof value === "string", "identify"),
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: /* @__PURE__ */ __name((str) => str, "resolve"),
    stringify: stringifyJSON
  },
  {
    identify: /* @__PURE__ */ __name((value) => value == null, "identify"),
    createNode: /* @__PURE__ */ __name(() => new Scalar(null), "createNode"),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: /* @__PURE__ */ __name(() => null, "resolve"),
    stringify: stringifyJSON
  },
  {
    identify: /* @__PURE__ */ __name((value) => typeof value === "boolean", "identify"),
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: /* @__PURE__ */ __name((str) => str === "true", "resolve"),
    stringify: stringifyJSON
  },
  {
    identify: intIdentify$1,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: /* @__PURE__ */ __name((str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10), "resolve"),
    stringify: /* @__PURE__ */ __name(({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value), "stringify")
  },
  {
    identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: /* @__PURE__ */ __name((str) => parseFloat(str), "resolve"),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema$1 = [map, seq].concat(jsonScalars, jsonError);
var binary = {
  identify: /* @__PURE__ */ __name((value) => value instanceof Uint8Array, "identify"),
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src2, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src2, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src2.replace(/[\n\r]/g, ""));
      const buffer2 = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer2[i] = str.charCodeAt(i);
      return buffer2;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src2;
    }
  },
  stringify({ comment: comment2, type: type2, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type2)
      type2 = Scalar.BLOCK_LITERAL;
    if (type2 !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type2 === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment: comment2, type: type2, value: str }, ctx, onComment, onChompKeep);
  }
};
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
__name(resolvePairs, "resolvePairs");
function createPairs(schema2, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema2);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
__name(createPairs, "createPairs");
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};
var YAMLOMap = class _YAMLOMap extends YAMLSeq {
  static {
    __name(this, "YAMLOMap");
  }
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = _YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx?.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
  static from(schema2, iterable, ctx) {
    const pairs2 = createPairs(schema2, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: /* @__PURE__ */ __name((value) => value instanceof Map, "identify"),
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar$1(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: /* @__PURE__ */ __name((schema2, iterable, ctx) => YAMLOMap.from(schema2, iterable, ctx), "createNode")
};
function boolStringify({ value, source: source7 }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source7 && boolObj.test.test(source7))
    return source7;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
__name(boolStringify, "boolStringify");
var trueTag = {
  identify: /* @__PURE__ */ __name((value) => value === true, "identify"),
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: /* @__PURE__ */ __name(() => new Scalar(true), "resolve"),
  stringify: boolStringify
};
var falseTag = {
  identify: /* @__PURE__ */ __name((value) => value === false, "identify"),
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: /* @__PURE__ */ __name(() => new Scalar(false), "resolve"),
  stringify: boolStringify
};
var floatNaN = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: /* @__PURE__ */ __name((str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, "resolve"),
  stringify: stringifyNumber
};
var floatExp = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: /* @__PURE__ */ __name((str) => parseFloat(str.replace(/_/g, "")), "resolve"),
  stringify(node2) {
    const num = Number(node2.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node2);
  }
};
var float = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node2 = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node2.minFractionDigits = f.length;
    }
    return node2;
  },
  stringify: stringifyNumber
};
var intIdentify = /* @__PURE__ */ __name((value) => typeof value === "bigint" || Number.isInteger(value), "intIdentify");
function intResolve(str, offset, radix, { intAsBigInt }) {
  const sign2 = str[0];
  if (sign2 === "-" || sign2 === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign2 === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign2 === "-" ? -1 * n : n;
}
__name(intResolve, "intResolve");
function intStringify(node2, radix, prefix) {
  const { value } = node2;
  if (intIdentify(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node2);
}
__name(intStringify, "intStringify");
var intBin = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve(str, 2, 2, opt), "resolve"),
  stringify: /* @__PURE__ */ __name((node2) => intStringify(node2, 2, "0b"), "stringify")
};
var intOct = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve(str, 1, 8, opt), "resolve"),
  stringify: /* @__PURE__ */ __name((node2) => intStringify(node2, 8, "0"), "stringify")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve(str, 0, 10, opt), "resolve"),
  stringify: stringifyNumber
};
var intHex = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve(str, 2, 16, opt), "resolve"),
  stringify: /* @__PURE__ */ __name((node2) => intStringify(node2, 16, "0x"), "stringify")
};
var YAMLSet = class _YAMLSet extends YAMLMap {
  static {
    __name(this, "YAMLSet");
  }
  constructor(schema2) {
    super(schema2);
    this.tag = _YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar$1(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema2, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new this(schema2);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: /* @__PURE__ */ __name((value) => value instanceof Set, "identify"),
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: /* @__PURE__ */ __name((schema2, iterable, ctx) => YAMLSet.from(schema2, iterable, ctx), "createNode"),
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  }
};
function parseSexagesimal(str, asBigInt) {
  const sign2 = str[0];
  const parts = sign2 === "-" || sign2 === "+" ? str.substring(1) : str;
  const num = /* @__PURE__ */ __name((n) => asBigInt ? BigInt(n) : Number(n), "num");
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign2 === "-" ? num(-1) * res : res;
}
__name(parseSexagesimal, "parseSexagesimal");
function stringifySexagesimal(node2) {
  let { value } = node2;
  let num = /* @__PURE__ */ __name((n) => n, "num");
  if (typeof value === "bigint")
    num = /* @__PURE__ */ __name((n) => BigInt(n), "num");
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node2);
  let sign2 = "";
  if (value < 0) {
    sign2 = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign2 + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
__name(stringifySexagesimal, "stringifySexagesimal");
var intTime = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "bigint" || Number.isInteger(value), "identify"),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt), "resolve"),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: /* @__PURE__ */ __name((str) => parseSexagesimal(str, false), "resolve"),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: /* @__PURE__ */ __name((value) => value instanceof Date, "identify"),
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: /* @__PURE__ */ __name(({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, ""), "stringify")
};
var schema = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float,
  binary,
  merge,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];
var schemas = /* @__PURE__ */ new Map([
  ["core", schema$2],
  ["failsafe", [map, seq, string]],
  ["json", schema$1],
  ["yaml11", schema],
  ["yaml-1.1", schema]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float: float$1,
  floatExp: floatExp$1,
  floatNaN: floatNaN$1,
  floatTime,
  int: int$1,
  intHex: intHex$1,
  intOct: intOct$1,
  intTime,
  map,
  merge,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge) ? schemaTags.concat(merge) : schemaTags.slice();
  }
  let tags = schemaTags;
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  if (addMergeTag)
    tags = tags.concat(merge);
  return tags.reduce((tags2, tag) => {
    const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
    if (!tagObj) {
      const tagName = JSON.stringify(tag);
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
    }
    if (!tags2.includes(tagObj))
      tags2.push(tagObj);
    return tags2;
  }, []);
}
__name(getTags, "getTags");
var sortMapEntriesByKey = /* @__PURE__ */ __name((a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0, "sortMapEntriesByKey");
var Schema = class _Schema {
  static {
    __name(this, "Schema");
  }
  constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema: schema2, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.name = typeof schema2 === "string" && schema2 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name, merge2);
    this.toStringOptions = toStringDefaults ?? null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR$1, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};
function stringifyDocument(doc, options2) {
  const lines = [];
  let hasDirectives = options2.directives === true;
  if (options2.directives !== false && doc.directives) {
    const dir3 = doc.directives.toString(doc);
    if (dir3) {
      lines.push(dir3);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options2);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify$2(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify$2(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
__name(stringifyDocument, "stringifyDocument");
var Document = class _Document {
  static {
    __name(this, "Document");
  }
  constructor(value, replacer, options2) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options2 === void 0 && replacer) {
      options2 = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, options2);
    this.options = opt;
    let { version: version22 } = opt;
    if (options2?._directives) {
      this.directives = options2._directives.atDocument();
      if (this.directives.yaml.explicit)
        version22 = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version: version22 });
    this.setSchema(version22, options2);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options2);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(_Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path31, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path31, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node2, name) {
    if (!node2.anchor) {
      const prev = anchorNames(this);
      node2.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node2.anchor);
  }
  createNode(value, replacer, options2) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = /* @__PURE__ */ __name((v) => typeof v === "number" || v instanceof String || v instanceof Number, "keyToStr");
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options2 === void 0 && replacer) {
      options2 = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options2 ?? {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects ?? true,
      keepUndefined: keepUndefined ?? false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node2 = createNode(value, tag, ctx);
    if (flow && isCollection$1(node2))
      node2.flow = true;
    setAnchors();
    return node2;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options2 = {}) {
    const k = this.createNode(key, null, options2);
    const v = this.createNode(value, null, options2);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path31) {
    if (isEmptyPath(path31)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path31) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection$1(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path31, keepScalar) {
    if (isEmptyPath(path31))
      return !keepScalar && isScalar$1(this.contents) ? this.contents.value : this.contents;
    return isCollection$1(this.contents) ? this.contents.getIn(path31, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection$1(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path31) {
    if (isEmptyPath(path31))
      return this.contents !== void 0;
    return isCollection$1(this.contents) ? this.contents.hasIn(path31) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path31, value) {
    if (isEmptyPath(path31)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path31), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path31, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version22, options2 = {}) {
    if (typeof version22 === "number")
      version22 = String(version22);
    let opt;
    switch (version22) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version22;
        else
          this.directives = new Directives({ version: version22 });
        opt = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version22);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options2.schema instanceof Object)
      this.schema = options2.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options2));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg ?? "", ctx);
    if (typeof onAnchor === "function")
      for (const { count: count3, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count3);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options2 = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options2 && (!Number.isInteger(options2.indent) || Number(options2.indent) <= 0)) {
      const s = JSON.stringify(options2.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options2);
  }
};
function assertCollection(contents) {
  if (isCollection$1(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
__name(assertCollection, "assertCollection");
var YAMLError = class extends Error {
  static {
    __name(this, "YAMLError");
  }
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  static {
    __name(this, "YAMLParseError");
  }
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  static {
    __name(this, "YAMLWarning");
  }
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = /* @__PURE__ */ __name((src2, lc) => (error22) => {
  if (error22.pos[0] === -1)
    return;
  error22.linePos = error22.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error22.linePos[0];
  error22.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src2.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src2.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count3 = 1;
    const end = error22.linePos[1];
    if (end && end.line === line && end.col > col) {
      count3 = Math.max(1, Math.min(end.col - col, 80 - ci));
    }
    const pointer = " ".repeat(ci) + "^".repeat(count3);
    error22.message += `:

${lineStr}
${pointer}
`;
  }
}, "prettifyError");
function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment2 = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
          tab = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment2)
          comment2 = cb;
        else
          comment2 += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment2)
            comment2 += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment: comment2,
    hasNewline,
    anchor,
    tag,
    newlineAfterProp,
    end,
    start: start ?? end
  };
}
__name(resolveProps, "resolveProps");
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
__name(containsNewline, "containsNewline");
function flowIndentCheck(indent, fc, onError) {
  if (fc?.type === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
__name(flowIndentCheck, "flowIndentCheck");
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar$1(a) && isScalar$1(b) && a.value === b.value;
  return items.some((pair) => isEqual(pair.key, search));
}
__name(mapIncludes, "mapIncludes");
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value?.type === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset, commentEnd ?? offset];
  return map2;
}
__name(resolveBlockMap, "resolveBlockMap");
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node2 = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node2.range[2];
    seq2.items.push(node2);
  }
  seq2.range = [bs.offset, offset, commentEnd ?? offset];
  return seq2;
}
__name(resolveBlockSeq, "resolveBlockSeq");
function resolveEnd(end, offset, reqSpace, onError) {
  let comment2 = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source: source7, type: type2 } = token;
      switch (type2) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source7.substring(1) || " ";
          if (!comment2)
            comment2 = cb;
          else
            comment2 += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment2)
            sep += source7;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type2} at node end`);
      }
      offset += source7.length;
    }
  }
  return { comment: comment2, offset };
}
__name(resolveEnd, "resolveEnd");
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = /* @__PURE__ */ __name((token) => token && (token.type === "block-map" || token.type === "block-seq"), "isBlock");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = tag?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop: for (const st of start) {
          switch (st.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              prevItemComment = st.source.substring(1);
              break loop;
            default:
              break loop;
          }
        }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        const endRange = (valueNode ?? keyNode).range;
        map2.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
__name(resolveFlowCollection, "resolveFlowCollection");
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
__name(resolveCollection, "resolveCollection");
function composeCollection(CN2, ctx, token, props, onError) {
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt?.collection) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
  const node2 = isNode(res) ? res : new Scalar(res);
  node2.range = coll.range;
  node2.tag = tagName;
  if (tag?.format)
    node2.format = tag.format;
  return node2;
}
__name(composeCollection, "composeCollection");
function resolveBlockScalar(ctx, scalar, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type2 = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type: type2, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src2 = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src2}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type2 === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type: type2, comment: header.comment, range: [start, end, end] };
}
__name(resolveBlockScalar, "resolveBlockScalar");
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source: source7 } = props[0];
  const mode = source7[0];
  let indent = 0;
  let chomp = "";
  let error22 = -1;
  for (let i = 1; i < source7.length; ++i) {
    const ch = source7[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error22 === -1)
        error22 = offset + i;
    }
  }
  if (error22 !== -1)
    onError(error22, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source7}`);
  let hasSpace = false;
  let comment2 = "";
  let length = source7.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      // fallthrough
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment2 = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment: comment2, length };
}
__name(parseBlockScalarHeader, "parseBlockScalarHeader");
function splitLines(source7) {
  const split = source7.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}
__name(splitLines, "splitLines");
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type: type2, source: source7, end } = scalar;
  let _type;
  let value;
  const _onError = /* @__PURE__ */ __name((rel, code, msg) => onError(offset + rel, code, msg), "_onError");
  switch (type2) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source7, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source7, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source7, _onError);
      break;
    /* istanbul ignore next should not happen */
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type2}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source7.length, offset + source7.length]
      };
  }
  const valueEnd = offset + source7.length;
  const re2 = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re2.comment,
    range: [offset, valueEnd, re2.offset]
  };
}
__name(resolveFlowScalar, "resolveFlowScalar");
function plainValue(source7, onError) {
  let badChar = "";
  switch (source7[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source7[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source7[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source7);
}
__name(plainValue, "plainValue");
function singleQuotedValue(source7, onError) {
  if (source7[source7.length - 1] !== "'" || source7.length === 1)
    onError(source7.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source7.slice(1, -1)).replace(/''/g, "'");
}
__name(singleQuotedValue, "singleQuotedValue");
function foldLines(source7) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source7);
  if (!match)
    return source7;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source7)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source7);
  return res + sep + (match?.[1] ?? "");
}
__name(foldLines, "foldLines");
function doubleQuotedValue(source7, onError) {
  let res = "";
  for (let i = 1; i < source7.length - 1; ++i) {
    const ch = source7[i];
    if (ch === "\r" && source7[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source7, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source7[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source7[i + 1];
        while (next === " " || next === "	")
          next = source7[++i + 1];
      } else if (next === "\r" && source7[i + 1] === "\n") {
        next = source7[++i + 1];
        while (next === " " || next === "	")
          next = source7[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source7, i + 1, length, onError);
        i += length;
      } else {
        const raw = source7.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source7[i + 1];
      while (next === " " || next === "	")
        next = source7[++i + 1];
      if (next !== "\n" && !(next === "\r" && source7[i + 2] === "\n"))
        res += i > wsStart ? source7.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source7[source7.length - 1] !== '"' || source7.length === 1)
    onError(source7.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
__name(doubleQuotedValue, "doubleQuotedValue");
function foldNewline(source7, offset) {
  let fold = "";
  let ch = source7[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source7[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source7[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
__name(foldNewline, "foldNewline");
var escapeCodes = {
  "0": "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: "\n",
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "\x85",
  // Unicode next line
  _: "\xA0",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source7, offset, length, onError) {
  const cc = source7.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source7.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
__name(parseCharCode, "parseCharCode");
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type: type2, comment: comment2, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag = ctx.schema[SCALAR$1];
  } else if (tagName)
    tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token.type === "scalar")
    tag = findScalarTagByTest(ctx, value, token, onError);
  else
    tag = ctx.schema[SCALAR$1];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar$1(res) ? res : new Scalar(res);
  } catch (error22) {
    const msg = error22 instanceof Error ? error22.message : String(error22);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type2)
    scalar.type = type2;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment2)
    scalar.comment = comment2;
  return scalar;
}
__name(composeScalar, "composeScalar");
function findScalarTagByName(schema2, value, tagName, tagToken, onError) {
  if (tagName === "!")
    return schema2[SCALAR$1];
  const matchWithTest = [];
  for (const tag of schema2.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if (tag.test?.test(value))
      return tag;
  const kt = schema2.knownTags[tagName];
  if (kt && !kt.collection) {
    schema2.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema2[SCALAR$1];
}
__name(findScalarTagByName, "findScalarTagByName");
function findScalarTagByTest({ atKey, directives, schema: schema2 }, value, token, onError) {
  const tag = schema2.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema2[SCALAR$1];
  if (schema2.compat) {
    const compat = schema2.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema2[SCALAR$1];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}
__name(findScalarTagByTest, "findScalarTagByTest");
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while (st?.type === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}
__name(emptyScalarPosition, "emptyScalarPosition");
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment: comment2, anchor, tag } = props;
  let node2;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node2 = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node2 = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node2.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node2 = composeCollection(CN, ctx, token, props, onError);
      if (anchor)
        node2.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node2 = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node2.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar$1(node2) || typeof node2.value !== "string" || node2.tag && node2.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag ?? token, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node2.spaceBefore = true;
  if (comment2) {
    if (token.type === "scalar" && token.source === "")
      node2.comment = comment2;
    else
      node2.commentBefore = comment2;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node2.srcToken = token;
  return node2;
}
__name(composeNode, "composeNode");
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment: comment2, anchor, tag, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node2 = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node2.anchor = anchor.source.substring(1);
    if (node2.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node2.spaceBefore = true;
  if (comment2) {
    node2.comment = comment2;
    node2.range[2] = end;
  }
  return node2;
}
__name(composeEmptyNode, "composeEmptyNode");
function composeAlias({ options: options2 }, { offset, source: source7, end }, onError) {
  const alias = new Alias(source7.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source7.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source7.length;
  const re2 = resolveEnd(end, valueEnd, options2.strict, onError);
  alias.range = [offset, valueEnd, re2.offset];
  if (re2.comment)
    alias.comment = re2.comment;
  return alias;
}
__name(composeAlias, "composeAlias");
function composeDoc(options2, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options2);
  const doc = new Document(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value ?? end?.[0],
    offset,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re2 = resolveEnd(end, contentEnd, false, onError);
  if (re2.comment)
    doc.comment = re2.comment;
  doc.range = [offset, contentEnd, re2.offset];
  return doc;
}
__name(composeDoc, "composeDoc");
function getErrorPos(src2) {
  if (typeof src2 === "number")
    return [src2, src2 + 1];
  if (Array.isArray(src2))
    return src2.length === 2 ? src2 : [src2[0], src2[1]];
  const { offset, source: source7 } = src2;
  return [offset, offset + (typeof source7 === "string" ? source7.length : 1)];
}
__name(getErrorPos, "getErrorPos");
function parsePrelude(prelude) {
  let comment2 = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source7 = prelude[i];
    switch (source7[0]) {
      case "#":
        comment2 += (comment2 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source7.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i + 1]?.[0] !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment: comment2, afterEmptyLine };
}
__name(parsePrelude, "parsePrelude");
var Composer = class {
  static {
    __name(this, "Composer");
  }
  constructor(options2 = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source7, code, message, warning) => {
      const pos = getErrorPos(source7);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options2.version || "1.2" });
    this.options = options2;
  }
  decorate(doc, afterDoc) {
    const { comment: comment2, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment2) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment2}` : comment2;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment2;
      } else if (isCollection$1(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error22 = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error22);
        else
          this.doc.errors.push(error22);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = /* @__PURE__ */ __name((pos, code, message) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset, code, message);
      else
        throw new YAMLParseError([offset, offset + 1], code, message);
    }, "_onError");
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar({ options: { strict } }, token, _onError);
    }
  }
  return null;
}
__name(resolveAsScalar, "resolveAsScalar");
function createScalarToken(value, context2) {
  const { implicitKey = false, indent, inFlow = false, offset = -1, type: type2 = "PLAIN" } = context2;
  const source7 = stringifyString({ type: type2, value }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context2.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source7[0]) {
    case "|":
    case ">": {
      const he = source7.indexOf("\n");
      const head = source7.substring(0, he);
      const body = source7.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source: source7, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source: source7, end };
    default:
      return { type: "scalar", offset, indent, source: source7, end };
  }
}
__name(createScalarToken, "createScalarToken");
function setScalarValue(token, value, context2 = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type: type2 } = context2;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type2)
    switch (token.type) {
      case "single-quoted-scalar":
        type2 = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type2 = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type2 = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type2 = "PLAIN";
    }
  const source7 = stringifyString({ type: type2, value }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source7[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source7);
      break;
    case '"':
      setFlowScalarValue(token, source7, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source7, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source7, "scalar");
  }
}
__name(setScalarValue, "setScalarValue");
function setBlockScalarValue(token, source7) {
  const he = source7.indexOf("\n");
  const head = source7.substring(0, he);
  const body = source7.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
__name(setBlockScalarValue, "setBlockScalarValue");
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
__name(addEndtoBlockProps, "addEndtoBlockProps");
function setFlowScalarValue(token, source7, type2) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type2;
      token.source = source7;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source7.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type: type2, source: source7, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source7.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type: type2, source: source7, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: type2, indent, source: source7, end });
    }
  }
}
__name(setFlowScalarValue, "setFlowScalarValue");
var stringify$1 = /* @__PURE__ */ __name((cst2) => "type" in cst2 ? stringifyToken(cst2) : stringifyItem(cst2), "stringify$1");
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
__name(stringifyToken, "stringifyToken");
function stringifyItem({ start, key, sep, value }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep)
    for (const st of sep)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}
__name(stringifyItem, "stringifyItem");
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove item");
function visit(cst2, visitor) {
  if ("type" in cst2 && cst2.type === "document")
    cst2 = { start: cst2.start, value: cst2.value };
  _visit(Object.freeze([]), cst2, visitor);
}
__name(visit, "visit");
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
visit.itemAtPath = (cst2, path31) => {
  let item = cst2;
  for (const [field, index2] of path31) {
    const tok = item?.[field];
    if (tok && "items" in tok) {
      item = tok.items[index2];
    } else
      return void 0;
  }
  return item;
};
visit.parentCollection = (cst2, path31) => {
  const parent = visit.itemAtPath(cst2, path31.slice(0, -1));
  const field = path31[path31.length - 1][0];
  const coll = parent?.[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path31, item, visitor) {
  let ctrl = visitor(item, path31);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path31.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path31);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path31) : ctrl;
}
__name(_visit, "_visit");
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR = "";
var isCollection = /* @__PURE__ */ __name((token) => !!token && "items" in token, "isCollection");
var isScalar = /* @__PURE__ */ __name((token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar"), "isScalar");
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
__name(prettyToken, "prettyToken");
function tokenType(source7) {
  switch (source7) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source7[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
__name(tokenType, "tokenType");
var cst = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOM,
  DOCUMENT,
  FLOW_END,
  SCALAR,
  createScalarToken,
  isCollection,
  isScalar,
  prettyToken,
  resolveAsScalar,
  setScalarValue,
  stringify: stringify$1,
  tokenType,
  visit
}, Symbol.toStringTag, { value: "Module" }));
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
__name(isEmpty, "isEmpty");
var hexDigits = new Set("0123456789ABCDEFabcdef");
var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var flowIndicatorChars = new Set(",[]{}");
var invalidAnchorChars = new Set(" ,[]{}\n\r	");
var isNotAnchorChar = /* @__PURE__ */ __name((ch) => !ch || invalidAnchorChars.has(ch), "isNotAnchorChar");
var Lexer = class {
  static {
    __name(this, "Lexer");
  }
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source7, incomplete = false) {
    if (source7) {
      if (typeof source7 !== "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source7 : source7;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = this.next ?? "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      let cs = line.indexOf("#");
      while (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	") {
          dirEnd = cs - 1;
          break;
        } else {
          cs = line.indexOf("#", cs + 1);
        }
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return s === "---" ? "doc" : "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      // fallthrough
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      // fallthrough
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote5 = this.charAt(0);
    let end = this.buffer.indexOf(quote5, this.pos + 1);
    if (quote5 === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
      switch (ch) {
        case " ":
          indent += 1;
          break;
        case "\n":
          nl = i2;
          indent = 0;
          break;
        case "\r": {
          const next = this.buffer[i2 + 1];
          if (!next && !this.atEnd)
            return this.setNext("block-scalar");
          if (next === "\n")
            break;
        }
        // fallthrough
        default:
          break loop;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else {
        this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      }
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    let i = nl + 1;
    ch = this.buffer[i];
    while (ch === " ")
      ch = this.buffer[++i];
    if (ch === "	") {
      while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
        ch = this.buffer[++i];
      nl = i - 1;
    } else if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " ")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && flowIndicatorChars.has(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && flowIndicatorChars.has(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.has(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};
var LineCounter = class {
  static {
    __name(this, "LineCounter");
  }
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};
function includesToken(list, type2) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type2)
      return true;
  return false;
}
__name(includesToken, "includesToken");
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
__name(findNonEmptyIndex, "findNonEmptyIndex");
function isFlowToken(token) {
  switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
__name(isFlowToken, "isFlowToken");
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
__name(getPrevProps, "getPrevProps");
function getFirstKeyStartProps(prev) {
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop: while (--i >= 0) {
    switch (prev[i].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break loop;
    }
  }
  while (prev[++i]?.type === "space") {
  }
  return prev.splice(i, prev.length);
}
__name(getFirstKeyStartProps, "getFirstKeyStartProps");
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
__name(fixFlowSeqItems, "fixFlowSeqItems");
var Parser = class {
  static {
    __name(this, "Parser");
  }
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source7, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source7, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source7) {
    this.source = source7;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source7.length;
      return;
    }
    const type2 = tokenType(source7);
    if (!type2) {
      const message = `Not a YAML token: ${source7}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source: source7 });
      this.offset += source7.length;
    } else if (type2 === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type2;
      yield* this.step();
      switch (type2) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source7.length);
          break;
        case "space":
          if (this.atNewLine && source7[0] === " ")
            this.indent += source7.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source7.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source7.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error22) {
    const token = error22 ?? this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !it.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if (last?.type === "comment")
            end?.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = prev?.value?.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map2.indent;
      const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !it.explicitKey) {
            it.start.push(this.sourceToken);
            it.explicitKey = true;
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start, explicitKey: true });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken], explicitKey: true }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (it.explicitKey) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep = it.sep;
              sep.push(this.sourceToken);
              delete it.key;
              delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs2 = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start, key: fs2, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs2);
          } else {
            Object.assign(it, { key: fs2, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (atMapIndent && bv.type !== "block-seq") {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if (last?.type === "comment")
            end?.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = prev?.value?.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs2 = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs2, sep: [] });
          else if (it.sep)
            this.stack.push(fs2);
          else
            Object.assign(it, { key: fs2, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type2) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type: type2,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      // fallthrough
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};
function parseOptions(options2) {
  const prettyErrors = options2.prettyErrors !== false;
  const lineCounter = options2.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
__name(parseOptions, "parseOptions");
function parseAllDocuments(source7, options2 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options2);
  const parser2 = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options2);
  const docs = Array.from(composer.compose(parser2.parse(source7)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError(source7, lineCounter));
      doc.warnings.forEach(prettifyError(source7, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
__name(parseAllDocuments, "parseAllDocuments");
function parseDocument(source7, options2 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options2);
  const parser2 = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options2);
  let doc = null;
  for (const _doc of composer.compose(parser2.parse(source7), true, source7.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source7, lineCounter));
    doc.warnings.forEach(prettifyError(source7, lineCounter));
  }
  return doc;
}
__name(parseDocument, "parseDocument");
function parse(src2, reviver, options2) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options2 === void 0 && reviver && typeof reviver === "object") {
    options2 = reviver;
  }
  const doc = parseDocument(src2, options2);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn3(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options2));
}
__name(parse, "parse");
function stringify(value, replacer, options2) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options2 === void 0 && replacer) {
    options2 = replacer;
  }
  if (typeof options2 === "string")
    options2 = options2.length;
  if (typeof options2 === "number") {
    const indent = Math.round(options2);
    options2 = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value === void 0) {
    const { keepUndefined } = options2 ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  if (isDocument(value) && !_replacer)
    return value.toString(options2);
  return new Document(value, _replacer, options2).toString(options2);
}
__name(stringify, "stringify");
var YAML = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alias,
  CST: cst,
  Composer,
  Document,
  Lexer,
  LineCounter,
  Pair,
  Parser,
  Scalar,
  Schema,
  YAMLError,
  YAMLMap,
  YAMLParseError,
  YAMLSeq,
  YAMLWarning,
  isAlias,
  isCollection: isCollection$1,
  isDocument,
  isMap,
  isNode,
  isPair,
  isScalar: isScalar$1,
  isSeq,
  parse,
  parseAllDocuments,
  parseDocument,
  stringify,
  visit: visit$1,
  visitAsync
}, Symbol.toStringTag, { value: "Module" }));
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser = /* @__PURE__ */ __name(function() {
    throw new Error(
      "ws does not work in the browser. Browser clients must use the native WebSocket object"
    );
  }, "browser");
  return browser;
}
__name(requireBrowser, "requireBrowser");
var browserExports = requireBrowser();
var wsLibrary = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var colors = colorsLibrary;
var debug4 = debugLibrary;
var diff2 = diffLibrary;
var dotenv = dotenvLibrary;
var jpegjs = jpegLibrary;
var lockfileLibrary = requireLockfile();
var lockfile = lockfileLibrary;
var mime = mimeLibrary;
var minimatch = minimatchLibrary;
var open2 = openLibrary;
var progress = progressLibrary;
var yaml = YAML;
var ws = wsLibrary;
var wsServer = browserExports.WebSocketServer;
var wsReceiver = browserExports.Receiver;
var wsSender = browserExports.Sender;
var HttpsProxyAgent = distExports$1.HttpsProxyAgent;
var SocksProxyAgent = distExports.SocksProxyAgent;
var getProxyForUrl = proxyFromEnvExports.getProxyForUrl;
var program = commanderExports.program;

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/_virtual/_commonjsHelpers.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
__name(getDefaultExportFromCjs2, "getDefaultExportFromCjs");
function getAugmentedNamespace2(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = /* @__PURE__ */ __name(function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    }, "a");
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return n[k];
      }, "get")
    });
  });
  return a;
}
__name(getAugmentedNamespace2, "getAugmentedNamespace");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/_virtual/utilsBundleImpl.js
var require$$02 = /* @__PURE__ */ getAugmentedNamespace2(utilsBundleImpl_exports);

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utilsBundle.js
var colors2 = require$$02.colors;
var debug5 = require$$02.debug;
var diff3 = require$$02.diff;
var dotenv2 = require$$02.dotenv;
var getProxyForUrl2 = require$$02.getProxyForUrl;
var HttpsProxyAgent2 = require$$02.HttpsProxyAgent;
var jpegjs2 = require$$02.jpegjs;
var lockfile2 = require$$02.lockfile;
var mime2 = require$$02.mime;
var minimatch2 = require$$02.minimatch;
var open3 = require$$02.open;
var PNG2 = require$$02.PNG;
var program2 = require$$02.program;
var progress2 = require$$02.progress;
var SocksProxyAgent2 = require$$02.SocksProxyAgent;
var yaml2 = require$$02.yaml;
var ws2 = require$$02.ws;
var wsServer2 = require$$02.wsServer;
var wsReceiver2 = require$$02.wsReceiver;
var wsSender2 = require$$02.wsSender;

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/debugLogger.js
var debugLoggerColorMap = {
  "api": 45,
  // cyan
  "protocol": 34,
  // green
  "install": 34,
  // green
  "download": 34,
  // green
  "browser": 0,
  // reset
  "socks": 92,
  // purple
  "client-certificates": 92,
  // purple
  "error": 160,
  // red,
  "channel": 33,
  // blue
  "server": 45,
  // cyan
  "server:channel": 34,
  // green
  "server:metadata": 33,
  // blue,
  "recorder": 45
  // cyan
};
var DebugLogger = class {
  static {
    __name(this, "DebugLogger");
  }
  constructor() {
    this._debuggers = /* @__PURE__ */ new Map();
    if (process.env.DEBUG_FILE) {
      const ansiRegex = new RegExp([
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|"), "g");
      const stream = fs.createWriteStream(process.env.DEBUG_FILE);
      debug5.log = (data) => {
        stream.write(data.replace(ansiRegex, ""));
        stream.write("\n");
      };
    }
  }
  log(name, message) {
    let cachedDebugger = this._debuggers.get(name);
    if (!cachedDebugger) {
      cachedDebugger = debug5(`pw:${name}`);
      this._debuggers.set(name, cachedDebugger);
      cachedDebugger.color = debugLoggerColorMap[name] || 0;
    }
    cachedDebugger(message);
  }
  isEnabled(name) {
    return debug5.enabled(`pw:${name}`);
  }
};
var debugLogger = new DebugLogger();
var kLogCount = 150;
var RecentLogsCollector = class {
  static {
    __name(this, "RecentLogsCollector");
  }
  constructor() {
    this._logs = [];
  }
  log(message) {
    this._logs.push(message);
    if (this._logs.length === kLogCount * 2)
      this._logs.splice(0, kLogCount);
  }
  recentLogs() {
    if (this._logs.length > kLogCount)
      return this._logs.slice(-150);
    return this._logs;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/happyEyeballs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import require$$0$82 from "node:dns";

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/http.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http/request.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
import { Socket } from "node:net";
import { Readable } from "node:stream";
var IncomingMessage = class extends Readable {
  static {
    __name(this, "IncomingMessage");
  }
  __unenv__ = {};
  aborted = false;
  httpVersion = "1.1";
  httpVersionMajor = 1;
  httpVersionMinor = 1;
  complete = true;
  connection;
  socket;
  headers = {};
  trailers = {};
  method = "GET";
  url = "/";
  statusCode = 200;
  statusMessage = "";
  closed = false;
  errored = null;
  readable = false;
  constructor(socket) {
    super();
    this.socket = this.connection = socket || new Socket();
  }
  get rawHeaders() {
    return rawHeaders(this.headers);
  }
  get rawTrailers() {
    return [];
  }
  setTimeout(_msecs, _callback) {
    return this;
  }
  get headersDistinct() {
    return _distinct(this.headers);
  }
  get trailersDistinct() {
    return _distinct(this.trailers);
  }
  _read() {
  }
};
function _distinct(obj) {
  const d = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key) {
      d[key] = (Array.isArray(value) ? value : [value]).filter(Boolean);
    }
  }
  return d;
}
__name(_distinct, "_distinct");

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http/response.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { Writable as Writable2 } from "node:stream";
var ServerResponse = class extends Writable2 {
  static {
    __name(this, "ServerResponse");
  }
  __unenv__ = true;
  statusCode = 200;
  statusMessage = "";
  upgrading = false;
  chunkedEncoding = false;
  shouldKeepAlive = false;
  useChunkedEncodingByDefault = false;
  sendDate = false;
  finished = false;
  headersSent = false;
  strictContentLength = false;
  connection = null;
  socket = null;
  req;
  _headers = {};
  constructor(req) {
    super();
    this.req = req;
  }
  assignSocket(socket) {
    socket._httpMessage = this;
    this.socket = socket;
    this.connection = socket;
    this.emit("socket", socket);
    this._flush();
  }
  _flush() {
    this.flushHeaders();
  }
  detachSocket(_socket) {
  }
  writeContinue(_callback) {
  }
  writeHead(statusCode, arg1, arg2) {
    if (statusCode) {
      this.statusCode = statusCode;
    }
    if (typeof arg1 === "string") {
      this.statusMessage = arg1;
      arg1 = void 0;
    }
    const headers = arg2 || arg1;
    if (headers) {
      if (Array.isArray(headers)) {
      } else {
        for (const key in headers) {
          this.setHeader(key, headers[key]);
        }
      }
    }
    this.headersSent = true;
    return this;
  }
  writeProcessing() {
  }
  setTimeout(_msecs, _callback) {
    return this;
  }
  appendHeader(name, value) {
    name = name.toLowerCase();
    const current = this._headers[name];
    const all = [...Array.isArray(current) ? current : [current], ...Array.isArray(value) ? value : [value]].filter(Boolean);
    this._headers[name] = all.length > 1 ? all : all[0];
    return this;
  }
  setHeader(name, value) {
    this._headers[name.toLowerCase()] = Array.isArray(value) ? [...value] : value;
    return this;
  }
  setHeaders(headers) {
    for (const [key, value] of headers.entries()) {
      this.setHeader(key, value);
    }
    return this;
  }
  getHeader(name) {
    return this._headers[name.toLowerCase()];
  }
  getHeaders() {
    return this._headers;
  }
  getHeaderNames() {
    return Object.keys(this._headers);
  }
  hasHeader(name) {
    return name.toLowerCase() in this._headers;
  }
  removeHeader(name) {
    delete this._headers[name.toLowerCase()];
  }
  addTrailers(_headers) {
  }
  flushHeaders() {
  }
  writeEarlyHints(_headers, cb) {
    if (typeof cb === "function") {
      cb();
    }
  }
};

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http/agent.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter2 } from "node:events";
var Agent = class extends EventEmitter2 {
  static {
    __name(this, "Agent");
  }
  __unenv__ = {};
  maxFreeSockets = 256;
  maxSockets = Infinity;
  maxTotalSockets = Infinity;
  freeSockets = {};
  sockets = {};
  requests = {};
  options;
  constructor(opts = {}) {
    super();
    this.options = opts;
  }
  destroy() {
  }
};

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http/constants.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var METHODS = [
  "ACL",
  "BIND",
  "CHECKOUT",
  "CONNECT",
  "COPY",
  "DELETE",
  "GET",
  "HEAD",
  "LINK",
  "LOCK",
  "M-SEARCH",
  "MERGE",
  "MKACTIVITY",
  "MKCALENDAR",
  "MKCOL",
  "MOVE",
  "NOTIFY",
  "OPTIONS",
  "PATCH",
  "POST",
  "PRI",
  "PROPFIND",
  "PROPPATCH",
  "PURGE",
  "PUT",
  "REBIND",
  "REPORT",
  "SEARCH",
  "SOURCE",
  "SUBSCRIBE",
  "TRACE",
  "UNBIND",
  "UNLINK",
  "UNLOCK",
  "UNSUBSCRIBE"
];
var STATUS_CODES = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a Teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Too Early",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
var maxHeaderSize = 16384;

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/http.mjs
var createServer3 = /* @__PURE__ */ notImplemented("http.createServer");
var request = /* @__PURE__ */ notImplemented("http.request");
var get = /* @__PURE__ */ notImplemented("http.get");
var Server2 = /* @__PURE__ */ notImplementedClass("http.Server");
var OutgoingMessage = /* @__PURE__ */ notImplementedClass("http.OutgoingMessage");
var ClientRequest = /* @__PURE__ */ notImplementedClass("http.ClientRequest");
var globalAgent = new Agent();
var validateHeaderName = /* @__PURE__ */ notImplemented("http.validateHeaderName");
var validateHeaderValue = /* @__PURE__ */ notImplemented("http.validateHeaderValue");
var setMaxIdleHTTPParsers = /* @__PURE__ */ notImplemented("http.setMaxIdleHTTPParsers");
var _connectionListener = /* @__PURE__ */ notImplemented("http._connectionListener");
var WebSocket2 = globalThis.WebSocket || /* @__PURE__ */ notImplementedClass("WebSocket");
var CloseEvent = globalThis.CloseEvent || /* @__PURE__ */ notImplementedClass("CloseEvent");
var MessageEvent = globalThis.MessageEvent || /* @__PURE__ */ notImplementedClass("MessageEvent");
var http_default = {
  METHODS,
  STATUS_CODES,
  maxHeaderSize,
  IncomingMessage,
  ServerResponse,
  WebSocket: WebSocket2,
  CloseEvent,
  MessageEvent,
  createServer: createServer3,
  request,
  get,
  Server: Server2,
  OutgoingMessage,
  ClientRequest,
  Agent,
  globalAgent,
  validateHeaderName,
  validateHeaderValue,
  setMaxIdleHTTPParsers,
  _connectionListener
};

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/https.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
var Server3 = /* @__PURE__ */ notImplementedClass("https.Server");
var Agent2 = Agent;
var globalAgent2 = /* @__PURE__ */ new Agent2();
var get2 = /* @__PURE__ */ notImplemented("https.get");
var createServer4 = /* @__PURE__ */ notImplemented("https.createServer");
var request2 = /* @__PURE__ */ notImplemented("https.request");
var https_default = {
  Server: Server3,
  Agent: Agent2,
  globalAgent: globalAgent2,
  get: get2,
  createServer: createServer4,
  request: request2
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/happyEyeballs.js
import net2 from "node:net";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/manualPromise.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/builtins.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function builtins(global2) {
  global2 = global2 ?? globalThis;
  if (!global2["__playwright_builtins__"]) {
    const builtins2 = {
      setTimeout: global2.setTimeout?.bind(global2),
      clearTimeout: global2.clearTimeout?.bind(global2),
      setInterval: global2.setInterval?.bind(global2),
      clearInterval: global2.clearInterval?.bind(global2),
      requestAnimationFrame: global2.requestAnimationFrame?.bind(global2),
      cancelAnimationFrame: global2.cancelAnimationFrame?.bind(global2),
      requestIdleCallback: global2.requestIdleCallback?.bind(global2),
      cancelIdleCallback: global2.cancelIdleCallback?.bind(global2),
      performance: global2.performance,
      eval: global2.eval?.bind(global2),
      Intl: global2.Intl,
      Date: global2.Date,
      Map: global2.Map,
      Set: global2.Set
    };
    Object.defineProperty(global2, "__playwright_builtins__", { value: builtins2, configurable: false, enumerable: false, writable: false });
  }
  return global2["__playwright_builtins__"];
}
__name(builtins, "builtins");
var instance = builtins();
var setTimeout2 = instance.setTimeout;
var clearTimeout2 = instance.clearTimeout;
instance.setInterval;
instance.clearInterval;
instance.requestAnimationFrame;
instance.cancelAnimationFrame;
instance.requestIdleCallback;
instance.cancelIdleCallback;
var performance3 = instance.performance;
instance.Intl;
instance.Date;
var Map2 = instance.Map;
var Set2 = instance.Set;

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/stackTrace.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function captureRawStack() {
  const stackTraceLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = 50;
  const error4 = new Error();
  const stack = error4.stack || "";
  Error.stackTraceLimit = stackTraceLimit;
  return stack.split("\n");
}
__name(captureRawStack, "captureRawStack");
function parseStackFrame(text, pathSeparator, showInternalStackFrames) {
  const match = text && text.match(re);
  if (!match)
    return null;
  let fname = match[2];
  let file = match[7];
  if (!file)
    return null;
  if (!showInternalStackFrames && (file.startsWith("internal") || file.startsWith("node:")))
    return null;
  const line = match[8];
  const column = match[9];
  const closeParen = match[11] === ")";
  const frame = {
    file: "",
    line: 0,
    column: 0
  };
  if (line)
    frame.line = Number(line);
  if (column)
    frame.column = Number(column);
  if (closeParen && file) {
    let closes = 0;
    for (let i = file.length - 1; i > 0; i--) {
      if (file.charAt(i) === ")") {
        closes++;
      } else if (file.charAt(i) === "(" && file.charAt(i - 1) === " ") {
        closes--;
        if (closes === -1 && file.charAt(i - 1) === " ") {
          const before = file.slice(0, i - 1);
          const after = file.slice(i + 1);
          file = after;
          fname += ` (${before}`;
          break;
        }
      }
    }
  }
  if (fname) {
    const methodMatch = fname.match(methodRe);
    if (methodMatch)
      fname = methodMatch[1];
  }
  if (file) {
    if (file.startsWith("file://"))
      file = fileURLToPath(file, pathSeparator);
    frame.file = file;
  }
  if (fname)
    frame.function = fname;
  return frame;
}
__name(parseStackFrame, "parseStackFrame");
function rewriteErrorMessage(e, newMessage) {
  const lines = (e.stack?.split("\n") || []).filter((l) => l.startsWith("    at "));
  e.message = newMessage;
  const errorTitle = `${e.name}: ${e.message}`;
  if (lines.length)
    e.stack = `${errorTitle}
${lines.join("\n")}`;
  return e;
}
__name(rewriteErrorMessage, "rewriteErrorMessage");
function stringifyStackFrames(frames) {
  const stackLines = [];
  for (const frame of frames) {
    if (frame.function)
      stackLines.push(`    at ${frame.function} (${frame.file}:${frame.line}:${frame.column})`);
    else
      stackLines.push(`    at ${frame.file}:${frame.line}:${frame.column}`);
  }
  return stackLines;
}
__name(stringifyStackFrames, "stringifyStackFrames");
function splitErrorMessage(message) {
  const separationIdx = message.indexOf(":");
  return {
    name: separationIdx !== -1 ? message.slice(0, separationIdx) : "",
    message: separationIdx !== -1 && separationIdx + 2 <= message.length ? message.substring(separationIdx + 2) : message
  };
}
__name(splitErrorMessage, "splitErrorMessage");
var re = new RegExp(
  "^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$"
);
var methodRe = /^(.*?) \[as (.*?)\]$/;
function fileURLToPath(fileUrl, pathSeparator) {
  if (!fileUrl.startsWith("file://"))
    return fileUrl;
  let path31 = decodeURIComponent(fileUrl.slice(7));
  if (path31.startsWith("/") && /^[a-zA-Z]:/.test(path31.slice(1)))
    path31 = path31.slice(1);
  return path31.replace(/\//g, pathSeparator);
}
__name(fileURLToPath, "fileURLToPath");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/manualPromise.js
var ManualPromise = class extends Promise {
  static {
    __name(this, "ManualPromise");
  }
  constructor() {
    let resolve;
    let reject;
    super((f, r) => {
      resolve = f;
      reject = r;
    });
    this._isDone = false;
    this._resolve = resolve;
    this._reject = reject;
  }
  isDone() {
    return this._isDone;
  }
  resolve(t) {
    this._isDone = true;
    this._resolve(t);
  }
  reject(e) {
    this._isDone = true;
    this._reject(e);
  }
  static get [Symbol.species]() {
    return Promise;
  }
  get [Symbol.toStringTag]() {
    return "ManualPromise";
  }
};
var LongStandingScope = class {
  static {
    __name(this, "LongStandingScope");
  }
  constructor() {
    this._terminatePromises = new Map2();
    this._isClosed = false;
  }
  reject(error4) {
    this._isClosed = true;
    this._terminateError = error4;
    for (const p of this._terminatePromises.keys())
      p.resolve(error4);
  }
  close(error4) {
    this._isClosed = true;
    this._closeError = error4;
    for (const [p, frames] of this._terminatePromises)
      p.resolve(cloneError(error4, frames));
  }
  isClosed() {
    return this._isClosed;
  }
  static async raceMultiple(scopes, promise) {
    return Promise.race(scopes.map((s) => s.race(promise)));
  }
  async race(promise) {
    return this._race(Array.isArray(promise) ? promise : [promise], false);
  }
  async safeRace(promise, defaultValue) {
    return this._race([promise], true, defaultValue);
  }
  async _race(promises2, safe2, defaultValue) {
    const terminatePromise = new ManualPromise();
    const frames = captureRawStack();
    if (this._terminateError)
      terminatePromise.resolve(this._terminateError);
    if (this._closeError)
      terminatePromise.resolve(cloneError(this._closeError, frames));
    this._terminatePromises.set(terminatePromise, frames);
    try {
      return await Promise.race([
        terminatePromise.then((e) => safe2 ? defaultValue : Promise.reject(e)),
        ...promises2
      ]);
    } finally {
      this._terminatePromises.delete(terminatePromise);
    }
  }
};
function cloneError(error4, frames) {
  const clone = new Error();
  clone.name = error4.name;
  clone.message = error4.message;
  clone.stack = [error4.name + ":" + error4.message, ...frames].join("\n");
  return clone;
}
__name(cloneError, "cloneError");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/time.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var _timeOrigin2 = performance3.timeOrigin;
var _timeShift = 0;
function monotonicTime() {
  return Math.floor((performance3.now() + _timeShift) * 1e3) / 1e3;
}
__name(monotonicTime, "monotonicTime");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/happyEyeballs.js
var connectionAttemptDelayMs = 300;
var kDNSLookupAt = Symbol("kDNSLookupAt");
var kTCPConnectionAt = Symbol("kTCPConnectionAt");
var HttpHappyEyeballsAgent = class extends http_default.Agent {
  static {
    __name(this, "HttpHappyEyeballsAgent");
  }
  createConnection(options2, oncreate) {
    if (net2.isIP(clientRequestArgsToHostName(options2)))
      return net2.createConnection(options2);
    createConnectionAsync(
      options2,
      oncreate,
      /* useTLS */
      false
    ).catch((err) => oncreate?.(err));
  }
};
var HttpsHappyEyeballsAgent = class extends https_default.Agent {
  static {
    __name(this, "HttpsHappyEyeballsAgent");
  }
  createConnection(options2, oncreate) {
    if (net2.isIP(clientRequestArgsToHostName(options2)))
      return tls_default.connect(options2);
    createConnectionAsync(
      options2,
      oncreate,
      /* useTLS */
      true
    ).catch((err) => oncreate?.(err));
  }
};
var httpsHappyEyeballsAgent = new HttpsHappyEyeballsAgent({ keepAlive: true });
var httpHappyEyeballsAgent = new HttpHappyEyeballsAgent({ keepAlive: true });
async function createSocket(host, port) {
  return new Promise((resolve, reject) => {
    if (net2.isIP(host)) {
      const socket = net2.createConnection({ host, port });
      socket.on("connect", () => resolve(socket));
      socket.on("error", (error4) => reject(error4));
    } else {
      createConnectionAsync(
        { host, port },
        (err, socket) => {
          if (err)
            reject(err);
          if (socket)
            resolve(socket);
        },
        /* useTLS */
        false
      ).catch((err) => reject(err));
    }
  });
}
__name(createSocket, "createSocket");
async function createTLSSocket(options2) {
  return new Promise((resolve, reject) => {
    assert3(options2.host, "host is required");
    if (net2.isIP(options2.host)) {
      const socket = tls_default.connect(options2);
      socket.on("secureConnect", () => resolve(socket));
      socket.on("error", (error4) => reject(error4));
    } else {
      createConnectionAsync(options2, (err, socket) => {
        if (err)
          reject(err);
        if (socket) {
          socket.on("secureConnect", () => resolve(socket));
          socket.on("error", (error4) => reject(error4));
        }
      }, true).catch((err) => reject(err));
    }
  });
}
__name(createTLSSocket, "createTLSSocket");
async function createConnectionAsync(options2, oncreate, useTLS) {
  const lookup = options2.__testHookLookup || lookupAddresses;
  const hostname2 = clientRequestArgsToHostName(options2);
  const addresses = await lookup(hostname2);
  const dnsLookupAt = monotonicTime();
  const sockets = /* @__PURE__ */ new Set();
  let firstError;
  let errorCount = 0;
  const handleError = /* @__PURE__ */ __name((socket, err) => {
    if (!sockets.delete(socket))
      return;
    ++errorCount;
    firstError ??= err;
    if (errorCount === addresses.length)
      oncreate?.(firstError);
  }, "handleError");
  const connected2 = new ManualPromise();
  for (const { address } of addresses) {
    const socket = useTLS ? tls_default.connect({
      ...options2,
      port: options2.port,
      host: address,
      servername: hostname2
    }) : net2.createConnection({
      ...options2,
      port: options2.port,
      host: address
    });
    socket[kDNSLookupAt] = dnsLookupAt;
    socket.on("connect", () => {
      socket[kTCPConnectionAt] = monotonicTime();
      connected2.resolve();
      oncreate?.(null, socket);
      sockets.delete(socket);
      for (const s of sockets)
        s.destroy();
      sockets.clear();
    });
    socket.on("timeout", () => {
      socket.destroy();
      handleError(socket, new Error("Connection timeout"));
    });
    socket.on("error", (e) => handleError(socket, e));
    sockets.add(socket);
    await Promise.race([
      connected2,
      new Promise((f) => setTimeout(f, connectionAttemptDelayMs))
    ]);
    if (connected2.isDone())
      break;
  }
}
__name(createConnectionAsync, "createConnectionAsync");
async function lookupAddresses(hostname2) {
  const addresses = await require$$0$82.promises.lookup(hostname2, { all: true, family: 0, verbatim: true });
  let firstFamily = addresses.filter(({ family }) => family === 6);
  let secondFamily = addresses.filter(({ family }) => family === 4);
  if (firstFamily.length && firstFamily[0] !== addresses[0]) {
    const tmp = firstFamily;
    firstFamily = secondFamily;
    secondFamily = tmp;
  }
  const result = [];
  for (let i = 0; i < Math.max(firstFamily.length, secondFamily.length); i++) {
    if (firstFamily[i])
      result.push(firstFamily[i]);
    if (secondFamily[i])
      result.push(secondFamily[i]);
  }
  return result;
}
__name(lookupAddresses, "lookupAddresses");
function clientRequestArgsToHostName(options2) {
  if (options2.hostname)
    return options2.hostname;
  if (options2.host)
    return options2.host;
  throw new Error("Either options.hostname or options.host must be provided");
}
__name(clientRequestArgsToHostName, "clientRequestArgsToHostName");
function timingForSocket(socket) {
  return {
    dnsLookupAt: socket[kDNSLookupAt],
    tcpConnectionAt: socket[kTCPConnectionAt]
  };
}
__name(timingForSocket, "timingForSocket");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/socksProxy.js
var SocksConnection = class {
  static {
    __name(this, "SocksConnection");
  }
  constructor(uid, socket, client) {
    this._buffer = Buffer.from([]);
    this._offset = 0;
    this._fence = 0;
    this._uid = uid;
    this._socket = socket;
    this._client = client;
    this._boundOnData = this._onData.bind(this);
    socket.on("data", this._boundOnData);
    socket.on("close", () => this._onClose());
    socket.on("end", () => this._onClose());
    socket.on("error", () => this._onClose());
    this._run().catch(() => this._socket.end());
  }
  async _run() {
    assert3(await this._authenticate());
    const { command: command2, host, port } = await this._parseRequest();
    if (command2 !== 1) {
      this._writeBytes(Buffer.from([
        5,
        7,
        0,
        // RSV
        1,
        // IPv4
        0,
        0,
        0,
        0,
        // Address
        0,
        0
        // Port
      ]));
      return;
    }
    this._socket.off("data", this._boundOnData);
    this._client.onSocketRequested({ uid: this._uid, host, port });
  }
  async _authenticate() {
    const version6 = await this._readByte();
    assert3(version6 === 5, "The VER field must be set to x05 for this version of the protocol, was " + version6);
    const nMethods = await this._readByte();
    assert3(nMethods, "No authentication methods specified");
    const methods = await this._readBytes(nMethods);
    for (const method of methods) {
      if (method === 0) {
        this._writeBytes(Buffer.from([version6, method]));
        return true;
      }
    }
    this._writeBytes(Buffer.from([
      version6,
      255
      /* NO_ACCEPTABLE_METHODS */
    ]));
    return false;
  }
  async _parseRequest() {
    const version6 = await this._readByte();
    assert3(version6 === 5, "The VER field must be set to x05 for this version of the protocol, was " + version6);
    const command2 = await this._readByte();
    await this._readByte();
    const addressType = await this._readByte();
    let host = "";
    switch (addressType) {
      case 1:
        host = (await this._readBytes(4)).join(".");
        break;
      case 3:
        const length = await this._readByte();
        host = (await this._readBytes(length)).toString();
        break;
      case 4:
        const bytes = await this._readBytes(16);
        const tokens = [];
        for (let i = 0; i < 8; ++i)
          tokens.push(bytes.readUInt16BE(i * 2).toString(16));
        host = tokens.join(":");
        break;
    }
    const port = (await this._readBytes(2)).readUInt16BE(0);
    this._buffer = Buffer.from([]);
    this._offset = 0;
    this._fence = 0;
    return {
      command: command2,
      host,
      port
    };
  }
  async _readByte() {
    const buffer2 = await this._readBytes(1);
    return buffer2[0];
  }
  async _readBytes(length) {
    this._fence = this._offset + length;
    if (!this._buffer || this._buffer.length < this._fence)
      await new Promise((f) => this._fenceCallback = f);
    this._offset += length;
    return this._buffer.slice(this._offset - length, this._offset);
  }
  _writeBytes(buffer2) {
    if (this._socket.writable)
      this._socket.write(buffer2);
  }
  _onClose() {
    this._client.onSocketClosed({ uid: this._uid });
  }
  _onData(buffer2) {
    this._buffer = Buffer.concat([this._buffer, buffer2]);
    if (this._fenceCallback && this._buffer.length >= this._fence) {
      const callback = this._fenceCallback;
      this._fenceCallback = void 0;
      callback();
    }
  }
  socketConnected(host, port) {
    this._writeBytes(Buffer.from([
      5,
      0,
      0,
      // RSV
      ...ipToSocksAddress(host),
      // ATYP, Address
      port >> 8,
      port & 255
      // Port
    ]));
    this._socket.on("data", (data) => this._client.onSocketData({ uid: this._uid, data }));
  }
  socketFailed(errorCode) {
    const buffer2 = Buffer.from([
      5,
      0,
      0,
      // RSV
      ...ipToSocksAddress("0.0.0.0"),
      // ATYP, Address
      0,
      0
      // Port
    ]);
    switch (errorCode) {
      case "ENOENT":
      case "ENOTFOUND":
      case "ETIMEDOUT":
      case "EHOSTUNREACH":
        buffer2[1] = 4;
        break;
      case "ENETUNREACH":
        buffer2[1] = 3;
        break;
      case "ECONNREFUSED":
        buffer2[1] = 5;
        break;
      case "ERULESET":
        buffer2[1] = 2;
        break;
    }
    this._writeBytes(buffer2);
    this._socket.end();
  }
  sendData(data) {
    this._socket.write(data);
  }
  end() {
    this._socket.end();
  }
  error(error4) {
    this._socket.destroy(new Error(error4));
  }
};
function hexToNumber(hex) {
  return [...hex].reduce((value, digit2) => {
    const code = digit2.charCodeAt(0);
    if (code >= 48 && code <= 57)
      return value + code;
    if (code >= 97 && code <= 102)
      return value + (code - 97) + 10;
    if (code >= 65 && code <= 70)
      return value + (code - 65) + 10;
    throw new Error("Invalid IPv6 token " + hex);
  }, 0);
}
__name(hexToNumber, "hexToNumber");
function ipToSocksAddress(address) {
  if (net3.isIPv4(address)) {
    return [
      1,
      // IPv4
      ...address.split(".", 4).map((t) => +t & 255)
      // Address
    ];
  }
  if (net3.isIPv6(address)) {
    const result = [4];
    const tokens = address.split(":", 8);
    while (tokens.length < 8)
      tokens.unshift("");
    for (const token of tokens) {
      const value = hexToNumber(token);
      result.push(value >> 8 & 255, value & 255);
    }
    return result;
  }
  throw new Error("Only IPv4 and IPv6 addresses are supported");
}
__name(ipToSocksAddress, "ipToSocksAddress");
function starMatchToRegex(pattern) {
  const source7 = pattern.split("*").map((s) => {
    return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }).join(".*");
  return new RegExp("^" + source7 + "$");
}
__name(starMatchToRegex, "starMatchToRegex");
function parsePattern(pattern) {
  if (!pattern)
    return () => false;
  const matchers = pattern.split(",").map((token) => {
    const match = token.match(/^(.*?)(?::(\d+))?$/);
    if (!match)
      throw new Error(`Unsupported token "${token}" in pattern "${pattern}"`);
    const tokenPort = match[2] ? +match[2] : void 0;
    const portMatches = /* @__PURE__ */ __name((port) => tokenPort === void 0 || tokenPort === port, "portMatches");
    let tokenHost = match[1];
    if (tokenHost === "<loopback>") {
      return (host, port) => {
        if (!portMatches(port))
          return false;
        return host === "localhost" || host.endsWith(".localhost") || host === "127.0.0.1" || host === "[::1]";
      };
    }
    if (tokenHost === "*")
      return (host, port) => portMatches(port);
    if (net3.isIPv4(tokenHost) || net3.isIPv6(tokenHost))
      return (host, port) => host === tokenHost && portMatches(port);
    if (tokenHost[0] === ".")
      tokenHost = "*" + tokenHost;
    const tokenRegex = starMatchToRegex(tokenHost);
    return (host, port) => {
      if (!portMatches(port))
        return false;
      if (net3.isIPv4(host) || net3.isIPv6(host))
        return false;
      return !!host.match(tokenRegex);
    };
  });
  return (host, port) => matchers.some((matcher) => matcher(host, port));
}
__name(parsePattern, "parsePattern");
var SocksProxy = class _SocksProxy extends require$$0$33 {
  static {
    __name(this, "SocksProxy");
  }
  constructor() {
    super();
    this._connections = /* @__PURE__ */ new Map();
    this._sockets = /* @__PURE__ */ new Set();
    this._closed = false;
    this._patternMatcher = () => false;
    this._directSockets = /* @__PURE__ */ new Map();
    this._server = new net3.Server((socket) => {
      const uid = createGuid();
      const connection = new SocksConnection(uid, socket, this);
      this._connections.set(uid, connection);
    });
    this._server.on("connection", (socket) => {
      if (this._closed) {
        socket.destroy();
        return;
      }
      this._sockets.add(socket);
      socket.once("close", () => this._sockets.delete(socket));
    });
  }
  static {
    this.Events = {
      SocksRequested: "socksRequested",
      SocksData: "socksData",
      SocksClosed: "socksClosed"
    };
  }
  setPattern(pattern) {
    try {
      this._patternMatcher = parsePattern(pattern);
    } catch (e) {
      this._patternMatcher = () => false;
    }
  }
  async _handleDirect(request4) {
    try {
      const socket = await createSocket(request4.host, request4.port);
      socket.on("data", (data) => this._connections.get(request4.uid)?.sendData(data));
      socket.on("error", (error4) => {
        this._connections.get(request4.uid)?.error(error4.message);
        this._directSockets.delete(request4.uid);
      });
      socket.on("end", () => {
        this._connections.get(request4.uid)?.end();
        this._directSockets.delete(request4.uid);
      });
      const localAddress = socket.localAddress;
      const localPort = socket.localPort;
      this._directSockets.set(request4.uid, socket);
      this._connections.get(request4.uid)?.socketConnected(localAddress, localPort);
    } catch (error4) {
      this._connections.get(request4.uid)?.socketFailed(error4.code);
    }
  }
  port() {
    return this._port;
  }
  async listen(port, hostname2) {
    return new Promise((f) => {
      this._server.listen(port, hostname2, () => {
        const port2 = this._server.address().port;
        this._port = port2;
        f(port2);
      });
    });
  }
  async close() {
    if (this._closed)
      return;
    this._closed = true;
    for (const socket of this._sockets)
      socket.destroy();
    this._sockets.clear();
    await new Promise((f) => this._server.close(f));
  }
  onSocketRequested(payload) {
    if (!this._patternMatcher(payload.host, payload.port)) {
      this._handleDirect(payload);
      return;
    }
    this.emit(_SocksProxy.Events.SocksRequested, payload);
  }
  onSocketData(payload) {
    const direct = this._directSockets.get(payload.uid);
    if (direct) {
      direct.write(payload.data);
      return;
    }
    this.emit(_SocksProxy.Events.SocksData, payload);
  }
  onSocketClosed(payload) {
    const direct = this._directSockets.get(payload.uid);
    if (direct) {
      direct.destroy();
      this._directSockets.delete(payload.uid);
      return;
    }
    this.emit(_SocksProxy.Events.SocksClosed, payload);
  }
  socketConnected({ uid, host, port }) {
    this._connections.get(uid)?.socketConnected(host, port);
  }
  socketFailed({ uid, errorCode }) {
    this._connections.get(uid)?.socketFailed(errorCode);
  }
  sendSocketData({ uid, data }) {
    this._connections.get(uid)?.sendData(data);
  }
  sendSocketEnd({ uid }) {
    this._connections.get(uid)?.end();
  }
  sendSocketError({ uid, error: error4 }) {
    this._connections.get(uid)?.error(error4);
  }
};
var SocksProxyHandler = class _SocksProxyHandler extends require$$0$33 {
  static {
    __name(this, "SocksProxyHandler");
  }
  constructor(pattern, redirectPortForTest) {
    super();
    this._sockets = /* @__PURE__ */ new Map();
    this._patternMatcher = () => false;
    this._patternMatcher = parsePattern(pattern);
    this._redirectPortForTest = redirectPortForTest;
  }
  static {
    this.Events = {
      SocksConnected: "socksConnected",
      SocksData: "socksData",
      SocksError: "socksError",
      SocksFailed: "socksFailed",
      SocksEnd: "socksEnd"
    };
  }
  cleanup() {
    for (const uid of this._sockets.keys())
      this.socketClosed({ uid });
  }
  async socketRequested({ uid, host, port }) {
    debugLogger.log("socks", `[${uid}] => request ${host}:${port}`);
    if (!this._patternMatcher(host, port)) {
      const payload = { uid, errorCode: "ERULESET" };
      debugLogger.log("socks", `[${uid}] <= pattern error ${payload.errorCode}`);
      this.emit(_SocksProxyHandler.Events.SocksFailed, payload);
      return;
    }
    if (host === "local.playwright")
      host = "localhost";
    try {
      if (this._redirectPortForTest)
        port = this._redirectPortForTest;
      const socket = await createSocket(host, port);
      socket.on("data", (data) => {
        const payload2 = { uid, data };
        this.emit(_SocksProxyHandler.Events.SocksData, payload2);
      });
      socket.on("error", (error4) => {
        const payload2 = { uid, error: error4.message };
        debugLogger.log("socks", `[${uid}] <= network socket error ${payload2.error}`);
        this.emit(_SocksProxyHandler.Events.SocksError, payload2);
        this._sockets.delete(uid);
      });
      socket.on("end", () => {
        const payload2 = { uid };
        debugLogger.log("socks", `[${uid}] <= network socket closed`);
        this.emit(_SocksProxyHandler.Events.SocksEnd, payload2);
        this._sockets.delete(uid);
      });
      const localAddress = socket.localAddress;
      const localPort = socket.localPort;
      this._sockets.set(uid, socket);
      const payload = { uid, host: localAddress, port: localPort };
      debugLogger.log("socks", `[${uid}] <= connected to network ${payload.host}:${payload.port}`);
      this.emit(_SocksProxyHandler.Events.SocksConnected, payload);
    } catch (error4) {
      const payload = { uid, errorCode: error4.code };
      debugLogger.log("socks", `[${uid}] <= connect error ${payload.errorCode}`);
      this.emit(_SocksProxyHandler.Events.SocksFailed, payload);
    }
  }
  sendSocketData({ uid, data }) {
    this._sockets.get(uid)?.write(data);
  }
  socketClosed({ uid }) {
    debugLogger.log("socks", `[${uid}] <= browser socket closed`);
    this._sockets.get(uid)?.destroy();
    this._sockets.delete(uid);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/registry/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/_virtual/_commonjs-dynamic-modules.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function commonjsRequire(path31) {
  throw new Error('Could not dynamically require "' + path31 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
__name(commonjsRequire, "commonjsRequire");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/browsers.json.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var comment = "Do not edit this file, use utils/roll_browser.js";
var browsers = [{ "name": "chromium", "revision": "1170", "installByDefault": true, "browserVersion": "136.0.7103.33" }, { "name": "chromium-headless-shell", "revision": "1170", "installByDefault": true, "browserVersion": "136.0.7103.33" }, { "name": "chromium-tip-of-tree", "revision": "1324", "installByDefault": false, "browserVersion": "137.0.7129.0" }, { "name": "chromium-tip-of-tree-headless-shell", "revision": "1324", "installByDefault": false, "browserVersion": "137.0.7129.0" }, { "name": "firefox", "revision": "1482", "installByDefault": true, "browserVersion": "137.0" }, { "name": "firefox-beta", "revision": "1477", "installByDefault": false, "browserVersion": "137.0b2" }, { "name": "webkit", "revision": "2161", "installByDefault": true, "revisionOverrides": { "debian11-x64": "2105", "debian11-arm64": "2105", "mac10.14": "1446", "mac10.15": "1616", "mac11": "1816", "mac11-arm64": "1816", "mac12": "2009", "mac12-arm64": "2009", "mac13": "2140", "mac13-arm64": "2140", "ubuntu20.04-x64": "2092", "ubuntu20.04-arm64": "2092" }, "browserVersion": "18.4" }, { "name": "ffmpeg", "revision": "1011", "installByDefault": true, "revisionOverrides": { "mac12": "1010", "mac12-arm64": "1010" } }, { "name": "winldd", "revision": "1007", "installByDefault": false }, { "name": "android", "revision": "1001", "installByDefault": false }];
var require$$03 = {
  comment,
  browsers
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/registry/index.js
import path9 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/registry/browserFetcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path5 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/userAgent.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/package.json.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var version4 = "1.53.0-next";
var require$$04 = {
  version: version4
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/linuxUtils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var didFailToReadOSRelease = false;
var osRelease;
function getLinuxDistributionInfoSync() {
  if (process.platform !== "linux")
    return void 0;
  if (!osRelease && !didFailToReadOSRelease) {
    try {
      const osReleaseText = fs.readFileSync("/etc/os-release", "utf8");
      const fields = parseOSReleaseText(osReleaseText);
      osRelease = {
        id: fields.get("id") ?? "",
        version: fields.get("version_id") ?? ""
      };
    } catch (e) {
      didFailToReadOSRelease = true;
    }
  }
  return osRelease;
}
__name(getLinuxDistributionInfoSync, "getLinuxDistributionInfoSync");
function parseOSReleaseText(osReleaseText) {
  const fields = /* @__PURE__ */ new Map();
  for (const line of osReleaseText.split("\n")) {
    const tokens = line.split("=");
    const name = tokens.shift();
    let value = tokens.join("=").trim();
    if (value.startsWith('"') && value.endsWith('"'))
      value = value.substring(1, value.length - 1);
    if (!name)
      continue;
    fields.set(name.toLowerCase(), value);
  }
  return fields;
}
__name(parseOSReleaseText, "parseOSReleaseText");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/userAgent.js
var cachedUserAgent;
function getUserAgent() {
  if (cachedUserAgent)
    return cachedUserAgent;
  try {
    cachedUserAgent = determineUserAgent();
  } catch (e) {
    cachedUserAgent = "Playwright/unknown";
  }
  return cachedUserAgent;
}
__name(getUserAgent, "getUserAgent");
function determineUserAgent() {
  let osIdentifier = "unknown";
  let osVersion = "unknown";
  if (process.platform === "win32") {
    const version6 = os_default.release().split(".");
    osIdentifier = "windows";
    osVersion = `${version6[0]}.${version6[1]}`;
  } else if (process.platform === "darwin") {
    const version6 = execSync("sw_vers -productVersion", { stdio: ["ignore", "pipe", "ignore"] }).toString().trim().split(".");
    osIdentifier = "macOS";
    osVersion = `${version6[0]}.${version6[1]}`;
  } else if (process.platform === "linux") {
    const distroInfo = getLinuxDistributionInfoSync();
    if (distroInfo) {
      osIdentifier = distroInfo.id || "linux";
      osVersion = distroInfo.version || "unknown";
    } else {
      osIdentifier = "linux";
    }
  }
  const additionalTokens = [];
  if (process.env.CI)
    additionalTokens.push("CI/1");
  const serializedTokens = additionalTokens.length ? " " + additionalTokens.join(" ") : "";
  const { embedderName, embedderVersion } = getEmbedderName();
  return `Playwright/${getPlaywrightVersion()} (${os_default.arch()}; ${osIdentifier} ${osVersion}) ${embedderName}/${embedderVersion}${serializedTokens}`;
}
__name(determineUserAgent, "determineUserAgent");
function getEmbedderName() {
  let embedderName = "unknown";
  let embedderVersion = "unknown";
  if (!process.env.PW_LANG_NAME) {
    embedderName = "node";
    embedderVersion = process.version.substring(1).split(".").slice(0, 2).join(".");
  } else if (["node", "python", "java", "csharp"].includes(process.env.PW_LANG_NAME)) {
    embedderName = process.env.PW_LANG_NAME;
    embedderVersion = process.env.PW_LANG_NAME_VERSION ?? "unknown";
  }
  return { embedderName, embedderVersion };
}
__name(getEmbedderName, "getEmbedderName");
function getPlaywrightVersion(majorMinorOnly = false) {
  const version6 = process.env.PW_VERSION_OVERRIDE || require$$04.version;
  return majorMinorOnly ? version6.split(".").slice(0, 2).join(".") : version6;
}
__name(getPlaywrightVersion, "getPlaywrightVersion");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/fileUtils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path4 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/zipBundle.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/_virtual/zipBundleImpl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/bundles/zipBundleImpl.js
var zipBundleImpl_exports = {};
__export(zipBundleImpl_exports, {
  extract: () => extract,
  yauzl: () => index$1,
  yazl: () => index$3
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import require$$64 from "node:stream";
import zlib__default from "node:zlib";
import require$$0$34 from "node:events";
import require$$0$14 from "node:buffer";
import path3 from "node:path";
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: /* @__PURE__ */ __name(() => e[k], "get")
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
__name(_mergeNamespaces, "_mergeNamespaces");
function getDefaultExportFromCjs3(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
__name(getDefaultExportFromCjs3, "getDefaultExportFromCjs");
var yazl = {};
var bufferCrc32;
var hasRequiredBufferCrc32;
function requireBufferCrc32() {
  if (hasRequiredBufferCrc32) return bufferCrc32;
  hasRequiredBufferCrc32 = 1;
  var Buffer2 = require$$0$14.Buffer;
  var CRC_TABLE = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918e3,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  if (typeof Int32Array !== "undefined") {
    CRC_TABLE = new Int32Array(CRC_TABLE);
  }
  function ensureBuffer(input) {
    if (Buffer2.isBuffer(input)) {
      return input;
    }
    var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
    if (typeof input === "number") {
      return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
    } else if (typeof input === "string") {
      return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
    } else {
      throw new Error("input must be buffer, number, or string, received " + typeof input);
    }
  }
  __name(ensureBuffer, "ensureBuffer");
  function bufferizeInt(num) {
    var tmp = ensureBuffer(4);
    tmp.writeInt32BE(num, 0);
    return tmp;
  }
  __name(bufferizeInt, "bufferizeInt");
  function _crc32(buf, previous) {
    buf = ensureBuffer(buf);
    if (Buffer2.isBuffer(previous)) {
      previous = previous.readUInt32BE(0);
    }
    var crc2 = ~~previous ^ -1;
    for (var n = 0; n < buf.length; n++) {
      crc2 = CRC_TABLE[(crc2 ^ buf[n]) & 255] ^ crc2 >>> 8;
    }
    return crc2 ^ -1;
  }
  __name(_crc32, "_crc32");
  function crc32() {
    return bufferizeInt(_crc32.apply(null, arguments));
  }
  __name(crc32, "crc32");
  crc32.signed = function() {
    return _crc32.apply(null, arguments);
  };
  crc32.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
  };
  bufferCrc32 = crc32;
  return bufferCrc32;
}
__name(requireBufferCrc32, "requireBufferCrc32");
var hasRequiredYazl;
function requireYazl() {
  if (hasRequiredYazl) return yazl;
  hasRequiredYazl = 1;
  var fs$1 = fs;
  var Transform2 = require$$64.Transform;
  var PassThrough = require$$64.PassThrough;
  var zlib2 = zlib__default;
  var util3 = util_default;
  var EventEmitter19 = require$$0$34.EventEmitter;
  var crc32 = requireBufferCrc32();
  yazl.ZipFile = ZipFile2;
  yazl.dateToDosDateTime = dateToDosDateTime;
  util3.inherits(ZipFile2, EventEmitter19);
  function ZipFile2() {
    this.outputStream = new PassThrough();
    this.entries = [];
    this.outputStreamCursor = 0;
    this.ended = false;
    this.allDone = false;
    this.forceZip64Eocd = false;
  }
  __name(ZipFile2, "ZipFile");
  ZipFile2.prototype.addFile = function(realPath, metadataPath, options2) {
    var self2 = this;
    metadataPath = validateMetadataPath(metadataPath, false);
    if (options2 == null) options2 = {};
    var entry = new Entry(metadataPath, false, options2);
    self2.entries.push(entry);
    fs$1.stat(realPath, function(err, stats) {
      if (err) return self2.emit("error", err);
      if (!stats.isFile()) return self2.emit("error", new Error("not a file: " + realPath));
      entry.uncompressedSize = stats.size;
      if (options2.mtime == null) entry.setLastModDate(stats.mtime);
      if (options2.mode == null) entry.setFileAttributesMode(stats.mode);
      entry.setFileDataPumpFunction(function() {
        var readStream = fs$1.createReadStream(realPath);
        entry.state = Entry.FILE_DATA_IN_PROGRESS;
        readStream.on("error", function(err2) {
          self2.emit("error", err2);
        });
        pumpFileDataReadStream(self2, entry, readStream);
      });
      pumpEntries(self2);
    });
  };
  ZipFile2.prototype.addReadStream = function(readStream, metadataPath, options2) {
    var self2 = this;
    metadataPath = validateMetadataPath(metadataPath, false);
    if (options2 == null) options2 = {};
    var entry = new Entry(metadataPath, false, options2);
    self2.entries.push(entry);
    entry.setFileDataPumpFunction(function() {
      entry.state = Entry.FILE_DATA_IN_PROGRESS;
      pumpFileDataReadStream(self2, entry, readStream);
    });
    pumpEntries(self2);
  };
  ZipFile2.prototype.addBuffer = function(buffer2, metadataPath, options2) {
    var self2 = this;
    metadataPath = validateMetadataPath(metadataPath, false);
    if (buffer2.length > 1073741823) throw new Error("buffer too large: " + buffer2.length + " > 1073741823");
    if (options2 == null) options2 = {};
    if (options2.size != null) throw new Error("options.size not allowed");
    var entry = new Entry(metadataPath, false, options2);
    entry.uncompressedSize = buffer2.length;
    entry.crc32 = crc32.unsigned(buffer2);
    entry.crcAndFileSizeKnown = true;
    self2.entries.push(entry);
    if (!entry.compress) {
      setCompressedBuffer(buffer2);
    } else {
      zlib2.deflateRaw(buffer2, function(err, compressedBuffer) {
        setCompressedBuffer(compressedBuffer);
      });
    }
    function setCompressedBuffer(compressedBuffer) {
      entry.compressedSize = compressedBuffer.length;
      entry.setFileDataPumpFunction(function() {
        writeToOutputStream(self2, compressedBuffer);
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        setImmediate(function() {
          pumpEntries(self2);
        });
      });
      pumpEntries(self2);
    }
    __name(setCompressedBuffer, "setCompressedBuffer");
  };
  ZipFile2.prototype.addEmptyDirectory = function(metadataPath, options2) {
    var self2 = this;
    metadataPath = validateMetadataPath(metadataPath, true);
    if (options2 == null) options2 = {};
    if (options2.size != null) throw new Error("options.size not allowed");
    if (options2.compress != null) throw new Error("options.compress not allowed");
    var entry = new Entry(metadataPath, true, options2);
    self2.entries.push(entry);
    entry.setFileDataPumpFunction(function() {
      writeToOutputStream(self2, entry.getDataDescriptor());
      entry.state = Entry.FILE_DATA_DONE;
      pumpEntries(self2);
    });
    pumpEntries(self2);
  };
  var eocdrSignatureBuffer = bufferFrom([80, 75, 5, 6]);
  ZipFile2.prototype.end = function(options2, finalSizeCallback) {
    if (typeof options2 === "function") {
      finalSizeCallback = options2;
      options2 = null;
    }
    if (options2 == null) options2 = {};
    if (this.ended) return;
    this.ended = true;
    this.finalSizeCallback = finalSizeCallback;
    this.forceZip64Eocd = !!options2.forceZip64Format;
    if (options2.comment) {
      if (typeof options2.comment === "string") {
        this.comment = encodeCp437(options2.comment);
      } else {
        this.comment = options2.comment;
      }
      if (this.comment.length > 65535) throw new Error("comment is too large");
      if (bufferIncludes(this.comment, eocdrSignatureBuffer)) throw new Error("comment contains end of central directory record signature");
    } else {
      this.comment = EMPTY_BUFFER;
    }
    pumpEntries(this);
  };
  function writeToOutputStream(self2, buffer2) {
    self2.outputStream.write(buffer2);
    self2.outputStreamCursor += buffer2.length;
  }
  __name(writeToOutputStream, "writeToOutputStream");
  function pumpFileDataReadStream(self2, entry, readStream) {
    var crc32Watcher = new Crc32Watcher();
    var uncompressedSizeCounter = new ByteCounter();
    var compressor = entry.compress ? new zlib2.DeflateRaw() : new PassThrough();
    var compressedSizeCounter = new ByteCounter();
    readStream.pipe(crc32Watcher).pipe(uncompressedSizeCounter).pipe(compressor).pipe(compressedSizeCounter).pipe(self2.outputStream, { end: false });
    compressedSizeCounter.on("end", function() {
      entry.crc32 = crc32Watcher.crc32;
      if (entry.uncompressedSize == null) {
        entry.uncompressedSize = uncompressedSizeCounter.byteCount;
      } else {
        if (entry.uncompressedSize !== uncompressedSizeCounter.byteCount) return self2.emit("error", new Error("file data stream has unexpected number of bytes"));
      }
      entry.compressedSize = compressedSizeCounter.byteCount;
      self2.outputStreamCursor += entry.compressedSize;
      writeToOutputStream(self2, entry.getDataDescriptor());
      entry.state = Entry.FILE_DATA_DONE;
      pumpEntries(self2);
    });
  }
  __name(pumpFileDataReadStream, "pumpFileDataReadStream");
  function pumpEntries(self2) {
    if (self2.allDone) return;
    if (self2.ended && self2.finalSizeCallback != null) {
      var finalSize = calculateFinalSize(self2);
      if (finalSize != null) {
        self2.finalSizeCallback(finalSize);
        self2.finalSizeCallback = null;
      }
    }
    var entry = getFirstNotDoneEntry();
    function getFirstNotDoneEntry() {
      for (var i = 0; i < self2.entries.length; i++) {
        var entry2 = self2.entries[i];
        if (entry2.state < Entry.FILE_DATA_DONE) return entry2;
      }
      return null;
    }
    __name(getFirstNotDoneEntry, "getFirstNotDoneEntry");
    if (entry != null) {
      if (entry.state < Entry.READY_TO_PUMP_FILE_DATA) return;
      if (entry.state === Entry.FILE_DATA_IN_PROGRESS) return;
      entry.relativeOffsetOfLocalHeader = self2.outputStreamCursor;
      var localFileHeader = entry.getLocalFileHeader();
      writeToOutputStream(self2, localFileHeader);
      entry.doFileDataPump();
    } else {
      if (self2.ended) {
        self2.offsetOfStartOfCentralDirectory = self2.outputStreamCursor;
        self2.entries.forEach(function(entry2) {
          var centralDirectoryRecord = entry2.getCentralDirectoryRecord();
          writeToOutputStream(self2, centralDirectoryRecord);
        });
        writeToOutputStream(self2, getEndOfCentralDirectoryRecord(self2));
        self2.outputStream.end();
        self2.allDone = true;
      }
    }
  }
  __name(pumpEntries, "pumpEntries");
  function calculateFinalSize(self2) {
    var pretendOutputCursor = 0;
    var centralDirectorySize = 0;
    for (var i = 0; i < self2.entries.length; i++) {
      var entry = self2.entries[i];
      if (entry.compress) return -1;
      if (entry.state >= Entry.READY_TO_PUMP_FILE_DATA) {
        if (entry.uncompressedSize == null) return -1;
      } else {
        if (entry.uncompressedSize == null) return null;
      }
      entry.relativeOffsetOfLocalHeader = pretendOutputCursor;
      var useZip64Format = entry.useZip64Format();
      pretendOutputCursor += LOCAL_FILE_HEADER_FIXED_SIZE + entry.utf8FileName.length;
      pretendOutputCursor += entry.uncompressedSize;
      if (!entry.crcAndFileSizeKnown) {
        if (useZip64Format) {
          pretendOutputCursor += ZIP64_DATA_DESCRIPTOR_SIZE;
        } else {
          pretendOutputCursor += DATA_DESCRIPTOR_SIZE;
        }
      }
      centralDirectorySize += CENTRAL_DIRECTORY_RECORD_FIXED_SIZE + entry.utf8FileName.length + entry.fileComment.length;
      if (useZip64Format) {
        centralDirectorySize += ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE;
      }
    }
    var endOfCentralDirectorySize = 0;
    if (self2.forceZip64Eocd || self2.entries.length >= 65535 || centralDirectorySize >= 65535 || pretendOutputCursor >= 4294967295) {
      endOfCentralDirectorySize += ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE;
    }
    endOfCentralDirectorySize += END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length;
    return pretendOutputCursor + centralDirectorySize + endOfCentralDirectorySize;
  }
  __name(calculateFinalSize, "calculateFinalSize");
  var ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 56;
  var ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE = 20;
  var END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 22;
  function getEndOfCentralDirectoryRecord(self2, actuallyJustTellMeHowLongItWouldBe) {
    var needZip64Format = false;
    var normalEntriesLength = self2.entries.length;
    if (self2.forceZip64Eocd || self2.entries.length >= 65535) {
      normalEntriesLength = 65535;
      needZip64Format = true;
    }
    var sizeOfCentralDirectory = self2.outputStreamCursor - self2.offsetOfStartOfCentralDirectory;
    var normalSizeOfCentralDirectory = sizeOfCentralDirectory;
    if (self2.forceZip64Eocd || sizeOfCentralDirectory >= 4294967295) {
      normalSizeOfCentralDirectory = 4294967295;
      needZip64Format = true;
    }
    var normalOffsetOfStartOfCentralDirectory = self2.offsetOfStartOfCentralDirectory;
    if (self2.forceZip64Eocd || self2.offsetOfStartOfCentralDirectory >= 4294967295) {
      normalOffsetOfStartOfCentralDirectory = 4294967295;
      needZip64Format = true;
    }
    var eocdrBuffer = bufferAlloc(END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length);
    eocdrBuffer.writeUInt32LE(101010256, 0);
    eocdrBuffer.writeUInt16LE(0, 4);
    eocdrBuffer.writeUInt16LE(0, 6);
    eocdrBuffer.writeUInt16LE(normalEntriesLength, 8);
    eocdrBuffer.writeUInt16LE(normalEntriesLength, 10);
    eocdrBuffer.writeUInt32LE(normalSizeOfCentralDirectory, 12);
    eocdrBuffer.writeUInt32LE(normalOffsetOfStartOfCentralDirectory, 16);
    eocdrBuffer.writeUInt16LE(self2.comment.length, 20);
    self2.comment.copy(eocdrBuffer, 22);
    if (!needZip64Format) return eocdrBuffer;
    var zip64EocdrBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE);
    zip64EocdrBuffer.writeUInt32LE(101075792, 0);
    writeUInt64LE(zip64EocdrBuffer, ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE - 12, 4);
    zip64EocdrBuffer.writeUInt16LE(VERSION_MADE_BY, 12);
    zip64EocdrBuffer.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_ZIP64, 14);
    zip64EocdrBuffer.writeUInt32LE(0, 16);
    zip64EocdrBuffer.writeUInt32LE(0, 20);
    writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 24);
    writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 32);
    writeUInt64LE(zip64EocdrBuffer, sizeOfCentralDirectory, 40);
    writeUInt64LE(zip64EocdrBuffer, self2.offsetOfStartOfCentralDirectory, 48);
    var zip64EocdlBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE);
    zip64EocdlBuffer.writeUInt32LE(117853008, 0);
    zip64EocdlBuffer.writeUInt32LE(0, 4);
    writeUInt64LE(zip64EocdlBuffer, self2.outputStreamCursor, 8);
    zip64EocdlBuffer.writeUInt32LE(1, 16);
    return Buffer.concat([
      zip64EocdrBuffer,
      zip64EocdlBuffer,
      eocdrBuffer
    ]);
  }
  __name(getEndOfCentralDirectoryRecord, "getEndOfCentralDirectoryRecord");
  function validateMetadataPath(metadataPath, isDirectory) {
    if (metadataPath === "") throw new Error("empty metadataPath");
    metadataPath = metadataPath.replace(/\\/g, "/");
    if (/^[a-zA-Z]:/.test(metadataPath) || /^\//.test(metadataPath)) throw new Error("absolute path: " + metadataPath);
    if (metadataPath.split("/").indexOf("..") !== -1) throw new Error("invalid relative path: " + metadataPath);
    var looksLikeDirectory = /\/$/.test(metadataPath);
    if (isDirectory) {
      if (!looksLikeDirectory) metadataPath += "/";
    } else {
      if (looksLikeDirectory) throw new Error("file path cannot end with '/': " + metadataPath);
    }
    return metadataPath;
  }
  __name(validateMetadataPath, "validateMetadataPath");
  var EMPTY_BUFFER = bufferAlloc(0);
  function Entry(metadataPath, isDirectory, options2) {
    this.utf8FileName = bufferFrom(metadataPath);
    if (this.utf8FileName.length > 65535) throw new Error("utf8 file name too long. " + utf8FileName.length + " > 65535");
    this.isDirectory = isDirectory;
    this.state = Entry.WAITING_FOR_METADATA;
    this.setLastModDate(options2.mtime != null ? options2.mtime : /* @__PURE__ */ new Date());
    if (options2.mode != null) {
      this.setFileAttributesMode(options2.mode);
    } else {
      this.setFileAttributesMode(isDirectory ? 16893 : 33204);
    }
    if (isDirectory) {
      this.crcAndFileSizeKnown = true;
      this.crc32 = 0;
      this.uncompressedSize = 0;
      this.compressedSize = 0;
    } else {
      this.crcAndFileSizeKnown = false;
      this.crc32 = null;
      this.uncompressedSize = null;
      this.compressedSize = null;
      if (options2.size != null) this.uncompressedSize = options2.size;
    }
    if (isDirectory) {
      this.compress = false;
    } else {
      this.compress = true;
      if (options2.compress != null) this.compress = !!options2.compress;
    }
    this.forceZip64Format = !!options2.forceZip64Format;
    if (options2.fileComment) {
      if (typeof options2.fileComment === "string") {
        this.fileComment = bufferFrom(options2.fileComment, "utf-8");
      } else {
        this.fileComment = options2.fileComment;
      }
      if (this.fileComment.length > 65535) throw new Error("fileComment is too large");
    } else {
      this.fileComment = EMPTY_BUFFER;
    }
  }
  __name(Entry, "Entry");
  Entry.WAITING_FOR_METADATA = 0;
  Entry.READY_TO_PUMP_FILE_DATA = 1;
  Entry.FILE_DATA_IN_PROGRESS = 2;
  Entry.FILE_DATA_DONE = 3;
  Entry.prototype.setLastModDate = function(date) {
    var dosDateTime = dateToDosDateTime(date);
    this.lastModFileTime = dosDateTime.time;
    this.lastModFileDate = dosDateTime.date;
  };
  Entry.prototype.setFileAttributesMode = function(mode) {
    if ((mode & 65535) !== mode) throw new Error("invalid mode. expected: 0 <= " + mode + " <= 65535");
    this.externalFileAttributes = mode << 16 >>> 0;
  };
  Entry.prototype.setFileDataPumpFunction = function(doFileDataPump) {
    this.doFileDataPump = doFileDataPump;
    this.state = Entry.READY_TO_PUMP_FILE_DATA;
  };
  Entry.prototype.useZip64Format = function() {
    return this.forceZip64Format || this.uncompressedSize != null && this.uncompressedSize > 4294967294 || this.compressedSize != null && this.compressedSize > 4294967294 || this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 4294967294;
  };
  var LOCAL_FILE_HEADER_FIXED_SIZE = 30;
  var VERSION_NEEDED_TO_EXTRACT_UTF8 = 20;
  var VERSION_NEEDED_TO_EXTRACT_ZIP64 = 45;
  var VERSION_MADE_BY = 3 << 8 | 63;
  var FILE_NAME_IS_UTF8 = 1 << 11;
  var UNKNOWN_CRC32_AND_FILE_SIZES = 1 << 3;
  Entry.prototype.getLocalFileHeader = function() {
    var crc322 = 0;
    var compressedSize = 0;
    var uncompressedSize = 0;
    if (this.crcAndFileSizeKnown) {
      crc322 = this.crc32;
      compressedSize = this.compressedSize;
      uncompressedSize = this.uncompressedSize;
    }
    var fixedSizeStuff = bufferAlloc(LOCAL_FILE_HEADER_FIXED_SIZE);
    var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
    if (!this.crcAndFileSizeKnown) generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
    fixedSizeStuff.writeUInt32LE(67324752, 0);
    fixedSizeStuff.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_UTF8, 4);
    fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 6);
    fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 8);
    fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 10);
    fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 12);
    fixedSizeStuff.writeUInt32LE(crc322, 14);
    fixedSizeStuff.writeUInt32LE(compressedSize, 18);
    fixedSizeStuff.writeUInt32LE(uncompressedSize, 22);
    fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 26);
    fixedSizeStuff.writeUInt16LE(0, 28);
    return Buffer.concat([
      fixedSizeStuff,
      // file name (variable size)
      this.utf8FileName
      // extra field (variable size)
      // no extra fields
    ]);
  };
  var DATA_DESCRIPTOR_SIZE = 16;
  var ZIP64_DATA_DESCRIPTOR_SIZE = 24;
  Entry.prototype.getDataDescriptor = function() {
    if (this.crcAndFileSizeKnown) {
      return EMPTY_BUFFER;
    }
    if (!this.useZip64Format()) {
      var buffer2 = bufferAlloc(DATA_DESCRIPTOR_SIZE);
      buffer2.writeUInt32LE(134695760, 0);
      buffer2.writeUInt32LE(this.crc32, 4);
      buffer2.writeUInt32LE(this.compressedSize, 8);
      buffer2.writeUInt32LE(this.uncompressedSize, 12);
      return buffer2;
    } else {
      var buffer2 = bufferAlloc(ZIP64_DATA_DESCRIPTOR_SIZE);
      buffer2.writeUInt32LE(134695760, 0);
      buffer2.writeUInt32LE(this.crc32, 4);
      writeUInt64LE(buffer2, this.compressedSize, 8);
      writeUInt64LE(buffer2, this.uncompressedSize, 16);
      return buffer2;
    }
  };
  var CENTRAL_DIRECTORY_RECORD_FIXED_SIZE = 46;
  var ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE = 28;
  Entry.prototype.getCentralDirectoryRecord = function() {
    var fixedSizeStuff = bufferAlloc(CENTRAL_DIRECTORY_RECORD_FIXED_SIZE);
    var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
    if (!this.crcAndFileSizeKnown) generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
    var normalCompressedSize = this.compressedSize;
    var normalUncompressedSize = this.uncompressedSize;
    var normalRelativeOffsetOfLocalHeader = this.relativeOffsetOfLocalHeader;
    var versionNeededToExtract;
    var zeiefBuffer;
    if (this.useZip64Format()) {
      normalCompressedSize = 4294967295;
      normalUncompressedSize = 4294967295;
      normalRelativeOffsetOfLocalHeader = 4294967295;
      versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_ZIP64;
      zeiefBuffer = bufferAlloc(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE);
      zeiefBuffer.writeUInt16LE(1, 0);
      zeiefBuffer.writeUInt16LE(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE - 4, 2);
      writeUInt64LE(zeiefBuffer, this.uncompressedSize, 4);
      writeUInt64LE(zeiefBuffer, this.compressedSize, 12);
      writeUInt64LE(zeiefBuffer, this.relativeOffsetOfLocalHeader, 20);
    } else {
      versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_UTF8;
      zeiefBuffer = EMPTY_BUFFER;
    }
    fixedSizeStuff.writeUInt32LE(33639248, 0);
    fixedSizeStuff.writeUInt16LE(VERSION_MADE_BY, 4);
    fixedSizeStuff.writeUInt16LE(versionNeededToExtract, 6);
    fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 8);
    fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 10);
    fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 12);
    fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 14);
    fixedSizeStuff.writeUInt32LE(this.crc32, 16);
    fixedSizeStuff.writeUInt32LE(normalCompressedSize, 20);
    fixedSizeStuff.writeUInt32LE(normalUncompressedSize, 24);
    fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 28);
    fixedSizeStuff.writeUInt16LE(zeiefBuffer.length, 30);
    fixedSizeStuff.writeUInt16LE(this.fileComment.length, 32);
    fixedSizeStuff.writeUInt16LE(0, 34);
    fixedSizeStuff.writeUInt16LE(0, 36);
    fixedSizeStuff.writeUInt32LE(this.externalFileAttributes, 38);
    fixedSizeStuff.writeUInt32LE(normalRelativeOffsetOfLocalHeader, 42);
    return Buffer.concat([
      fixedSizeStuff,
      // file name (variable size)
      this.utf8FileName,
      // extra field (variable size)
      zeiefBuffer,
      // file comment (variable size)
      this.fileComment
    ]);
  };
  Entry.prototype.getCompressionMethod = function() {
    var NO_COMPRESSION = 0;
    var DEFLATE_COMPRESSION = 8;
    return this.compress ? DEFLATE_COMPRESSION : NO_COMPRESSION;
  };
  function dateToDosDateTime(jsDate) {
    var date = 0;
    date |= jsDate.getDate() & 31;
    date |= (jsDate.getMonth() + 1 & 15) << 5;
    date |= (jsDate.getFullYear() - 1980 & 127) << 9;
    var time3 = 0;
    time3 |= Math.floor(jsDate.getSeconds() / 2);
    time3 |= (jsDate.getMinutes() & 63) << 5;
    time3 |= (jsDate.getHours() & 31) << 11;
    return { date, time: time3 };
  }
  __name(dateToDosDateTime, "dateToDosDateTime");
  function writeUInt64LE(buffer2, n, offset) {
    var high = Math.floor(n / 4294967296);
    var low = n % 4294967296;
    buffer2.writeUInt32LE(low, offset);
    buffer2.writeUInt32LE(high, offset + 4);
  }
  __name(writeUInt64LE, "writeUInt64LE");
  util3.inherits(ByteCounter, Transform2);
  function ByteCounter(options2) {
    Transform2.call(this, options2);
    this.byteCount = 0;
  }
  __name(ByteCounter, "ByteCounter");
  ByteCounter.prototype._transform = function(chunk, encoding2, cb) {
    this.byteCount += chunk.length;
    cb(null, chunk);
  };
  util3.inherits(Crc32Watcher, Transform2);
  function Crc32Watcher(options2) {
    Transform2.call(this, options2);
    this.crc32 = 0;
  }
  __name(Crc32Watcher, "Crc32Watcher");
  Crc32Watcher.prototype._transform = function(chunk, encoding2, cb) {
    this.crc32 = crc32.unsigned(chunk, this.crc32);
    cb(null, chunk);
  };
  var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
  if (cp437.length !== 256) throw new Error("assertion failure");
  var reverseCp437 = null;
  function encodeCp437(string2) {
    if (/^[\x20-\x7e]*$/.test(string2)) {
      return bufferFrom(string2, "utf-8");
    }
    if (reverseCp437 == null) {
      reverseCp437 = {};
      for (var i = 0; i < cp437.length; i++) {
        reverseCp437[cp437[i]] = i;
      }
    }
    var result = bufferAlloc(string2.length);
    for (var i = 0; i < string2.length; i++) {
      var b = reverseCp437[string2[i]];
      if (b == null) throw new Error("character not encodable in CP437: " + JSON.stringify(string2[i]));
      result[i] = b;
    }
    return result;
  }
  __name(encodeCp437, "encodeCp437");
  function bufferAlloc(size) {
    bufferAlloc = modern;
    try {
      return bufferAlloc(size);
    } catch (e) {
      bufferAlloc = legacy;
      return bufferAlloc(size);
    }
    function modern(size2) {
      return Buffer.allocUnsafe(size2);
    }
    __name(modern, "modern");
    function legacy(size2) {
      return new Buffer(size2);
    }
    __name(legacy, "legacy");
  }
  __name(bufferAlloc, "bufferAlloc");
  function bufferFrom(something, encoding2) {
    bufferFrom = modern;
    try {
      return bufferFrom(something, encoding2);
    } catch (e) {
      bufferFrom = legacy;
      return bufferFrom(something, encoding2);
    }
    function modern(something2, encoding3) {
      return Buffer.from(something2, encoding3);
    }
    __name(modern, "modern");
    function legacy(something2, encoding3) {
      return new Buffer(something2, encoding3);
    }
    __name(legacy, "legacy");
  }
  __name(bufferFrom, "bufferFrom");
  function bufferIncludes(buffer2, content) {
    bufferIncludes = modern;
    try {
      return bufferIncludes(buffer2, content);
    } catch (e) {
      bufferIncludes = legacy;
      return bufferIncludes(buffer2, content);
    }
    function modern(buffer3, content2) {
      return buffer3.includes(content2);
    }
    __name(modern, "modern");
    function legacy(buffer3, content2) {
      for (var i = 0; i <= buffer3.length - content2.length; i++) {
        for (var j = 0; ; j++) {
          if (j === content2.length) return true;
          if (buffer3[i + j] !== content2[j]) break;
        }
      }
      return false;
    }
    __name(legacy, "legacy");
  }
  __name(bufferIncludes, "bufferIncludes");
  return yazl;
}
__name(requireYazl, "requireYazl");
var yazlExports = requireYazl();
var index$2 = /* @__PURE__ */ getDefaultExportFromCjs3(yazlExports);
var index$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$2
}, [yazlExports]);
var yauzl = {};
var fdSlicer = {};
var pend;
var hasRequiredPend;
function requirePend() {
  if (hasRequiredPend) return pend;
  hasRequiredPend = 1;
  pend = Pend;
  function Pend() {
    this.pending = 0;
    this.max = Infinity;
    this.listeners = [];
    this.waiting = [];
    this.error = null;
  }
  __name(Pend, "Pend");
  Pend.prototype.go = function(fn) {
    if (this.pending < this.max) {
      pendGo(this, fn);
    } else {
      this.waiting.push(fn);
    }
  };
  Pend.prototype.wait = function(cb) {
    if (this.pending === 0) {
      cb(this.error);
    } else {
      this.listeners.push(cb);
    }
  };
  Pend.prototype.hold = function() {
    return pendHold(this);
  };
  function pendHold(self2) {
    self2.pending += 1;
    var called = false;
    return onCb;
    function onCb(err) {
      if (called) throw new Error("callback called twice");
      called = true;
      self2.error = self2.error || err;
      self2.pending -= 1;
      if (self2.waiting.length > 0 && self2.pending < self2.max) {
        pendGo(self2, self2.waiting.shift());
      } else if (self2.pending === 0) {
        var listeners2 = self2.listeners;
        self2.listeners = [];
        listeners2.forEach(cbListener);
      }
    }
    __name(onCb, "onCb");
    function cbListener(listener) {
      listener(self2.error);
    }
    __name(cbListener, "cbListener");
  }
  __name(pendHold, "pendHold");
  function pendGo(self2, fn) {
    fn(pendHold(self2));
  }
  __name(pendGo, "pendGo");
  return pend;
}
__name(requirePend, "requirePend");
var hasRequiredFdSlicer;
function requireFdSlicer() {
  if (hasRequiredFdSlicer) return fdSlicer;
  hasRequiredFdSlicer = 1;
  var fs$1 = fs;
  var util3 = util_default;
  var stream = require$$64;
  var Readable3 = stream.Readable;
  var Writable4 = stream.Writable;
  var PassThrough = stream.PassThrough;
  var Pend = requirePend();
  var EventEmitter19 = require$$0$34.EventEmitter;
  fdSlicer.createFromBuffer = createFromBuffer;
  fdSlicer.createFromFd = createFromFd;
  fdSlicer.BufferSlicer = BufferSlicer;
  fdSlicer.FdSlicer = FdSlicer;
  util3.inherits(FdSlicer, EventEmitter19);
  function FdSlicer(fd, options2) {
    options2 = options2 || {};
    EventEmitter19.call(this);
    this.fd = fd;
    this.pend = new Pend();
    this.pend.max = 1;
    this.refCount = 0;
    this.autoClose = !!options2.autoClose;
  }
  __name(FdSlicer, "FdSlicer");
  FdSlicer.prototype.read = function(buffer2, offset, length, position, callback) {
    var self2 = this;
    self2.pend.go(function(cb) {
      fs$1.read(self2.fd, buffer2, offset, length, position, function(err, bytesRead, buffer3) {
        cb();
        callback(err, bytesRead, buffer3);
      });
    });
  };
  FdSlicer.prototype.write = function(buffer2, offset, length, position, callback) {
    var self2 = this;
    self2.pend.go(function(cb) {
      fs$1.write(self2.fd, buffer2, offset, length, position, function(err, written, buffer3) {
        cb();
        callback(err, written, buffer3);
      });
    });
  };
  FdSlicer.prototype.createReadStream = function(options2) {
    return new ReadStream3(this, options2);
  };
  FdSlicer.prototype.createWriteStream = function(options2) {
    return new WriteStream3(this, options2);
  };
  FdSlicer.prototype.ref = function() {
    this.refCount += 1;
  };
  FdSlicer.prototype.unref = function() {
    var self2 = this;
    self2.refCount -= 1;
    if (self2.refCount > 0) return;
    if (self2.refCount < 0) throw new Error("invalid unref");
    if (self2.autoClose) {
      fs$1.close(self2.fd, onCloseDone);
    }
    function onCloseDone(err) {
      if (err) {
        self2.emit("error", err);
      } else {
        self2.emit("close");
      }
    }
    __name(onCloseDone, "onCloseDone");
  };
  util3.inherits(ReadStream3, Readable3);
  function ReadStream3(context2, options2) {
    options2 = options2 || {};
    Readable3.call(this, options2);
    this.context = context2;
    this.context.ref();
    this.start = options2.start || 0;
    this.endOffset = options2.end;
    this.pos = this.start;
    this.destroyed = false;
  }
  __name(ReadStream3, "ReadStream");
  ReadStream3.prototype._read = function(n) {
    var self2 = this;
    if (self2.destroyed) return;
    var toRead = Math.min(self2._readableState.highWaterMark, n);
    if (self2.endOffset != null) {
      toRead = Math.min(toRead, self2.endOffset - self2.pos);
    }
    if (toRead <= 0) {
      self2.destroyed = true;
      self2.push(null);
      self2.context.unref();
      return;
    }
    self2.context.pend.go(function(cb) {
      if (self2.destroyed) return cb();
      var buffer2 = new Buffer(toRead);
      fs$1.read(self2.context.fd, buffer2, 0, toRead, self2.pos, function(err, bytesRead) {
        if (err) {
          self2.destroy(err);
        } else if (bytesRead === 0) {
          self2.destroyed = true;
          self2.push(null);
          self2.context.unref();
        } else {
          self2.pos += bytesRead;
          self2.push(buffer2.slice(0, bytesRead));
        }
        cb();
      });
    });
  };
  ReadStream3.prototype.destroy = function(err) {
    if (this.destroyed) return;
    err = err || new Error("stream destroyed");
    this.destroyed = true;
    this.emit("error", err);
    this.context.unref();
  };
  util3.inherits(WriteStream3, Writable4);
  function WriteStream3(context2, options2) {
    options2 = options2 || {};
    Writable4.call(this, options2);
    this.context = context2;
    this.context.ref();
    this.start = options2.start || 0;
    this.endOffset = options2.end == null ? Infinity : +options2.end;
    this.bytesWritten = 0;
    this.pos = this.start;
    this.destroyed = false;
    this.on("finish", this.destroy.bind(this));
  }
  __name(WriteStream3, "WriteStream");
  WriteStream3.prototype._write = function(buffer2, encoding2, callback) {
    var self2 = this;
    if (self2.destroyed) return;
    if (self2.pos + buffer2.length > self2.endOffset) {
      var err = new Error("maximum file length exceeded");
      err.code = "ETOOBIG";
      self2.destroy();
      callback(err);
      return;
    }
    self2.context.pend.go(function(cb) {
      if (self2.destroyed) return cb();
      fs$1.write(self2.context.fd, buffer2, 0, buffer2.length, self2.pos, function(err2, bytes) {
        if (err2) {
          self2.destroy();
          cb();
          callback(err2);
        } else {
          self2.bytesWritten += bytes;
          self2.pos += bytes;
          self2.emit("progress");
          cb();
          callback();
        }
      });
    });
  };
  WriteStream3.prototype.destroy = function() {
    if (this.destroyed) return;
    this.destroyed = true;
    this.context.unref();
  };
  util3.inherits(BufferSlicer, EventEmitter19);
  function BufferSlicer(buffer2, options2) {
    EventEmitter19.call(this);
    options2 = options2 || {};
    this.refCount = 0;
    this.buffer = buffer2;
    this.maxChunkSize = options2.maxChunkSize || Number.MAX_SAFE_INTEGER;
  }
  __name(BufferSlicer, "BufferSlicer");
  BufferSlicer.prototype.read = function(buffer2, offset, length, position, callback) {
    var end = position + length;
    var delta = end - this.buffer.length;
    var written = delta > 0 ? delta : length;
    this.buffer.copy(buffer2, offset, position, end);
    setImmediate(function() {
      callback(null, written);
    });
  };
  BufferSlicer.prototype.write = function(buffer2, offset, length, position, callback) {
    buffer2.copy(this.buffer, position, offset, offset + length);
    setImmediate(function() {
      callback(null, length, buffer2);
    });
  };
  BufferSlicer.prototype.createReadStream = function(options2) {
    options2 = options2 || {};
    var readStream = new PassThrough(options2);
    readStream.destroyed = false;
    readStream.start = options2.start || 0;
    readStream.endOffset = options2.end;
    readStream.pos = readStream.endOffset || this.buffer.length;
    var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
    var offset = 0;
    while (true) {
      var nextOffset = offset + this.maxChunkSize;
      if (nextOffset >= entireSlice.length) {
        if (offset < entireSlice.length) {
          readStream.write(entireSlice.slice(offset, entireSlice.length));
        }
        break;
      }
      readStream.write(entireSlice.slice(offset, nextOffset));
      offset = nextOffset;
    }
    readStream.end();
    readStream.destroy = function() {
      readStream.destroyed = true;
    };
    return readStream;
  };
  BufferSlicer.prototype.createWriteStream = function(options2) {
    var bufferSlicer = this;
    options2 = options2 || {};
    var writeStream = new Writable4(options2);
    writeStream.start = options2.start || 0;
    writeStream.endOffset = options2.end == null ? this.buffer.length : +options2.end;
    writeStream.bytesWritten = 0;
    writeStream.pos = writeStream.start;
    writeStream.destroyed = false;
    writeStream._write = function(buffer2, encoding2, callback) {
      if (writeStream.destroyed) return;
      var end = writeStream.pos + buffer2.length;
      if (end > writeStream.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        writeStream.destroyed = true;
        callback(err);
        return;
      }
      buffer2.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer2.length);
      writeStream.bytesWritten += buffer2.length;
      writeStream.pos = end;
      writeStream.emit("progress");
      callback();
    };
    writeStream.destroy = function() {
      writeStream.destroyed = true;
    };
    return writeStream;
  };
  BufferSlicer.prototype.ref = function() {
    this.refCount += 1;
  };
  BufferSlicer.prototype.unref = function() {
    this.refCount -= 1;
    if (this.refCount < 0) {
      throw new Error("invalid unref");
    }
  };
  function createFromBuffer(buffer2, options2) {
    return new BufferSlicer(buffer2, options2);
  }
  __name(createFromBuffer, "createFromBuffer");
  function createFromFd(fd, options2) {
    return new FdSlicer(fd, options2);
  }
  __name(createFromFd, "createFromFd");
  return fdSlicer;
}
__name(requireFdSlicer, "requireFdSlicer");
var hasRequiredYauzl;
function requireYauzl() {
  if (hasRequiredYauzl) return yauzl;
  hasRequiredYauzl = 1;
  var fs$1 = fs;
  var zlib2 = zlib__default;
  var fd_slicer = requireFdSlicer();
  var crc32 = requireBufferCrc32();
  var util3 = util_default;
  var EventEmitter19 = require$$0$34.EventEmitter;
  var Transform2 = require$$64.Transform;
  var PassThrough = require$$64.PassThrough;
  var Writable4 = require$$64.Writable;
  yauzl.open = open6;
  yauzl.fromFd = fromFd;
  yauzl.fromBuffer = fromBuffer;
  yauzl.fromRandomAccessReader = fromRandomAccessReader;
  yauzl.dosDateTimeToDate = dosDateTimeToDate;
  yauzl.validateFileName = validateFileName;
  yauzl.ZipFile = ZipFile2;
  yauzl.Entry = Entry;
  yauzl.RandomAccessReader = RandomAccessReader;
  function open6(path31, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 == null) options2 = {};
    if (options2.autoClose == null) options2.autoClose = true;
    if (options2.lazyEntries == null) options2.lazyEntries = false;
    if (options2.decodeStrings == null) options2.decodeStrings = true;
    if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
    if (options2.strictFileNames == null) options2.strictFileNames = false;
    if (callback == null) callback = defaultCallback;
    fs$1.open(path31, "r", function(err, fd) {
      if (err) return callback(err);
      fromFd(fd, options2, function(err2, zipfile) {
        if (err2) fs$1.close(fd, defaultCallback);
        callback(err2, zipfile);
      });
    });
  }
  __name(open6, "open");
  function fromFd(fd, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 == null) options2 = {};
    if (options2.autoClose == null) options2.autoClose = false;
    if (options2.lazyEntries == null) options2.lazyEntries = false;
    if (options2.decodeStrings == null) options2.decodeStrings = true;
    if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
    if (options2.strictFileNames == null) options2.strictFileNames = false;
    if (callback == null) callback = defaultCallback;
    fs$1.fstat(fd, function(err, stats) {
      if (err) return callback(err);
      var reader = fd_slicer.createFromFd(fd, { autoClose: true });
      fromRandomAccessReader(reader, stats.size, options2, callback);
    });
  }
  __name(fromFd, "fromFd");
  function fromBuffer(buffer2, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 == null) options2 = {};
    options2.autoClose = false;
    if (options2.lazyEntries == null) options2.lazyEntries = false;
    if (options2.decodeStrings == null) options2.decodeStrings = true;
    if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
    if (options2.strictFileNames == null) options2.strictFileNames = false;
    var reader = fd_slicer.createFromBuffer(buffer2, { maxChunkSize: 65536 });
    fromRandomAccessReader(reader, buffer2.length, options2, callback);
  }
  __name(fromBuffer, "fromBuffer");
  function fromRandomAccessReader(reader, totalSize, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 == null) options2 = {};
    if (options2.autoClose == null) options2.autoClose = true;
    if (options2.lazyEntries == null) options2.lazyEntries = false;
    if (options2.decodeStrings == null) options2.decodeStrings = true;
    var decodeStrings = !!options2.decodeStrings;
    if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
    if (options2.strictFileNames == null) options2.strictFileNames = false;
    if (callback == null) callback = defaultCallback;
    if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
    if (totalSize > Number.MAX_SAFE_INTEGER) {
      throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
    }
    reader.ref();
    var eocdrWithoutCommentSize = 22;
    var maxCommentSize = 65535;
    var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
    var buffer2 = newBuffer(bufferSize);
    var bufferReadStart = totalSize - buffer2.length;
    readAndAssertNoEof(reader, buffer2, 0, bufferSize, bufferReadStart, function(err) {
      if (err) return callback(err);
      for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
        if (buffer2.readUInt32LE(i) !== 101010256) continue;
        var eocdrBuffer = buffer2.slice(i);
        var diskNumber = eocdrBuffer.readUInt16LE(4);
        if (diskNumber !== 0) {
          return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
        }
        var entryCount = eocdrBuffer.readUInt16LE(10);
        var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
        var commentLength = eocdrBuffer.readUInt16LE(20);
        var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
        if (commentLength !== expectedCommentLength) {
          return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
        }
        var comment2 = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
        if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
          return callback(null, new ZipFile2(reader, centralDirectoryOffset, totalSize, entryCount, comment2, options2.autoClose, options2.lazyEntries, decodeStrings, options2.validateEntrySizes, options2.strictFileNames));
        }
        var zip64EocdlBuffer = newBuffer(20);
        var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
        readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
          if (err2) return callback(err2);
          if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
            return callback(new Error("invalid zip64 end of central directory locator signature"));
          }
          var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
          var zip64EocdrBuffer = newBuffer(56);
          readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
            if (err3) return callback(err3);
            if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
              return callback(new Error("invalid zip64 end of central directory record signature"));
            }
            entryCount = readUInt64LE(zip64EocdrBuffer, 32);
            centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
            return callback(null, new ZipFile2(reader, centralDirectoryOffset, totalSize, entryCount, comment2, options2.autoClose, options2.lazyEntries, decodeStrings, options2.validateEntrySizes, options2.strictFileNames));
          });
        });
        return;
      }
      callback(new Error("end of central directory record signature not found"));
    });
  }
  __name(fromRandomAccessReader, "fromRandomAccessReader");
  util3.inherits(ZipFile2, EventEmitter19);
  function ZipFile2(reader, centralDirectoryOffset, fileSize, entryCount, comment2, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
    var self2 = this;
    EventEmitter19.call(self2);
    self2.reader = reader;
    self2.reader.on("error", function(err) {
      emitError(self2, err);
    });
    self2.reader.once("close", function() {
      self2.emit("close");
    });
    self2.readEntryCursor = centralDirectoryOffset;
    self2.fileSize = fileSize;
    self2.entryCount = entryCount;
    self2.comment = comment2;
    self2.entriesRead = 0;
    self2.autoClose = !!autoClose;
    self2.lazyEntries = !!lazyEntries;
    self2.decodeStrings = !!decodeStrings;
    self2.validateEntrySizes = !!validateEntrySizes;
    self2.strictFileNames = !!strictFileNames;
    self2.isOpen = true;
    self2.emittedError = false;
    if (!self2.lazyEntries) self2._readEntry();
  }
  __name(ZipFile2, "ZipFile");
  ZipFile2.prototype.close = function() {
    if (!this.isOpen) return;
    this.isOpen = false;
    this.reader.unref();
  };
  function emitErrorAndAutoClose(self2, err) {
    if (self2.autoClose) self2.close();
    emitError(self2, err);
  }
  __name(emitErrorAndAutoClose, "emitErrorAndAutoClose");
  function emitError(self2, err) {
    if (self2.emittedError) return;
    self2.emittedError = true;
    self2.emit("error", err);
  }
  __name(emitError, "emitError");
  ZipFile2.prototype.readEntry = function() {
    if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
    this._readEntry();
  };
  ZipFile2.prototype._readEntry = function() {
    var self2 = this;
    if (self2.entryCount === self2.entriesRead) {
      setImmediate(function() {
        if (self2.autoClose) self2.close();
        if (self2.emittedError) return;
        self2.emit("end");
      });
      return;
    }
    if (self2.emittedError) return;
    var buffer2 = newBuffer(46);
    readAndAssertNoEof(self2.reader, buffer2, 0, buffer2.length, self2.readEntryCursor, function(err) {
      if (err) return emitErrorAndAutoClose(self2, err);
      if (self2.emittedError) return;
      var entry = new Entry();
      var signature = buffer2.readUInt32LE(0);
      if (signature !== 33639248) return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
      entry.versionMadeBy = buffer2.readUInt16LE(4);
      entry.versionNeededToExtract = buffer2.readUInt16LE(6);
      entry.generalPurposeBitFlag = buffer2.readUInt16LE(8);
      entry.compressionMethod = buffer2.readUInt16LE(10);
      entry.lastModFileTime = buffer2.readUInt16LE(12);
      entry.lastModFileDate = buffer2.readUInt16LE(14);
      entry.crc32 = buffer2.readUInt32LE(16);
      entry.compressedSize = buffer2.readUInt32LE(20);
      entry.uncompressedSize = buffer2.readUInt32LE(24);
      entry.fileNameLength = buffer2.readUInt16LE(28);
      entry.extraFieldLength = buffer2.readUInt16LE(30);
      entry.fileCommentLength = buffer2.readUInt16LE(32);
      entry.internalFileAttributes = buffer2.readUInt16LE(36);
      entry.externalFileAttributes = buffer2.readUInt32LE(38);
      entry.relativeOffsetOfLocalHeader = buffer2.readUInt32LE(42);
      if (entry.generalPurposeBitFlag & 64) return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
      self2.readEntryCursor += 46;
      buffer2 = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
      readAndAssertNoEof(self2.reader, buffer2, 0, buffer2.length, self2.readEntryCursor, function(err2) {
        if (err2) return emitErrorAndAutoClose(self2, err2);
        if (self2.emittedError) return;
        var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
        entry.fileName = self2.decodeStrings ? decodeBuffer(buffer2, 0, entry.fileNameLength, isUtf8) : buffer2.slice(0, entry.fileNameLength);
        var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
        var extraFieldBuffer = buffer2.slice(entry.fileNameLength, fileCommentStart);
        entry.extraFields = [];
        var i = 0;
        while (i < extraFieldBuffer.length - 3) {
          var headerId = extraFieldBuffer.readUInt16LE(i + 0);
          var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
          var dataStart = i + 4;
          var dataEnd = dataStart + dataSize;
          if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
          var dataBuffer = newBuffer(dataSize);
          extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
          entry.extraFields.push({
            id: headerId,
            data: dataBuffer
          });
          i = dataEnd;
        }
        entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer2, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer2.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
        entry.comment = entry.fileComment;
        self2.readEntryCursor += buffer2.length;
        self2.entriesRead += 1;
        if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
          var zip64EiefBuffer = null;
          for (var i = 0; i < entry.extraFields.length; i++) {
            var extraField = entry.extraFields[i];
            if (extraField.id === 1) {
              zip64EiefBuffer = extraField.data;
              break;
            }
          }
          if (zip64EiefBuffer == null) {
            return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
          }
          var index2 = 0;
          if (entry.uncompressedSize === 4294967295) {
            if (index2 + 8 > zip64EiefBuffer.length) {
              return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
            }
            entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index2);
            index2 += 8;
          }
          if (entry.compressedSize === 4294967295) {
            if (index2 + 8 > zip64EiefBuffer.length) {
              return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
            }
            entry.compressedSize = readUInt64LE(zip64EiefBuffer, index2);
            index2 += 8;
          }
          if (entry.relativeOffsetOfLocalHeader === 4294967295) {
            if (index2 + 8 > zip64EiefBuffer.length) {
              return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
            }
            entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index2);
            index2 += 8;
          }
        }
        if (self2.decodeStrings) {
          for (var i = 0; i < entry.extraFields.length; i++) {
            var extraField = entry.extraFields[i];
            if (extraField.id === 28789) {
              if (extraField.data.length < 6) {
                continue;
              }
              if (extraField.data.readUInt8(0) !== 1) {
                continue;
              }
              var oldNameCrc32 = extraField.data.readUInt32LE(1);
              if (crc32.unsigned(buffer2.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                continue;
              }
              entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
              break;
            }
          }
        }
        if (self2.validateEntrySizes && entry.compressionMethod === 0) {
          var expectedCompressedSize = entry.uncompressedSize;
          if (entry.isEncrypted()) {
            expectedCompressedSize += 12;
          }
          if (entry.compressedSize !== expectedCompressedSize) {
            var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
            return emitErrorAndAutoClose(self2, new Error(msg));
          }
        }
        if (self2.decodeStrings) {
          if (!self2.strictFileNames) {
            entry.fileName = entry.fileName.replace(/\\/g, "/");
          }
          var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
          if (errorMessage != null) return emitErrorAndAutoClose(self2, new Error(errorMessage));
        }
        self2.emit("entry", entry);
        if (!self2.lazyEntries) self2._readEntry();
      });
    });
  };
  ZipFile2.prototype.openReadStream = function(entry, options2, callback) {
    var self2 = this;
    var relativeStart = 0;
    var relativeEnd = entry.compressedSize;
    if (callback == null) {
      callback = options2;
      options2 = {};
    } else {
      if (options2.decrypt != null) {
        if (!entry.isEncrypted()) {
          throw new Error("options.decrypt can only be specified for encrypted entries");
        }
        if (options2.decrypt !== false) throw new Error("invalid options.decrypt value: " + options2.decrypt);
        if (entry.isCompressed()) {
          if (options2.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
        }
      }
      if (options2.decompress != null) {
        if (!entry.isCompressed()) {
          throw new Error("options.decompress can only be specified for compressed entries");
        }
        if (!(options2.decompress === false || options2.decompress === true)) {
          throw new Error("invalid options.decompress value: " + options2.decompress);
        }
      }
      if (options2.start != null || options2.end != null) {
        if (entry.isCompressed() && options2.decompress !== false) {
          throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
        }
        if (entry.isEncrypted() && options2.decrypt !== false) {
          throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
        }
      }
      if (options2.start != null) {
        relativeStart = options2.start;
        if (relativeStart < 0) throw new Error("options.start < 0");
        if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
      }
      if (options2.end != null) {
        relativeEnd = options2.end;
        if (relativeEnd < 0) throw new Error("options.end < 0");
        if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
        if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
      }
    }
    if (!self2.isOpen) return callback(new Error("closed"));
    if (entry.isEncrypted()) {
      if (options2.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
    }
    self2.reader.ref();
    var buffer2 = newBuffer(30);
    readAndAssertNoEof(self2.reader, buffer2, 0, buffer2.length, entry.relativeOffsetOfLocalHeader, function(err) {
      try {
        if (err) return callback(err);
        var signature = buffer2.readUInt32LE(0);
        if (signature !== 67324752) {
          return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
        }
        var fileNameLength = buffer2.readUInt16LE(26);
        var extraFieldLength = buffer2.readUInt16LE(28);
        var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer2.length + fileNameLength + extraFieldLength;
        var decompress;
        if (entry.compressionMethod === 0) {
          decompress = false;
        } else if (entry.compressionMethod === 8) {
          decompress = options2.decompress != null ? options2.decompress : true;
        } else {
          return callback(new Error("unsupported compression method: " + entry.compressionMethod));
        }
        var fileDataStart = localFileHeaderEnd;
        var fileDataEnd = fileDataStart + entry.compressedSize;
        if (entry.compressedSize !== 0) {
          if (fileDataEnd > self2.fileSize) {
            return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
          }
        }
        var readStream = self2.reader.createReadStream({
          start: fileDataStart + relativeStart,
          end: fileDataStart + relativeEnd
        });
        var endpointStream = readStream;
        if (decompress) {
          var destroyed = false;
          var inflateFilter = zlib2.createInflateRaw();
          readStream.on("error", function(err2) {
            setImmediate(function() {
              if (!destroyed) inflateFilter.emit("error", err2);
            });
          });
          readStream.pipe(inflateFilter);
          if (self2.validateEntrySizes) {
            endpointStream = new AssertByteCountStream(entry.uncompressedSize);
            inflateFilter.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed) endpointStream.emit("error", err2);
              });
            });
            inflateFilter.pipe(endpointStream);
          } else {
            endpointStream = inflateFilter;
          }
          endpointStream.destroy = function() {
            destroyed = true;
            if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
            readStream.unpipe(inflateFilter);
            readStream.destroy();
          };
        }
        callback(null, endpointStream);
      } finally {
        self2.reader.unref();
      }
    });
  };
  function Entry() {
  }
  __name(Entry, "Entry");
  Entry.prototype.getLastModDate = function() {
    return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
  };
  Entry.prototype.isEncrypted = function() {
    return (this.generalPurposeBitFlag & 1) !== 0;
  };
  Entry.prototype.isCompressed = function() {
    return this.compressionMethod === 8;
  };
  function dosDateTimeToDate(date, time3) {
    var day = date & 31;
    var month = (date >> 5 & 15) - 1;
    var year = (date >> 9 & 127) + 1980;
    var millisecond = 0;
    var second = (time3 & 31) * 2;
    var minute = time3 >> 5 & 63;
    var hour = time3 >> 11 & 31;
    return new Date(year, month, day, hour, minute, second, millisecond);
  }
  __name(dosDateTimeToDate, "dosDateTimeToDate");
  function validateFileName(fileName) {
    if (fileName.indexOf("\\") !== -1) {
      return "invalid characters in fileName: " + fileName;
    }
    if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
      return "absolute path: " + fileName;
    }
    if (fileName.split("/").indexOf("..") !== -1) {
      return "invalid relative path: " + fileName;
    }
    return null;
  }
  __name(validateFileName, "validateFileName");
  function readAndAssertNoEof(reader, buffer2, offset, length, position, callback) {
    if (length === 0) {
      return setImmediate(function() {
        callback(null, newBuffer(0));
      });
    }
    reader.read(buffer2, offset, length, position, function(err, bytesRead) {
      if (err) return callback(err);
      if (bytesRead < length) {
        return callback(new Error("unexpected EOF"));
      }
      callback();
    });
  }
  __name(readAndAssertNoEof, "readAndAssertNoEof");
  util3.inherits(AssertByteCountStream, Transform2);
  function AssertByteCountStream(byteCount) {
    Transform2.call(this);
    this.actualByteCount = 0;
    this.expectedByteCount = byteCount;
  }
  __name(AssertByteCountStream, "AssertByteCountStream");
  AssertByteCountStream.prototype._transform = function(chunk, encoding2, cb) {
    this.actualByteCount += chunk.length;
    if (this.actualByteCount > this.expectedByteCount) {
      var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
      return cb(new Error(msg));
    }
    cb(null, chunk);
  };
  AssertByteCountStream.prototype._flush = function(cb) {
    if (this.actualByteCount < this.expectedByteCount) {
      var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
      return cb(new Error(msg));
    }
    cb();
  };
  util3.inherits(RandomAccessReader, EventEmitter19);
  function RandomAccessReader() {
    EventEmitter19.call(this);
    this.refCount = 0;
  }
  __name(RandomAccessReader, "RandomAccessReader");
  RandomAccessReader.prototype.ref = function() {
    this.refCount += 1;
  };
  RandomAccessReader.prototype.unref = function() {
    var self2 = this;
    self2.refCount -= 1;
    if (self2.refCount > 0) return;
    if (self2.refCount < 0) throw new Error("invalid unref");
    self2.close(onCloseDone);
    function onCloseDone(err) {
      if (err) return self2.emit("error", err);
      self2.emit("close");
    }
    __name(onCloseDone, "onCloseDone");
  };
  RandomAccessReader.prototype.createReadStream = function(options2) {
    var start = options2.start;
    var end = options2.end;
    if (start === end) {
      var emptyStream = new PassThrough();
      setImmediate(function() {
        emptyStream.end();
      });
      return emptyStream;
    }
    var stream = this._readStreamForRange(start, end);
    var destroyed = false;
    var refUnrefFilter = new RefUnrefFilter(this);
    stream.on("error", function(err) {
      setImmediate(function() {
        if (!destroyed) refUnrefFilter.emit("error", err);
      });
    });
    refUnrefFilter.destroy = function() {
      stream.unpipe(refUnrefFilter);
      refUnrefFilter.unref();
      stream.destroy();
    };
    var byteCounter = new AssertByteCountStream(end - start);
    refUnrefFilter.on("error", function(err) {
      setImmediate(function() {
        if (!destroyed) byteCounter.emit("error", err);
      });
    });
    byteCounter.destroy = function() {
      destroyed = true;
      refUnrefFilter.unpipe(byteCounter);
      refUnrefFilter.destroy();
    };
    return stream.pipe(refUnrefFilter).pipe(byteCounter);
  };
  RandomAccessReader.prototype._readStreamForRange = function(start, end) {
    throw new Error("not implemented");
  };
  RandomAccessReader.prototype.read = function(buffer2, offset, length, position, callback) {
    var readStream = this.createReadStream({ start: position, end: position + length });
    var writeStream = new Writable4();
    var written = 0;
    writeStream._write = function(chunk, encoding2, cb) {
      chunk.copy(buffer2, offset + written, 0, chunk.length);
      written += chunk.length;
      cb();
    };
    writeStream.on("finish", callback);
    readStream.on("error", function(error4) {
      callback(error4);
    });
    readStream.pipe(writeStream);
  };
  RandomAccessReader.prototype.close = function(callback) {
    setImmediate(callback);
  };
  util3.inherits(RefUnrefFilter, PassThrough);
  function RefUnrefFilter(context2) {
    PassThrough.call(this);
    this.context = context2;
    this.context.ref();
    this.unreffedYet = false;
  }
  __name(RefUnrefFilter, "RefUnrefFilter");
  RefUnrefFilter.prototype._flush = function(cb) {
    this.unref();
    cb();
  };
  RefUnrefFilter.prototype.unref = function(cb) {
    if (this.unreffedYet) return;
    this.unreffedYet = true;
    this.context.unref();
  };
  var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
  function decodeBuffer(buffer2, start, end, isUtf8) {
    if (isUtf8) {
      return buffer2.toString("utf8", start, end);
    } else {
      var result = "";
      for (var i = start; i < end; i++) {
        result += cp437[buffer2[i]];
      }
      return result;
    }
  }
  __name(decodeBuffer, "decodeBuffer");
  function readUInt64LE(buffer2, offset) {
    var lower32 = buffer2.readUInt32LE(offset);
    var upper32 = buffer2.readUInt32LE(offset + 4);
    return upper32 * 4294967296 + lower32;
  }
  __name(readUInt64LE, "readUInt64LE");
  var newBuffer;
  if (typeof Buffer.allocUnsafe === "function") {
    newBuffer = /* @__PURE__ */ __name(function(len) {
      return Buffer.allocUnsafe(len);
    }, "newBuffer");
  } else {
    newBuffer = /* @__PURE__ */ __name(function(len) {
      return new Buffer(len);
    }, "newBuffer");
  }
  function defaultCallback(err) {
    if (err) throw err;
  }
  __name(defaultCallback, "defaultCallback");
  return yauzl;
}
__name(requireYauzl, "requireYauzl");
var yauzlExports = requireYauzl();
var index = /* @__PURE__ */ getDefaultExportFromCjs3(yauzlExports);
var index$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [yauzlExports]);
var browser2 = { exports: {} };
var ms2;
var hasRequiredMs2;
function requireMs2() {
  if (hasRequiredMs2) return ms2;
  hasRequiredMs2 = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms2 = /* @__PURE__ */ __name(function(val, options2) {
    options2 = options2 || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  }, "ms");
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  __name(parse2, "parse");
  function fmtShort(ms3) {
    var msAbs = Math.abs(ms3);
    if (msAbs >= d) {
      return Math.round(ms3 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms3 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms3 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms3 / s) + "s";
    }
    return ms3 + "ms";
  }
  __name(fmtShort, "fmtShort");
  function fmtLong(ms3) {
    var msAbs = Math.abs(ms3);
    if (msAbs >= d) {
      return plural(ms3, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms3, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms3, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms3, msAbs, s, "second");
    }
    return ms3 + " ms";
  }
  __name(fmtLong, "fmtLong");
  function plural(ms3, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms3 / n) + " " + name + (isPlural ? "s" : "");
  }
  __name(plural, "plural");
  return ms2;
}
__name(requireMs2, "requireMs");
var common3;
var hasRequiredCommon3;
function requireCommon3() {
  if (hasRequiredCommon3) return common3;
  hasRequiredCommon3 = 1;
  function setup(env3) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs2();
    createDebug.destroy = destroy;
    Object.keys(env3).forEach((key) => {
      createDebug[key] = env3[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    __name(selectColor, "selectColor");
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug6(...args) {
        if (!debug6.enabled) {
          return;
        }
        const self2 = debug6;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms3 = curr - (prevTime || curr);
        self2.diff = ms3;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      __name(debug6, "debug");
      debug6.namespace = namespace;
      debug6.useColors = createDebug.useColors();
      debug6.color = createDebug.selectColor(namespace);
      debug6.extend = extend;
      debug6.destroy = createDebug.destroy;
      Object.defineProperty(debug6, "enabled", {
        enumerable: true,
        configurable: false,
        get: /* @__PURE__ */ __name(() => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        }, "get"),
        set: /* @__PURE__ */ __name((v) => {
          enableOverride = v;
        }, "set")
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug6);
      }
      return debug6;
    }
    __name(createDebug, "createDebug");
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    __name(extend, "extend");
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    __name(enable, "enable");
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    __name(disable, "disable");
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    __name(enabled, "enabled");
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    __name(toNamespace, "toNamespace");
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    __name(coerce, "coerce");
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    __name(destroy, "destroy");
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  __name(setup, "setup");
  common3 = setup;
  return common3;
}
__name(requireCommon3, "requireCommon");
var hasRequiredBrowser2;
function requireBrowser2() {
  if (hasRequiredBrowser2) return browser2.exports;
  hasRequiredBrowser2 = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error4) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error4) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error4) {
      }
    }
    __name(localstorage, "localstorage");
    module.exports = requireCommon3()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error4) {
        return "[UnexpectedJSONParseError]: " + error4.message;
      }
    };
  })(browser2, browser2.exports);
  return browser2.exports;
}
__name(requireBrowser2, "requireBrowser");
var getStream = { exports: {} };
var once2 = { exports: {} };
var wrappy_1;
var hasRequiredWrappy;
function requireWrappy() {
  if (hasRequiredWrappy) return wrappy_1;
  hasRequiredWrappy = 1;
  wrappy_1 = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
    __name(wrapper, "wrapper");
  }
  __name(wrappy, "wrappy");
  return wrappy_1;
}
__name(requireWrappy, "requireWrappy");
var hasRequiredOnce;
function requireOnce() {
  if (hasRequiredOnce) return once2.exports;
  hasRequiredOnce = 1;
  var wrappy = requireWrappy();
  once2.exports = wrappy(once$1);
  once2.exports.strict = wrappy(onceStrict);
  once$1.proto = once$1(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: /* @__PURE__ */ __name(function() {
        return once$1(this);
      }, "value"),
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: /* @__PURE__ */ __name(function() {
        return onceStrict(this);
      }, "value"),
      configurable: true
    });
  });
  function once$1(fn) {
    var f = /* @__PURE__ */ __name(function() {
      if (f.called) return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    }, "f");
    f.called = false;
    return f;
  }
  __name(once$1, "once$1");
  function onceStrict(fn) {
    var f = /* @__PURE__ */ __name(function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    }, "f");
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
  __name(onceStrict, "onceStrict");
  return once2.exports;
}
__name(requireOnce, "requireOnce");
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var once3 = requireOnce();
  var noop = /* @__PURE__ */ __name(function() {
  }, "noop");
  var isRequest = /* @__PURE__ */ __name(function(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }, "isRequest");
  var isChildProcess = /* @__PURE__ */ __name(function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
  }, "isChildProcess");
  var eos = /* @__PURE__ */ __name(function(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once3(callback || noop);
    var ws3 = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = /* @__PURE__ */ __name(function() {
      if (!stream.writable) onfinish();
    }, "onlegacyfinish");
    var onfinish = /* @__PURE__ */ __name(function() {
      writable = false;
      if (!readable) callback.call(stream);
    }, "onfinish");
    var onend = /* @__PURE__ */ __name(function() {
      readable = false;
      if (!writable) callback.call(stream);
    }, "onend");
    var onexit = /* @__PURE__ */ __name(function(exitCode2) {
      callback.call(stream, exitCode2 ? new Error("exited with error code: " + exitCode2) : null);
    }, "onexit");
    var onerror = /* @__PURE__ */ __name(function(err) {
      callback.call(stream, err);
    }, "onerror");
    var onclose = /* @__PURE__ */ __name(function() {
      process.nextTick(onclosenexttick);
    }, "onclose");
    var onclosenexttick = /* @__PURE__ */ __name(function() {
      if (cancelled) return;
      if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error("premature close"));
      if (writable && !(ws3 && (ws3.ended && !ws3.destroyed))) return callback.call(stream, new Error("premature close"));
    }, "onclosenexttick");
    var onrequest = /* @__PURE__ */ __name(function() {
      stream.req.on("finish", onfinish);
    }, "onrequest");
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !ws3) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (isChildProcess(stream)) stream.on("exit", onexit);
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      cancelled = true;
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("exit", onexit);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }, "eos");
  endOfStream = eos;
  return endOfStream;
}
__name(requireEndOfStream, "requireEndOfStream");
var pump_1;
var hasRequiredPump;
function requirePump() {
  if (hasRequiredPump) return pump_1;
  hasRequiredPump = 1;
  var once3 = requireOnce();
  var eos = requireEndOfStream();
  var fs$1 = fs;
  var noop = /* @__PURE__ */ __name(function() {
  }, "noop");
  var ancient = /^v?\.0/.test(process.version);
  var isFn = /* @__PURE__ */ __name(function(fn) {
    return typeof fn === "function";
  }, "isFn");
  var isFS = /* @__PURE__ */ __name(function(stream) {
    if (!ancient) return false;
    if (!fs$1) return false;
    return (stream instanceof (fs$1.ReadStream || noop) || stream instanceof (fs$1.WriteStream || noop)) && isFn(stream.close);
  }, "isFS");
  var isRequest = /* @__PURE__ */ __name(function(stream) {
    return stream.setHeader && isFn(stream.abort);
  }, "isRequest");
  var destroyer = /* @__PURE__ */ __name(function(stream, reading, writing, callback) {
    callback = once3(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    eos(stream, { readable: reading, writable: writing }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isFS(stream)) return stream.close(noop);
      if (isRequest(stream)) return stream.abort();
      if (isFn(stream.destroy)) return stream.destroy();
      callback(err || new Error("stream was destroyed"));
    };
  }, "destroyer");
  var call = /* @__PURE__ */ __name(function(fn) {
    fn();
  }, "call");
  var pipe = /* @__PURE__ */ __name(function(from, to) {
    return from.pipe(to);
  }, "pipe");
  var pump = /* @__PURE__ */ __name(function() {
    var streams = Array.prototype.slice.call(arguments);
    var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new Error("pump requires two streams per minimum");
    var error4;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error4) error4 = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error4);
      });
    });
    return streams.reduce(pipe);
  }, "pump");
  pump_1 = pump;
  return pump_1;
}
__name(requirePump, "requirePump");
var bufferStream;
var hasRequiredBufferStream;
function requireBufferStream() {
  if (hasRequiredBufferStream) return bufferStream;
  hasRequiredBufferStream = 1;
  const { PassThrough: PassThroughStream } = require$$64;
  bufferStream = /* @__PURE__ */ __name((options2) => {
    options2 = { ...options2 };
    const { array } = options2;
    let { encoding: encoding2 } = options2;
    const isBuffer2 = encoding2 === "buffer";
    let objectMode = false;
    if (array) {
      objectMode = !(encoding2 || isBuffer2);
    } else {
      encoding2 = encoding2 || "utf8";
    }
    if (isBuffer2) {
      encoding2 = null;
    }
    const stream = new PassThroughStream({ objectMode });
    if (encoding2) {
      stream.setEncoding(encoding2);
    }
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk) => {
      chunks.push(chunk);
      if (objectMode) {
        length = chunks.length;
      } else {
        length += chunk.length;
      }
    });
    stream.getBufferedValue = () => {
      if (array) {
        return chunks;
      }
      return isBuffer2 ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = () => length;
    return stream;
  }, "bufferStream");
  return bufferStream;
}
__name(requireBufferStream, "requireBufferStream");
var hasRequiredGetStream;
function requireGetStream() {
  if (hasRequiredGetStream) return getStream.exports;
  hasRequiredGetStream = 1;
  const { constants: BufferConstants } = require$$0$14;
  const pump = requirePump();
  const bufferStream2 = requireBufferStream();
  class MaxBufferError extends Error {
    static {
      __name(this, "MaxBufferError");
    }
    constructor() {
      super("maxBuffer exceeded");
      this.name = "MaxBufferError";
    }
  }
  async function getStream$1(inputStream, options2) {
    if (!inputStream) {
      return Promise.reject(new Error("Expected a stream"));
    }
    options2 = {
      maxBuffer: Infinity,
      ...options2
    };
    const { maxBuffer } = options2;
    let stream;
    await new Promise((resolve, reject) => {
      const rejectPromise = /* @__PURE__ */ __name((error4) => {
        if (error4 && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
          error4.bufferedData = stream.getBufferedValue();
        }
        reject(error4);
      }, "rejectPromise");
      stream = pump(inputStream, bufferStream2(options2), (error4) => {
        if (error4) {
          rejectPromise(error4);
          return;
        }
        resolve();
      });
      stream.on("data", () => {
        if (stream.getBufferedLength() > maxBuffer) {
          rejectPromise(new MaxBufferError());
        }
      });
    });
    return stream.getBufferedValue();
  }
  __name(getStream$1, "getStream$1");
  getStream.exports = getStream$1;
  getStream.exports.default = getStream$1;
  getStream.exports.buffer = (stream, options2) => getStream$1(stream, { ...options2, encoding: "buffer" });
  getStream.exports.array = (stream, options2) => getStream$1(stream, { ...options2, array: true });
  getStream.exports.MaxBufferError = MaxBufferError;
  return getStream.exports;
}
__name(requireGetStream, "requireGetStream");
var extractZip$1;
var hasRequiredExtractZip;
function requireExtractZip() {
  if (hasRequiredExtractZip) return extractZip$1;
  hasRequiredExtractZip = 1;
  const debug6 = requireBrowser2()("extract-zip");
  const { createWriteStream: createWriteStream2, promises: fs$1 } = fs;
  const getStream2 = requireGetStream();
  const path$1 = path3;
  const { promisify: promisify3 } = util_default;
  const stream = require$$64;
  const yauzl3 = requireYauzl();
  const openZip = promisify3(yauzl3.open);
  const pipeline3 = promisify3(stream.pipeline);
  class Extractor {
    static {
      __name(this, "Extractor");
    }
    constructor(zipPath, opts) {
      this.zipPath = zipPath;
      this.opts = opts;
    }
    async extract() {
      debug6("opening", this.zipPath, "with opts", this.opts);
      this.zipfile = await openZip(this.zipPath, { lazyEntries: true });
      this.canceled = false;
      return new Promise((resolve, reject) => {
        this.zipfile.on("error", (err) => {
          this.canceled = true;
          reject(err);
        });
        this.zipfile.readEntry();
        this.zipfile.on("close", () => {
          if (!this.canceled) {
            debug6("zip extraction complete");
            resolve();
          }
        });
        this.zipfile.on("entry", async (entry) => {
          if (this.canceled) {
            debug6("skipping entry", entry.fileName, { cancelled: this.canceled });
            return;
          }
          debug6("zipfile entry", entry.fileName);
          if (entry.fileName.startsWith("__MACOSX/")) {
            this.zipfile.readEntry();
            return;
          }
          const destDir = path$1.dirname(path$1.join(this.opts.dir, entry.fileName));
          try {
            await fs$1.mkdir(destDir, { recursive: true });
            const canonicalDestDir = await fs$1.realpath(destDir);
            const relativeDestDir = path$1.relative(this.opts.dir, canonicalDestDir);
            if (relativeDestDir.split(path$1.sep).includes("..")) {
              throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
            }
            await this.extractEntry(entry);
            debug6("finished processing", entry.fileName);
            this.zipfile.readEntry();
          } catch (err) {
            this.canceled = true;
            this.zipfile.close();
            reject(err);
          }
        });
      });
    }
    async extractEntry(entry) {
      if (this.canceled) {
        debug6("skipping entry extraction", entry.fileName, { cancelled: this.canceled });
        return;
      }
      if (this.opts.onEntry) {
        this.opts.onEntry(entry, this.zipfile);
      }
      const dest = path$1.join(this.opts.dir, entry.fileName);
      const mode = entry.externalFileAttributes >> 16 & 65535;
      const IFMT = 61440;
      const IFDIR = 16384;
      const IFLNK = 40960;
      const symlink2 = (mode & IFMT) === IFLNK;
      let isDir = (mode & IFMT) === IFDIR;
      if (!isDir && entry.fileName.endsWith("/")) {
        isDir = true;
      }
      const madeBy = entry.versionMadeBy >> 8;
      if (!isDir) isDir = madeBy === 0 && entry.externalFileAttributes === 16;
      debug6("extracting entry", { filename: entry.fileName, isDir, isSymlink: symlink2 });
      const procMode = this.getExtractedMode(mode, isDir) & 511;
      const destDir = isDir ? dest : path$1.dirname(dest);
      const mkdirOptions = { recursive: true };
      if (isDir) {
        mkdirOptions.mode = procMode;
      }
      debug6("mkdir", { dir: destDir, ...mkdirOptions });
      await fs$1.mkdir(destDir, mkdirOptions);
      if (isDir) return;
      debug6("opening read stream", dest);
      const readStream = await promisify3(this.zipfile.openReadStream.bind(this.zipfile))(entry);
      if (symlink2) {
        const link2 = await getStream2(readStream);
        debug6("creating symlink", link2, dest);
        await fs$1.symlink(link2, dest);
      } else {
        await pipeline3(readStream, createWriteStream2(dest, { mode: procMode }));
      }
    }
    getExtractedMode(entryMode, isDir) {
      let mode = entryMode;
      if (mode === 0) {
        if (isDir) {
          if (this.opts.defaultDirMode) {
            mode = parseInt(this.opts.defaultDirMode, 10);
          }
          if (!mode) {
            mode = 493;
          }
        } else {
          if (this.opts.defaultFileMode) {
            mode = parseInt(this.opts.defaultFileMode, 10);
          }
          if (!mode) {
            mode = 420;
          }
        }
      }
      return mode;
    }
  }
  extractZip$1 = /* @__PURE__ */ __name(async function(zipPath, opts) {
    debug6("creating target directory", opts.dir);
    if (!path$1.isAbsolute(opts.dir)) {
      throw new Error("Target directory is expected to be absolute");
    }
    await fs$1.mkdir(opts.dir, { recursive: true });
    opts.dir = await fs$1.realpath(opts.dir);
    return new Extractor(zipPath, opts).extract();
  }, "extractZip$1");
  return extractZip$1;
}
__name(requireExtractZip, "requireExtractZip");
var extractZipExports = requireExtractZip();
var extractZip = /* @__PURE__ */ getDefaultExportFromCjs3(extractZipExports);
var extract = extractZip;

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/_virtual/zipBundleImpl.js
var require$$05 = /* @__PURE__ */ getAugmentedNamespace2(zipBundleImpl_exports);

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/zipBundle.js
var yazl2 = require$$05.yazl;
var yauzl2 = require$$05.yauzl;
var extract2 = require$$05.extract;

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/fileUtils.js
var existsAsync = /* @__PURE__ */ __name((path210) => new Promise((resolve) => fs.stat(path210, (err) => resolve(!err))), "existsAsync");
async function mkdirIfNeeded(filePath) {
  await fs.promises.mkdir(path4.dirname(filePath), { recursive: true }).catch(() => {
  });
}
__name(mkdirIfNeeded, "mkdirIfNeeded");
async function removeFolders(dirs) {
  return await Promise.all(dirs.map(
    (dir3) => fs.promises.rm(dir3, { recursive: true, force: true, maxRetries: 10 }).catch((e) => e)
  ));
}
__name(removeFolders, "removeFolders");
function canAccessFile(file) {
  if (!file)
    return false;
  try {
    fs.accessSync(file);
    return true;
  } catch (e) {
    return false;
  }
}
__name(canAccessFile, "canAccessFile");
var SerializedFS = class {
  static {
    __name(this, "SerializedFS");
  }
  constructor() {
    this._buffers = /* @__PURE__ */ new Map();
    this._operations = [];
    this._operationsDone = new ManualPromise();
    this._operationsDone.resolve();
  }
  mkdir(dir3) {
    this._appendOperation({ op: "mkdir", dir: dir3 });
  }
  writeFile(file, content, skipIfExists) {
    this._buffers.delete(file);
    this._appendOperation({ op: "writeFile", file, content, skipIfExists });
  }
  appendFile(file, text, flush) {
    if (!this._buffers.has(file))
      this._buffers.set(file, []);
    this._buffers.get(file).push(text);
    if (flush)
      this._flushFile(file);
  }
  _flushFile(file) {
    const buffer2 = this._buffers.get(file);
    if (buffer2 === void 0)
      return;
    const content = buffer2.join("");
    this._buffers.delete(file);
    this._appendOperation({ op: "appendFile", file, content });
  }
  copyFile(from, to) {
    this._flushFile(from);
    this._buffers.delete(to);
    this._appendOperation({ op: "copyFile", from, to });
  }
  async syncAndGetError() {
    for (const file of this._buffers.keys())
      this._flushFile(file);
    await this._operationsDone;
    return this._error;
  }
  zip(entries, zipFileName) {
    for (const file of this._buffers.keys())
      this._flushFile(file);
    this._appendOperation({ op: "zip", entries, zipFileName });
  }
  // This method serializes all writes to the trace.
  _appendOperation(op) {
    const last = this._operations[this._operations.length - 1];
    if (last?.op === "appendFile" && op.op === "appendFile" && last.file === op.file) {
      last.content += op.content;
      return;
    }
    this._operations.push(op);
    if (this._operationsDone.isDone())
      this._performOperations();
  }
  async _performOperations() {
    this._operationsDone = new ManualPromise();
    while (this._operations.length) {
      const op = this._operations.shift();
      if (this._error)
        continue;
      try {
        await this._performOperation(op);
      } catch (e) {
        this._error = e;
      }
    }
    this._operationsDone.resolve();
  }
  async _performOperation(op) {
    switch (op.op) {
      case "mkdir": {
        await fs.promises.mkdir(op.dir, { recursive: true });
        return;
      }
      case "writeFile": {
        if (op.skipIfExists)
          await fs.promises.writeFile(op.file, op.content, { flag: "wx" }).catch(() => {
          });
        else
          await fs.promises.writeFile(op.file, op.content);
        return;
      }
      case "copyFile": {
        await fs.promises.copyFile(op.from, op.to);
        return;
      }
      case "appendFile": {
        await fs.promises.appendFile(op.file, op.content);
        return;
      }
      case "zip": {
        const zipFile = new yazl2.ZipFile();
        const result = new ManualPromise();
        zipFile.on("error", (error4) => result.reject(error4));
        for (const entry of op.entries)
          zipFile.addFile(entry.value, entry.name);
        zipFile.end();
        zipFile.outputStream.pipe(fs.createWriteStream(op.zipFileName)).on("close", () => result.resolve()).on("error", (error4) => result.reject(error4));
        await result;
        return;
      }
    }
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/registry/browserFetcher.js
async function downloadBrowserWithProgressBar(title2, browserDirectory, executablePath, downloadURLs, downloadFileName, downloadSocketTimeout) {
  if (await existsAsync(browserDirectoryToMarkerFilePath(browserDirectory))) {
    debugLogger.log("install", `${title2} is already downloaded.`);
    return false;
  }
  const zipPath = path5.join(os_default.tmpdir(), downloadFileName);
  try {
    const retryCount = 5;
    for (let attempt = 1; attempt <= retryCount; ++attempt) {
      debugLogger.log("install", `downloading ${title2} - attempt #${attempt}`);
      const url4 = downloadURLs[(attempt - 1) % downloadURLs.length];
      logPolitely(`Downloading ${title2}` + colors2.dim(` from ${url4}`));
      const { error: error4 } = await downloadBrowserWithProgressBarOutOfProcess(title2, browserDirectory, url4, zipPath, executablePath, downloadSocketTimeout);
      if (!error4) {
        debugLogger.log("install", `SUCCESS installing ${title2}`);
        break;
      }
      if (await existsAsync(zipPath))
        await fs.promises.unlink(zipPath);
      if (await existsAsync(browserDirectory))
        await fs.promises.rmdir(browserDirectory, { recursive: true });
      const errorMessage = error4?.message || "";
      debugLogger.log("install", `attempt #${attempt} - ERROR: ${errorMessage}`);
      if (attempt >= retryCount)
        throw error4;
    }
  } catch (e) {
    debugLogger.log("install", `FAILED installation ${title2} with error: ${e}`);
    process.exitCode = 1;
    throw e;
  } finally {
    if (await existsAsync(zipPath))
      await fs.promises.unlink(zipPath);
  }
  logPolitely(`${title2} downloaded to ${browserDirectory}`);
  return true;
}
__name(downloadBrowserWithProgressBar, "downloadBrowserWithProgressBar");
function downloadBrowserWithProgressBarOutOfProcess(title2, browserDirectory, url4, zipPath, executablePath, socketTimeout) {
  const cp2 = fork(path5.join("/home/runner/work/playwright/playwright/packages/playwright-cloudflare", "oopDownloadBrowserMain.js"));
  const promise = new ManualPromise();
  const progress3 = getDownloadProgress();
  cp2.on("message", (message) => {
    if (message?.method === "log")
      debugLogger.log("install", message.params.message);
    if (message?.method === "progress")
      progress3(message.params.done, message.params.total);
  });
  cp2.on("exit", (code) => {
    if (code !== 0) {
      promise.resolve({ error: new Error(`Download failure, code=${code}`) });
      return;
    }
    if (!fs.existsSync(browserDirectoryToMarkerFilePath(browserDirectory)))
      promise.resolve({ error: new Error(`Download failure, ${browserDirectoryToMarkerFilePath(browserDirectory)} does not exist`) });
    else
      promise.resolve({ error: null });
  });
  cp2.on("error", (error4) => {
    promise.resolve({ error: error4 });
  });
  debugLogger.log("install", `running download:`);
  debugLogger.log("install", `-- from url: ${url4}`);
  debugLogger.log("install", `-- to location: ${zipPath}`);
  const downloadParams = {
    title: title2,
    browserDirectory,
    url: url4,
    zipPath,
    executablePath,
    socketTimeout,
    userAgent: getUserAgent()
  };
  cp2.send({ method: "download", params: downloadParams });
  return promise;
}
__name(downloadBrowserWithProgressBarOutOfProcess, "downloadBrowserWithProgressBarOutOfProcess");
function logPolitely(toBeLogged) {
  const logLevel = process.env.npm_config_loglevel;
  const logLevelDisplay = ["silent", "error", "warn"].indexOf(logLevel || "") > -1;
  if (!logLevelDisplay)
    console.log(toBeLogged);
}
__name(logPolitely, "logPolitely");
function getDownloadProgress() {
  if (process.stdout.isTTY)
    return getAnimatedDownloadProgress();
  return getBasicDownloadProgress();
}
__name(getDownloadProgress, "getDownloadProgress");
function getAnimatedDownloadProgress() {
  let progressBar;
  let lastDownloadedBytes = 0;
  return (downloadedBytes, totalBytes) => {
    if (!progressBar) {
      progressBar = new progress2(
        `${toMegabytes(
          totalBytes
        )} [:bar] :percent :etas`,
        {
          complete: "=",
          incomplete: " ",
          width: 20,
          total: totalBytes
        }
      );
    }
    const delta = downloadedBytes - lastDownloadedBytes;
    lastDownloadedBytes = downloadedBytes;
    progressBar.tick(delta);
  };
}
__name(getAnimatedDownloadProgress, "getAnimatedDownloadProgress");
function getBasicDownloadProgress() {
  const totalRows = 10;
  const stepWidth = 8;
  let lastRow = -1;
  return (downloadedBytes, totalBytes) => {
    const percentage = downloadedBytes / totalBytes;
    const row = Math.floor(totalRows * percentage);
    if (row > lastRow) {
      lastRow = row;
      const percentageString = String(percentage * 100 | 0).padStart(3);
      console.log(`|${"\u25A0".repeat(row * stepWidth)}${" ".repeat((totalRows - row) * stepWidth)}| ${percentageString}% of ${toMegabytes(totalBytes)}`);
    }
  };
}
__name(getBasicDownloadProgress, "getBasicDownloadProgress");
function toMegabytes(bytes) {
  const mb = bytes / 1024 / 1024;
  return `${Math.round(mb * 10) / 10} MiB`;
}
__name(toMegabytes, "toMegabytes");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/registry/dependencies.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path6 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/registry/nativeDeps.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var deps = {
  "ubuntu20.04-x64": {
    tools: [
      "xvfb",
      "fonts-noto-color-emoji",
      "ttf-unifont",
      "libfontconfig",
      "libfreetype6",
      "xfonts-cyrillic",
      "xfonts-scalable",
      "fonts-liberation",
      "fonts-ipafont-gothic",
      "fonts-wqy-zenhei",
      "fonts-tlwg-loma-otf",
      "ttf-ubuntu-font-family"
    ],
    chromium: [
      "fonts-liberation",
      "libasound2",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libatspi2.0-0",
      "libcairo2",
      "libcups2",
      "libdbus-1-3",
      "libdrm2",
      "libegl1",
      "libgbm1",
      "libglib2.0-0",
      "libgtk-3-0",
      "libnspr4",
      "libnss3",
      "libpango-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb1",
      "libxcomposite1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxrandr2",
      "libxshmfence1"
    ],
    firefox: [
      "ffmpeg",
      "libatk1.0-0",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libdbus-glib-1-2",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf2.0-0",
      "libglib2.0-0",
      "libgtk-3-0",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libpangoft2-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb-shm0",
      "libxcb1",
      "libxcomposite1",
      "libxcursor1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxi6",
      "libxrender1",
      "libxt6",
      "libxtst6"
    ],
    webkit: [
      "libenchant-2-2",
      "libflite1",
      "libx264-155",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libcairo2",
      "libegl1",
      "libenchant1c2a",
      "libepoxy0",
      "libevdev2",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf2.0-0",
      "libgl1",
      "libgles2",
      "libglib2.0-0",
      "libgtk-3-0",
      "libgudev-1.0-0",
      "libharfbuzz-icu0",
      "libharfbuzz0b",
      "libhyphen0",
      "libicu66",
      "libjpeg-turbo8",
      "libnghttp2-14",
      "libnotify4",
      "libopengl0",
      "libopenjp2-7",
      "libopus0",
      "libpango-1.0-0",
      "libpng16-16",
      "libsecret-1-0",
      "libvpx6",
      "libwayland-client0",
      "libwayland-egl1",
      "libwayland-server0",
      "libwebp6",
      "libwebpdemux2",
      "libwoff1",
      "libx11-6",
      "libxcomposite1",
      "libxdamage1",
      "libxkbcommon0",
      "libxml2",
      "libxslt1.1",
      "libatomic1",
      "libevent-2.1-7"
    ],
    lib2package: {
      "libflite.so.1": "libflite1",
      "libflite_usenglish.so.1": "libflite1",
      "libflite_cmu_grapheme_lang.so.1": "libflite1",
      "libflite_cmu_grapheme_lex.so.1": "libflite1",
      "libflite_cmu_indic_lang.so.1": "libflite1",
      "libflite_cmu_indic_lex.so.1": "libflite1",
      "libflite_cmulex.so.1": "libflite1",
      "libflite_cmu_time_awb.so.1": "libflite1",
      "libflite_cmu_us_awb.so.1": "libflite1",
      "libflite_cmu_us_kal16.so.1": "libflite1",
      "libflite_cmu_us_kal.so.1": "libflite1",
      "libflite_cmu_us_rms.so.1": "libflite1",
      "libflite_cmu_us_slt.so.1": "libflite1",
      "libx264.so": "libx264-155",
      "libasound.so.2": "libasound2",
      "libatk-1.0.so.0": "libatk1.0-0",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
      "libatspi.so.0": "libatspi2.0-0",
      "libcairo-gobject.so.2": "libcairo-gobject2",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdbus-glib-1.so.2": "libdbus-glib-1-2",
      "libdrm.so.2": "libdrm2",
      "libEGL.so.1": "libegl1",
      "libenchant.so.1": "libenchant1c2a",
      "libevdev.so.2": "libevdev2",
      "libepoxy.so.0": "libepoxy0",
      "libfontconfig.so.1": "libfontconfig1",
      "libfreetype.so.6": "libfreetype6",
      "libgbm.so.1": "libgbm1",
      "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf2.0-0",
      "libgdk-3.so.0": "libgtk-3-0",
      "libgdk-x11-2.0.so.0": "libgtk2.0-0",
      "libgio-2.0.so.0": "libglib2.0-0",
      "libGL.so.1": "libgl1",
      "libGLESv2.so.2": "libgles2",
      "libglib-2.0.so.0": "libglib2.0-0",
      "libgmodule-2.0.so.0": "libglib2.0-0",
      "libgobject-2.0.so.0": "libglib2.0-0",
      "libgthread-2.0.so.0": "libglib2.0-0",
      "libgtk-3.so.0": "libgtk-3-0",
      "libgtk-x11-2.0.so.0": "libgtk2.0-0",
      "libgudev-1.0.so.0": "libgudev-1.0-0",
      "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
      "libharfbuzz.so.0": "libharfbuzz0b",
      "libhyphen.so.0": "libhyphen0",
      "libicui18n.so.66": "libicu66",
      "libicuuc.so.66": "libicu66",
      "libjpeg.so.8": "libjpeg-turbo8",
      "libnotify.so.4": "libnotify4",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libOpenGL.so.0": "libopengl0",
      "libopenjp2.so.7": "libopenjp2-7",
      "libopus.so.0": "libopus0",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
      "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
      "libpng16.so.16": "libpng16-16",
      "libsecret-1.so.0": "libsecret-1-0",
      "libsmime3.so": "libnss3",
      "libvpx.so.6": "libvpx6",
      "libwayland-client.so.0": "libwayland-client0",
      "libwayland-egl.so.1": "libwayland-egl1",
      "libwayland-server.so.0": "libwayland-server0",
      "libwebp.so.6": "libwebp6",
      "libwebpdemux.so.2": "libwebpdemux2",
      "libwoff2dec.so.1.0.2": "libwoff1",
      "libX11-xcb.so.1": "libx11-xcb1",
      "libX11.so.6": "libx11-6",
      "libxcb-dri3.so.0": "libxcb-dri3-0",
      "libxcb-shm.so.0": "libxcb-shm0",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXcursor.so.1": "libxcursor1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libXi.so.6": "libxi6",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libxml2.so.2": "libxml2",
      "libXrandr.so.2": "libxrandr2",
      "libXrender.so.1": "libxrender1",
      "libxslt.so.1": "libxslt1.1",
      "libXt.so.6": "libxt6",
      "libXtst.so.6": "libxtst6",
      "libxshmfence.so.1": "libxshmfence1",
      "libatomic.so.1": "libatomic1",
      "libenchant-2.so.2": "libenchant-2-2",
      "libevent-2.1.so.7": "libevent-2.1-7"
    }
  },
  "ubuntu22.04-x64": {
    tools: [
      "xvfb",
      "fonts-noto-color-emoji",
      "fonts-unifont",
      "libfontconfig1",
      "libfreetype6",
      "xfonts-cyrillic",
      "xfonts-scalable",
      "fonts-liberation",
      "fonts-ipafont-gothic",
      "fonts-wqy-zenhei",
      "fonts-tlwg-loma-otf",
      "fonts-freefont-ttf"
    ],
    chromium: [
      "libasound2",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libatspi2.0-0",
      "libcairo2",
      "libcups2",
      "libdbus-1-3",
      "libdrm2",
      "libgbm1",
      "libglib2.0-0",
      "libnspr4",
      "libnss3",
      "libpango-1.0-0",
      "libwayland-client0",
      "libx11-6",
      "libxcb1",
      "libxcomposite1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxkbcommon0",
      "libxrandr2"
    ],
    firefox: [
      "ffmpeg",
      "libasound2",
      "libatk1.0-0",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libdbus-glib-1-2",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf-2.0-0",
      "libglib2.0-0",
      "libgtk-3-0",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb-shm0",
      "libxcb1",
      "libxcomposite1",
      "libxcursor1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxi6",
      "libxrandr2",
      "libxrender1",
      "libxtst6"
    ],
    webkit: [
      "libsoup-3.0-0",
      "libenchant-2-2",
      "gstreamer1.0-libav",
      "gstreamer1.0-plugins-bad",
      "gstreamer1.0-plugins-base",
      "gstreamer1.0-plugins-good",
      "libicu70",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libcairo2",
      "libdbus-1-3",
      "libdrm2",
      "libegl1",
      "libepoxy0",
      "libevdev2",
      "libffi7",
      "libfontconfig1",
      "libfreetype6",
      "libgbm1",
      "libgdk-pixbuf-2.0-0",
      "libgles2",
      "libglib2.0-0",
      "libglx0",
      "libgstreamer-gl1.0-0",
      "libgstreamer-plugins-base1.0-0",
      "libgstreamer1.0-0",
      "libgtk-4-1",
      "libgudev-1.0-0",
      "libharfbuzz-icu0",
      "libharfbuzz0b",
      "libhyphen0",
      "libjpeg-turbo8",
      "liblcms2-2",
      "libmanette-0.2-0",
      "libnotify4",
      "libopengl0",
      "libopenjp2-7",
      "libopus0",
      "libpango-1.0-0",
      "libpng16-16",
      "libproxy1v5",
      "libsecret-1-0",
      "libwayland-client0",
      "libwayland-egl1",
      "libwayland-server0",
      "libwebpdemux2",
      "libwoff1",
      "libx11-6",
      "libxcomposite1",
      "libxdamage1",
      "libxkbcommon0",
      "libxml2",
      "libxslt1.1",
      "libx264-163",
      "libatomic1",
      "libevent-2.1-7",
      "libavif13"
    ],
    lib2package: {
      "libavif.so.13": "libavif13",
      "libsoup-3.0.so.0": "libsoup-3.0-0",
      "libasound.so.2": "libasound2",
      "libatk-1.0.so.0": "libatk1.0-0",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
      "libatspi.so.0": "libatspi2.0-0",
      "libcairo-gobject.so.2": "libcairo-gobject2",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdbus-glib-1.so.2": "libdbus-glib-1-2",
      "libdrm.so.2": "libdrm2",
      "libEGL.so.1": "libegl1",
      "libepoxy.so.0": "libepoxy0",
      "libevdev.so.2": "libevdev2",
      "libffi.so.7": "libffi7",
      "libfontconfig.so.1": "libfontconfig1",
      "libfreetype.so.6": "libfreetype6",
      "libgbm.so.1": "libgbm1",
      "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf-2.0-0",
      "libgdk-3.so.0": "libgtk-3-0",
      "libgio-2.0.so.0": "libglib2.0-0",
      "libGLESv2.so.2": "libgles2",
      "libglib-2.0.so.0": "libglib2.0-0",
      "libGLX.so.0": "libglx0",
      "libgmodule-2.0.so.0": "libglib2.0-0",
      "libgobject-2.0.so.0": "libglib2.0-0",
      "libgstallocators-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstapp-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstaudio-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstbase-1.0.so.0": "libgstreamer1.0-0",
      "libgstfft-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
      "libgstpbutils-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
      "libgsttag-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstvideo-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgtk-3.so.0": "libgtk-3-0",
      "libgtk-4.so.1": "libgtk-4-1",
      "libgudev-1.0.so.0": "libgudev-1.0-0",
      "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
      "libharfbuzz.so.0": "libharfbuzz0b",
      "libhyphen.so.0": "libhyphen0",
      "libjpeg.so.8": "libjpeg-turbo8",
      "liblcms2.so.2": "liblcms2-2",
      "libmanette-0.2.so.0": "libmanette-0.2-0",
      "libnotify.so.4": "libnotify4",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libOpenGL.so.0": "libopengl0",
      "libopenjp2.so.7": "libopenjp2-7",
      "libopus.so.0": "libopus0",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
      "libpng16.so.16": "libpng16-16",
      "libproxy.so.1": "libproxy1v5",
      "libsecret-1.so.0": "libsecret-1-0",
      "libsmime3.so": "libnss3",
      "libwayland-client.so.0": "libwayland-client0",
      "libwayland-egl.so.1": "libwayland-egl1",
      "libwayland-server.so.0": "libwayland-server0",
      "libwebpdemux.so.2": "libwebpdemux2",
      "libwoff2dec.so.1.0.2": "libwoff1",
      "libX11-xcb.so.1": "libx11-xcb1",
      "libX11.so.6": "libx11-6",
      "libxcb-shm.so.0": "libxcb-shm0",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXcursor.so.1": "libxcursor1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libXi.so.6": "libxi6",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libxml2.so.2": "libxml2",
      "libXrandr.so.2": "libxrandr2",
      "libXrender.so.1": "libxrender1",
      "libxslt.so.1": "libxslt1.1",
      "libXtst.so.6": "libxtst6",
      "libicui18n.so.60": "libicu70",
      "libicuuc.so.66": "libicu70",
      "libicui18n.so.66": "libicu70",
      "libwebp.so.6": "libwebp6",
      "libenchant-2.so.2": "libenchant-2-2",
      "libx264.so": "libx264-163",
      "libvpx.so.7": "libvpx7",
      "libatomic.so.1": "libatomic1",
      "libevent-2.1.so.7": "libevent-2.1-7"
    }
  },
  "ubuntu24.04-x64": {
    tools: [
      "xvfb",
      "fonts-noto-color-emoji",
      "fonts-unifont",
      "libfontconfig1",
      "libfreetype6",
      "xfonts-cyrillic",
      "xfonts-scalable",
      "fonts-liberation",
      "fonts-ipafont-gothic",
      "fonts-wqy-zenhei",
      "fonts-tlwg-loma-otf",
      "fonts-freefont-ttf"
    ],
    chromium: [
      "libasound2t64",
      "libatk-bridge2.0-0t64",
      "libatk1.0-0t64",
      "libatspi2.0-0t64",
      "libcairo2",
      "libcups2t64",
      "libdbus-1-3",
      "libdrm2",
      "libgbm1",
      "libglib2.0-0t64",
      "libnspr4",
      "libnss3",
      "libpango-1.0-0",
      "libx11-6",
      "libxcb1",
      "libxcomposite1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxkbcommon0",
      "libxrandr2"
    ],
    firefox: [
      "libasound2t64",
      "libatk1.0-0t64",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf-2.0-0",
      "libglib2.0-0t64",
      "libgtk-3-0t64",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb-shm0",
      "libxcb1",
      "libxcomposite1",
      "libxcursor1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxi6",
      "libxrandr2",
      "libxrender1"
    ],
    webkit: [
      "gstreamer1.0-libav",
      "gstreamer1.0-plugins-bad",
      "gstreamer1.0-plugins-base",
      "gstreamer1.0-plugins-good",
      "libicu74",
      "libatomic1",
      "libatk-bridge2.0-0t64",
      "libatk1.0-0t64",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libdrm2",
      "libenchant-2-2",
      "libepoxy0",
      "libevent-2.1-7t64",
      "libflite1",
      "libfontconfig1",
      "libfreetype6",
      "libgbm1",
      "libgdk-pixbuf-2.0-0",
      "libgles2",
      "libglib2.0-0t64",
      "libgstreamer-gl1.0-0",
      "libgstreamer-plugins-bad1.0-0",
      "libgstreamer-plugins-base1.0-0",
      "libgstreamer1.0-0",
      "libgtk-4-1",
      "libharfbuzz-icu0",
      "libharfbuzz0b",
      "libhyphen0",
      "libicu74",
      "libjpeg-turbo8",
      "liblcms2-2",
      "libmanette-0.2-0",
      "libopus0",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libpng16-16t64",
      "libsecret-1-0",
      "libvpx9",
      "libwayland-client0",
      "libwayland-egl1",
      "libwayland-server0",
      "libwebp7",
      "libwebpdemux2",
      "libwoff1",
      "libx11-6",
      "libxkbcommon0",
      "libxml2",
      "libxslt1.1",
      "libx264-164",
      "libavif16"
    ],
    lib2package: {
      "libavif.so.16": "libavif16",
      "libasound.so.2": "libasound2t64",
      "libatk-1.0.so.0": "libatk1.0-0t64",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0t64",
      "libatomic.so.1": "libatomic1",
      "libatspi.so.0": "libatspi2.0-0t64",
      "libcairo-gobject.so.2": "libcairo-gobject2",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2t64",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdrm.so.2": "libdrm2",
      "libenchant-2.so.2": "libenchant-2-2",
      "libepoxy.so.0": "libepoxy0",
      "libevent-2.1.so.7": "libevent-2.1-7t64",
      "libflite_cmu_grapheme_lang.so.1": "libflite1",
      "libflite_cmu_grapheme_lex.so.1": "libflite1",
      "libflite_cmu_indic_lang.so.1": "libflite1",
      "libflite_cmu_indic_lex.so.1": "libflite1",
      "libflite_cmu_time_awb.so.1": "libflite1",
      "libflite_cmu_us_awb.so.1": "libflite1",
      "libflite_cmu_us_kal.so.1": "libflite1",
      "libflite_cmu_us_kal16.so.1": "libflite1",
      "libflite_cmu_us_rms.so.1": "libflite1",
      "libflite_cmu_us_slt.so.1": "libflite1",
      "libflite_cmulex.so.1": "libflite1",
      "libflite_usenglish.so.1": "libflite1",
      "libflite.so.1": "libflite1",
      "libfontconfig.so.1": "libfontconfig1",
      "libfreetype.so.6": "libfreetype6",
      "libgbm.so.1": "libgbm1",
      "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf-2.0-0",
      "libgdk-3.so.0": "libgtk-3-0t64",
      "libgio-2.0.so.0": "libglib2.0-0t64",
      "libGLESv2.so.2": "libgles2",
      "libglib-2.0.so.0": "libglib2.0-0t64",
      "libgmodule-2.0.so.0": "libglib2.0-0t64",
      "libgobject-2.0.so.0": "libglib2.0-0t64",
      "libgstallocators-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstapp-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstaudio-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstbase-1.0.so.0": "libgstreamer1.0-0",
      "libgstcodecparsers-1.0.so.0": "libgstreamer-plugins-bad1.0-0",
      "libgstfft-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
      "libgstpbutils-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
      "libgsttag-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstvideo-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgtk-3.so.0": "libgtk-3-0t64",
      "libgtk-4.so.1": "libgtk-4-1",
      "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
      "libharfbuzz.so.0": "libharfbuzz0b",
      "libhyphen.so.0": "libhyphen0",
      "libicudata.so.74": "libicu74",
      "libicui18n.so.74": "libicu74",
      "libicuuc.so.74": "libicu74",
      "libjpeg.so.8": "libjpeg-turbo8",
      "liblcms2.so.2": "liblcms2-2",
      "libmanette-0.2.so.0": "libmanette-0.2-0",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libopus.so.0": "libopus0",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
      "libpng16.so.16": "libpng16-16t64",
      "libsecret-1.so.0": "libsecret-1-0",
      "libsmime3.so": "libnss3",
      "libsoup-3.0.so.0": "libsoup-3.0-0",
      "libvpx.so.9": "libvpx9",
      "libwayland-client.so.0": "libwayland-client0",
      "libwayland-egl.so.1": "libwayland-egl1",
      "libwayland-server.so.0": "libwayland-server0",
      "libwebp.so.7": "libwebp7",
      "libwebpdemux.so.2": "libwebpdemux2",
      "libwoff2dec.so.1.0.2": "libwoff1",
      "libX11-xcb.so.1": "libx11-xcb1",
      "libX11.so.6": "libx11-6",
      "libxcb-shm.so.0": "libxcb-shm0",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXcursor.so.1": "libxcursor1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libXi.so.6": "libxi6",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libxml2.so.2": "libxml2",
      "libXrandr.so.2": "libxrandr2",
      "libXrender.so.1": "libxrender1",
      "libxslt.so.1": "libxslt1.1",
      "libx264.so": "libx264-164"
    }
  },
  "debian11-x64": {
    tools: [
      "xvfb",
      "fonts-noto-color-emoji",
      "fonts-unifont",
      "libfontconfig1",
      "libfreetype6",
      "xfonts-cyrillic",
      "xfonts-scalable",
      "fonts-liberation",
      "fonts-ipafont-gothic",
      "fonts-wqy-zenhei",
      "fonts-tlwg-loma-otf",
      "fonts-freefont-ttf"
    ],
    chromium: [
      "libasound2",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libatspi2.0-0",
      "libcairo2",
      "libcups2",
      "libdbus-1-3",
      "libdrm2",
      "libgbm1",
      "libglib2.0-0",
      "libnspr4",
      "libnss3",
      "libpango-1.0-0",
      "libwayland-client0",
      "libx11-6",
      "libxcb1",
      "libxcomposite1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxkbcommon0",
      "libxrandr2"
    ],
    firefox: [
      "libasound2",
      "libatk1.0-0",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libdbus-glib-1-2",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf-2.0-0",
      "libglib2.0-0",
      "libgtk-3-0",
      "libharfbuzz0b",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb-shm0",
      "libxcb1",
      "libxcomposite1",
      "libxcursor1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxi6",
      "libxrandr2",
      "libxrender1",
      "libxtst6"
    ],
    webkit: [
      "gstreamer1.0-libav",
      "gstreamer1.0-plugins-bad",
      "gstreamer1.0-plugins-base",
      "gstreamer1.0-plugins-good",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libcairo2",
      "libdbus-1-3",
      "libdrm2",
      "libegl1",
      "libenchant-2-2",
      "libepoxy0",
      "libevdev2",
      "libfontconfig1",
      "libfreetype6",
      "libgbm1",
      "libgdk-pixbuf-2.0-0",
      "libgles2",
      "libglib2.0-0",
      "libglx0",
      "libgstreamer-gl1.0-0",
      "libgstreamer-plugins-base1.0-0",
      "libgstreamer1.0-0",
      "libgtk-3-0",
      "libgudev-1.0-0",
      "libharfbuzz-icu0",
      "libharfbuzz0b",
      "libhyphen0",
      "libicu67",
      "libjpeg62-turbo",
      "liblcms2-2",
      "libmanette-0.2-0",
      "libnghttp2-14",
      "libnotify4",
      "libopengl0",
      "libopenjp2-7",
      "libopus0",
      "libpango-1.0-0",
      "libpng16-16",
      "libproxy1v5",
      "libsecret-1-0",
      "libwayland-client0",
      "libwayland-egl1",
      "libwayland-server0",
      "libwebp6",
      "libwebpdemux2",
      "libwoff1",
      "libx11-6",
      "libxcomposite1",
      "libxdamage1",
      "libxkbcommon0",
      "libxml2",
      "libxslt1.1",
      "libatomic1",
      "libevent-2.1-7"
    ],
    lib2package: {
      "libasound.so.2": "libasound2",
      "libatk-1.0.so.0": "libatk1.0-0",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
      "libatspi.so.0": "libatspi2.0-0",
      "libcairo-gobject.so.2": "libcairo-gobject2",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdbus-glib-1.so.2": "libdbus-glib-1-2",
      "libdrm.so.2": "libdrm2",
      "libEGL.so.1": "libegl1",
      "libenchant-2.so.2": "libenchant-2-2",
      "libepoxy.so.0": "libepoxy0",
      "libevdev.so.2": "libevdev2",
      "libfontconfig.so.1": "libfontconfig1",
      "libfreetype.so.6": "libfreetype6",
      "libgbm.so.1": "libgbm1",
      "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf-2.0-0",
      "libgdk-3.so.0": "libgtk-3-0",
      "libgio-2.0.so.0": "libglib2.0-0",
      "libGLESv2.so.2": "libgles2",
      "libglib-2.0.so.0": "libglib2.0-0",
      "libGLX.so.0": "libglx0",
      "libgmodule-2.0.so.0": "libglib2.0-0",
      "libgobject-2.0.so.0": "libglib2.0-0",
      "libgstallocators-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstapp-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstaudio-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstbase-1.0.so.0": "libgstreamer1.0-0",
      "libgstfft-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
      "libgstpbutils-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
      "libgsttag-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstvideo-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgtk-3.so.0": "libgtk-3-0",
      "libgudev-1.0.so.0": "libgudev-1.0-0",
      "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
      "libharfbuzz.so.0": "libharfbuzz0b",
      "libhyphen.so.0": "libhyphen0",
      "libicui18n.so.67": "libicu67",
      "libicuuc.so.67": "libicu67",
      "libjpeg.so.62": "libjpeg62-turbo",
      "liblcms2.so.2": "liblcms2-2",
      "libmanette-0.2.so.0": "libmanette-0.2-0",
      "libnotify.so.4": "libnotify4",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libOpenGL.so.0": "libopengl0",
      "libopenjp2.so.7": "libopenjp2-7",
      "libopus.so.0": "libopus0",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
      "libpng16.so.16": "libpng16-16",
      "libproxy.so.1": "libproxy1v5",
      "libsecret-1.so.0": "libsecret-1-0",
      "libsmime3.so": "libnss3",
      "libwayland-client.so.0": "libwayland-client0",
      "libwayland-egl.so.1": "libwayland-egl1",
      "libwayland-server.so.0": "libwayland-server0",
      "libwebp.so.6": "libwebp6",
      "libwebpdemux.so.2": "libwebpdemux2",
      "libwoff2dec.so.1.0.2": "libwoff1",
      "libX11-xcb.so.1": "libx11-xcb1",
      "libX11.so.6": "libx11-6",
      "libxcb-shm.so.0": "libxcb-shm0",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXcursor.so.1": "libxcursor1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libXi.so.6": "libxi6",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libxml2.so.2": "libxml2",
      "libXrandr.so.2": "libxrandr2",
      "libXrender.so.1": "libxrender1",
      "libxslt.so.1": "libxslt1.1",
      "libXtst.so.6": "libxtst6",
      "libatomic.so.1": "libatomic1",
      "libevent-2.1.so.7": "libevent-2.1-7"
    }
  },
  "debian12-x64": {
    tools: [
      "xvfb",
      "fonts-noto-color-emoji",
      "fonts-unifont",
      "libfontconfig1",
      "libfreetype6",
      "xfonts-scalable",
      "fonts-liberation",
      "fonts-ipafont-gothic",
      "fonts-wqy-zenhei",
      "fonts-tlwg-loma-otf",
      "fonts-freefont-ttf"
    ],
    chromium: [
      "libasound2",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libatspi2.0-0",
      "libcairo2",
      "libcups2",
      "libdbus-1-3",
      "libdrm2",
      "libgbm1",
      "libglib2.0-0",
      "libnspr4",
      "libnss3",
      "libpango-1.0-0",
      "libx11-6",
      "libxcb1",
      "libxcomposite1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxkbcommon0",
      "libxrandr2"
    ],
    firefox: [
      "libasound2",
      "libatk1.0-0",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libdbus-glib-1-2",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf-2.0-0",
      "libglib2.0-0",
      "libgtk-3-0",
      "libharfbuzz0b",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb-shm0",
      "libxcb1",
      "libxcomposite1",
      "libxcursor1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxi6",
      "libxrandr2",
      "libxrender1",
      "libxtst6"
    ],
    webkit: [
      "libsoup-3.0-0",
      "gstreamer1.0-libav",
      "gstreamer1.0-plugins-bad",
      "gstreamer1.0-plugins-base",
      "gstreamer1.0-plugins-good",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libcairo2",
      "libdbus-1-3",
      "libdrm2",
      "libegl1",
      "libenchant-2-2",
      "libepoxy0",
      "libevdev2",
      "libfontconfig1",
      "libfreetype6",
      "libgbm1",
      "libgdk-pixbuf-2.0-0",
      "libgles2",
      "libglib2.0-0",
      "libglx0",
      "libgstreamer-gl1.0-0",
      "libgstreamer-plugins-base1.0-0",
      "libgstreamer1.0-0",
      "libgtk-4-1",
      "libgudev-1.0-0",
      "libharfbuzz-icu0",
      "libharfbuzz0b",
      "libhyphen0",
      "libicu72",
      "libjpeg62-turbo",
      "liblcms2-2",
      "libmanette-0.2-0",
      "libnotify4",
      "libopengl0",
      "libopenjp2-7",
      "libopus0",
      "libpango-1.0-0",
      "libpng16-16",
      "libproxy1v5",
      "libsecret-1-0",
      "libwayland-client0",
      "libwayland-egl1",
      "libwayland-server0",
      "libwebp7",
      "libwebpdemux2",
      "libwoff1",
      "libx11-6",
      "libxcomposite1",
      "libxdamage1",
      "libxkbcommon0",
      "libxml2",
      "libxslt1.1",
      "libatomic1",
      "libevent-2.1-7",
      "libavif15"
    ],
    lib2package: {
      "libavif.so.15": "libavif15",
      "libsoup-3.0.so.0": "libsoup-3.0-0",
      "libasound.so.2": "libasound2",
      "libatk-1.0.so.0": "libatk1.0-0",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
      "libatspi.so.0": "libatspi2.0-0",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdrm.so.2": "libdrm2",
      "libgbm.so.1": "libgbm1",
      "libgio-2.0.so.0": "libglib2.0-0",
      "libglib-2.0.so.0": "libglib2.0-0",
      "libgobject-2.0.so.0": "libglib2.0-0",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libsmime3.so": "libnss3",
      "libX11.so.6": "libx11-6",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libXrandr.so.2": "libxrandr2",
      "libgtk-4.so.1": "libgtk-4-1"
    }
  }
};
deps["ubuntu20.04-arm64"] = {
  tools: [...deps["ubuntu20.04-x64"].tools],
  chromium: [...deps["ubuntu20.04-x64"].chromium],
  firefox: [
    ...deps["ubuntu20.04-x64"].firefox
  ],
  webkit: [
    ...deps["ubuntu20.04-x64"].webkit
  ],
  lib2package: {
    ...deps["ubuntu20.04-x64"].lib2package
  }
};
deps["ubuntu22.04-arm64"] = {
  tools: [...deps["ubuntu22.04-x64"].tools],
  chromium: [...deps["ubuntu22.04-x64"].chromium],
  firefox: [
    ...deps["ubuntu22.04-x64"].firefox
  ],
  webkit: [
    ...deps["ubuntu22.04-x64"].webkit
  ],
  lib2package: {
    ...deps["ubuntu22.04-x64"].lib2package
  }
};
deps["ubuntu24.04-arm64"] = {
  tools: [...deps["ubuntu24.04-x64"].tools],
  chromium: [...deps["ubuntu24.04-x64"].chromium],
  firefox: [
    ...deps["ubuntu24.04-x64"].firefox
  ],
  webkit: [
    ...deps["ubuntu24.04-x64"].webkit
  ],
  lib2package: {
    ...deps["ubuntu24.04-x64"].lib2package
  }
};
deps["debian11-arm64"] = {
  tools: [...deps["debian11-x64"].tools],
  chromium: [...deps["debian11-x64"].chromium],
  firefox: [
    ...deps["debian11-x64"].firefox
  ],
  webkit: [
    ...deps["debian11-x64"].webkit
  ],
  lib2package: {
    ...deps["debian11-x64"].lib2package
  }
};
deps["debian12-arm64"] = {
  tools: [...deps["debian12-x64"].tools],
  chromium: [...deps["debian12-x64"].chromium],
  firefox: [
    ...deps["debian12-x64"].firefox
  ],
  webkit: [
    ...deps["debian12-x64"].webkit
  ],
  lib2package: {
    ...deps["debian12-x64"].lib2package
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/ascii.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function wrapInASCIIBox(text, padding = 0) {
  const lines = text.split("\n");
  const maxLength = Math.max(...lines.map((line) => line.length));
  return [
    "\u2554" + "\u2550".repeat(maxLength + padding * 2) + "\u2557",
    ...lines.map((line) => "\u2551" + " ".repeat(padding) + line + " ".repeat(maxLength - line.length + padding) + "\u2551"),
    "\u255A" + "\u2550".repeat(maxLength + padding * 2) + "\u255D"
  ].join("\n");
}
__name(wrapInASCIIBox, "wrapInASCIIBox");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/hostPlatform.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function calculatePlatform() {
  if (process.env.PLAYWRIGHT_HOST_PLATFORM_OVERRIDE) {
    return {
      hostPlatform: process.env.PLAYWRIGHT_HOST_PLATFORM_OVERRIDE,
      isOfficiallySupportedPlatform: false
    };
  }
  const platform4 = os_default.platform();
  if (platform4 === "darwin") {
    const ver = os_default.release().split(".").map((a) => parseInt(a, 10));
    let macVersion = "";
    if (ver[0] < 18) {
      macVersion = "mac10.13";
    } else if (ver[0] === 18) {
      macVersion = "mac10.14";
    } else if (ver[0] === 19) {
      macVersion = "mac10.15";
    } else {
      const LAST_STABLE_MACOS_MAJOR_VERSION = 15;
      macVersion = "mac" + Math.min(ver[0] - 9, LAST_STABLE_MACOS_MAJOR_VERSION);
      if (os_default.cpus().some((cpu) => cpu.model.includes("Apple")))
        macVersion += "-arm64";
    }
    return { hostPlatform: macVersion, isOfficiallySupportedPlatform: true };
  }
  if (platform4 === "linux") {
    if (!["x64", "arm64"].includes(os_default.arch()))
      return { hostPlatform: "<unknown>", isOfficiallySupportedPlatform: false };
    const archSuffix = "-" + os_default.arch();
    const distroInfo = getLinuxDistributionInfoSync();
    if (distroInfo?.id === "ubuntu" || distroInfo?.id === "pop" || distroInfo?.id === "neon" || distroInfo?.id === "tuxedo") {
      const isUbuntu = distroInfo?.id === "ubuntu";
      const version6 = distroInfo?.version;
      const major = parseInt(distroInfo.version, 10);
      if (major < 20)
        return { hostPlatform: "ubuntu18.04" + archSuffix, isOfficiallySupportedPlatform: false };
      if (major < 22)
        return { hostPlatform: "ubuntu20.04" + archSuffix, isOfficiallySupportedPlatform: isUbuntu && version6 === "20.04" };
      if (major < 24)
        return { hostPlatform: "ubuntu22.04" + archSuffix, isOfficiallySupportedPlatform: isUbuntu && version6 === "22.04" };
      if (major < 26)
        return { hostPlatform: "ubuntu24.04" + archSuffix, isOfficiallySupportedPlatform: isUbuntu && version6 === "24.04" };
      return { hostPlatform: "ubuntu" + distroInfo.version + archSuffix, isOfficiallySupportedPlatform: false };
    }
    if (distroInfo?.id === "linuxmint") {
      const mintMajor = parseInt(distroInfo.version, 10);
      if (mintMajor <= 20)
        return { hostPlatform: "ubuntu20.04" + archSuffix, isOfficiallySupportedPlatform: false };
      if (mintMajor === 21)
        return { hostPlatform: "ubuntu22.04" + archSuffix, isOfficiallySupportedPlatform: false };
      return { hostPlatform: "ubuntu24.04" + archSuffix, isOfficiallySupportedPlatform: false };
    }
    if (distroInfo?.id === "debian" || distroInfo?.id === "raspbian") {
      const isOfficiallySupportedPlatform2 = distroInfo?.id === "debian";
      if (distroInfo?.version === "11")
        return { hostPlatform: "debian11" + archSuffix, isOfficiallySupportedPlatform: isOfficiallySupportedPlatform2 };
      if (distroInfo?.version === "12")
        return { hostPlatform: "debian12" + archSuffix, isOfficiallySupportedPlatform: isOfficiallySupportedPlatform2 };
      if (distroInfo?.version === "")
        return { hostPlatform: "debian12" + archSuffix, isOfficiallySupportedPlatform: isOfficiallySupportedPlatform2 };
    }
    return { hostPlatform: "ubuntu20.04" + archSuffix, isOfficiallySupportedPlatform: false };
  }
  if (platform4 === "win32")
    return { hostPlatform: "win64", isOfficiallySupportedPlatform: true };
  return { hostPlatform: "<unknown>", isOfficiallySupportedPlatform: false };
}
__name(calculatePlatform, "calculatePlatform");
var { hostPlatform, isOfficiallySupportedPlatform } = calculatePlatform();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/spawnAsync.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function spawnAsync(cmd, args, options2 = {}) {
  const process2 = spawn(cmd, args, Object.assign({ windowsHide: true }, options2));
  return new Promise((resolve) => {
    let stdout2 = "";
    let stderr2 = "";
    if (process2.stdout)
      process2.stdout.on("data", (data) => stdout2 += data.toString());
    if (process2.stderr)
      process2.stderr.on("data", (data) => stderr2 += data.toString());
    process2.on("close", (code) => resolve({ stdout: stdout2, stderr: stderr2, code }));
    process2.on("error", (error4) => resolve({ stdout: stdout2, stderr: stderr2, code: 0, error: error4 }));
  });
}
__name(spawnAsync, "spawnAsync");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/registry/dependencies.js
var BIN_DIRECTORY = path6.join("/home/runner/work/playwright/playwright/packages/playwright-cloudflare", "..", "..", "..", "bin");
var languageBindingVersion = process.env.PW_CLI_DISPLAY_VERSION || require$$04.version;
var dockerVersionFilePath = "/ms-playwright/.docker-info";
function dockerVersion(dockerImageNameTemplate) {
  return {
    driverVersion: languageBindingVersion,
    dockerImageName: dockerImageNameTemplate.replace("%version%", languageBindingVersion)
  };
}
__name(dockerVersion, "dockerVersion");
function readDockerVersionSync() {
  try {
    const data = JSON.parse(fs.readFileSync(dockerVersionFilePath, "utf8"));
    return {
      ...data,
      dockerImageNameTemplate: data.dockerImageName.replace(data.driverVersion, "%version%")
    };
  } catch (e) {
    return null;
  }
}
__name(readDockerVersionSync, "readDockerVersionSync");
var checkExecutable = /* @__PURE__ */ __name((filePath) => {
  if (process.platform === "win32")
    return filePath.endsWith(".exe");
  return fs.promises.access(filePath, fs.constants.X_OK).then(() => true).catch(() => false);
}, "checkExecutable");
function isSupportedWindowsVersion() {
  if (os_default.platform() !== "win32" || os_default.arch() !== "x64")
    return false;
  const [major, minor] = os_default.release().split(".").map((token) => parseInt(token, 10));
  return major > 6 || major === 6 && minor > 1;
}
__name(isSupportedWindowsVersion, "isSupportedWindowsVersion");
async function installDependenciesWindows(targets, dryRun) {
  if (targets.has("chromium")) {
    const command2 = "powershell.exe";
    const args = ["-ExecutionPolicy", "Bypass", "-File", path6.join(BIN_DIRECTORY, "install_media_pack.ps1")];
    if (dryRun) {
      console.log(`${command2} ${quoteProcessArgs(args).join(" ")}`);
      return;
    }
    const { code } = await spawnAsync(command2, args, { cwd: BIN_DIRECTORY, stdio: "inherit" });
    if (code !== 0)
      throw new Error("Failed to install windows dependencies!");
  }
}
__name(installDependenciesWindows, "installDependenciesWindows");
async function installDependenciesLinux(targets, dryRun) {
  const libraries = [];
  const platform4 = hostPlatform;
  if (!isOfficiallySupportedPlatform)
    console.warn(`BEWARE: your OS is not officially supported by Playwright; installing dependencies for ${platform4} as a fallback.`);
  for (const target of targets) {
    const info3 = deps[platform4];
    if (!info3) {
      console.warn(`Cannot install dependencies for ${platform4} with Playwright ${getPlaywrightVersion()}!`);
      return;
    }
    libraries.push(...info3[target]);
  }
  const uniqueLibraries = Array.from(new Set(libraries));
  if (!dryRun)
    console.log(`Installing dependencies...`);
  const commands = [];
  commands.push("apt-get update");
  commands.push([
    "apt-get",
    "install",
    "-y",
    "--no-install-recommends",
    ...uniqueLibraries
  ].join(" "));
  const { command: command2, args, elevatedPermissions } = await transformCommandsForRoot(commands);
  if (dryRun) {
    console.log(`${command2} ${quoteProcessArgs(args).join(" ")}`);
    return;
  }
  if (elevatedPermissions)
    console.log("Switching to root user to install dependencies...");
  const child = spawn(command2, args, { stdio: "inherit" });
  await new Promise((resolve, reject) => {
    child.on("exit", (code) => code === 0 ? resolve() : reject(new Error(`Installation process exited with code: ${code}`)));
    child.on("error", reject);
  });
}
__name(installDependenciesLinux, "installDependenciesLinux");
async function validateDependenciesWindows(sdkLanguage, windowsExeAndDllDirectories) {
  const directoryPaths = windowsExeAndDllDirectories;
  const lddPaths = [];
  for (const directoryPath of directoryPaths)
    lddPaths.push(...await executablesOrSharedLibraries(directoryPath));
  const allMissingDeps = await Promise.all(lddPaths.map((lddPath) => missingFileDependenciesWindows(sdkLanguage, lddPath)));
  const missingDeps = /* @__PURE__ */ new Set();
  for (const deps2 of allMissingDeps) {
    for (const dep of deps2)
      missingDeps.add(dep);
  }
  if (!missingDeps.size)
    return;
  let isCrtMissing = false;
  let isMediaFoundationMissing = false;
  for (const dep of missingDeps) {
    if (dep.startsWith("api-ms-win-crt") || dep === "vcruntime140.dll" || dep === "vcruntime140_1.dll" || dep === "msvcp140.dll")
      isCrtMissing = true;
    else if (dep === "mf.dll" || dep === "mfplat.dll" || dep === "msmpeg2vdec.dll" || dep === "evr.dll" || dep === "avrt.dll")
      isMediaFoundationMissing = true;
  }
  const details = [];
  if (isCrtMissing) {
    details.push(
      `Some of the Universal C Runtime files cannot be found on the system. You can fix`,
      `that by installing Microsoft Visual C++ Redistributable for Visual Studio from:`,
      `https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads`,
      ``
    );
  }
  if (isMediaFoundationMissing) {
    details.push(
      `Some of the Media Foundation files cannot be found on the system. If you are`,
      `on Windows Server try fixing this by running the following command in PowerShell`,
      `as Administrator:`,
      ``,
      `    Install-WindowsFeature Server-Media-Foundation`,
      ``,
      `For Windows N editions visit:`,
      `https://support.microsoft.com/en-us/help/3145500/media-feature-pack-list-for-windows-n-editions`,
      ``
    );
  }
  details.push(
    `Full list of missing libraries:`,
    `    ${[...missingDeps].join("\n    ")}`,
    ``
  );
  const message = `Host system is missing dependencies!

${details.join("\n")}`;
  if (isSupportedWindowsVersion()) {
    throw new Error(message);
  } else {
    console.warn(`WARNING: running on unsupported windows version!`);
    console.warn(message);
  }
}
__name(validateDependenciesWindows, "validateDependenciesWindows");
async function validateDependenciesLinux(sdkLanguage, linuxLddDirectories, dlOpenLibraries) {
  const directoryPaths = linuxLddDirectories;
  const lddPaths = [];
  for (const directoryPath of directoryPaths)
    lddPaths.push(...await executablesOrSharedLibraries(directoryPath));
  const missingDepsPerFile = await Promise.all(lddPaths.map((lddPath) => missingFileDependencies(lddPath, directoryPaths)));
  const missingDeps = /* @__PURE__ */ new Set();
  for (const deps2 of missingDepsPerFile) {
    for (const dep of deps2)
      missingDeps.add(dep);
  }
  for (const dep of await missingDLOPENLibraries(dlOpenLibraries))
    missingDeps.add(dep);
  if (!missingDeps.size)
    return;
  const allMissingDeps = new Set(missingDeps);
  const missingPackages = /* @__PURE__ */ new Set();
  const libraryToPackageNameMapping = deps[hostPlatform] ? {
    ...deps[hostPlatform]?.lib2package || {},
    ...MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU
  } : {};
  for (const missingDep of missingDeps) {
    const packageName = libraryToPackageNameMapping[missingDep];
    if (packageName) {
      missingPackages.add(packageName);
      missingDeps.delete(missingDep);
    }
  }
  const maybeSudo = process.getuid?.() && os_default.platform() !== "win32" ? "sudo " : "";
  const dockerInfo = readDockerVersionSync();
  const errorLines = [
    `Host system is missing dependencies to run browsers.`
  ];
  if (dockerInfo && !dockerInfo.driverVersion.startsWith(getPlaywrightVersion(
    true
    /* majorMinorOnly */
  ) + ".")) {
    const pwVersion = getPlaywrightVersion();
    const requiredDockerImage = dockerInfo.dockerImageName.replace(dockerInfo.driverVersion, pwVersion);
    errorLines.push(...[
      `This is most likely due to Docker image version not matching Playwright version:`,
      `- Playwright  : ${pwVersion}`,
      `- Docker image: ${dockerInfo.driverVersion}`,
      ``,
      `Either:`,
      `- (recommended) use Docker image "${requiredDockerImage}"`,
      `- (alternative 1) run the following command inside Docker to install missing dependencies:`,
      ``,
      `    ${maybeSudo}${buildPlaywrightCLICommand(sdkLanguage, "install-deps")}`,
      ``,
      `- (alternative 2) use apt inside Docker:`,
      ``,
      `    ${maybeSudo}apt-get install ${[...missingPackages].join("\\\n        ")}`,
      ``,
      `<3 Playwright Team`
    ]);
  } else if (missingPackages.size && !missingDeps.size) {
    errorLines.push(...[
      `Please install them with the following command:`,
      ``,
      `    ${maybeSudo}${buildPlaywrightCLICommand(sdkLanguage, "install-deps")}`,
      ``,
      `Alternatively, use apt:`,
      `    ${maybeSudo}apt-get install ${[...missingPackages].join("\\\n        ")}`,
      ``,
      `<3 Playwright Team`
    ]);
  } else {
    errorLines.push(...[
      `Missing libraries:`,
      ...[...allMissingDeps].map((dep) => "    " + dep)
    ]);
  }
  throw new Error("\n" + wrapInASCIIBox(errorLines.join("\n"), 1));
}
__name(validateDependenciesLinux, "validateDependenciesLinux");
function isSharedLib(basename) {
  switch (os_default.platform()) {
    case "linux":
      return basename.endsWith(".so") || basename.includes(".so.");
    case "win32":
      return basename.endsWith(".dll");
    default:
      return false;
  }
}
__name(isSharedLib, "isSharedLib");
async function executablesOrSharedLibraries(directoryPath) {
  if (!fs.existsSync(directoryPath))
    return [];
  const allPaths = (await fs.promises.readdir(directoryPath)).map((file) => path6.resolve(directoryPath, file));
  const allStats = await Promise.all(allPaths.map((aPath) => fs.promises.stat(aPath)));
  const filePaths = allPaths.filter((aPath, index2) => allStats[index2].isFile());
  const executablersOrLibraries = (await Promise.all(filePaths.map(async (filePath) => {
    const basename = path6.basename(filePath).toLowerCase();
    if (isSharedLib(basename))
      return filePath;
    if (await checkExecutable(filePath))
      return filePath;
    return false;
  }))).filter(Boolean);
  return executablersOrLibraries;
}
__name(executablesOrSharedLibraries, "executablesOrSharedLibraries");
async function missingFileDependenciesWindows(sdkLanguage, filePath) {
  const executable = registry.findExecutable("winldd").executablePathOrDie(sdkLanguage);
  const dirname = path6.dirname(filePath);
  const { stdout: stdout2, code } = await spawnAsync(executable, [filePath], {
    cwd: dirname,
    env: {
      ...process.env,
      LD_LIBRARY_PATH: process.env.LD_LIBRARY_PATH ? `${process.env.LD_LIBRARY_PATH}:${dirname}` : dirname
    }
  });
  if (code !== 0)
    return [];
  const missingDeps = stdout2.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim().toLowerCase());
  return missingDeps;
}
__name(missingFileDependenciesWindows, "missingFileDependenciesWindows");
async function missingFileDependencies(filePath, extraLDPaths) {
  const dirname = path6.dirname(filePath);
  let LD_LIBRARY_PATH = extraLDPaths.join(":");
  if (process.env.LD_LIBRARY_PATH)
    LD_LIBRARY_PATH = `${process.env.LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}`;
  const { stdout: stdout2, code } = await spawnAsync("ldd", [filePath], {
    cwd: dirname,
    env: {
      ...process.env,
      LD_LIBRARY_PATH
    }
  });
  if (code !== 0)
    return [];
  const missingDeps = stdout2.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim());
  return missingDeps;
}
__name(missingFileDependencies, "missingFileDependencies");
async function missingDLOPENLibraries(libraries) {
  if (!libraries.length)
    return [];
  const { stdout: stdout2, code, error: error4 } = await spawnAsync("/sbin/ldconfig", ["-p"], {});
  if (code !== 0 || error4)
    return [];
  const isLibraryAvailable = /* @__PURE__ */ __name((library) => stdout2.toLowerCase().includes(library.toLowerCase()), "isLibraryAvailable");
  return libraries.filter((library) => !isLibraryAvailable(library));
}
__name(missingDLOPENLibraries, "missingDLOPENLibraries");
var MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU = {
  // libgstlibav.so (the only actual library provided by gstreamer1.0-libav) is not
  // in the ldconfig cache, so we detect the actual library required for playing h.264
  // and if it's missing recommend installing missing gstreamer lib.
  // gstreamer1.0-libav -> libavcodec57 -> libx264-152
  "libx264.so": "gstreamer1.0-libav"
};
function quoteProcessArgs(args) {
  return args.map((arg) => {
    if (arg.includes(" "))
      return `"${arg}"`;
    return arg;
  });
}
__name(quoteProcessArgs, "quoteProcessArgs");
async function transformCommandsForRoot(commands) {
  const isRoot = process.getuid?.() === 0;
  if (isRoot)
    return { command: "sh", args: ["-c", `${commands.join("&& ")}`], elevatedPermissions: false };
  const sudoExists = await spawnAsync("which", ["sudo"]);
  if (sudoExists.code === 0)
    return { command: "sudo", args: ["--", "sh", "-c", `${commands.join("&& ")}`], elevatedPermissions: true };
  return { command: "su", args: ["root", "-c", `${commands.join("&& ")}`], elevatedPermissions: true };
}
__name(transformCommandsForRoot, "transformCommandsForRoot");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/selectorParser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/cssParser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/cssTokenizer.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var between = /* @__PURE__ */ __name(function(num, first, last) {
  return num >= first && num <= last;
}, "between");
function digit(code) {
  return between(code, 48, 57);
}
__name(digit, "digit");
function hexdigit(code) {
  return digit(code) || between(code, 65, 70) || between(code, 97, 102);
}
__name(hexdigit, "hexdigit");
function uppercaseletter(code) {
  return between(code, 65, 90);
}
__name(uppercaseletter, "uppercaseletter");
function lowercaseletter(code) {
  return between(code, 97, 122);
}
__name(lowercaseletter, "lowercaseletter");
function letter(code) {
  return uppercaseletter(code) || lowercaseletter(code);
}
__name(letter, "letter");
function nonascii(code) {
  return code >= 128;
}
__name(nonascii, "nonascii");
function namestartchar(code) {
  return letter(code) || nonascii(code) || code === 95;
}
__name(namestartchar, "namestartchar");
function namechar(code) {
  return namestartchar(code) || digit(code) || code === 45;
}
__name(namechar, "namechar");
function nonprintable(code) {
  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;
}
__name(nonprintable, "nonprintable");
function newline(code) {
  return code === 10;
}
__name(newline, "newline");
function whitespace(code) {
  return newline(code) || code === 9 || code === 32;
}
__name(whitespace, "whitespace");
var maximumallowedcodepoint = 1114111;
var InvalidCharacterError = class extends Error {
  static {
    __name(this, "InvalidCharacterError");
  }
  constructor(message) {
    super(message);
    this.name = "InvalidCharacterError";
  }
};
function preprocess(str) {
  const codepoints = [];
  for (let i = 0; i < str.length; i++) {
    let code = str.charCodeAt(i);
    if (code === 13 && str.charCodeAt(i + 1) === 10) {
      code = 10;
      i++;
    }
    if (code === 13 || code === 12)
      code = 10;
    if (code === 0)
      code = 65533;
    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {
      const lead = code - 55296;
      const trail = str.charCodeAt(i + 1) - 56320;
      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
      i++;
    }
    codepoints.push(code);
  }
  return codepoints;
}
__name(preprocess, "preprocess");
function stringFromCode(code) {
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= Math.pow(2, 16);
  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;
  const trail = code % Math.pow(2, 10) + 56320;
  return String.fromCharCode(lead) + String.fromCharCode(trail);
}
__name(stringFromCode, "stringFromCode");
function tokenize2(str1) {
  const str = preprocess(str1);
  let i = -1;
  const tokens = [];
  let code;
  const codepoint = /* @__PURE__ */ __name(function(i2) {
    if (i2 >= str.length)
      return -1;
    return str[i2];
  }, "codepoint");
  const next = /* @__PURE__ */ __name(function(num) {
    if (num === void 0)
      num = 1;
    if (num > 3)
      throw "Spec Error: no more than three codepoints of lookahead.";
    return codepoint(i + num);
  }, "next");
  const consume = /* @__PURE__ */ __name(function(num) {
    if (num === void 0)
      num = 1;
    i += num;
    code = codepoint(i);
    return true;
  }, "consume");
  const reconsume = /* @__PURE__ */ __name(function() {
    i -= 1;
    return true;
  }, "reconsume");
  const eof = /* @__PURE__ */ __name(function(codepoint2) {
    if (codepoint2 === void 0)
      codepoint2 = code;
    return codepoint2 === -1;
  }, "eof");
  const consumeAToken = /* @__PURE__ */ __name(function() {
    consumeComments();
    consume();
    if (whitespace(code)) {
      while (whitespace(next()))
        consume();
      return new WhitespaceToken();
    } else if (code === 34) {
      return consumeAStringToken();
    } else if (code === 35) {
      if (namechar(next()) || areAValidEscape(next(1), next(2))) {
        const token = new HashToken("");
        if (wouldStartAnIdentifier(next(1), next(2), next(3)))
          token.type = "id";
        token.value = consumeAName();
        return token;
      } else {
        return new DelimToken(code);
      }
    } else if (code === 36) {
      if (next() === 61) {
        consume();
        return new SuffixMatchToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 39) {
      return consumeAStringToken();
    } else if (code === 40) {
      return new OpenParenToken();
    } else if (code === 41) {
      return new CloseParenToken();
    } else if (code === 42) {
      if (next() === 61) {
        consume();
        return new SubstringMatchToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 43) {
      if (startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 44) {
      return new CommaToken();
    } else if (code === 45) {
      if (startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else if (next(1) === 45 && next(2) === 62) {
        consume(2);
        return new CDCToken();
      } else if (startsWithAnIdentifier()) {
        reconsume();
        return consumeAnIdentlikeToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 46) {
      if (startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 58) {
      return new ColonToken();
    } else if (code === 59) {
      return new SemicolonToken();
    } else if (code === 60) {
      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {
        consume(3);
        return new CDOToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 64) {
      if (wouldStartAnIdentifier(next(1), next(2), next(3)))
        return new AtKeywordToken(consumeAName());
      else
        return new DelimToken(code);
    } else if (code === 91) {
      return new OpenSquareToken();
    } else if (code === 92) {
      if (startsWithAValidEscape()) {
        reconsume();
        return consumeAnIdentlikeToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 93) {
      return new CloseSquareToken();
    } else if (code === 94) {
      if (next() === 61) {
        consume();
        return new PrefixMatchToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 123) {
      return new OpenCurlyToken();
    } else if (code === 124) {
      if (next() === 61) {
        consume();
        return new DashMatchToken();
      } else if (next() === 124) {
        consume();
        return new ColumnToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 125) {
      return new CloseCurlyToken();
    } else if (code === 126) {
      if (next() === 61) {
        consume();
        return new IncludeMatchToken();
      } else {
        return new DelimToken(code);
      }
    } else if (digit(code)) {
      reconsume();
      return consumeANumericToken();
    } else if (namestartchar(code)) {
      reconsume();
      return consumeAnIdentlikeToken();
    } else if (eof()) {
      return new EOFToken();
    } else {
      return new DelimToken(code);
    }
  }, "consumeAToken");
  const consumeComments = /* @__PURE__ */ __name(function() {
    while (next(1) === 47 && next(2) === 42) {
      consume(2);
      while (true) {
        consume();
        if (code === 42 && next() === 47) {
          consume();
          break;
        } else if (eof()) {
          return;
        }
      }
    }
  }, "consumeComments");
  const consumeANumericToken = /* @__PURE__ */ __name(function() {
    const num = consumeANumber();
    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
      const token = new DimensionToken();
      token.value = num.value;
      token.repr = num.repr;
      token.type = num.type;
      token.unit = consumeAName();
      return token;
    } else if (next() === 37) {
      consume();
      const token = new PercentageToken();
      token.value = num.value;
      token.repr = num.repr;
      return token;
    } else {
      const token = new NumberToken();
      token.value = num.value;
      token.repr = num.repr;
      token.type = num.type;
      return token;
    }
  }, "consumeANumericToken");
  const consumeAnIdentlikeToken = /* @__PURE__ */ __name(function() {
    const str2 = consumeAName();
    if (str2.toLowerCase() === "url" && next() === 40) {
      consume();
      while (whitespace(next(1)) && whitespace(next(2)))
        consume();
      if (next() === 34 || next() === 39)
        return new FunctionToken(str2);
      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))
        return new FunctionToken(str2);
      else
        return consumeAURLToken();
    } else if (next() === 40) {
      consume();
      return new FunctionToken(str2);
    } else {
      return new IdentToken(str2);
    }
  }, "consumeAnIdentlikeToken");
  const consumeAStringToken = /* @__PURE__ */ __name(function(endingCodePoint) {
    if (endingCodePoint === void 0)
      endingCodePoint = code;
    let string2 = "";
    while (consume()) {
      if (code === endingCodePoint || eof()) {
        return new StringToken(string2);
      } else if (newline(code)) {
        reconsume();
        return new BadStringToken();
      } else if (code === 92) {
        if (eof(next()))
          ;
        else if (newline(next()))
          consume();
        else
          string2 += stringFromCode(consumeEscape());
      } else {
        string2 += stringFromCode(code);
      }
    }
    throw new Error("Internal error");
  }, "consumeAStringToken");
  const consumeAURLToken = /* @__PURE__ */ __name(function() {
    const token = new URLToken("");
    while (whitespace(next()))
      consume();
    if (eof(next()))
      return token;
    while (consume()) {
      if (code === 41 || eof()) {
        return token;
      } else if (whitespace(code)) {
        while (whitespace(next()))
          consume();
        if (next() === 41 || eof(next())) {
          consume();
          return token;
        } else {
          consumeTheRemnantsOfABadURL();
          return new BadURLToken();
        }
      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {
        consumeTheRemnantsOfABadURL();
        return new BadURLToken();
      } else if (code === 92) {
        if (startsWithAValidEscape()) {
          token.value += stringFromCode(consumeEscape());
        } else {
          consumeTheRemnantsOfABadURL();
          return new BadURLToken();
        }
      } else {
        token.value += stringFromCode(code);
      }
    }
    throw new Error("Internal error");
  }, "consumeAURLToken");
  const consumeEscape = /* @__PURE__ */ __name(function() {
    consume();
    if (hexdigit(code)) {
      const digits = [code];
      for (let total = 0; total < 5; total++) {
        if (hexdigit(next())) {
          consume();
          digits.push(code);
        } else {
          break;
        }
      }
      if (whitespace(next()))
        consume();
      let value = parseInt(digits.map(function(x) {
        return String.fromCharCode(x);
      }).join(""), 16);
      if (value > maximumallowedcodepoint)
        value = 65533;
      return value;
    } else if (eof()) {
      return 65533;
    } else {
      return code;
    }
  }, "consumeEscape");
  const areAValidEscape = /* @__PURE__ */ __name(function(c1, c2) {
    if (c1 !== 92)
      return false;
    if (newline(c2))
      return false;
    return true;
  }, "areAValidEscape");
  const startsWithAValidEscape = /* @__PURE__ */ __name(function() {
    return areAValidEscape(code, next());
  }, "startsWithAValidEscape");
  const wouldStartAnIdentifier = /* @__PURE__ */ __name(function(c1, c2, c3) {
    if (c1 === 45)
      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);
    else if (namestartchar(c1))
      return true;
    else if (c1 === 92)
      return areAValidEscape(c1, c2);
    else
      return false;
  }, "wouldStartAnIdentifier");
  const startsWithAnIdentifier = /* @__PURE__ */ __name(function() {
    return wouldStartAnIdentifier(code, next(1), next(2));
  }, "startsWithAnIdentifier");
  const wouldStartANumber = /* @__PURE__ */ __name(function(c1, c2, c3) {
    if (c1 === 43 || c1 === 45) {
      if (digit(c2))
        return true;
      if (c2 === 46 && digit(c3))
        return true;
      return false;
    } else if (c1 === 46) {
      if (digit(c2))
        return true;
      return false;
    } else if (digit(c1)) {
      return true;
    } else {
      return false;
    }
  }, "wouldStartANumber");
  const startsWithANumber = /* @__PURE__ */ __name(function() {
    return wouldStartANumber(code, next(1), next(2));
  }, "startsWithANumber");
  const consumeAName = /* @__PURE__ */ __name(function() {
    let result = "";
    while (consume()) {
      if (namechar(code)) {
        result += stringFromCode(code);
      } else if (startsWithAValidEscape()) {
        result += stringFromCode(consumeEscape());
      } else {
        reconsume();
        return result;
      }
    }
    throw new Error("Internal parse error");
  }, "consumeAName");
  const consumeANumber = /* @__PURE__ */ __name(function() {
    let repr = "";
    let type2 = "integer";
    if (next() === 43 || next() === 45) {
      consume();
      repr += stringFromCode(code);
    }
    while (digit(next())) {
      consume();
      repr += stringFromCode(code);
    }
    if (next(1) === 46 && digit(next(2))) {
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      type2 = "number";
      while (digit(next())) {
        consume();
        repr += stringFromCode(code);
      }
    }
    const c1 = next(1), c2 = next(2), c3 = next(3);
    if ((c1 === 69 || c1 === 101) && digit(c2)) {
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      type2 = "number";
      while (digit(next())) {
        consume();
        repr += stringFromCode(code);
      }
    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      type2 = "number";
      while (digit(next())) {
        consume();
        repr += stringFromCode(code);
      }
    }
    const value = convertAStringToANumber(repr);
    return { type: type2, value, repr };
  }, "consumeANumber");
  const convertAStringToANumber = /* @__PURE__ */ __name(function(string2) {
    return +string2;
  }, "convertAStringToANumber");
  const consumeTheRemnantsOfABadURL = /* @__PURE__ */ __name(function() {
    while (consume()) {
      if (code === 41 || eof()) {
        return;
      } else if (startsWithAValidEscape()) {
        consumeEscape();
      } else ;
    }
  }, "consumeTheRemnantsOfABadURL");
  let iterationCount = 0;
  while (!eof(next())) {
    tokens.push(consumeAToken());
    iterationCount++;
    if (iterationCount > str.length * 2)
      throw new Error("I'm infinite-looping!");
  }
  return tokens;
}
__name(tokenize2, "tokenize");
var CSSParserToken = class {
  static {
    __name(this, "CSSParserToken");
  }
  constructor() {
    this.tokenType = "";
  }
  toJSON() {
    return { token: this.tokenType };
  }
  toString() {
    return this.tokenType;
  }
  toSource() {
    return "" + this;
  }
};
var BadStringToken = class extends CSSParserToken {
  static {
    __name(this, "BadStringToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "BADSTRING";
  }
};
var BadURLToken = class extends CSSParserToken {
  static {
    __name(this, "BadURLToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "BADURL";
  }
};
var WhitespaceToken = class extends CSSParserToken {
  static {
    __name(this, "WhitespaceToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "WHITESPACE";
  }
  toString() {
    return "WS";
  }
  toSource() {
    return " ";
  }
};
var CDOToken = class extends CSSParserToken {
  static {
    __name(this, "CDOToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "CDO";
  }
  toSource() {
    return "<!--";
  }
};
var CDCToken = class extends CSSParserToken {
  static {
    __name(this, "CDCToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "CDC";
  }
  toSource() {
    return "-->";
  }
};
var ColonToken = class extends CSSParserToken {
  static {
    __name(this, "ColonToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = ":";
  }
};
var SemicolonToken = class extends CSSParserToken {
  static {
    __name(this, "SemicolonToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = ";";
  }
};
var CommaToken = class extends CSSParserToken {
  static {
    __name(this, "CommaToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = ",";
  }
};
var GroupingToken = class extends CSSParserToken {
  static {
    __name(this, "GroupingToken");
  }
  constructor() {
    super(...arguments);
    this.value = "";
    this.mirror = "";
  }
};
var OpenCurlyToken = class extends GroupingToken {
  static {
    __name(this, "OpenCurlyToken");
  }
  constructor() {
    super();
    this.tokenType = "{";
    this.value = "{";
    this.mirror = "}";
  }
};
var CloseCurlyToken = class extends GroupingToken {
  static {
    __name(this, "CloseCurlyToken");
  }
  constructor() {
    super();
    this.tokenType = "}";
    this.value = "}";
    this.mirror = "{";
  }
};
var OpenSquareToken = class extends GroupingToken {
  static {
    __name(this, "OpenSquareToken");
  }
  constructor() {
    super();
    this.tokenType = "[";
    this.value = "[";
    this.mirror = "]";
  }
};
var CloseSquareToken = class extends GroupingToken {
  static {
    __name(this, "CloseSquareToken");
  }
  constructor() {
    super();
    this.tokenType = "]";
    this.value = "]";
    this.mirror = "[";
  }
};
var OpenParenToken = class extends GroupingToken {
  static {
    __name(this, "OpenParenToken");
  }
  constructor() {
    super();
    this.tokenType = "(";
    this.value = "(";
    this.mirror = ")";
  }
};
var CloseParenToken = class extends GroupingToken {
  static {
    __name(this, "CloseParenToken");
  }
  constructor() {
    super();
    this.tokenType = ")";
    this.value = ")";
    this.mirror = "(";
  }
};
var IncludeMatchToken = class extends CSSParserToken {
  static {
    __name(this, "IncludeMatchToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "~=";
  }
};
var DashMatchToken = class extends CSSParserToken {
  static {
    __name(this, "DashMatchToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "|=";
  }
};
var PrefixMatchToken = class extends CSSParserToken {
  static {
    __name(this, "PrefixMatchToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "^=";
  }
};
var SuffixMatchToken = class extends CSSParserToken {
  static {
    __name(this, "SuffixMatchToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "$=";
  }
};
var SubstringMatchToken = class extends CSSParserToken {
  static {
    __name(this, "SubstringMatchToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "*=";
  }
};
var ColumnToken = class extends CSSParserToken {
  static {
    __name(this, "ColumnToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "||";
  }
};
var EOFToken = class extends CSSParserToken {
  static {
    __name(this, "EOFToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "EOF";
  }
  toSource() {
    return "";
  }
};
var DelimToken = class extends CSSParserToken {
  static {
    __name(this, "DelimToken");
  }
  constructor(code) {
    super();
    this.tokenType = "DELIM";
    this.value = "";
    this.value = stringFromCode(code);
  }
  toString() {
    return "DELIM(" + this.value + ")";
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    return json;
  }
  toSource() {
    if (this.value === "\\")
      return "\\\n";
    else
      return this.value;
  }
};
var StringValuedToken = class extends CSSParserToken {
  static {
    __name(this, "StringValuedToken");
  }
  constructor() {
    super(...arguments);
    this.value = "";
  }
  ASCIIMatch(str) {
    return this.value.toLowerCase() === str.toLowerCase();
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    return json;
  }
};
var IdentToken = class extends StringValuedToken {
  static {
    __name(this, "IdentToken");
  }
  constructor(val) {
    super();
    this.tokenType = "IDENT";
    this.value = val;
  }
  toString() {
    return "IDENT(" + this.value + ")";
  }
  toSource() {
    return escapeIdent(this.value);
  }
};
var FunctionToken = class extends StringValuedToken {
  static {
    __name(this, "FunctionToken");
  }
  constructor(val) {
    super();
    this.tokenType = "FUNCTION";
    this.value = val;
    this.mirror = ")";
  }
  toString() {
    return "FUNCTION(" + this.value + ")";
  }
  toSource() {
    return escapeIdent(this.value) + "(";
  }
};
var AtKeywordToken = class extends StringValuedToken {
  static {
    __name(this, "AtKeywordToken");
  }
  constructor(val) {
    super();
    this.tokenType = "AT-KEYWORD";
    this.value = val;
  }
  toString() {
    return "AT(" + this.value + ")";
  }
  toSource() {
    return "@" + escapeIdent(this.value);
  }
};
var HashToken = class extends StringValuedToken {
  static {
    __name(this, "HashToken");
  }
  constructor(val) {
    super();
    this.tokenType = "HASH";
    this.value = val;
    this.type = "unrestricted";
  }
  toString() {
    return "HASH(" + this.value + ")";
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    json.type = this.type;
    return json;
  }
  toSource() {
    if (this.type === "id")
      return "#" + escapeIdent(this.value);
    else
      return "#" + escapeHash(this.value);
  }
};
var StringToken = class extends StringValuedToken {
  static {
    __name(this, "StringToken");
  }
  constructor(val) {
    super();
    this.tokenType = "STRING";
    this.value = val;
  }
  toString() {
    return '"' + escapeString(this.value) + '"';
  }
};
var URLToken = class extends StringValuedToken {
  static {
    __name(this, "URLToken");
  }
  constructor(val) {
    super();
    this.tokenType = "URL";
    this.value = val;
  }
  toString() {
    return "URL(" + this.value + ")";
  }
  toSource() {
    return 'url("' + escapeString(this.value) + '")';
  }
};
var NumberToken = class extends CSSParserToken {
  static {
    __name(this, "NumberToken");
  }
  constructor() {
    super();
    this.tokenType = "NUMBER";
    this.type = "integer";
    this.repr = "";
  }
  toString() {
    if (this.type === "integer")
      return "INT(" + this.value + ")";
    return "NUMBER(" + this.value + ")";
  }
  toJSON() {
    const json = super.toJSON();
    json.value = this.value;
    json.type = this.type;
    json.repr = this.repr;
    return json;
  }
  toSource() {
    return this.repr;
  }
};
var PercentageToken = class extends CSSParserToken {
  static {
    __name(this, "PercentageToken");
  }
  constructor() {
    super();
    this.tokenType = "PERCENTAGE";
    this.repr = "";
  }
  toString() {
    return "PERCENTAGE(" + this.value + ")";
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    json.repr = this.repr;
    return json;
  }
  toSource() {
    return this.repr + "%";
  }
};
var DimensionToken = class extends CSSParserToken {
  static {
    __name(this, "DimensionToken");
  }
  constructor() {
    super();
    this.tokenType = "DIMENSION";
    this.type = "integer";
    this.repr = "";
    this.unit = "";
  }
  toString() {
    return "DIM(" + this.value + "," + this.unit + ")";
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    json.type = this.type;
    json.repr = this.repr;
    json.unit = this.unit;
    return json;
  }
  toSource() {
    const source7 = this.repr;
    let unit = escapeIdent(this.unit);
    if (unit[0].toLowerCase() === "e" && (unit[1] === "-" || between(unit.charCodeAt(1), 48, 57))) {
      unit = "\\65 " + unit.slice(1, unit.length);
    }
    return source7 + unit;
  }
};
function escapeIdent(string2) {
  string2 = "" + string2;
  let result = "";
  const firstcode = string2.charCodeAt(0);
  for (let i = 0; i < string2.length; i++) {
    const code = string2.charCodeAt(i);
    if (code === 0)
      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)
      result += "\\" + code.toString(16) + " ";
    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))
      result += string2[i];
    else
      result += "\\" + string2[i];
  }
  return result;
}
__name(escapeIdent, "escapeIdent");
function escapeHash(string2) {
  string2 = "" + string2;
  let result = "";
  for (let i = 0; i < string2.length; i++) {
    const code = string2.charCodeAt(i);
    if (code === 0)
      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))
      result += string2[i];
    else
      result += "\\" + code.toString(16) + " ";
  }
  return result;
}
__name(escapeHash, "escapeHash");
function escapeString(string2) {
  string2 = "" + string2;
  let result = "";
  for (let i = 0; i < string2.length; i++) {
    const code = string2.charCodeAt(i);
    if (code === 0)
      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
    if (between(code, 1, 31) || code === 127)
      result += "\\" + code.toString(16) + " ";
    else if (code === 34 || code === 92)
      result += "\\" + string2[i];
    else
      result += string2[i];
  }
  return result;
}
__name(escapeString, "escapeString");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/cssParser.js
var InvalidSelectorError = class extends Error {
  static {
    __name(this, "InvalidSelectorError");
  }
};
function isInvalidSelectorError(error4) {
  return error4 instanceof InvalidSelectorError;
}
__name(isInvalidSelectorError, "isInvalidSelectorError");
function parseCSS(selector, customNames) {
  let tokens;
  try {
    tokens = tokenize2(selector);
    if (!(tokens[tokens.length - 1] instanceof EOFToken))
      tokens.push(new EOFToken());
  } catch (e) {
    const newMessage = e.message + ` while parsing css selector "${selector}". Did you mean to CSS.escape it?`;
    const index2 = (e.stack || "").indexOf(e.message);
    if (index2 !== -1)
      e.stack = e.stack.substring(0, index2) + newMessage + e.stack.substring(index2 + e.message.length);
    e.message = newMessage;
    throw e;
  }
  const unsupportedToken = tokens.find((token) => {
    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || // TODO: Consider using these for something, e.g. to escape complex strings.
    // For example :xpath{ (//div/bar[@attr="foo"])[2]/baz }
    // Or this way :xpath( {complex-xpath-goes-here("hello")} )
    token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || // TODO: Consider treating these as strings?
    token instanceof URLToken || token instanceof PercentageToken;
  });
  if (unsupportedToken)
    throw new InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing css selector "${selector}". Did you mean to CSS.escape it?`);
  let pos = 0;
  const names = new Set2();
  function unexpected() {
    return new InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing css selector "${selector}". Did you mean to CSS.escape it?`);
  }
  __name(unexpected, "unexpected");
  function skipWhitespace() {
    while (tokens[pos] instanceof WhitespaceToken)
      pos++;
  }
  __name(skipWhitespace, "skipWhitespace");
  function isIdent(p = pos) {
    return tokens[p] instanceof IdentToken;
  }
  __name(isIdent, "isIdent");
  function isString3(p = pos) {
    return tokens[p] instanceof StringToken;
  }
  __name(isString3, "isString");
  function isNumber2(p = pos) {
    return tokens[p] instanceof NumberToken;
  }
  __name(isNumber2, "isNumber");
  function isComma(p = pos) {
    return tokens[p] instanceof CommaToken;
  }
  __name(isComma, "isComma");
  function isOpenParen(p = pos) {
    return tokens[p] instanceof OpenParenToken;
  }
  __name(isOpenParen, "isOpenParen");
  function isCloseParen(p = pos) {
    return tokens[p] instanceof CloseParenToken;
  }
  __name(isCloseParen, "isCloseParen");
  function isFunction2(p = pos) {
    return tokens[p] instanceof FunctionToken;
  }
  __name(isFunction2, "isFunction");
  function isStar(p = pos) {
    return tokens[p] instanceof DelimToken && tokens[p].value === "*";
  }
  __name(isStar, "isStar");
  function isEOF(p = pos) {
    return tokens[p] instanceof EOFToken;
  }
  __name(isEOF, "isEOF");
  function isClauseCombinator(p = pos) {
    return tokens[p] instanceof DelimToken && [">", "+", "~"].includes(tokens[p].value);
  }
  __name(isClauseCombinator, "isClauseCombinator");
  function isSelectorClauseEnd(p = pos) {
    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;
  }
  __name(isSelectorClauseEnd, "isSelectorClauseEnd");
  function consumeFunctionArguments() {
    const result2 = [consumeArgument()];
    while (true) {
      skipWhitespace();
      if (!isComma())
        break;
      pos++;
      result2.push(consumeArgument());
    }
    return result2;
  }
  __name(consumeFunctionArguments, "consumeFunctionArguments");
  function consumeArgument() {
    skipWhitespace();
    if (isNumber2())
      return tokens[pos++].value;
    if (isString3())
      return tokens[pos++].value;
    return consumeComplexSelector();
  }
  __name(consumeArgument, "consumeArgument");
  function consumeComplexSelector() {
    const result2 = { simples: [] };
    skipWhitespace();
    if (isClauseCombinator()) {
      result2.simples.push({ selector: { functions: [{ name: "scope", args: [] }] }, combinator: "" });
    } else {
      result2.simples.push({ selector: consumeSimpleSelector(), combinator: "" });
    }
    while (true) {
      skipWhitespace();
      if (isClauseCombinator()) {
        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;
        skipWhitespace();
      } else if (isSelectorClauseEnd()) {
        break;
      }
      result2.simples.push({ combinator: "", selector: consumeSimpleSelector() });
    }
    return result2;
  }
  __name(consumeComplexSelector, "consumeComplexSelector");
  function consumeSimpleSelector() {
    let rawCSSString = "";
    const functions = [];
    while (!isSelectorClauseEnd()) {
      if (isIdent() || isStar()) {
        rawCSSString += tokens[pos++].toSource();
      } else if (tokens[pos] instanceof HashToken) {
        rawCSSString += tokens[pos++].toSource();
      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === ".") {
        pos++;
        if (isIdent())
          rawCSSString += "." + tokens[pos++].toSource();
        else
          throw unexpected();
      } else if (tokens[pos] instanceof ColonToken) {
        pos++;
        if (isIdent()) {
          if (!customNames.has(tokens[pos].value.toLowerCase())) {
            rawCSSString += ":" + tokens[pos++].toSource();
          } else {
            const name = tokens[pos++].value.toLowerCase();
            functions.push({ name, args: [] });
            names.add(name);
          }
        } else if (isFunction2()) {
          const name = tokens[pos++].value.toLowerCase();
          if (!customNames.has(name)) {
            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;
          } else {
            functions.push({ name, args: consumeFunctionArguments() });
            names.add(name);
          }
          skipWhitespace();
          if (!isCloseParen())
            throw unexpected();
          pos++;
        } else {
          throw unexpected();
        }
      } else if (tokens[pos] instanceof OpenSquareToken) {
        rawCSSString += "[";
        pos++;
        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())
          rawCSSString += tokens[pos++].toSource();
        if (!(tokens[pos] instanceof CloseSquareToken))
          throw unexpected();
        rawCSSString += "]";
        pos++;
      } else {
        throw unexpected();
      }
    }
    if (!rawCSSString && !functions.length)
      throw unexpected();
    return { css: rawCSSString || void 0, functions };
  }
  __name(consumeSimpleSelector, "consumeSimpleSelector");
  function consumeBuiltinFunctionArguments() {
    let s = "";
    let balance = 1;
    while (!isEOF()) {
      if (isOpenParen() || isFunction2())
        balance++;
      if (isCloseParen())
        balance--;
      if (!balance)
        break;
      s += tokens[pos++].toSource();
    }
    return s;
  }
  __name(consumeBuiltinFunctionArguments, "consumeBuiltinFunctionArguments");
  const result = consumeFunctionArguments();
  if (!isEOF())
    throw unexpected();
  if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))
    throw new InvalidSelectorError(`Error while parsing css selector "${selector}". Did you mean to CSS.escape it?`);
  return { selector: result, names: Array.from(names) };
}
__name(parseCSS, "parseCSS");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/selectorParser.js
var kNestedSelectorNames = new Set2(["internal:has", "internal:has-not", "internal:and", "internal:or", "internal:chain", "left-of", "right-of", "above", "below", "near"]);
var kNestedSelectorNamesWithDistance = new Set2(["left-of", "right-of", "above", "below", "near"]);
var customCSSNames = new Set2(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);
function parseSelector(selector) {
  const parsedStrings = parseSelectorString(selector);
  const parts = [];
  for (const part of parsedStrings.parts) {
    if (part.name === "css" || part.name === "css:light") {
      if (part.name === "css:light")
        part.body = ":light(" + part.body + ")";
      const parsedCSS = parseCSS(part.body, customCSSNames);
      parts.push({
        name: "css",
        body: parsedCSS.selector,
        source: part.body
      });
      continue;
    }
    if (kNestedSelectorNames.has(part.name)) {
      let innerSelector;
      let distance;
      try {
        const unescaped = JSON.parse("[" + part.body + "]");
        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== "string")
          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);
        innerSelector = unescaped[0];
        if (unescaped.length === 2) {
          if (typeof unescaped[1] !== "number" || !kNestedSelectorNamesWithDistance.has(part.name))
            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);
          distance = unescaped[1];
        }
      } catch (e) {
        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);
      }
      const nested = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };
      const lastFrame = [...nested.body.parsed.parts].reverse().find((part2) => part2.name === "internal:control" && part2.body === "enter-frame");
      const lastFrameIndex = lastFrame ? nested.body.parsed.parts.indexOf(lastFrame) : -1;
      if (lastFrameIndex !== -1 && selectorPartsEqual(nested.body.parsed.parts.slice(0, lastFrameIndex + 1), parts.slice(0, lastFrameIndex + 1)))
        nested.body.parsed.parts.splice(0, lastFrameIndex + 1);
      parts.push(nested);
      continue;
    }
    parts.push({ ...part, source: part.body });
  }
  if (kNestedSelectorNames.has(parts[0].name))
    throw new InvalidSelectorError(`"${parts[0].name}" selector cannot be first`);
  return {
    capture: parsedStrings.capture,
    parts
  };
}
__name(parseSelector, "parseSelector");
function splitSelectorByFrame(selectorText) {
  const selector = parseSelector(selectorText);
  const result = [];
  let chunk = {
    parts: []
  };
  let chunkStartIndex = 0;
  for (let i = 0; i < selector.parts.length; ++i) {
    const part = selector.parts[i];
    if (part.name === "internal:control" && part.body === "enter-frame") {
      if (!chunk.parts.length)
        throw new InvalidSelectorError("Selector cannot start with entering frame, select the iframe first");
      result.push(chunk);
      chunk = { parts: [] };
      chunkStartIndex = i + 1;
      continue;
    }
    if (selector.capture === i)
      chunk.capture = i - chunkStartIndex;
    chunk.parts.push(part);
  }
  if (!chunk.parts.length)
    throw new InvalidSelectorError(`Selector cannot end with entering frame, while parsing selector ${selectorText}`);
  result.push(chunk);
  if (typeof selector.capture === "number" && typeof result[result.length - 1].capture !== "number")
    throw new InvalidSelectorError(`Can not capture the selector before diving into the frame. Only use * after the last frame has been selected`);
  return result;
}
__name(splitSelectorByFrame, "splitSelectorByFrame");
function selectorPartsEqual(list1, list2) {
  return stringifySelector({ parts: list1 }) === stringifySelector({ parts: list2 });
}
__name(selectorPartsEqual, "selectorPartsEqual");
function stringifySelector(selector, forceEngineName) {
  if (typeof selector === "string")
    return selector;
  return selector.parts.map((p, i) => {
    let includeEngine = true;
    if (!forceEngineName && i !== selector.capture) {
      if (p.name === "css")
        includeEngine = false;
      else if (p.name === "xpath" && p.source.startsWith("//") || p.source.startsWith(".."))
        includeEngine = false;
    }
    const prefix = includeEngine ? p.name + "=" : "";
    return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;
  }).join(" >> ");
}
__name(stringifySelector, "stringifySelector");
function visitAllSelectorParts(selector, visitor) {
  const visit2 = /* @__PURE__ */ __name((selector2, nested) => {
    for (const part of selector2.parts) {
      visitor(part, nested);
      if (kNestedSelectorNames.has(part.name))
        visit2(part.body.parsed, true);
    }
  }, "visit");
  visit2(selector, false);
}
__name(visitAllSelectorParts, "visitAllSelectorParts");
function parseSelectorString(selector) {
  let index2 = 0;
  let quote5;
  let start = 0;
  const result = { parts: [] };
  const append = /* @__PURE__ */ __name(() => {
    const part = selector.substring(start, index2).trim();
    const eqIndex = part.indexOf("=");
    let name;
    let body;
    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
      name = part.substring(0, eqIndex).trim();
      body = part.substring(eqIndex + 1);
    } else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
      name = "text";
      body = part;
    } else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
      name = "text";
      body = part;
    } else if (/^\(*\/\//.test(part) || part.startsWith("..")) {
      name = "xpath";
      body = part;
    } else {
      name = "css";
      body = part;
    }
    let capture = false;
    if (name[0] === "*") {
      capture = true;
      name = name.substring(1);
    }
    result.parts.push({ name, body });
    if (capture) {
      if (result.capture !== void 0)
        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);
      result.capture = result.parts.length - 1;
    }
  }, "append");
  if (!selector.includes(">>")) {
    index2 = selector.length;
    append();
    return result;
  }
  const shouldIgnoreTextSelectorQuote = /* @__PURE__ */ __name(() => {
    const prefix = selector.substring(start, index2);
    const match = prefix.match(/^\s*text\s*=(.*)$/);
    return !!match && !!match[1];
  }, "shouldIgnoreTextSelectorQuote");
  while (index2 < selector.length) {
    const c = selector[index2];
    if (c === "\\" && index2 + 1 < selector.length) {
      index2 += 2;
    } else if (c === quote5) {
      quote5 = void 0;
      index2++;
    } else if (!quote5 && (c === '"' || c === "'" || c === "`") && !shouldIgnoreTextSelectorQuote()) {
      quote5 = c;
      index2++;
    } else if (!quote5 && c === ">" && selector[index2 + 1] === ">") {
      append();
      index2 += 2;
      start = index2;
    } else {
      index2++;
    }
  }
  append();
  return result;
}
__name(parseSelectorString, "parseSelectorString");
function parseAttributeSelector(selector, allowUnquotedStrings) {
  let wp = 0;
  let EOL2 = selector.length === 0;
  const next = /* @__PURE__ */ __name(() => selector[wp] || "", "next");
  const eat1 = /* @__PURE__ */ __name(() => {
    const result2 = next();
    ++wp;
    EOL2 = wp >= selector.length;
    return result2;
  }, "eat1");
  const syntaxError = /* @__PURE__ */ __name((stage) => {
    if (EOL2)
      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \`${selector}\``);
    throw new InvalidSelectorError(`Error while parsing selector \`${selector}\` - unexpected symbol "${next()}" at position ${wp}` + (stage ? " during " + stage : ""));
  }, "syntaxError");
  function skipSpaces() {
    while (!EOL2 && /\s/.test(next()))
      eat1();
  }
  __name(skipSpaces, "skipSpaces");
  function isCSSNameChar(char) {
    return char >= "\x80" || char >= "0" && char <= "9" || char >= "A" && char <= "Z" || char >= "a" && char <= "z" || char >= "0" && char <= "9" || char === "_" || char === "-";
  }
  __name(isCSSNameChar, "isCSSNameChar");
  function readIdentifier() {
    let result2 = "";
    skipSpaces();
    while (!EOL2 && isCSSNameChar(next()))
      result2 += eat1();
    return result2;
  }
  __name(readIdentifier, "readIdentifier");
  function readQuotedString(quote5) {
    let result2 = eat1();
    if (result2 !== quote5)
      syntaxError("parsing quoted string");
    while (!EOL2 && next() !== quote5) {
      if (next() === "\\")
        eat1();
      result2 += eat1();
    }
    if (next() !== quote5)
      syntaxError("parsing quoted string");
    result2 += eat1();
    return result2;
  }
  __name(readQuotedString, "readQuotedString");
  function readRegularExpression() {
    if (eat1() !== "/")
      syntaxError("parsing regular expression");
    let source7 = "";
    let inClass = false;
    while (!EOL2) {
      if (next() === "\\") {
        source7 += eat1();
        if (EOL2)
          syntaxError("parsing regular expression");
      } else if (inClass && next() === "]") {
        inClass = false;
      } else if (!inClass && next() === "[") {
        inClass = true;
      } else if (!inClass && next() === "/") {
        break;
      }
      source7 += eat1();
    }
    if (eat1() !== "/")
      syntaxError("parsing regular expression");
    let flags = "";
    while (!EOL2 && next().match(/[dgimsuy]/))
      flags += eat1();
    try {
      return new RegExp(source7, flags);
    } catch (e) {
      throw new InvalidSelectorError(`Error while parsing selector \`${selector}\`: ${e.message}`);
    }
  }
  __name(readRegularExpression, "readRegularExpression");
  function readAttributeToken() {
    let token = "";
    skipSpaces();
    if (next() === `'` || next() === `"`)
      token = readQuotedString(next()).slice(1, -1);
    else
      token = readIdentifier();
    if (!token)
      syntaxError("parsing property path");
    return token;
  }
  __name(readAttributeToken, "readAttributeToken");
  function readOperator() {
    skipSpaces();
    let op = "";
    if (!EOL2)
      op += eat1();
    if (!EOL2 && op !== "=")
      op += eat1();
    if (!["=", "*=", "^=", "$=", "|=", "~="].includes(op))
      syntaxError("parsing operator");
    return op;
  }
  __name(readOperator, "readOperator");
  function readAttribute() {
    eat1();
    const jsonPath = [];
    jsonPath.push(readAttributeToken());
    skipSpaces();
    while (next() === ".") {
      eat1();
      jsonPath.push(readAttributeToken());
      skipSpaces();
    }
    if (next() === "]") {
      eat1();
      return { name: jsonPath.join("."), jsonPath, op: "<truthy>", value: null, caseSensitive: false };
    }
    const operator = readOperator();
    let value = void 0;
    let caseSensitive = true;
    skipSpaces();
    if (next() === "/") {
      if (operator !== "=")
        throw new InvalidSelectorError(`Error while parsing selector \`${selector}\` - cannot use ${operator} in attribute with regular expression`);
      value = readRegularExpression();
    } else if (next() === `'` || next() === `"`) {
      value = readQuotedString(next()).slice(1, -1);
      skipSpaces();
      if (next() === "i" || next() === "I") {
        caseSensitive = false;
        eat1();
      } else if (next() === "s" || next() === "S") {
        caseSensitive = true;
        eat1();
      }
    } else {
      value = "";
      while (!EOL2 && (isCSSNameChar(next()) || next() === "+" || next() === "."))
        value += eat1();
      if (value === "true") {
        value = true;
      } else if (value === "false") {
        value = false;
      } else ;
    }
    skipSpaces();
    if (next() !== "]")
      syntaxError("parsing attribute value");
    eat1();
    if (operator !== "=" && typeof value !== "string")
      throw new InvalidSelectorError(`Error while parsing selector \`${selector}\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);
    return { name: jsonPath.join("."), jsonPath, op: operator, value, caseSensitive };
  }
  __name(readAttribute, "readAttribute");
  const result = {
    name: "",
    attributes: []
  };
  result.name = readIdentifier();
  skipSpaces();
  while (next() === "[") {
    result.attributes.push(readAttribute());
    skipSpaces();
  }
  if (!EOL2)
    syntaxError(void 0);
  if (!result.name && !result.attributes.length)
    throw new InvalidSelectorError(`Error while parsing selector \`${selector}\` - selector cannot be empty`);
  return result;
}
__name(parseAttributeSelector, "parseAttributeSelector");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/mimeType.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isTextualMimeType(mimeType) {
  return !!mimeType.match(/^(text\/.*?|application\/(json|(x-)?javascript|xml.*?|ecmascript|graphql|x-www-form-urlencoded)|image\/svg(\+xml)?|application\/.*?(\+json|\+xml))(;\s*charset=.*)?$/);
}
__name(isTextualMimeType, "isTextualMimeType");
function getMimeTypeForPath(path31) {
  const dotIndex = path31.lastIndexOf(".");
  if (dotIndex === -1)
    return null;
  const extension = path31.substring(dotIndex + 1);
  return types3.get(extension) || null;
}
__name(getMimeTypeForPath, "getMimeTypeForPath");
var types3 = new Map2([
  ["ez", "application/andrew-inset"],
  ["aw", "application/applixware"],
  ["atom", "application/atom+xml"],
  ["atomcat", "application/atomcat+xml"],
  ["atomdeleted", "application/atomdeleted+xml"],
  ["atomsvc", "application/atomsvc+xml"],
  ["dwd", "application/atsc-dwd+xml"],
  ["held", "application/atsc-held+xml"],
  ["rsat", "application/atsc-rsat+xml"],
  ["bdoc", "application/bdoc"],
  ["xcs", "application/calendar+xml"],
  ["ccxml", "application/ccxml+xml"],
  ["cdfx", "application/cdfx+xml"],
  ["cdmia", "application/cdmi-capability"],
  ["cdmic", "application/cdmi-container"],
  ["cdmid", "application/cdmi-domain"],
  ["cdmio", "application/cdmi-object"],
  ["cdmiq", "application/cdmi-queue"],
  ["cu", "application/cu-seeme"],
  ["mpd", "application/dash+xml"],
  ["davmount", "application/davmount+xml"],
  ["dbk", "application/docbook+xml"],
  ["dssc", "application/dssc+der"],
  ["xdssc", "application/dssc+xml"],
  ["ecma", "application/ecmascript"],
  ["es", "application/ecmascript"],
  ["emma", "application/emma+xml"],
  ["emotionml", "application/emotionml+xml"],
  ["epub", "application/epub+zip"],
  ["exi", "application/exi"],
  ["exp", "application/express"],
  ["fdt", "application/fdt+xml"],
  ["pfr", "application/font-tdpfr"],
  ["geojson", "application/geo+json"],
  ["gml", "application/gml+xml"],
  ["gpx", "application/gpx+xml"],
  ["gxf", "application/gxf"],
  ["gz", "application/gzip"],
  ["hjson", "application/hjson"],
  ["stk", "application/hyperstudio"],
  ["ink", "application/inkml+xml"],
  ["inkml", "application/inkml+xml"],
  ["ipfix", "application/ipfix"],
  ["its", "application/its+xml"],
  ["ear", "application/java-archive"],
  ["jar", "application/java-archive"],
  ["war", "application/java-archive"],
  ["ser", "application/java-serialized-object"],
  ["class", "application/java-vm"],
  ["js", "application/javascript"],
  ["mjs", "application/javascript"],
  ["json", "application/json"],
  ["map", "application/json"],
  ["json5", "application/json5"],
  ["jsonml", "application/jsonml+json"],
  ["jsonld", "application/ld+json"],
  ["lgr", "application/lgr+xml"],
  ["lostxml", "application/lost+xml"],
  ["hqx", "application/mac-binhex40"],
  ["cpt", "application/mac-compactpro"],
  ["mads", "application/mads+xml"],
  ["webmanifest", "application/manifest+json"],
  ["mrc", "application/marc"],
  ["mrcx", "application/marcxml+xml"],
  ["ma", "application/mathematica"],
  ["mb", "application/mathematica"],
  ["nb", "application/mathematica"],
  ["mathml", "application/mathml+xml"],
  ["mbox", "application/mbox"],
  ["mscml", "application/mediaservercontrol+xml"],
  ["metalink", "application/metalink+xml"],
  ["meta4", "application/metalink4+xml"],
  ["mets", "application/mets+xml"],
  ["maei", "application/mmt-aei+xml"],
  ["musd", "application/mmt-usd+xml"],
  ["mods", "application/mods+xml"],
  ["m21", "application/mp21"],
  ["mp21", "application/mp21"],
  ["m4p", "application/mp4"],
  ["mp4s", "application/mp4"],
  ["doc", "application/msword"],
  ["dot", "application/msword"],
  ["mxf", "application/mxf"],
  ["nq", "application/n-quads"],
  ["nt", "application/n-triples"],
  ["cjs", "application/node"],
  ["bin", "application/octet-stream"],
  ["bpk", "application/octet-stream"],
  ["buffer", "application/octet-stream"],
  ["deb", "application/octet-stream"],
  ["deploy", "application/octet-stream"],
  ["dist", "application/octet-stream"],
  ["distz", "application/octet-stream"],
  ["dll", "application/octet-stream"],
  ["dmg", "application/octet-stream"],
  ["dms", "application/octet-stream"],
  ["dump", "application/octet-stream"],
  ["elc", "application/octet-stream"],
  ["exe", "application/octet-stream"],
  ["img", "application/octet-stream"],
  ["iso", "application/octet-stream"],
  ["lrf", "application/octet-stream"],
  ["mar", "application/octet-stream"],
  ["msi", "application/octet-stream"],
  ["msm", "application/octet-stream"],
  ["msp", "application/octet-stream"],
  ["pkg", "application/octet-stream"],
  ["so", "application/octet-stream"],
  ["oda", "application/oda"],
  ["opf", "application/oebps-package+xml"],
  ["ogx", "application/ogg"],
  ["omdoc", "application/omdoc+xml"],
  ["onepkg", "application/onenote"],
  ["onetmp", "application/onenote"],
  ["onetoc", "application/onenote"],
  ["onetoc2", "application/onenote"],
  ["oxps", "application/oxps"],
  ["relo", "application/p2p-overlay+xml"],
  ["xer", "application/patch-ops-error+xml"],
  ["pdf", "application/pdf"],
  ["pgp", "application/pgp-encrypted"],
  ["asc", "application/pgp-signature"],
  ["sig", "application/pgp-signature"],
  ["prf", "application/pics-rules"],
  ["p10", "application/pkcs10"],
  ["p7c", "application/pkcs7-mime"],
  ["p7m", "application/pkcs7-mime"],
  ["p7s", "application/pkcs7-signature"],
  ["p8", "application/pkcs8"],
  ["ac", "application/pkix-attr-cert"],
  ["cer", "application/pkix-cert"],
  ["crl", "application/pkix-crl"],
  ["pkipath", "application/pkix-pkipath"],
  ["pki", "application/pkixcmp"],
  ["pls", "application/pls+xml"],
  ["ai", "application/postscript"],
  ["eps", "application/postscript"],
  ["ps", "application/postscript"],
  ["provx", "application/provenance+xml"],
  ["pskcxml", "application/pskc+xml"],
  ["raml", "application/raml+yaml"],
  ["owl", "application/rdf+xml"],
  ["rdf", "application/rdf+xml"],
  ["rif", "application/reginfo+xml"],
  ["rnc", "application/relax-ng-compact-syntax"],
  ["rl", "application/resource-lists+xml"],
  ["rld", "application/resource-lists-diff+xml"],
  ["rs", "application/rls-services+xml"],
  ["rapd", "application/route-apd+xml"],
  ["sls", "application/route-s-tsid+xml"],
  ["rusd", "application/route-usd+xml"],
  ["gbr", "application/rpki-ghostbusters"],
  ["mft", "application/rpki-manifest"],
  ["roa", "application/rpki-roa"],
  ["rsd", "application/rsd+xml"],
  ["rss", "application/rss+xml"],
  ["rtf", "application/rtf"],
  ["sbml", "application/sbml+xml"],
  ["scq", "application/scvp-cv-request"],
  ["scs", "application/scvp-cv-response"],
  ["spq", "application/scvp-vp-request"],
  ["spp", "application/scvp-vp-response"],
  ["sdp", "application/sdp"],
  ["senmlx", "application/senml+xml"],
  ["sensmlx", "application/sensml+xml"],
  ["setpay", "application/set-payment-initiation"],
  ["setreg", "application/set-registration-initiation"],
  ["shf", "application/shf+xml"],
  ["sieve", "application/sieve"],
  ["siv", "application/sieve"],
  ["smi", "application/smil+xml"],
  ["smil", "application/smil+xml"],
  ["rq", "application/sparql-query"],
  ["srx", "application/sparql-results+xml"],
  ["gram", "application/srgs"],
  ["grxml", "application/srgs+xml"],
  ["sru", "application/sru+xml"],
  ["ssdl", "application/ssdl+xml"],
  ["ssml", "application/ssml+xml"],
  ["swidtag", "application/swid+xml"],
  ["tei", "application/tei+xml"],
  ["teicorpus", "application/tei+xml"],
  ["tfi", "application/thraud+xml"],
  ["tsd", "application/timestamped-data"],
  ["toml", "application/toml"],
  ["trig", "application/trig"],
  ["ttml", "application/ttml+xml"],
  ["ubj", "application/ubjson"],
  ["rsheet", "application/urc-ressheet+xml"],
  ["td", "application/urc-targetdesc+xml"],
  ["vxml", "application/voicexml+xml"],
  ["wasm", "application/wasm"],
  ["wgt", "application/widget"],
  ["hlp", "application/winhlp"],
  ["wsdl", "application/wsdl+xml"],
  ["wspolicy", "application/wspolicy+xml"],
  ["xaml", "application/xaml+xml"],
  ["xav", "application/xcap-att+xml"],
  ["xca", "application/xcap-caps+xml"],
  ["xdf", "application/xcap-diff+xml"],
  ["xel", "application/xcap-el+xml"],
  ["xns", "application/xcap-ns+xml"],
  ["xenc", "application/xenc+xml"],
  ["xht", "application/xhtml+xml"],
  ["xhtml", "application/xhtml+xml"],
  ["xlf", "application/xliff+xml"],
  ["rng", "application/xml"],
  ["xml", "application/xml"],
  ["xsd", "application/xml"],
  ["xsl", "application/xml"],
  ["dtd", "application/xml-dtd"],
  ["xop", "application/xop+xml"],
  ["xpl", "application/xproc+xml"],
  ["*xsl", "application/xslt+xml"],
  ["xslt", "application/xslt+xml"],
  ["xspf", "application/xspf+xml"],
  ["mxml", "application/xv+xml"],
  ["xhvml", "application/xv+xml"],
  ["xvm", "application/xv+xml"],
  ["xvml", "application/xv+xml"],
  ["yang", "application/yang"],
  ["yin", "application/yin+xml"],
  ["zip", "application/zip"],
  ["*3gpp", "audio/3gpp"],
  ["adp", "audio/adpcm"],
  ["amr", "audio/amr"],
  ["au", "audio/basic"],
  ["snd", "audio/basic"],
  ["kar", "audio/midi"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["rmi", "audio/midi"],
  ["mxmf", "audio/mobile-xmf"],
  ["*mp3", "audio/mp3"],
  ["m4a", "audio/mp4"],
  ["mp4a", "audio/mp4"],
  ["m2a", "audio/mpeg"],
  ["m3a", "audio/mpeg"],
  ["mp2", "audio/mpeg"],
  ["mp2a", "audio/mpeg"],
  ["mp3", "audio/mpeg"],
  ["mpga", "audio/mpeg"],
  ["oga", "audio/ogg"],
  ["ogg", "audio/ogg"],
  ["opus", "audio/ogg"],
  ["spx", "audio/ogg"],
  ["s3m", "audio/s3m"],
  ["sil", "audio/silk"],
  ["wav", "audio/wav"],
  ["*wav", "audio/wave"],
  ["weba", "audio/webm"],
  ["xm", "audio/xm"],
  ["ttc", "font/collection"],
  ["otf", "font/otf"],
  ["ttf", "font/ttf"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["exr", "image/aces"],
  ["apng", "image/apng"],
  ["avif", "image/avif"],
  ["bmp", "image/bmp"],
  ["cgm", "image/cgm"],
  ["drle", "image/dicom-rle"],
  ["emf", "image/emf"],
  ["fits", "image/fits"],
  ["g3", "image/g3fax"],
  ["gif", "image/gif"],
  ["heic", "image/heic"],
  ["heics", "image/heic-sequence"],
  ["heif", "image/heif"],
  ["heifs", "image/heif-sequence"],
  ["hej2", "image/hej2k"],
  ["hsj2", "image/hsj2"],
  ["ief", "image/ief"],
  ["jls", "image/jls"],
  ["jp2", "image/jp2"],
  ["jpg2", "image/jp2"],
  ["jpe", "image/jpeg"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["jph", "image/jph"],
  ["jhc", "image/jphc"],
  ["jpm", "image/jpm"],
  ["jpf", "image/jpx"],
  ["jpx", "image/jpx"],
  ["jxr", "image/jxr"],
  ["jxra", "image/jxra"],
  ["jxrs", "image/jxrs"],
  ["jxs", "image/jxs"],
  ["jxsc", "image/jxsc"],
  ["jxsi", "image/jxsi"],
  ["jxss", "image/jxss"],
  ["ktx", "image/ktx"],
  ["ktx2", "image/ktx2"],
  ["png", "image/png"],
  ["sgi", "image/sgi"],
  ["svg", "image/svg+xml"],
  ["svgz", "image/svg+xml"],
  ["t38", "image/t38"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["tfx", "image/tiff-fx"],
  ["webp", "image/webp"],
  ["wmf", "image/wmf"],
  ["disposition-notification", "message/disposition-notification"],
  ["u8msg", "message/global"],
  ["u8dsn", "message/global-delivery-status"],
  ["u8mdn", "message/global-disposition-notification"],
  ["u8hdr", "message/global-headers"],
  ["eml", "message/rfc822"],
  ["mime", "message/rfc822"],
  ["3mf", "model/3mf"],
  ["gltf", "model/gltf+json"],
  ["glb", "model/gltf-binary"],
  ["iges", "model/iges"],
  ["igs", "model/iges"],
  ["mesh", "model/mesh"],
  ["msh", "model/mesh"],
  ["silo", "model/mesh"],
  ["mtl", "model/mtl"],
  ["obj", "model/obj"],
  ["stpx", "model/step+xml"],
  ["stpz", "model/step+zip"],
  ["stpxz", "model/step-xml+zip"],
  ["stl", "model/stl"],
  ["vrml", "model/vrml"],
  ["wrl", "model/vrml"],
  ["*x3db", "model/x3d+binary"],
  ["x3dbz", "model/x3d+binary"],
  ["x3db", "model/x3d+fastinfoset"],
  ["*x3dv", "model/x3d+vrml"],
  ["x3dvz", "model/x3d+vrml"],
  ["x3d", "model/x3d+xml"],
  ["x3dz", "model/x3d+xml"],
  ["x3dv", "model/x3d-vrml"],
  ["appcache", "text/cache-manifest"],
  ["manifest", "text/cache-manifest"],
  ["ics", "text/calendar"],
  ["ifb", "text/calendar"],
  ["coffee", "text/coffeescript"],
  ["litcoffee", "text/coffeescript"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["shtml", "text/html"],
  ["jade", "text/jade"],
  ["jsx", "text/jsx"],
  ["less", "text/less"],
  ["markdown", "text/markdown"],
  ["md", "text/markdown"],
  ["mml", "text/mathml"],
  ["mdx", "text/mdx"],
  ["n3", "text/n3"],
  ["conf", "text/plain"],
  ["def", "text/plain"],
  ["in", "text/plain"],
  ["ini", "text/plain"],
  ["list", "text/plain"],
  ["log", "text/plain"],
  ["text", "text/plain"],
  ["txt", "text/plain"],
  ["rtx", "text/richtext"],
  ["*rtf", "text/rtf"],
  ["sgm", "text/sgml"],
  ["sgml", "text/sgml"],
  ["shex", "text/shex"],
  ["slim", "text/slim"],
  ["slm", "text/slim"],
  ["spdx", "text/spdx"],
  ["styl", "text/stylus"],
  ["stylus", "text/stylus"],
  ["tsv", "text/tab-separated-values"],
  ["man", "text/troff"],
  ["me", "text/troff"],
  ["ms", "text/troff"],
  ["roff", "text/troff"],
  ["t", "text/troff"],
  ["tr", "text/troff"],
  ["ttl", "text/turtle"],
  ["uri", "text/uri-list"],
  ["uris", "text/uri-list"],
  ["urls", "text/uri-list"],
  ["vcard", "text/vcard"],
  ["vtt", "text/vtt"],
  ["*xml", "text/xml"],
  ["yaml", "text/yaml"],
  ["yml", "text/yaml"],
  ["3gp", "video/3gpp"],
  ["3gpp", "video/3gpp"],
  ["3g2", "video/3gpp2"],
  ["h261", "video/h261"],
  ["h263", "video/h263"],
  ["h264", "video/h264"],
  ["m4s", "video/iso.segment"],
  ["jpgv", "video/jpeg"],
  ["jpm", "video/jpm"],
  ["jpgm", "video/jpm"],
  ["mj2", "video/mj2"],
  ["mjp2", "video/mj2"],
  ["ts", "video/mp2t"],
  ["mp4", "video/mp4"],
  ["mp4v", "video/mp4"],
  ["mpg4", "video/mp4"],
  ["m1v", "video/mpeg"],
  ["m2v", "video/mpeg"],
  ["mpe", "video/mpeg"],
  ["mpeg", "video/mpeg"],
  ["mpg", "video/mpeg"],
  ["ogv", "video/ogg"],
  ["mov", "video/quicktime"],
  ["qt", "video/quicktime"],
  ["webm", "video/webm"]
]);

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/urlMatch.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/stringUtils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function escapeWithQuotes(text, char = "'") {
  const stringified = JSON.stringify(text);
  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\"/g, '"');
  if (char === "'")
    return char + escapedText.replace(/[']/g, "\\'") + char;
  if (char === '"')
    return char + escapedText.replace(/["]/g, '\\"') + char;
  if (char === "`")
    return char + escapedText.replace(/[`]/g, "`") + char;
  throw new Error("Invalid escape char");
}
__name(escapeWithQuotes, "escapeWithQuotes");
function isString2(obj) {
  return typeof obj === "string" || obj instanceof String;
}
__name(isString2, "isString");
function toTitleCase(name) {
  return name.charAt(0).toUpperCase() + name.substring(1);
}
__name(toTitleCase, "toTitleCase");
function toSnakeCase(name) {
  return name.replace(/([a-z0-9])([A-Z])/g, "$1_$2").replace(/([A-Z])([A-Z][a-z])/g, "$1_$2").toLowerCase();
}
__name(toSnakeCase, "toSnakeCase");
function cssEscape(s) {
  let result = "";
  for (let i = 0; i < s.length; i++)
    result += cssEscapeOne(s, i);
  return result;
}
__name(cssEscape, "cssEscape");
function quoteCSSAttributeValue(text) {
  return `"${cssEscape(text).replace(/\\ /g, " ")}"`;
}
__name(quoteCSSAttributeValue, "quoteCSSAttributeValue");
function cssEscapeOne(s, i) {
  const c = s.charCodeAt(i);
  if (c === 0)
    return "\uFFFD";
  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))
    return "\\" + c.toString(16) + " ";
  if (i === 0 && c === 45 && s.length === 1)
    return "\\" + s.charAt(i);
  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)
    return s.charAt(i);
  return "\\" + s.charAt(i);
}
__name(cssEscapeOne, "cssEscapeOne");
function normalizeEscapedRegexQuotes(source7) {
  return source7.replace(/(^|[^\\])(\\\\)*\\(['"`])/g, "$1$2$3");
}
__name(normalizeEscapedRegexQuotes, "normalizeEscapedRegexQuotes");
function escapeRegexForSelector(re2) {
  if (re2.unicode || re2.unicodeSets)
    return String(re2);
  return String(re2).replace(/(^|[^\\])(\\\\)*(["'`])/g, "$1$2\\$3").replace(/>>/g, "\\>\\>");
}
__name(escapeRegexForSelector, "escapeRegexForSelector");
function escapeForTextSelector(text, exact) {
  if (typeof text !== "string")
    return escapeRegexForSelector(text);
  return `${JSON.stringify(text)}${exact ? "s" : "i"}`;
}
__name(escapeForTextSelector, "escapeForTextSelector");
function escapeForAttributeSelector(value, exact) {
  if (typeof value !== "string")
    return escapeRegexForSelector(value);
  return `"${value.replace(/\\/g, "\\\\").replace(/["]/g, '\\"')}"${exact ? "s" : "i"}`;
}
__name(escapeForAttributeSelector, "escapeForAttributeSelector");
function trimString(input, cap, suffix = "") {
  if (input.length <= cap)
    return input;
  const chars = [...input];
  if (chars.length > cap)
    return chars.slice(0, cap - suffix.length).join("") + suffix;
  return chars.join("");
}
__name(trimString, "trimString");
function trimStringWithEllipsis(input, cap) {
  return trimString(input, cap, "\u2026");
}
__name(trimStringWithEllipsis, "trimStringWithEllipsis");
var escaped = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
function escapeHTML2(s) {
  return s.replace(/[&<]/ug, (char) => escaped[char]);
}
__name(escapeHTML2, "escapeHTML");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/urlMatch.js
var escapedChars = new Set2(["$", "^", "+", ".", "*", "(", ")", "|", "\\", "?", "{", "}", "[", "]"]);
function globToRegexPattern(glob) {
  const tokens = ["^"];
  let inGroup = false;
  for (let i = 0; i < glob.length; ++i) {
    const c = glob[i];
    if (c === "\\" && i + 1 < glob.length) {
      const char = glob[++i];
      tokens.push(escapedChars.has(char) ? "\\" + char : char);
      continue;
    }
    if (c === "*") {
      const beforeDeep = glob[i - 1];
      let starCount = 1;
      while (glob[i + 1] === "*") {
        starCount++;
        i++;
      }
      const afterDeep = glob[i + 1];
      const isDeep = starCount > 1 && (beforeDeep === "/" || beforeDeep === void 0) && (afterDeep === "/" || afterDeep === void 0);
      if (isDeep) {
        tokens.push("((?:[^/]*(?:/|$))*)");
        i++;
      } else {
        tokens.push("([^/]*)");
      }
      continue;
    }
    switch (c) {
      case "{":
        inGroup = true;
        tokens.push("(");
        break;
      case "}":
        inGroup = false;
        tokens.push(")");
        break;
      case ",":
        if (inGroup) {
          tokens.push("|");
          break;
        }
        tokens.push("\\" + c);
        break;
      default:
        tokens.push(escapedChars.has(c) ? "\\" + c : c);
    }
  }
  tokens.push("$");
  return tokens.join("");
}
__name(globToRegexPattern, "globToRegexPattern");
function isRegExp2(obj) {
  return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp2, "isRegExp");
function urlMatchesEqual(match1, match2) {
  if (isRegExp2(match1) && isRegExp2(match2))
    return match1.source === match2.source && match1.flags === match2.flags;
  return match1 === match2;
}
__name(urlMatchesEqual, "urlMatchesEqual");
function urlMatches(baseURL, urlString, match, webSocketUrl) {
  if (match === void 0 || match === "")
    return true;
  if (isString2(match))
    match = new RegExp(resolveGlobToRegexPattern(baseURL, match, webSocketUrl));
  if (isRegExp2(match)) {
    const r = match.test(urlString);
    return r;
  }
  const url4 = parseURL(urlString);
  if (!url4)
    return false;
  if (typeof match !== "function")
    throw new Error("url parameter should be string, RegExp or function");
  return match(url4);
}
__name(urlMatches, "urlMatches");
function resolveGlobToRegexPattern(baseURL, glob, webSocketUrl) {
  if (webSocketUrl)
    baseURL = toWebSocketBaseUrl(baseURL);
  glob = resolveGlobBase(baseURL, glob);
  return globToRegexPattern(glob);
}
__name(resolveGlobToRegexPattern, "resolveGlobToRegexPattern");
function toWebSocketBaseUrl(baseURL) {
  if (baseURL && /^https?:\/\//.test(baseURL))
    baseURL = baseURL.replace(/^http/, "ws");
  return baseURL;
}
__name(toWebSocketBaseUrl, "toWebSocketBaseUrl");
function resolveGlobBase(baseURL, match) {
  if (!match.startsWith("*")) {
    let mapToken = /* @__PURE__ */ __name(function(original, replacement) {
      if (original.length === 0)
        return "";
      tokenMap.set(replacement, original);
      return replacement;
    }, "mapToken");
    const tokenMap = new Map2();
    match = match.replaceAll(/\\\\\?/g, "?");
    const relativePath = match.split("/").map((token, index2) => {
      if (token === "." || token === ".." || token === "")
        return token;
      if (index2 === 0 && token.endsWith(":"))
        return mapToken(token, "http:");
      const questionIndex = token.indexOf("?");
      if (questionIndex === -1)
        return mapToken(token, `$_${index2}_$`);
      const newPrefix = mapToken(token.substring(0, questionIndex), `$_${index2}_$`);
      const newSuffix = mapToken(token.substring(questionIndex), `?$_${index2}_$`);
      return newPrefix + newSuffix;
    }).join("/");
    let resolved = constructURLBasedOnBaseURL(baseURL, relativePath);
    for (const [token, original] of tokenMap)
      resolved = resolved.replace(token, original);
    match = resolved;
  }
  return match;
}
__name(resolveGlobBase, "resolveGlobBase");
function parseURL(url4) {
  try {
    return new URL(url4);
  } catch (e) {
    return null;
  }
}
__name(parseURL, "parseURL");
function constructURLBasedOnBaseURL(baseURL, givenURL) {
  try {
    return new URL(givenURL, baseURL).toString();
  } catch (e) {
    return givenURL;
  }
}
__name(constructURLBasedOnBaseURL, "constructURLBasedOnBaseURL");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/_virtual/pixelmatch.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/third_party/pixelmatch.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var pixelmatch_1;
var hasRequiredPixelmatch;
function requirePixelmatch() {
  if (hasRequiredPixelmatch) return pixelmatch_1;
  hasRequiredPixelmatch = 1;
  pixelmatch_1 = pixelmatch2;
  const defaultOptions = {
    threshold: 0.1,
    // matching threshold (0 to 1); smaller is more sensitive
    includeAA: false,
    // whether to skip anti-aliasing detection
    alpha: 0.1,
    // opacity of original image in diff output
    aaColor: [255, 255, 0],
    // color of anti-aliased pixels in diff output
    diffColor: [255, 0, 0],
    // color of different pixels in diff output
    diffColorAlt: null,
    // whether to detect dark on light differences between img1 and img2 and set an alternative color to differentiate between the two
    diffMask: false
    // draw the diff over a transparent background (a mask)
  };
  function pixelmatch2(img1, img2, output, width, height, options2) {
    if (!isPixelData(img1) || !isPixelData(img2) || output && !isPixelData(output))
      throw new Error("Image data: Uint8Array, Uint8ClampedArray or Buffer expected.");
    if (img1.length !== img2.length || output && output.length !== img1.length)
      throw new Error("Image sizes do not match.");
    if (img1.length !== width * height * 4) throw new Error("Image data size does not match width/height.");
    options2 = Object.assign({}, defaultOptions, options2);
    const len = width * height;
    const a32 = new Uint32Array(img1.buffer, img1.byteOffset, len);
    const b32 = new Uint32Array(img2.buffer, img2.byteOffset, len);
    let identical = true;
    for (let i = 0; i < len; i++) {
      if (a32[i] !== b32[i]) {
        identical = false;
        break;
      }
    }
    if (identical) {
      if (output && !options2.diffMask) {
        for (let i = 0; i < len; i++) drawGrayPixel(img1, 4 * i, options2.alpha, output);
      }
      return 0;
    }
    const maxDelta = 35215 * options2.threshold * options2.threshold;
    let diff4 = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const pos = (y * width + x) * 4;
        const delta = colorDelta(img1, img2, pos, pos);
        if (Math.abs(delta) > maxDelta) {
          if (!options2.includeAA && (antialiased(img1, x, y, width, height, img2) || antialiased(img2, x, y, width, height, img1))) {
            if (output && !options2.diffMask) drawPixel2(output, pos, ...options2.aaColor);
          } else {
            if (output) {
              drawPixel2(output, pos, ...delta < 0 && options2.diffColorAlt || options2.diffColor);
            }
            diff4++;
          }
        } else if (output) {
          if (!options2.diffMask) drawGrayPixel(img1, pos, options2.alpha, output);
        }
      }
    }
    return diff4;
  }
  __name(pixelmatch2, "pixelmatch");
  function isPixelData(arr) {
    return ArrayBuffer.isView(arr) && arr.constructor.BYTES_PER_ELEMENT === 1;
  }
  __name(isPixelData, "isPixelData");
  function antialiased(img, x1, y1, width, height, img2) {
    const x0 = Math.max(x1 - 1, 0);
    const y0 = Math.max(y1 - 1, 0);
    const x2 = Math.min(x1 + 1, width - 1);
    const y2 = Math.min(y1 + 1, height - 1);
    const pos = (y1 * width + x1) * 4;
    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;
    let min = 0;
    let max = 0;
    let minX, minY, maxX, maxY;
    for (let x = x0; x <= x2; x++) {
      for (let y = y0; y <= y2; y++) {
        if (x === x1 && y === y1) continue;
        const delta = colorDelta(img, img, pos, (y * width + x) * 4, true);
        if (delta === 0) {
          zeroes++;
          if (zeroes > 2) return false;
        } else if (delta < min) {
          min = delta;
          minX = x;
          minY = y;
        } else if (delta > max) {
          max = delta;
          maxX = x;
          maxY = y;
        }
      }
    }
    if (min === 0 || max === 0) return false;
    return hasManySiblings(img, minX, minY, width, height) && hasManySiblings(img2, minX, minY, width, height) || hasManySiblings(img, maxX, maxY, width, height) && hasManySiblings(img2, maxX, maxY, width, height);
  }
  __name(antialiased, "antialiased");
  function hasManySiblings(img, x1, y1, width, height) {
    const x0 = Math.max(x1 - 1, 0);
    const y0 = Math.max(y1 - 1, 0);
    const x2 = Math.min(x1 + 1, width - 1);
    const y2 = Math.min(y1 + 1, height - 1);
    const pos = (y1 * width + x1) * 4;
    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;
    for (let x = x0; x <= x2; x++) {
      for (let y = y0; y <= y2; y++) {
        if (x === x1 && y === y1) continue;
        const pos2 = (y * width + x) * 4;
        if (img[pos] === img[pos2] && img[pos + 1] === img[pos2 + 1] && img[pos + 2] === img[pos2 + 2] && img[pos + 3] === img[pos2 + 3]) zeroes++;
        if (zeroes > 2) return true;
      }
    }
    return false;
  }
  __name(hasManySiblings, "hasManySiblings");
  function colorDelta(img1, img2, k, m, yOnly) {
    let r1 = img1[k + 0];
    let g1 = img1[k + 1];
    let b1 = img1[k + 2];
    let a1 = img1[k + 3];
    let r2 = img2[m + 0];
    let g2 = img2[m + 1];
    let b2 = img2[m + 2];
    let a2 = img2[m + 3];
    if (a1 === a2 && r1 === r2 && g1 === g2 && b1 === b2) return 0;
    if (a1 < 255) {
      a1 /= 255;
      r1 = blend(r1, a1);
      g1 = blend(g1, a1);
      b1 = blend(b1, a1);
    }
    if (a2 < 255) {
      a2 /= 255;
      r2 = blend(r2, a2);
      g2 = blend(g2, a2);
      b2 = blend(b2, a2);
    }
    const y1 = rgb2y(r1, g1, b1);
    const y2 = rgb2y(r2, g2, b2);
    const y = y1 - y2;
    if (yOnly) return y;
    const i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2);
    const q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);
    const delta = 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;
    return y1 > y2 ? -delta : delta;
  }
  __name(colorDelta, "colorDelta");
  function rgb2y(r, g, b) {
    return r * 0.29889531 + g * 0.58662247 + b * 0.11448223;
  }
  __name(rgb2y, "rgb2y");
  function rgb2i(r, g, b) {
    return r * 0.59597799 - g * 0.2741761 - b * 0.32180189;
  }
  __name(rgb2i, "rgb2i");
  function rgb2q(r, g, b) {
    return r * 0.21147017 - g * 0.52261711 + b * 0.31114694;
  }
  __name(rgb2q, "rgb2q");
  function blend(c, a) {
    return 255 + (c - 255) * a;
  }
  __name(blend, "blend");
  function drawPixel2(output, pos, r, g, b) {
    output[pos + 0] = r;
    output[pos + 1] = g;
    output[pos + 2] = b;
    output[pos + 3] = 255;
  }
  __name(drawPixel2, "drawPixel");
  function drawGrayPixel(img, i, alpha, output) {
    const r = img[i + 0];
    const g = img[i + 1];
    const b = img[i + 2];
    const val = blend(rgb2y(r, g, b), alpha * img[i + 3] / 255);
    drawPixel2(output, i, val, val, val);
  }
  __name(drawGrayPixel, "drawGrayPixel");
  return pixelmatch_1;
}
__name(requirePixelmatch, "requirePixelmatch");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/_virtual/pixelmatch.js
var pixelmatchExports = requirePixelmatch();
var pixelmatch = /* @__PURE__ */ getDefaultExportFromCjs2(pixelmatchExports);

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/debug.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/env.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getFromENV(name) {
  let value = process.env[name];
  value = value === void 0 ? process.env[`npm_config_${name.toLowerCase()}`] : value;
  value = value === void 0 ? process.env[`npm_package_config_${name.toLowerCase()}`] : value;
  return value;
}
__name(getFromENV, "getFromENV");
function getAsBooleanFromENV(name, defaultValue) {
  const value = getFromENV(name);
  if (value === "false" || value === "0")
    return false;
  if (value)
    return true;
  return false;
}
__name(getAsBooleanFromENV, "getAsBooleanFromENV");
function getPackageManager() {
  const env3 = process.env.npm_config_user_agent || "";
  if (env3.includes("yarn"))
    return "yarn";
  if (env3.includes("pnpm"))
    return "pnpm";
  return "npm";
}
__name(getPackageManager, "getPackageManager");
function getPackageManagerExecCommand() {
  const packageManager = getPackageManager();
  if (packageManager === "yarn")
    return "yarn";
  if (packageManager === "pnpm")
    return "pnpm exec";
  return "npx";
}
__name(getPackageManagerExecCommand, "getPackageManagerExecCommand");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/debug.js
var _debugMode = getFromENV("PWDEBUG") || "";
function debugMode() {
  if (_debugMode === "console")
    return "console";
  if (_debugMode === "0" || _debugMode === "false")
    return "";
  return _debugMode ? "inspector" : "";
}
__name(debugMode, "debugMode");
var _isUnderTest = !!process.env.PWTEST_UNDER_TEST;
function isUnderTest() {
  return _isUnderTest;
}
__name(isUnderTest, "isUnderTest");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/network.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/http2.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http2/constants.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var NGHTTP2_ERR_FRAME_SIZE_ERROR = -522;
var NGHTTP2_SESSION_SERVER = 0;
var NGHTTP2_SESSION_CLIENT = 1;
var NGHTTP2_STREAM_STATE_IDLE = 1;
var NGHTTP2_STREAM_STATE_OPEN = 2;
var NGHTTP2_STREAM_STATE_RESERVED_LOCAL = 3;
var NGHTTP2_STREAM_STATE_RESERVED_REMOTE = 4;
var NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL = 5;
var NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE = 6;
var NGHTTP2_STREAM_STATE_CLOSED = 7;
var NGHTTP2_FLAG_NONE = 0;
var NGHTTP2_FLAG_END_STREAM = 1;
var NGHTTP2_FLAG_END_HEADERS = 4;
var NGHTTP2_FLAG_ACK = 1;
var NGHTTP2_FLAG_PADDED = 8;
var NGHTTP2_FLAG_PRIORITY = 32;
var DEFAULT_SETTINGS_HEADER_TABLE_SIZE = 4096;
var DEFAULT_SETTINGS_ENABLE_PUSH = 1;
var DEFAULT_SETTINGS_MAX_CONCURRENT_STREAMS = 4294967295;
var DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE = 65535;
var DEFAULT_SETTINGS_MAX_FRAME_SIZE = 16384;
var DEFAULT_SETTINGS_MAX_HEADER_LIST_SIZE = 65535;
var DEFAULT_SETTINGS_ENABLE_CONNECT_PROTOCOL = 0;
var MAX_MAX_FRAME_SIZE = 16777215;
var MIN_MAX_FRAME_SIZE = 16384;
var MAX_INITIAL_WINDOW_SIZE = 2147483647;
var NGHTTP2_SETTINGS_HEADER_TABLE_SIZE = 1;
var NGHTTP2_SETTINGS_ENABLE_PUSH = 2;
var NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS = 3;
var NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE = 4;
var NGHTTP2_SETTINGS_MAX_FRAME_SIZE = 5;
var NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE = 6;
var NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL = 8;
var PADDING_STRATEGY_NONE = 0;
var PADDING_STRATEGY_ALIGNED = 1;
var PADDING_STRATEGY_MAX = 2;
var PADDING_STRATEGY_CALLBACK = 1;
var NGHTTP2_NO_ERROR = 0;
var NGHTTP2_PROTOCOL_ERROR = 1;
var NGHTTP2_INTERNAL_ERROR = 2;
var NGHTTP2_FLOW_CONTROL_ERROR = 3;
var NGHTTP2_SETTINGS_TIMEOUT = 4;
var NGHTTP2_STREAM_CLOSED = 5;
var NGHTTP2_FRAME_SIZE_ERROR = 6;
var NGHTTP2_REFUSED_STREAM = 7;
var NGHTTP2_CANCEL = 8;
var NGHTTP2_COMPRESSION_ERROR = 9;
var NGHTTP2_CONNECT_ERROR = 10;
var NGHTTP2_ENHANCE_YOUR_CALM = 11;
var NGHTTP2_INADEQUATE_SECURITY = 12;
var NGHTTP2_HTTP_1_1_REQUIRED = 13;
var NGHTTP2_DEFAULT_WEIGHT = 16;
var HTTP2_HEADER_STATUS = ":status";
var HTTP2_HEADER_METHOD = ":method";
var HTTP2_HEADER_AUTHORITY = ":authority";
var HTTP2_HEADER_SCHEME = ":scheme";
var HTTP2_HEADER_PATH = ":path";
var HTTP2_HEADER_PROTOCOL = ":protocol";
var HTTP2_HEADER_ACCEPT_ENCODING = "accept-encoding";
var HTTP2_HEADER_ACCEPT_LANGUAGE = "accept-language";
var HTTP2_HEADER_ACCEPT_RANGES = "accept-ranges";
var HTTP2_HEADER_ACCEPT = "accept";
var HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS = "access-control-allow-credentials";
var HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS = "access-control-allow-headers";
var HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS = "access-control-allow-methods";
var HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN = "access-control-allow-origin";
var HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS = "access-control-expose-headers";
var HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS = "access-control-request-headers";
var HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD = "access-control-request-method";
var HTTP2_HEADER_AGE = "age";
var HTTP2_HEADER_AUTHORIZATION = "authorization";
var HTTP2_HEADER_CACHE_CONTROL = "cache-control";
var HTTP2_HEADER_CONNECTION = "connection";
var HTTP2_HEADER_CONTENT_DISPOSITION = "content-disposition";
var HTTP2_HEADER_CONTENT_ENCODING = "content-encoding";
var HTTP2_HEADER_CONTENT_LENGTH = "content-length";
var HTTP2_HEADER_CONTENT_TYPE = "content-type";
var HTTP2_HEADER_COOKIE = "cookie";
var HTTP2_HEADER_DATE = "date";
var HTTP2_HEADER_ETAG = "etag";
var HTTP2_HEADER_FORWARDED = "forwarded";
var HTTP2_HEADER_HOST = "host";
var HTTP2_HEADER_IF_MODIFIED_SINCE = "if-modified-since";
var HTTP2_HEADER_IF_NONE_MATCH = "if-none-match";
var HTTP2_HEADER_IF_RANGE = "if-range";
var HTTP2_HEADER_LAST_MODIFIED = "last-modified";
var HTTP2_HEADER_LINK = "link";
var HTTP2_HEADER_LOCATION = "location";
var HTTP2_HEADER_RANGE = "range";
var HTTP2_HEADER_REFERER = "referer";
var HTTP2_HEADER_SERVER = "server";
var HTTP2_HEADER_SET_COOKIE = "set-cookie";
var HTTP2_HEADER_STRICT_TRANSPORT_SECURITY = "strict-transport-security";
var HTTP2_HEADER_TRANSFER_ENCODING = "transfer-encoding";
var HTTP2_HEADER_TE = "te";
var HTTP2_HEADER_UPGRADE_INSECURE_REQUESTS = "upgrade-insecure-requests";
var HTTP2_HEADER_UPGRADE = "upgrade";
var HTTP2_HEADER_USER_AGENT = "user-agent";
var HTTP2_HEADER_VARY = "vary";
var HTTP2_HEADER_X_CONTENT_TYPE_OPTIONS = "x-content-type-options";
var HTTP2_HEADER_X_FRAME_OPTIONS = "x-frame-options";
var HTTP2_HEADER_KEEP_ALIVE = "keep-alive";
var HTTP2_HEADER_PROXY_CONNECTION = "proxy-connection";
var HTTP2_HEADER_X_XSS_PROTECTION = "x-xss-protection";
var HTTP2_HEADER_ALT_SVC = "alt-svc";
var HTTP2_HEADER_CONTENT_SECURITY_POLICY = "content-security-policy";
var HTTP2_HEADER_EARLY_DATA = "early-data";
var HTTP2_HEADER_EXPECT_CT = "expect-ct";
var HTTP2_HEADER_ORIGIN = "origin";
var HTTP2_HEADER_PURPOSE = "purpose";
var HTTP2_HEADER_TIMING_ALLOW_ORIGIN = "timing-allow-origin";
var HTTP2_HEADER_X_FORWARDED_FOR = "x-forwarded-for";
var HTTP2_HEADER_PRIORITY = "priority";
var HTTP2_HEADER_ACCEPT_CHARSET = "accept-charset";
var HTTP2_HEADER_ACCESS_CONTROL_MAX_AGE = "access-control-max-age";
var HTTP2_HEADER_ALLOW = "allow";
var HTTP2_HEADER_CONTENT_LANGUAGE = "content-language";
var HTTP2_HEADER_CONTENT_LOCATION = "content-location";
var HTTP2_HEADER_CONTENT_MD5 = "content-md5";
var HTTP2_HEADER_CONTENT_RANGE = "content-range";
var HTTP2_HEADER_DNT = "dnt";
var HTTP2_HEADER_EXPECT = "expect";
var HTTP2_HEADER_EXPIRES = "expires";
var HTTP2_HEADER_FROM = "from";
var HTTP2_HEADER_IF_MATCH = "if-match";
var HTTP2_HEADER_IF_UNMODIFIED_SINCE = "if-unmodified-since";
var HTTP2_HEADER_MAX_FORWARDS = "max-forwards";
var HTTP2_HEADER_PREFER = "prefer";
var HTTP2_HEADER_PROXY_AUTHENTICATE = "proxy-authenticate";
var HTTP2_HEADER_PROXY_AUTHORIZATION = "proxy-authorization";
var HTTP2_HEADER_REFRESH = "refresh";
var HTTP2_HEADER_RETRY_AFTER = "retry-after";
var HTTP2_HEADER_TRAILER = "trailer";
var HTTP2_HEADER_TK = "tk";
var HTTP2_HEADER_VIA = "via";
var HTTP2_HEADER_WARNING = "warning";
var HTTP2_HEADER_WWW_AUTHENTICATE = "www-authenticate";
var HTTP2_HEADER_HTTP2_SETTINGS = "http2-settings";
var HTTP2_METHOD_ACL = "ACL";
var HTTP2_METHOD_BASELINE_CONTROL = "BASELINE-CONTROL";
var HTTP2_METHOD_BIND = "BIND";
var HTTP2_METHOD_CHECKIN = "CHECKIN";
var HTTP2_METHOD_CHECKOUT = "CHECKOUT";
var HTTP2_METHOD_CONNECT = "CONNECT";
var HTTP2_METHOD_COPY = "COPY";
var HTTP2_METHOD_DELETE = "DELETE";
var HTTP2_METHOD_GET = "GET";
var HTTP2_METHOD_HEAD = "HEAD";
var HTTP2_METHOD_LABEL = "LABEL";
var HTTP2_METHOD_LINK = "LINK";
var HTTP2_METHOD_LOCK = "LOCK";
var HTTP2_METHOD_MERGE = "MERGE";
var HTTP2_METHOD_MKACTIVITY = "MKACTIVITY";
var HTTP2_METHOD_MKCALENDAR = "MKCALENDAR";
var HTTP2_METHOD_MKCOL = "MKCOL";
var HTTP2_METHOD_MKREDIRECTREF = "MKREDIRECTREF";
var HTTP2_METHOD_MKWORKSPACE = "MKWORKSPACE";
var HTTP2_METHOD_MOVE = "MOVE";
var HTTP2_METHOD_OPTIONS = "OPTIONS";
var HTTP2_METHOD_ORDERPATCH = "ORDERPATCH";
var HTTP2_METHOD_PATCH = "PATCH";
var HTTP2_METHOD_POST = "POST";
var HTTP2_METHOD_PRI = "PRI";
var HTTP2_METHOD_PROPFIND = "PROPFIND";
var HTTP2_METHOD_PROPPATCH = "PROPPATCH";
var HTTP2_METHOD_PUT = "PUT";
var HTTP2_METHOD_REBIND = "REBIND";
var HTTP2_METHOD_REPORT = "REPORT";
var HTTP2_METHOD_SEARCH = "SEARCH";
var HTTP2_METHOD_TRACE = "TRACE";
var HTTP2_METHOD_UNBIND = "UNBIND";
var HTTP2_METHOD_UNCHECKOUT = "UNCHECKOUT";
var HTTP2_METHOD_UNLINK = "UNLINK";
var HTTP2_METHOD_UNLOCK = "UNLOCK";
var HTTP2_METHOD_UPDATE = "UPDATE";
var HTTP2_METHOD_UPDATEREDIRECTREF = "UPDATEREDIRECTREF";
var HTTP2_METHOD_VERSION_CONTROL = "VERSION-CONTROL";
var HTTP_STATUS_CONTINUE = 100;
var HTTP_STATUS_SWITCHING_PROTOCOLS = 101;
var HTTP_STATUS_PROCESSING = 102;
var HTTP_STATUS_EARLY_HINTS = 103;
var HTTP_STATUS_OK = 200;
var HTTP_STATUS_CREATED = 201;
var HTTP_STATUS_ACCEPTED = 202;
var HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION = 203;
var HTTP_STATUS_NO_CONTENT = 204;
var HTTP_STATUS_RESET_CONTENT = 205;
var HTTP_STATUS_PARTIAL_CONTENT = 206;
var HTTP_STATUS_MULTI_STATUS = 207;
var HTTP_STATUS_ALREADY_REPORTED = 208;
var HTTP_STATUS_IM_USED = 226;
var HTTP_STATUS_MULTIPLE_CHOICES = 300;
var HTTP_STATUS_MOVED_PERMANENTLY = 301;
var HTTP_STATUS_FOUND = 302;
var HTTP_STATUS_SEE_OTHER = 303;
var HTTP_STATUS_NOT_MODIFIED = 304;
var HTTP_STATUS_USE_PROXY = 305;
var HTTP_STATUS_TEMPORARY_REDIRECT = 307;
var HTTP_STATUS_PERMANENT_REDIRECT = 308;
var HTTP_STATUS_BAD_REQUEST = 400;
var HTTP_STATUS_UNAUTHORIZED = 401;
var HTTP_STATUS_PAYMENT_REQUIRED = 402;
var HTTP_STATUS_FORBIDDEN = 403;
var HTTP_STATUS_NOT_FOUND = 404;
var HTTP_STATUS_METHOD_NOT_ALLOWED = 405;
var HTTP_STATUS_NOT_ACCEPTABLE = 406;
var HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED = 407;
var HTTP_STATUS_REQUEST_TIMEOUT = 408;
var HTTP_STATUS_CONFLICT = 409;
var HTTP_STATUS_GONE = 410;
var HTTP_STATUS_LENGTH_REQUIRED = 411;
var HTTP_STATUS_PRECONDITION_FAILED = 412;
var HTTP_STATUS_PAYLOAD_TOO_LARGE = 413;
var HTTP_STATUS_URI_TOO_LONG = 414;
var HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE = 415;
var HTTP_STATUS_RANGE_NOT_SATISFIABLE = 416;
var HTTP_STATUS_EXPECTATION_FAILED = 417;
var HTTP_STATUS_TEAPOT = 418;
var HTTP_STATUS_MISDIRECTED_REQUEST = 421;
var HTTP_STATUS_UNPROCESSABLE_ENTITY = 422;
var HTTP_STATUS_LOCKED = 423;
var HTTP_STATUS_FAILED_DEPENDENCY = 424;
var HTTP_STATUS_TOO_EARLY = 425;
var HTTP_STATUS_UPGRADE_REQUIRED = 426;
var HTTP_STATUS_PRECONDITION_REQUIRED = 428;
var HTTP_STATUS_TOO_MANY_REQUESTS = 429;
var HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE = 431;
var HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS = 451;
var HTTP_STATUS_INTERNAL_SERVER_ERROR = 500;
var HTTP_STATUS_NOT_IMPLEMENTED = 501;
var HTTP_STATUS_BAD_GATEWAY = 502;
var HTTP_STATUS_SERVICE_UNAVAILABLE = 503;
var HTTP_STATUS_GATEWAY_TIMEOUT = 504;
var HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED = 505;
var HTTP_STATUS_VARIANT_ALSO_NEGOTIATES = 506;
var HTTP_STATUS_INSUFFICIENT_STORAGE = 507;
var HTTP_STATUS_LOOP_DETECTED = 508;
var HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED = 509;
var HTTP_STATUS_NOT_EXTENDED = 510;
var HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED = 511;

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/http2.mjs
var constants6 = {
  NGHTTP2_ERR_FRAME_SIZE_ERROR,
  NGHTTP2_SESSION_SERVER,
  NGHTTP2_SESSION_CLIENT,
  NGHTTP2_STREAM_STATE_IDLE,
  NGHTTP2_STREAM_STATE_OPEN,
  NGHTTP2_STREAM_STATE_RESERVED_LOCAL,
  NGHTTP2_STREAM_STATE_RESERVED_REMOTE,
  NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL,
  NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE,
  NGHTTP2_STREAM_STATE_CLOSED,
  NGHTTP2_FLAG_NONE,
  NGHTTP2_FLAG_END_STREAM,
  NGHTTP2_FLAG_END_HEADERS,
  NGHTTP2_FLAG_ACK,
  NGHTTP2_FLAG_PADDED,
  NGHTTP2_FLAG_PRIORITY,
  DEFAULT_SETTINGS_HEADER_TABLE_SIZE,
  DEFAULT_SETTINGS_ENABLE_PUSH,
  DEFAULT_SETTINGS_MAX_CONCURRENT_STREAMS,
  DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE,
  DEFAULT_SETTINGS_MAX_FRAME_SIZE,
  DEFAULT_SETTINGS_MAX_HEADER_LIST_SIZE,
  DEFAULT_SETTINGS_ENABLE_CONNECT_PROTOCOL,
  MAX_MAX_FRAME_SIZE,
  MIN_MAX_FRAME_SIZE,
  MAX_INITIAL_WINDOW_SIZE,
  NGHTTP2_SETTINGS_HEADER_TABLE_SIZE,
  NGHTTP2_SETTINGS_ENABLE_PUSH,
  NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS,
  NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE,
  NGHTTP2_SETTINGS_MAX_FRAME_SIZE,
  NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE,
  NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL,
  PADDING_STRATEGY_NONE,
  PADDING_STRATEGY_ALIGNED,
  PADDING_STRATEGY_MAX,
  PADDING_STRATEGY_CALLBACK,
  NGHTTP2_NO_ERROR,
  NGHTTP2_PROTOCOL_ERROR,
  NGHTTP2_INTERNAL_ERROR,
  NGHTTP2_FLOW_CONTROL_ERROR,
  NGHTTP2_SETTINGS_TIMEOUT,
  NGHTTP2_STREAM_CLOSED,
  NGHTTP2_FRAME_SIZE_ERROR,
  NGHTTP2_REFUSED_STREAM,
  NGHTTP2_CANCEL,
  NGHTTP2_COMPRESSION_ERROR,
  NGHTTP2_CONNECT_ERROR,
  NGHTTP2_ENHANCE_YOUR_CALM,
  NGHTTP2_INADEQUATE_SECURITY,
  NGHTTP2_HTTP_1_1_REQUIRED,
  NGHTTP2_DEFAULT_WEIGHT,
  HTTP2_HEADER_STATUS,
  HTTP2_HEADER_METHOD,
  HTTP2_HEADER_AUTHORITY,
  HTTP2_HEADER_SCHEME,
  HTTP2_HEADER_PATH,
  HTTP2_HEADER_PROTOCOL,
  HTTP2_HEADER_ACCEPT_ENCODING,
  HTTP2_HEADER_ACCEPT_LANGUAGE,
  HTTP2_HEADER_ACCEPT_RANGES,
  HTTP2_HEADER_ACCEPT,
  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS,
  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS,
  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS,
  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,
  HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS,
  HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
  HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
  HTTP2_HEADER_AGE,
  HTTP2_HEADER_AUTHORIZATION,
  HTTP2_HEADER_CACHE_CONTROL,
  HTTP2_HEADER_CONNECTION,
  HTTP2_HEADER_CONTENT_DISPOSITION,
  HTTP2_HEADER_CONTENT_ENCODING,
  HTTP2_HEADER_CONTENT_LENGTH,
  HTTP2_HEADER_CONTENT_TYPE,
  HTTP2_HEADER_COOKIE,
  HTTP2_HEADER_DATE,
  HTTP2_HEADER_ETAG,
  HTTP2_HEADER_FORWARDED,
  HTTP2_HEADER_HOST,
  HTTP2_HEADER_IF_MODIFIED_SINCE,
  HTTP2_HEADER_IF_NONE_MATCH,
  HTTP2_HEADER_IF_RANGE,
  HTTP2_HEADER_LAST_MODIFIED,
  HTTP2_HEADER_LINK,
  HTTP2_HEADER_LOCATION,
  HTTP2_HEADER_RANGE,
  HTTP2_HEADER_REFERER,
  HTTP2_HEADER_SERVER,
  HTTP2_HEADER_SET_COOKIE,
  HTTP2_HEADER_STRICT_TRANSPORT_SECURITY,
  HTTP2_HEADER_TRANSFER_ENCODING,
  HTTP2_HEADER_TE,
  HTTP2_HEADER_UPGRADE_INSECURE_REQUESTS,
  HTTP2_HEADER_UPGRADE,
  HTTP2_HEADER_USER_AGENT,
  HTTP2_HEADER_VARY,
  HTTP2_HEADER_X_CONTENT_TYPE_OPTIONS,
  HTTP2_HEADER_X_FRAME_OPTIONS,
  HTTP2_HEADER_KEEP_ALIVE,
  HTTP2_HEADER_PROXY_CONNECTION,
  HTTP2_HEADER_X_XSS_PROTECTION,
  HTTP2_HEADER_ALT_SVC,
  HTTP2_HEADER_CONTENT_SECURITY_POLICY,
  HTTP2_HEADER_EARLY_DATA,
  HTTP2_HEADER_EXPECT_CT,
  HTTP2_HEADER_ORIGIN,
  HTTP2_HEADER_PURPOSE,
  HTTP2_HEADER_TIMING_ALLOW_ORIGIN,
  HTTP2_HEADER_X_FORWARDED_FOR,
  HTTP2_HEADER_PRIORITY,
  HTTP2_HEADER_ACCEPT_CHARSET,
  HTTP2_HEADER_ACCESS_CONTROL_MAX_AGE,
  HTTP2_HEADER_ALLOW,
  HTTP2_HEADER_CONTENT_LANGUAGE,
  HTTP2_HEADER_CONTENT_LOCATION,
  HTTP2_HEADER_CONTENT_MD5,
  HTTP2_HEADER_CONTENT_RANGE,
  HTTP2_HEADER_DNT,
  HTTP2_HEADER_EXPECT,
  HTTP2_HEADER_EXPIRES,
  HTTP2_HEADER_FROM,
  HTTP2_HEADER_IF_MATCH,
  HTTP2_HEADER_IF_UNMODIFIED_SINCE,
  HTTP2_HEADER_MAX_FORWARDS,
  HTTP2_HEADER_PREFER,
  HTTP2_HEADER_PROXY_AUTHENTICATE,
  HTTP2_HEADER_PROXY_AUTHORIZATION,
  HTTP2_HEADER_REFRESH,
  HTTP2_HEADER_RETRY_AFTER,
  HTTP2_HEADER_TRAILER,
  HTTP2_HEADER_TK,
  HTTP2_HEADER_VIA,
  HTTP2_HEADER_WARNING,
  HTTP2_HEADER_WWW_AUTHENTICATE,
  HTTP2_HEADER_HTTP2_SETTINGS,
  HTTP2_METHOD_ACL,
  HTTP2_METHOD_BASELINE_CONTROL,
  HTTP2_METHOD_BIND,
  HTTP2_METHOD_CHECKIN,
  HTTP2_METHOD_CHECKOUT,
  HTTP2_METHOD_CONNECT,
  HTTP2_METHOD_COPY,
  HTTP2_METHOD_DELETE,
  HTTP2_METHOD_GET,
  HTTP2_METHOD_HEAD,
  HTTP2_METHOD_LABEL,
  HTTP2_METHOD_LINK,
  HTTP2_METHOD_LOCK,
  HTTP2_METHOD_MERGE,
  HTTP2_METHOD_MKACTIVITY,
  HTTP2_METHOD_MKCALENDAR,
  HTTP2_METHOD_MKCOL,
  HTTP2_METHOD_MKREDIRECTREF,
  HTTP2_METHOD_MKWORKSPACE,
  HTTP2_METHOD_MOVE,
  HTTP2_METHOD_OPTIONS,
  HTTP2_METHOD_ORDERPATCH,
  HTTP2_METHOD_PATCH,
  HTTP2_METHOD_POST,
  HTTP2_METHOD_PRI,
  HTTP2_METHOD_PROPFIND,
  HTTP2_METHOD_PROPPATCH,
  HTTP2_METHOD_PUT,
  HTTP2_METHOD_REBIND,
  HTTP2_METHOD_REPORT,
  HTTP2_METHOD_SEARCH,
  HTTP2_METHOD_TRACE,
  HTTP2_METHOD_UNBIND,
  HTTP2_METHOD_UNCHECKOUT,
  HTTP2_METHOD_UNLINK,
  HTTP2_METHOD_UNLOCK,
  HTTP2_METHOD_UPDATE,
  HTTP2_METHOD_UPDATEREDIRECTREF,
  HTTP2_METHOD_VERSION_CONTROL,
  HTTP_STATUS_CONTINUE,
  HTTP_STATUS_SWITCHING_PROTOCOLS,
  HTTP_STATUS_PROCESSING,
  HTTP_STATUS_EARLY_HINTS,
  HTTP_STATUS_OK,
  HTTP_STATUS_CREATED,
  HTTP_STATUS_ACCEPTED,
  HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION,
  HTTP_STATUS_NO_CONTENT,
  HTTP_STATUS_RESET_CONTENT,
  HTTP_STATUS_PARTIAL_CONTENT,
  HTTP_STATUS_MULTI_STATUS,
  HTTP_STATUS_ALREADY_REPORTED,
  HTTP_STATUS_IM_USED,
  HTTP_STATUS_MULTIPLE_CHOICES,
  HTTP_STATUS_MOVED_PERMANENTLY,
  HTTP_STATUS_FOUND,
  HTTP_STATUS_SEE_OTHER,
  HTTP_STATUS_NOT_MODIFIED,
  HTTP_STATUS_USE_PROXY,
  HTTP_STATUS_TEMPORARY_REDIRECT,
  HTTP_STATUS_PERMANENT_REDIRECT,
  HTTP_STATUS_BAD_REQUEST,
  HTTP_STATUS_UNAUTHORIZED,
  HTTP_STATUS_PAYMENT_REQUIRED,
  HTTP_STATUS_FORBIDDEN,
  HTTP_STATUS_NOT_FOUND,
  HTTP_STATUS_METHOD_NOT_ALLOWED,
  HTTP_STATUS_NOT_ACCEPTABLE,
  HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED,
  HTTP_STATUS_REQUEST_TIMEOUT,
  HTTP_STATUS_CONFLICT,
  HTTP_STATUS_GONE,
  HTTP_STATUS_LENGTH_REQUIRED,
  HTTP_STATUS_PRECONDITION_FAILED,
  HTTP_STATUS_PAYLOAD_TOO_LARGE,
  HTTP_STATUS_URI_TOO_LONG,
  HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,
  HTTP_STATUS_RANGE_NOT_SATISFIABLE,
  HTTP_STATUS_EXPECTATION_FAILED,
  HTTP_STATUS_TEAPOT,
  HTTP_STATUS_MISDIRECTED_REQUEST,
  HTTP_STATUS_UNPROCESSABLE_ENTITY,
  HTTP_STATUS_LOCKED,
  HTTP_STATUS_FAILED_DEPENDENCY,
  HTTP_STATUS_TOO_EARLY,
  HTTP_STATUS_UPGRADE_REQUIRED,
  HTTP_STATUS_PRECONDITION_REQUIRED,
  HTTP_STATUS_TOO_MANY_REQUESTS,
  HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE,
  HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS,
  HTTP_STATUS_INTERNAL_SERVER_ERROR,
  HTTP_STATUS_NOT_IMPLEMENTED,
  HTTP_STATUS_BAD_GATEWAY,
  HTTP_STATUS_SERVICE_UNAVAILABLE,
  HTTP_STATUS_GATEWAY_TIMEOUT,
  HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED,
  HTTP_STATUS_VARIANT_ALSO_NEGOTIATES,
  HTTP_STATUS_INSUFFICIENT_STORAGE,
  HTTP_STATUS_LOOP_DETECTED,
  HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED,
  HTTP_STATUS_NOT_EXTENDED,
  HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED
};
var createSecureServer = /* @__PURE__ */ notImplemented("http2.createSecureServer");
var createServer5 = /* @__PURE__ */ notImplemented("http2.createServer");
var connect2 = /* @__PURE__ */ notImplemented("http2.connect");
var performServerHandshake = /* @__PURE__ */ notImplemented("http2.performServerHandshake ");
var Http2ServerRequest = /* @__PURE__ */ notImplementedClass("http2.Http2ServerRequest");
var Http2ServerResponse = /* @__PURE__ */ notImplementedClass("http2.Http2ServerResponse");
var getDefaultSettings = /* @__PURE__ */ __name(function() {
  return /* @__PURE__ */ Object.create({
    headerTableSize: 4096,
    enablePush: true,
    initialWindowSize: 65535,
    maxFrameSize: 16384,
    maxConcurrentStreams: 4294967295,
    maxHeaderSize: 65535,
    maxHeaderListSize: 65535,
    enableConnectProtocol: false
  });
}, "getDefaultSettings");
var getPackedSettings = /* @__PURE__ */ __name(function() {
  return Buffer.from("");
}, "getPackedSettings");
var getUnpackedSettings = /* @__PURE__ */ __name(function() {
  return /* @__PURE__ */ Object.create({});
}, "getUnpackedSettings");
var sensitiveHeaders = /* @__PURE__ */ Symbol("nodejs.http2.sensitiveHeaders");
var http2_default = {
  constants: constants6,
  createSecureServer,
  createServer: createServer5,
  Http2ServerRequest,
  Http2ServerResponse,
  connect: connect2,
  getDefaultSettings,
  getPackedSettings,
  getUnpackedSettings,
  performServerHandshake,
  sensitiveHeaders
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/network.js
import url2 from "node:url";
var NET_DEFAULT_TIMEOUT = 3e4;
function httpRequest(params, onResponse, onError) {
  const parsedUrl = url2.parse(params.url);
  let options2 = {
    ...parsedUrl,
    agent: parsedUrl.protocol === "https:" ? httpsHappyEyeballsAgent : httpHappyEyeballsAgent,
    method: params.method || "GET",
    headers: params.headers
  };
  if (params.rejectUnauthorized !== void 0)
    options2.rejectUnauthorized = params.rejectUnauthorized;
  const timeout = params.timeout ?? NET_DEFAULT_TIMEOUT;
  const proxyURL = getProxyForUrl2(params.url);
  if (proxyURL) {
    const parsedProxyURL = url2.parse(proxyURL);
    if (params.url.startsWith("http:")) {
      options2 = {
        path: parsedUrl.href,
        host: parsedProxyURL.hostname,
        port: parsedProxyURL.port,
        headers: options2.headers,
        method: options2.method
      };
    } else {
      parsedProxyURL.secureProxy = parsedProxyURL.protocol === "https:";
      options2.agent = new HttpsProxyAgent2(parsedProxyURL);
      options2.rejectUnauthorized = false;
    }
  }
  const requestCallback = /* @__PURE__ */ __name((res) => {
    const statusCode = res.statusCode || 0;
    if (statusCode >= 300 && statusCode < 400 && res.headers.location) {
      request4.destroy();
      httpRequest({ ...params, url: new URL(res.headers.location, params.url).toString() }, onResponse, onError);
    } else {
      onResponse(res);
    }
  }, "requestCallback");
  const request4 = options2.protocol === "https:" ? https_default.request(options2, requestCallback) : http_default.request(options2, requestCallback);
  request4.on("error", onError);
  if (timeout !== void 0) {
    const rejectOnTimeout = /* @__PURE__ */ __name(() => {
      onError(new Error(`Request to ${params.url} timed out after ${timeout}ms`));
      request4.abort();
    }, "rejectOnTimeout");
    if (timeout <= 0) {
      rejectOnTimeout();
      return;
    }
    request4.setTimeout(timeout, rejectOnTimeout);
  }
  request4.end(params.data);
}
__name(httpRequest, "httpRequest");
function fetchData(params, onError) {
  return new Promise((resolve, reject) => {
    httpRequest(params, async (response) => {
      if (response.statusCode !== 200) {
        const error4 = onError ? await onError(params, response) : new Error(`fetch failed: server returned code ${response.statusCode}. URL: ${params.url}`);
        reject(error4);
        return;
      }
      let body = "";
      response.on("data", (chunk) => body += chunk);
      response.on("error", (error4) => reject(error4));
      response.on("end", () => resolve(body));
    }, reject);
  });
}
__name(fetchData, "fetchData");
function shouldBypassProxy(url22, bypass) {
  if (!bypass)
    return false;
  const domains = bypass.split(",").map((s) => {
    s = s.trim();
    if (!s.startsWith("."))
      s = "." + s;
    return s;
  });
  const domain2 = "." + url22.hostname;
  return domains.some((d) => domain2.endsWith(d));
}
__name(shouldBypassProxy, "shouldBypassProxy");
function createProxyAgent(proxy, forUrl) {
  if (!proxy)
    return;
  if (forUrl && proxy.bypass && shouldBypassProxy(forUrl, proxy.bypass))
    return;
  let proxyServer = proxy.server.trim();
  if (!/^\w+:\/\//.test(proxyServer))
    proxyServer = "http://" + proxyServer;
  const proxyOpts = url2.parse(proxyServer);
  if (proxyOpts.protocol?.startsWith("socks")) {
    return new SocksProxyAgent2({
      host: proxyOpts.hostname,
      port: proxyOpts.port || void 0
    });
  }
  if (proxy.username)
    proxyOpts.auth = `${proxy.username}:${proxy.password || ""}`;
  if (forUrl && ["ws:", "wss:"].includes(forUrl.protocol)) {
    return new HttpsProxyAgent2(proxyOpts);
  }
  return new HttpsProxyAgent2(proxyOpts);
}
__name(createProxyAgent, "createProxyAgent");
function createHttpServer(...args) {
  const server = http_default.createServer(...args);
  decorateServer(server);
  return server;
}
__name(createHttpServer, "createHttpServer");
function decorateServer(server) {
  const sockets = /* @__PURE__ */ new Set();
  server.on("connection", (socket) => {
    sockets.add(socket);
    socket.once("close", () => sockets.delete(socket));
  });
  const close3 = server.close;
  server.close = (callback) => {
    for (const socket of sockets)
      socket.destroy();
    sockets.clear();
    return close3.call(server, callback);
  };
}
__name(decorateServer, "decorateServer");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/nodePlatform.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/inspector.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
init_noop();
var close2 = noop_default;
var console2 = {
  debug: noop_default,
  error: noop_default,
  info: noop_default,
  log: noop_default,
  warn: noop_default,
  dir: noop_default,
  dirxml: noop_default,
  table: noop_default,
  trace: noop_default,
  group: noop_default,
  groupCollapsed: noop_default,
  groupEnd: noop_default,
  clear: noop_default,
  count: noop_default,
  countReset: noop_default,
  assert: noop_default,
  profile: noop_default,
  profileEnd: noop_default,
  time: noop_default,
  timeLog: noop_default,
  timeStamp: noop_default
};
var open4 = /* @__PURE__ */ __name(() => ({
  __unenv__: true,
  [Symbol.dispose]() {
    return Promise.resolve();
  }
}), "open");
var url3 = /* @__PURE__ */ __name(() => void 0, "url");
var waitForDebugger = noop_default;
var Session = /* @__PURE__ */ notImplementedClass("inspector.Session");
var Network = {
  loadingFailed: /* @__PURE__ */ notImplemented("inspector.Network.loadingFailed"),
  loadingFinished: /* @__PURE__ */ notImplemented("inspector.Network.loadingFinished"),
  requestWillBeSent: /* @__PURE__ */ notImplemented("inspector.Network.requestWillBeSent"),
  responseReceived: /* @__PURE__ */ notImplemented("inspector.Network.responseReceived")
};
var inspector_default = {
  Session,
  close: close2,
  console: console2,
  open: open4,
  url: url3,
  waitForDebugger,
  Network
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/nodePlatform.js
import path7 from "node:path";
import { pipeline, Writable as Writable3, Readable as Readable2 } from "node:stream";
import { EventEmitter as EventEmitter3 } from "node:events";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/zones.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/async_hooks.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var workerdAsyncHooks = process.getBuiltinModule("node:async_hooks");
var { AsyncLocalStorage, AsyncResource } = workerdAsyncHooks;

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/zones.js
var asyncLocalStorage = new AsyncLocalStorage();
var Zone = class _Zone {
  static {
    __name(this, "Zone");
  }
  constructor(asyncLocalStorage2, store) {
    this._asyncLocalStorage = asyncLocalStorage2;
    this._data = store;
  }
  with(type2, data) {
    return new _Zone(this._asyncLocalStorage, new Map(this._data).set(type2, data));
  }
  without(type2) {
    const data = type2 ? new Map(this._data) : /* @__PURE__ */ new Map();
    data.delete(type2);
    return new _Zone(this._asyncLocalStorage, data);
  }
  run(func) {
    return this._asyncLocalStorage.run(this, func);
  }
  data(type2) {
    return this._data.get(type2);
  }
};
var emptyZone = new Zone(asyncLocalStorage, /* @__PURE__ */ new Map());
function currentZone() {
  return asyncLocalStorage.getStore() ?? emptyZone;
}
__name(currentZone, "currentZone");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/nodePlatform.js
var pipelineAsync = promisify(pipeline);
var NodeZone = class _NodeZone {
  static {
    __name(this, "NodeZone");
  }
  constructor(zone) {
    this._zone = zone;
  }
  push(data) {
    return new _NodeZone(this._zone.with("apiZone", data));
  }
  pop() {
    return new _NodeZone(this._zone.without("apiZone"));
  }
  run(func) {
    return this._zone.run(func);
  }
  data() {
    return this._zone.data("apiZone");
  }
};
var boxedStackPrefixes = [];
var coreDir = path7.dirname(".");
var nodePlatform = {
  name: "node",
  boxedStackPrefixes: /* @__PURE__ */ __name(() => {
    if (process.env.PWDEBUGIMPL)
      return [];
    return [coreDir, ...boxedStackPrefixes];
  }, "boxedStackPrefixes"),
  calculateSha1: /* @__PURE__ */ __name((text) => {
    const sha1 = crypto_default.createHash("sha1");
    sha1.update(text);
    return Promise.resolve(sha1.digest("hex"));
  }, "calculateSha1"),
  colors: colors2,
  coreDir,
  createGuid: /* @__PURE__ */ __name(() => crypto_default.randomBytes(16).toString("hex"), "createGuid"),
  defaultMaxListeners: /* @__PURE__ */ __name(() => EventEmitter3.defaultMaxListeners, "defaultMaxListeners"),
  fs: /* @__PURE__ */ __name(() => fs, "fs"),
  env: process.env,
  inspectCustom: inspect.custom,
  isDebugMode: /* @__PURE__ */ __name(() => !!debugMode(), "isDebugMode"),
  isJSDebuggerAttached: /* @__PURE__ */ __name(() => !!inspector_default.url(), "isJSDebuggerAttached"),
  isLogEnabled(name) {
    return debugLogger.isEnabled(name);
  },
  isUnderTest: /* @__PURE__ */ __name(() => isUnderTest(), "isUnderTest"),
  log(name, message) {
    debugLogger.log(name, message);
  },
  path: /* @__PURE__ */ __name(() => path7, "path"),
  pathSeparator: path7.sep,
  showInternalStackFrames: /* @__PURE__ */ __name(() => !!process.env.PWDEBUGIMPL, "showInternalStackFrames"),
  async streamFile(path210, stream) {
    await pipelineAsync(fs.createReadStream(path210), stream);
  },
  streamReadable: /* @__PURE__ */ __name((channel2) => {
    return new ReadableStreamImpl(channel2);
  }, "streamReadable"),
  streamWritable: /* @__PURE__ */ __name((channel2) => {
    return new WritableStreamImpl(channel2);
  }, "streamWritable"),
  zones: {
    current: /* @__PURE__ */ __name(() => new NodeZone(currentZone()), "current"),
    empty: new NodeZone(emptyZone)
  }
};
var ReadableStreamImpl = class extends Readable2 {
  static {
    __name(this, "ReadableStreamImpl");
  }
  constructor(channel2) {
    super();
    this._channel = channel2;
  }
  async _read() {
    const result = await this._channel.read({ size: 1024 * 1024 });
    if (result.binary.byteLength)
      this.push(result.binary);
    else
      this.push(null);
  }
  _destroy(error4, callback) {
    this._channel.close().catch((e) => null);
    super._destroy(error4, callback);
  }
};
var WritableStreamImpl = class extends Writable3 {
  static {
    __name(this, "WritableStreamImpl");
  }
  constructor(channel2) {
    super();
    this._channel = channel2;
  }
  async _write(chunk, encoding2, callback) {
    const error4 = await this._channel.write({ binary: typeof chunk === "string" ? Buffer.from(chunk) : chunk }).catch((e) => e);
    callback(error4 || null);
  }
  async _final(callback) {
    const error4 = await this._channel.close().catch((e) => e);
    callback(error4 || null);
  }
};

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/readline.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/readline/promises.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/readline/interface.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter4 } from "node:events";
var Interface = class extends EventEmitter4 {
  static {
    __name(this, "Interface");
  }
  terminal = false;
  line = "";
  cursor = 0;
  getPrompt() {
    return "";
  }
  setPrompt(prompt) {
  }
  prompt(preserveCursor) {
  }
  question(query, options2, callback) {
    callback && typeof callback === "function" && callback("");
  }
  resume() {
    return this;
  }
  close() {
  }
  write(data, key) {
  }
  getCursorPos() {
    return {
      rows: 0,
      cols: 0
    };
  }
  pause() {
    return this;
  }
  async *[Symbol.asyncIterator]() {
    yield "";
  }
};

// ../../.local/share/mise/installs/npm-wrangler/4.22.0/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/readline.mjs
var createInterface = /* @__PURE__ */ __name(() => new Interface(), "createInterface");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/profiler.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path8 from "node:path";
var profileDir = process.env.PWTEST_PROFILE_DIR || "";
var session;
async function startProfiling() {
  if (!profileDir)
    return;
  session = new inspector_default.Session();
  session.connect();
  await new Promise((f) => {
    session.post("Profiler.enable", () => {
      session.post("Profiler.start", f);
    });
  });
}
__name(startProfiling, "startProfiling");
async function stopProfiling(profileName) {
  if (!profileDir)
    return;
  await new Promise((f) => session.post("Profiler.stop", (err, { profile: profile3 }) => {
    if (!err) {
      fs.mkdirSync(profileDir, { recursive: true });
      fs.writeFileSync(path8.join(profileDir, profileName + ".json"), JSON.stringify(profile3));
    }
    f();
  }));
}
__name(stopProfiling, "stopProfiling");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/registry/index.js
var PACKAGE_PATH = path9.join("/home/runner/work/playwright/playwright/packages/playwright-cloudflare", "..", "..", "..");
var BIN_PATH = path9.join("/home/runner/work/playwright/playwright/packages/playwright-cloudflare", "..", "..", "..", "bin");
var PLAYWRIGHT_CDN_MIRRORS = [
  "https://cdn.playwright.dev/dbazure/download/playwright",
  // ESRP CDN
  "https://playwright.download.prss.microsoft.com/dbazure/download/playwright",
  // Directly hit ESRP CDN
  "https://cdn.playwright.dev"
  // Hit the Storage Bucket directly
];
if (process.env.PW_TEST_CDN_THAT_SHOULD_WORK) {
  for (let i = 0; i < PLAYWRIGHT_CDN_MIRRORS.length; i++) {
    const cdn = PLAYWRIGHT_CDN_MIRRORS[i];
    if (cdn !== process.env.PW_TEST_CDN_THAT_SHOULD_WORK) {
      const parsedCDN = new URL(cdn);
      parsedCDN.hostname = parsedCDN.hostname + ".does-not-resolve.playwright.dev";
      PLAYWRIGHT_CDN_MIRRORS[i] = parsedCDN.toString();
    }
  }
}
var EXECUTABLE_PATHS = {
  "chromium": {
    "linux": ["chrome-linux", "chrome"],
    "mac": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
    "win": ["chrome-win", "chrome.exe"]
  },
  "chromium-headless-shell": {
    "linux": ["chrome-linux", "headless_shell"],
    "mac": ["chrome-mac", "headless_shell"],
    "win": ["chrome-win", "headless_shell.exe"]
  },
  "firefox": {
    "linux": ["firefox", "firefox"],
    "mac": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
    "win": ["firefox", "firefox.exe"]
  },
  "webkit": {
    "linux": ["pw_run.sh"],
    "mac": ["pw_run.sh"],
    "win": ["Playwright.exe"]
  },
  "ffmpeg": {
    "linux": ["ffmpeg-linux"],
    "mac": ["ffmpeg-mac"],
    "win": ["ffmpeg-win64.exe"]
  },
  "winldd": {
    "linux": void 0,
    "mac": void 0,
    "win": ["PrintDeps.exe"]
  }
};
var DOWNLOAD_PATHS = {
  "chromium": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/chromium/%s/chromium-linux.zip",
    "ubuntu22.04-x64": "builds/chromium/%s/chromium-linux.zip",
    "ubuntu24.04-x64": "builds/chromium/%s/chromium-linux.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
    "ubuntu22.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
    "ubuntu24.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
    "debian11-x64": "builds/chromium/%s/chromium-linux.zip",
    "debian11-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
    "debian12-x64": "builds/chromium/%s/chromium-linux.zip",
    "debian12-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
    "mac10.13": "builds/chromium/%s/chromium-mac.zip",
    "mac10.14": "builds/chromium/%s/chromium-mac.zip",
    "mac10.15": "builds/chromium/%s/chromium-mac.zip",
    "mac11": "builds/chromium/%s/chromium-mac.zip",
    "mac11-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
    "mac12": "builds/chromium/%s/chromium-mac.zip",
    "mac12-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
    "mac13": "builds/chromium/%s/chromium-mac.zip",
    "mac13-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
    "mac14": "builds/chromium/%s/chromium-mac.zip",
    "mac14-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
    "mac15": "builds/chromium/%s/chromium-mac.zip",
    "mac15-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
    "win64": "builds/chromium/%s/chromium-win64.zip"
  },
  "chromium-headless-shell": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/chromium/%s/chromium-headless-shell-linux.zip",
    "ubuntu22.04-x64": "builds/chromium/%s/chromium-headless-shell-linux.zip",
    "ubuntu24.04-x64": "builds/chromium/%s/chromium-headless-shell-linux.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/chromium/%s/chromium-headless-shell-linux-arm64.zip",
    "ubuntu22.04-arm64": "builds/chromium/%s/chromium-headless-shell-linux-arm64.zip",
    "ubuntu24.04-arm64": "builds/chromium/%s/chromium-headless-shell-linux-arm64.zip",
    "debian11-x64": "builds/chromium/%s/chromium-headless-shell-linux.zip",
    "debian11-arm64": "builds/chromium/%s/chromium-headless-shell-linux-arm64.zip",
    "debian12-x64": "builds/chromium/%s/chromium-headless-shell-linux.zip",
    "debian12-arm64": "builds/chromium/%s/chromium-headless-shell-linux-arm64.zip",
    "mac10.13": void 0,
    "mac10.14": void 0,
    "mac10.15": void 0,
    "mac11": "builds/chromium/%s/chromium-headless-shell-mac.zip",
    "mac11-arm64": "builds/chromium/%s/chromium-headless-shell-mac-arm64.zip",
    "mac12": "builds/chromium/%s/chromium-headless-shell-mac.zip",
    "mac12-arm64": "builds/chromium/%s/chromium-headless-shell-mac-arm64.zip",
    "mac13": "builds/chromium/%s/chromium-headless-shell-mac.zip",
    "mac13-arm64": "builds/chromium/%s/chromium-headless-shell-mac-arm64.zip",
    "mac14": "builds/chromium/%s/chromium-headless-shell-mac.zip",
    "mac14-arm64": "builds/chromium/%s/chromium-headless-shell-mac-arm64.zip",
    "mac15": "builds/chromium/%s/chromium-headless-shell-mac.zip",
    "mac15-arm64": "builds/chromium/%s/chromium-headless-shell-mac-arm64.zip",
    "win64": "builds/chromium/%s/chromium-headless-shell-win64.zip"
  },
  "chromium-tip-of-tree": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
    "ubuntu22.04-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
    "ubuntu24.04-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
    "ubuntu22.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
    "ubuntu24.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
    "debian11-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
    "debian11-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
    "debian12-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
    "debian12-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
    "mac10.13": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac10.14": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac10.15": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac11": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac11-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
    "mac12": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac12-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
    "mac13": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac13-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
    "mac14": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac14-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
    "mac15": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac15-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
    "win64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-win64.zip"
  },
  "chromium-tip-of-tree-headless-shell": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux.zip",
    "ubuntu22.04-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux.zip",
    "ubuntu24.04-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux-arm64.zip",
    "ubuntu22.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux-arm64.zip",
    "ubuntu24.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux-arm64.zip",
    "debian11-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux.zip",
    "debian11-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux-arm64.zip",
    "debian12-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux.zip",
    "debian12-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux-arm64.zip",
    "mac10.13": void 0,
    "mac10.14": void 0,
    "mac10.15": void 0,
    "mac11": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac.zip",
    "mac11-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac-arm64.zip",
    "mac12": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac.zip",
    "mac12-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac-arm64.zip",
    "mac13": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac.zip",
    "mac13-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac-arm64.zip",
    "mac14": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac.zip",
    "mac14-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac-arm64.zip",
    "mac15": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac.zip",
    "mac15-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac-arm64.zip",
    "win64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-win64.zip"
  },
  "firefox": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/firefox/%s/firefox-ubuntu-20.04.zip",
    "ubuntu22.04-x64": "builds/firefox/%s/firefox-ubuntu-22.04.zip",
    "ubuntu24.04-x64": "builds/firefox/%s/firefox-ubuntu-24.04.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/firefox/%s/firefox-ubuntu-20.04-arm64.zip",
    "ubuntu22.04-arm64": "builds/firefox/%s/firefox-ubuntu-22.04-arm64.zip",
    "ubuntu24.04-arm64": "builds/firefox/%s/firefox-ubuntu-24.04-arm64.zip",
    "debian11-x64": "builds/firefox/%s/firefox-debian-11.zip",
    "debian11-arm64": "builds/firefox/%s/firefox-debian-11-arm64.zip",
    "debian12-x64": "builds/firefox/%s/firefox-debian-12.zip",
    "debian12-arm64": "builds/firefox/%s/firefox-debian-12-arm64.zip",
    "mac10.13": "builds/firefox/%s/firefox-mac.zip",
    "mac10.14": "builds/firefox/%s/firefox-mac.zip",
    "mac10.15": "builds/firefox/%s/firefox-mac.zip",
    "mac11": "builds/firefox/%s/firefox-mac.zip",
    "mac11-arm64": "builds/firefox/%s/firefox-mac-arm64.zip",
    "mac12": "builds/firefox/%s/firefox-mac.zip",
    "mac12-arm64": "builds/firefox/%s/firefox-mac-arm64.zip",
    "mac13": "builds/firefox/%s/firefox-mac.zip",
    "mac13-arm64": "builds/firefox/%s/firefox-mac-arm64.zip",
    "mac14": "builds/firefox/%s/firefox-mac.zip",
    "mac14-arm64": "builds/firefox/%s/firefox-mac-arm64.zip",
    "mac15": "builds/firefox/%s/firefox-mac.zip",
    "mac15-arm64": "builds/firefox/%s/firefox-mac-arm64.zip",
    "win64": "builds/firefox/%s/firefox-win64.zip"
  },
  "firefox-beta": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip",
    "ubuntu22.04-x64": "builds/firefox-beta/%s/firefox-beta-ubuntu-22.04.zip",
    "ubuntu24.04-x64": "builds/firefox-beta/%s/firefox-beta-ubuntu-24.04.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": void 0,
    "ubuntu22.04-arm64": "builds/firefox-beta/%s/firefox-beta-ubuntu-22.04-arm64.zip",
    "ubuntu24.04-arm64": "builds/firefox-beta/%s/firefox-beta-ubuntu-24.04-arm64.zip",
    "debian11-x64": "builds/firefox-beta/%s/firefox-beta-debian-11.zip",
    "debian11-arm64": "builds/firefox-beta/%s/firefox-beta-debian-11-arm64.zip",
    "debian12-x64": "builds/firefox-beta/%s/firefox-beta-debian-12.zip",
    "debian12-arm64": "builds/firefox-beta/%s/firefox-beta-debian-12-arm64.zip",
    "mac10.13": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac10.14": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac10.15": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac11": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac11-arm64": "builds/firefox-beta/%s/firefox-beta-mac-arm64.zip",
    "mac12": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac12-arm64": "builds/firefox-beta/%s/firefox-beta-mac-arm64.zip",
    "mac13": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac13-arm64": "builds/firefox-beta/%s/firefox-beta-mac-arm64.zip",
    "mac14": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac14-arm64": "builds/firefox-beta/%s/firefox-beta-mac-arm64.zip",
    "mac15": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac15-arm64": "builds/firefox-beta/%s/firefox-beta-mac-arm64.zip",
    "win64": "builds/firefox-beta/%s/firefox-beta-win64.zip"
  },
  "webkit": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/webkit/%s/webkit-ubuntu-20.04.zip",
    "ubuntu22.04-x64": "builds/webkit/%s/webkit-ubuntu-22.04.zip",
    "ubuntu24.04-x64": "builds/webkit/%s/webkit-ubuntu-24.04.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/webkit/%s/webkit-ubuntu-20.04-arm64.zip",
    "ubuntu22.04-arm64": "builds/webkit/%s/webkit-ubuntu-22.04-arm64.zip",
    "ubuntu24.04-arm64": "builds/webkit/%s/webkit-ubuntu-24.04-arm64.zip",
    "debian11-x64": "builds/webkit/%s/webkit-debian-11.zip",
    "debian11-arm64": "builds/webkit/%s/webkit-debian-11-arm64.zip",
    "debian12-x64": "builds/webkit/%s/webkit-debian-12.zip",
    "debian12-arm64": "builds/webkit/%s/webkit-debian-12-arm64.zip",
    "mac10.13": void 0,
    "mac10.14": "builds/deprecated-webkit-mac-10.14/%s/deprecated-webkit-mac-10.14.zip",
    "mac10.15": "builds/deprecated-webkit-mac-10.15/%s/deprecated-webkit-mac-10.15.zip",
    "mac11": "builds/webkit/%s/webkit-mac-11.zip",
    "mac11-arm64": "builds/webkit/%s/webkit-mac-11-arm64.zip",
    "mac12": "builds/webkit/%s/webkit-mac-12.zip",
    "mac12-arm64": "builds/webkit/%s/webkit-mac-12-arm64.zip",
    "mac13": "builds/webkit/%s/webkit-mac-13.zip",
    "mac13-arm64": "builds/webkit/%s/webkit-mac-13-arm64.zip",
    "mac14": "builds/webkit/%s/webkit-mac-14.zip",
    "mac14-arm64": "builds/webkit/%s/webkit-mac-14-arm64.zip",
    "mac15": "builds/webkit/%s/webkit-mac-15.zip",
    "mac15-arm64": "builds/webkit/%s/webkit-mac-15-arm64.zip",
    "win64": "builds/webkit/%s/webkit-win64.zip"
  },
  "ffmpeg": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/ffmpeg/%s/ffmpeg-linux.zip",
    "ubuntu22.04-x64": "builds/ffmpeg/%s/ffmpeg-linux.zip",
    "ubuntu24.04-x64": "builds/ffmpeg/%s/ffmpeg-linux.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
    "ubuntu22.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
    "ubuntu24.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
    "debian11-x64": "builds/ffmpeg/%s/ffmpeg-linux.zip",
    "debian11-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
    "debian12-x64": "builds/ffmpeg/%s/ffmpeg-linux.zip",
    "debian12-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
    "mac10.13": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac10.14": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac10.15": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac11": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac11-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
    "mac12": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac12-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
    "mac13": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac13-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
    "mac14": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac14-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
    "mac15": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac15-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
    "win64": "builds/ffmpeg/%s/ffmpeg-win64.zip"
  },
  "winldd": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": void 0,
    "ubuntu22.04-x64": void 0,
    "ubuntu24.04-x64": void 0,
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": void 0,
    "ubuntu22.04-arm64": void 0,
    "ubuntu24.04-arm64": void 0,
    "debian11-x64": void 0,
    "debian11-arm64": void 0,
    "debian12-x64": void 0,
    "debian12-arm64": void 0,
    "mac10.13": void 0,
    "mac10.14": void 0,
    "mac10.15": void 0,
    "mac11": void 0,
    "mac11-arm64": void 0,
    "mac12": void 0,
    "mac12-arm64": void 0,
    "mac13": void 0,
    "mac13-arm64": void 0,
    "mac14": void 0,
    "mac14-arm64": void 0,
    "mac15": void 0,
    "mac15-arm64": void 0,
    "win64": "builds/winldd/%s/winldd-win64.zip"
  },
  "android": {
    "<unknown>": "builds/android/%s/android.zip",
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/android/%s/android.zip",
    "ubuntu22.04-x64": "builds/android/%s/android.zip",
    "ubuntu24.04-x64": "builds/android/%s/android.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/android/%s/android.zip",
    "ubuntu22.04-arm64": "builds/android/%s/android.zip",
    "ubuntu24.04-arm64": "builds/android/%s/android.zip",
    "debian11-x64": "builds/android/%s/android.zip",
    "debian11-arm64": "builds/android/%s/android.zip",
    "debian12-x64": "builds/android/%s/android.zip",
    "debian12-arm64": "builds/android/%s/android.zip",
    "mac10.13": "builds/android/%s/android.zip",
    "mac10.14": "builds/android/%s/android.zip",
    "mac10.15": "builds/android/%s/android.zip",
    "mac11": "builds/android/%s/android.zip",
    "mac11-arm64": "builds/android/%s/android.zip",
    "mac12": "builds/android/%s/android.zip",
    "mac12-arm64": "builds/android/%s/android.zip",
    "mac13": "builds/android/%s/android.zip",
    "mac13-arm64": "builds/android/%s/android.zip",
    "mac14": "builds/android/%s/android.zip",
    "mac14-arm64": "builds/android/%s/android.zip",
    "mac15": "builds/android/%s/android.zip",
    "mac15-arm64": "builds/android/%s/android.zip",
    "win64": "builds/android/%s/android.zip"
  },
  // TODO(bidi): implement downloads.
  "bidi": {}
};
var registryDirectory = (() => {
  let result;
  const envDefined = getFromENV("PLAYWRIGHT_BROWSERS_PATH");
  if (envDefined === "0") {
    result = path9.join("/home/runner/work/playwright/playwright/packages/playwright-cloudflare", "..", "..", "..", ".local-browsers");
  } else if (envDefined) {
    result = envDefined;
  } else {
    let cacheDirectory;
    if (process.platform === "linux")
      cacheDirectory = process.env.XDG_CACHE_HOME || path9.join(os_default.homedir(), ".cache");
    else if (process.platform === "darwin")
      cacheDirectory = path9.join(os_default.homedir(), "Library", "Caches");
    else if (process.platform === "win32")
      cacheDirectory = process.env.LOCALAPPDATA || path9.join(os_default.homedir(), "AppData", "Local");
    else
      throw new Error("Unsupported platform: " + process.platform);
    result = path9.join(cacheDirectory, "ms-playwright");
  }
  if (!path9.isAbsolute(result)) {
    result = path9.resolve(getFromENV("INIT_CWD") || process.cwd(), result);
  }
  return result;
})();
function isBrowserDirectory(browserDirectory) {
  const baseName = path9.basename(browserDirectory);
  for (const browserName of allDownloadable) {
    if (baseName.startsWith(browserName.replace(/-/g, "_") + "-"))
      return true;
  }
  return false;
}
__name(isBrowserDirectory, "isBrowserDirectory");
function readDescriptors(browsersJSON) {
  return browsersJSON["browsers"].map((obj) => {
    const name = obj.name;
    const revisionOverride = (obj.revisionOverrides || {})[hostPlatform];
    const revision = revisionOverride || obj.revision;
    const browserDirectoryPrefix = revisionOverride ? `${name}_${hostPlatform}_special` : `${name}`;
    const descriptor = {
      name,
      revision,
      hasRevisionOverride: !!revisionOverride,
      // We only put browser version for the supported operating systems.
      browserVersion: revisionOverride ? void 0 : obj.browserVersion,
      installByDefault: !!obj.installByDefault,
      // Method `isBrowserDirectory` determines directory to be browser iff
      // it starts with some browser name followed by '-'. Some browser names
      // are prefixes of others, e.g. 'webkit' is a prefix of `webkit-technology-preview`.
      // To avoid older registries erroneously removing 'webkit-technology-preview', we have to
      // ensure that browser folders to never include dashes inside.
      dir: path9.join(registryDirectory, browserDirectoryPrefix.replace(/-/g, "_") + "-" + revision)
    };
    return descriptor;
  });
}
__name(readDescriptors, "readDescriptors");
var allDownloadable = ["android", "chromium", "firefox", "webkit", "ffmpeg", "firefox-beta", "chromium-tip-of-tree", "chromium-headless-shell", "chromium-tip-of-tree-headless-shell"];
var Registry = class {
  static {
    __name(this, "Registry");
  }
  constructor(browsersJSON) {
    const descriptors = readDescriptors(browsersJSON);
    const findExecutablePath = /* @__PURE__ */ __name((dir3, name) => {
      let tokens = void 0;
      if (process.platform === "linux")
        tokens = EXECUTABLE_PATHS[name]["linux"];
      else if (process.platform === "darwin")
        tokens = EXECUTABLE_PATHS[name]["mac"];
      else if (process.platform === "win32")
        tokens = EXECUTABLE_PATHS[name]["win"];
      return tokens ? path9.join(dir3, ...tokens) : void 0;
    }, "findExecutablePath");
    const executablePathOrDie = /* @__PURE__ */ __name((name, e, installByDefault, sdkLanguage) => {
      if (!e)
        throw new Error(`${name} is not supported on ${hostPlatform}`);
      const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install${installByDefault ? "" : " " + name}`);
      if (!canAccessFile(e)) {
        const currentDockerVersion = readDockerVersionSync();
        const preferredDockerVersion = currentDockerVersion ? dockerVersion(currentDockerVersion.dockerImageNameTemplate) : null;
        const isOutdatedDockerImage = currentDockerVersion && preferredDockerVersion && currentDockerVersion.dockerImageName !== preferredDockerVersion.dockerImageName;
        const prettyMessage = isOutdatedDockerImage ? [
          `Looks like ${sdkLanguage === "javascript" ? "Playwright Test or " : ""}Playwright was just updated to ${preferredDockerVersion.driverVersion}.`,
          `Please update docker image as well.`,
          `-  current: ${currentDockerVersion.dockerImageName}`,
          `- required: ${preferredDockerVersion.dockerImageName}`,
          ``,
          `<3 Playwright Team`
        ].join("\n") : [
          `Looks like ${sdkLanguage === "javascript" ? "Playwright Test or " : ""}Playwright was just installed or updated.`,
          `Please run the following command to download new browser${installByDefault ? "s" : ""}:`,
          ``,
          `    ${installCommand}`,
          ``,
          `<3 Playwright Team`
        ].join("\n");
        throw new Error(`Executable doesn't exist at ${e}
${wrapInASCIIBox(prettyMessage, 1)}`);
      }
      return e;
    }, "executablePathOrDie");
    this._executables = [];
    const chromium2 = descriptors.find((d) => d.name === "chromium");
    const chromiumExecutable = findExecutablePath(chromium2.dir, "chromium");
    this._executables.push({
      type: "browser",
      name: "chromium",
      browserName: "chromium",
      directory: chromium2.dir,
      executablePath: /* @__PURE__ */ __name(() => chromiumExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("chromium", chromiumExecutable, chromium2.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: chromium2.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, chromium2.dir, ["chrome-linux"], [], ["chrome-win"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(chromium2),
      browserVersion: chromium2.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(chromium2, chromiumExecutable), "_install"),
      _dependencyGroup: "chromium",
      _isHermeticInstallation: true
    });
    const chromiumHeadlessShell = descriptors.find((d) => d.name === "chromium-headless-shell");
    const chromiumHeadlessShellExecutable = findExecutablePath(chromiumHeadlessShell.dir, "chromium-headless-shell");
    this._executables.push({
      type: "channel",
      name: "chromium-headless-shell",
      browserName: "chromium",
      directory: chromiumHeadlessShell.dir,
      executablePath: /* @__PURE__ */ __name(() => chromiumHeadlessShellExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("chromium", chromiumHeadlessShellExecutable, chromiumHeadlessShell.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: chromiumHeadlessShell.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, chromiumHeadlessShell.dir, ["chrome-linux"], [], ["chrome-win"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(chromiumHeadlessShell),
      browserVersion: chromium2.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(chromiumHeadlessShell, chromiumHeadlessShellExecutable), "_install"),
      _dependencyGroup: "chromium",
      _isHermeticInstallation: true
    });
    const chromiumTipOfTreeHeadlessShell = descriptors.find((d) => d.name === "chromium-tip-of-tree-headless-shell");
    const chromiumTipOfTreeHeadlessShellExecutable = findExecutablePath(chromiumTipOfTreeHeadlessShell.dir, "chromium-headless-shell");
    this._executables.push({
      type: "channel",
      name: "chromium-tip-of-tree-headless-shell",
      browserName: "chromium",
      directory: chromiumTipOfTreeHeadlessShell.dir,
      executablePath: /* @__PURE__ */ __name(() => chromiumTipOfTreeHeadlessShellExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("chromium", chromiumTipOfTreeHeadlessShellExecutable, chromiumTipOfTreeHeadlessShell.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: chromiumTipOfTreeHeadlessShell.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, chromiumTipOfTreeHeadlessShell.dir, ["chrome-linux"], [], ["chrome-win"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(chromiumTipOfTreeHeadlessShell),
      browserVersion: chromium2.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(chromiumTipOfTreeHeadlessShell, chromiumTipOfTreeHeadlessShellExecutable), "_install"),
      _dependencyGroup: "chromium",
      _isHermeticInstallation: true
    });
    const chromiumTipOfTree = descriptors.find((d) => d.name === "chromium-tip-of-tree");
    const chromiumTipOfTreeExecutable = findExecutablePath(chromiumTipOfTree.dir, "chromium");
    this._executables.push({
      type: "tool",
      name: "chromium-tip-of-tree",
      browserName: "chromium",
      directory: chromiumTipOfTree.dir,
      executablePath: /* @__PURE__ */ __name(() => chromiumTipOfTreeExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("chromium-tip-of-tree", chromiumTipOfTreeExecutable, chromiumTipOfTree.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: chromiumTipOfTree.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, chromiumTipOfTree.dir, ["chrome-linux"], [], ["chrome-win"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(chromiumTipOfTree),
      browserVersion: chromiumTipOfTree.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(chromiumTipOfTree, chromiumTipOfTreeExecutable), "_install"),
      _dependencyGroup: "chromium",
      _isHermeticInstallation: true
    });
    this._executables.push(this._createChromiumChannel("chrome", {
      "linux": "/opt/google/chrome/chrome",
      "darwin": "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
      "win32": `\\Google\\Chrome\\Application\\chrome.exe`
    }, () => this._installChromiumChannel("chrome", {
      "linux": "reinstall_chrome_stable_linux.sh",
      "darwin": "reinstall_chrome_stable_mac.sh",
      "win32": "reinstall_chrome_stable_win.ps1"
    })));
    this._executables.push(this._createChromiumChannel("chrome-beta", {
      "linux": "/opt/google/chrome-beta/chrome",
      "darwin": "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta",
      "win32": `\\Google\\Chrome Beta\\Application\\chrome.exe`
    }, () => this._installChromiumChannel("chrome-beta", {
      "linux": "reinstall_chrome_beta_linux.sh",
      "darwin": "reinstall_chrome_beta_mac.sh",
      "win32": "reinstall_chrome_beta_win.ps1"
    })));
    this._executables.push(this._createChromiumChannel("chrome-dev", {
      "linux": "/opt/google/chrome-unstable/chrome",
      "darwin": "/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev",
      "win32": `\\Google\\Chrome Dev\\Application\\chrome.exe`
    }));
    this._executables.push(this._createChromiumChannel("chrome-canary", {
      "linux": "",
      "darwin": "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
      "win32": `\\Google\\Chrome SxS\\Application\\chrome.exe`
    }));
    this._executables.push(this._createChromiumChannel("msedge", {
      "linux": "/opt/microsoft/msedge/msedge",
      "darwin": "/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge",
      "win32": `\\Microsoft\\Edge\\Application\\msedge.exe`
    }, () => this._installMSEdgeChannel("msedge", {
      "linux": "reinstall_msedge_stable_linux.sh",
      "darwin": "reinstall_msedge_stable_mac.sh",
      "win32": "reinstall_msedge_stable_win.ps1"
    })));
    this._executables.push(this._createChromiumChannel("msedge-beta", {
      "linux": "/opt/microsoft/msedge-beta/msedge",
      "darwin": "/Applications/Microsoft Edge Beta.app/Contents/MacOS/Microsoft Edge Beta",
      "win32": `\\Microsoft\\Edge Beta\\Application\\msedge.exe`
    }, () => this._installMSEdgeChannel("msedge-beta", {
      "darwin": "reinstall_msedge_beta_mac.sh",
      "linux": "reinstall_msedge_beta_linux.sh",
      "win32": "reinstall_msedge_beta_win.ps1"
    })));
    this._executables.push(this._createChromiumChannel("msedge-dev", {
      "linux": "/opt/microsoft/msedge-dev/msedge",
      "darwin": "/Applications/Microsoft Edge Dev.app/Contents/MacOS/Microsoft Edge Dev",
      "win32": `\\Microsoft\\Edge Dev\\Application\\msedge.exe`
    }, () => this._installMSEdgeChannel("msedge-dev", {
      "darwin": "reinstall_msedge_dev_mac.sh",
      "linux": "reinstall_msedge_dev_linux.sh",
      "win32": "reinstall_msedge_dev_win.ps1"
    })));
    this._executables.push(this._createChromiumChannel("msedge-canary", {
      "linux": "",
      "darwin": "/Applications/Microsoft Edge Canary.app/Contents/MacOS/Microsoft Edge Canary",
      "win32": `\\Microsoft\\Edge SxS\\Application\\msedge.exe`
    }));
    this._executables.push(this._createBidiFirefoxChannel("moz-firefox", {
      "linux": "/snap/bin/firefox",
      "darwin": "/Applications/Firefox.app/Contents/MacOS/firefox",
      "win32": "\\Mozilla Firefox\\firefox.exe"
    }));
    this._executables.push(this._createBidiFirefoxChannel("moz-firefox-beta", {
      "linux": "/opt/firefox-beta/firefox",
      "darwin": "/Applications/Firefox.app/Contents/MacOS/firefox",
      "win32": "\\Mozilla Firefox\\firefox.exe"
    }));
    this._executables.push(this._createBidiFirefoxChannel("moz-firefox-nightly", {
      "linux": "/opt/firefox-nightly/firefox",
      "darwin": "/Applications/Firefox Nightly.app/Contents/MacOS/firefox",
      "win32": "\\Mozilla Firefox\\firefox.exe"
    }));
    this._executables.push(this._createBidiChromiumChannel("bidi-chrome-stable", {
      "linux": "/opt/google/chrome/chrome",
      "darwin": "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
      "win32": `\\Google\\Chrome\\Application\\chrome.exe`
    }));
    this._executables.push(this._createBidiChromiumChannel("bidi-chrome-canary", {
      "linux": "",
      "darwin": "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
      "win32": `\\Google\\Chrome SxS\\Application\\chrome.exe`
    }));
    this._executables.push({
      type: "browser",
      name: "bidi-chromium",
      browserName: "bidi",
      directory: chromium2.dir,
      executablePath: /* @__PURE__ */ __name(() => chromiumExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("chromium", chromiumExecutable, chromium2.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, chromium2.dir, ["chrome-linux"], [], ["chrome-win"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(chromium2),
      browserVersion: chromium2.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(chromium2, chromiumExecutable), "_install"),
      _dependencyGroup: "chromium",
      _isHermeticInstallation: true
    });
    const firefox = descriptors.find((d) => d.name === "firefox");
    const firefoxExecutable = findExecutablePath(firefox.dir, "firefox");
    this._executables.push({
      type: "browser",
      name: "firefox",
      browserName: "firefox",
      directory: firefox.dir,
      executablePath: /* @__PURE__ */ __name(() => firefoxExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("firefox", firefoxExecutable, firefox.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: firefox.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, firefox.dir, ["firefox"], [], ["firefox"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(firefox),
      browserVersion: firefox.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(firefox, firefoxExecutable), "_install"),
      _dependencyGroup: "firefox",
      _isHermeticInstallation: true
    });
    const firefoxBeta = descriptors.find((d) => d.name === "firefox-beta");
    const firefoxBetaExecutable = findExecutablePath(firefoxBeta.dir, "firefox");
    this._executables.push({
      type: "tool",
      name: "firefox-beta",
      browserName: "firefox",
      directory: firefoxBeta.dir,
      executablePath: /* @__PURE__ */ __name(() => firefoxBetaExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("firefox-beta", firefoxBetaExecutable, firefoxBeta.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: firefoxBeta.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, firefoxBeta.dir, ["firefox"], [], ["firefox"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(firefoxBeta),
      browserVersion: firefoxBeta.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(firefoxBeta, firefoxBetaExecutable), "_install"),
      _dependencyGroup: "firefox",
      _isHermeticInstallation: true
    });
    const webkit = descriptors.find((d) => d.name === "webkit");
    const webkitExecutable = findExecutablePath(webkit.dir, "webkit");
    const webkitLinuxLddDirectories = [
      path9.join("minibrowser-gtk"),
      path9.join("minibrowser-gtk", "bin"),
      path9.join("minibrowser-gtk", "lib"),
      path9.join("minibrowser-gtk", "sys", "lib"),
      path9.join("minibrowser-wpe"),
      path9.join("minibrowser-wpe", "bin"),
      path9.join("minibrowser-wpe", "lib"),
      path9.join("minibrowser-wpe", "sys", "lib")
    ];
    this._executables.push({
      type: "browser",
      name: "webkit",
      browserName: "webkit",
      directory: webkit.dir,
      executablePath: /* @__PURE__ */ __name(() => webkitExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("webkit", webkitExecutable, webkit.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: webkit.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, webkit.dir, webkitLinuxLddDirectories, ["libGLESv2.so.2", "libx264.so"], [""]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(webkit),
      browserVersion: webkit.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(webkit, webkitExecutable), "_install"),
      _dependencyGroup: "webkit",
      _isHermeticInstallation: true
    });
    const ffmpeg = descriptors.find((d) => d.name === "ffmpeg");
    const ffmpegExecutable = findExecutablePath(ffmpeg.dir, "ffmpeg");
    this._executables.push({
      type: "tool",
      name: "ffmpeg",
      browserName: void 0,
      directory: ffmpeg.dir,
      executablePath: /* @__PURE__ */ __name(() => ffmpegExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("ffmpeg", ffmpegExecutable, ffmpeg.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: ffmpeg.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(ffmpeg),
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(ffmpeg, ffmpegExecutable), "_install"),
      _dependencyGroup: "tools",
      _isHermeticInstallation: true
    });
    const winldd = descriptors.find((d) => d.name === "winldd");
    const winlddExecutable = findExecutablePath(winldd.dir, "winldd");
    this._executables.push({
      type: "tool",
      name: "winldd",
      browserName: void 0,
      directory: winldd.dir,
      executablePath: /* @__PURE__ */ __name(() => winlddExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("winldd", winlddExecutable, winldd.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: process.platform === "win32" ? "download-by-default" : "none",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(winldd),
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(winldd, winlddExecutable), "_install"),
      _dependencyGroup: "tools",
      _isHermeticInstallation: true
    });
    const android = descriptors.find((d) => d.name === "android");
    this._executables.push({
      type: "tool",
      name: "android",
      browserName: void 0,
      directory: android.dir,
      executablePath: /* @__PURE__ */ __name(() => void 0, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name(() => "", "executablePathOrDie"),
      installType: "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(android),
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(android), "_install"),
      _dependencyGroup: "tools",
      _isHermeticInstallation: true
    });
    this._executables.push({
      type: "browser",
      name: "bidi",
      browserName: "bidi",
      directory: void 0,
      executablePath: /* @__PURE__ */ __name(() => void 0, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name(() => "", "executablePathOrDie"),
      installType: "none",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      downloadURLs: [],
      _install: /* @__PURE__ */ __name(() => Promise.resolve(), "_install"),
      _dependencyGroup: "tools",
      _isHermeticInstallation: true
    });
  }
  _createChromiumChannel(name, lookAt, install) {
    const executablePath = /* @__PURE__ */ __name((sdkLanguage, shouldThrow) => {
      const suffix = lookAt[process.platform];
      if (!suffix) {
        if (shouldThrow)
          throw new Error(`Chromium distribution '${name}' is not supported on ${process.platform}`);
        return void 0;
      }
      const prefixes = process.platform === "win32" ? [
        process.env.LOCALAPPDATA,
        process.env.PROGRAMFILES,
        process.env["PROGRAMFILES(X86)"],
        // In some cases there is no PROGRAMFILES/(86) env var set but HOMEDRIVE is set.
        process.env.HOMEDRIVE + "\\Program Files",
        process.env.HOMEDRIVE + "\\Program Files (x86)"
      ].filter(Boolean) : [""];
      for (const prefix of prefixes) {
        const executablePath2 = path9.join(prefix, suffix);
        if (canAccessFile(executablePath2))
          return executablePath2;
      }
      if (!shouldThrow)
        return void 0;
      const location2 = prefixes.length ? ` at ${path9.join(prefixes[0], suffix)}` : ``;
      const installation = install ? `
Run "${buildPlaywrightCLICommand(sdkLanguage, "install " + name)}"` : "";
      throw new Error(`Chromium distribution '${name}' is not found${location2}${installation}`);
    }, "executablePath");
    return {
      type: "channel",
      name,
      browserName: "chromium",
      directory: void 0,
      executablePath: /* @__PURE__ */ __name((sdkLanguage) => executablePath(sdkLanguage, false), "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePath(sdkLanguage, true), "executablePathOrDie"),
      installType: install ? "install-script" : "none",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      _isHermeticInstallation: false,
      _install: install
    };
  }
  _createBidiFirefoxChannel(name, lookAt, install) {
    const executablePath = /* @__PURE__ */ __name((sdkLanguage, shouldThrow) => {
      const suffix = lookAt[process.platform];
      if (!suffix) {
        if (shouldThrow)
          throw new Error(`Firefox distribution '${name}' is not supported on ${process.platform}`);
        return void 0;
      }
      const prefixes = process.platform === "win32" ? [
        process.env.LOCALAPPDATA,
        process.env.PROGRAMFILES,
        process.env["PROGRAMFILES(X86)"],
        // In some cases there is no PROGRAMFILES/(86) env var set but HOMEDRIVE is set.
        process.env.HOMEDRIVE + "\\Program Files",
        process.env.HOMEDRIVE + "\\Program Files (x86)"
      ].filter(Boolean) : [""];
      for (const prefix of prefixes) {
        const executablePath2 = path9.join(prefix, suffix);
        if (canAccessFile(executablePath2))
          return executablePath2;
      }
      if (shouldThrow)
        throw new Error(`Cannot find Firefox installation for channel '${name}' at the standard system paths.`);
      return void 0;
    }, "executablePath");
    return {
      type: "channel",
      name,
      browserName: "bidi",
      directory: void 0,
      executablePath: /* @__PURE__ */ __name((sdkLanguage) => executablePath(sdkLanguage, false), "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePath(sdkLanguage, true), "executablePathOrDie"),
      installType: "none",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      _isHermeticInstallation: true,
      _install: install
    };
  }
  _createBidiChromiumChannel(name, lookAt, install) {
    const executablePath = /* @__PURE__ */ __name((sdkLanguage, shouldThrow) => {
      const suffix = lookAt[process.platform];
      if (!suffix) {
        if (shouldThrow)
          throw new Error(`Firefox distribution '${name}' is not supported on ${process.platform}`);
        return void 0;
      }
      const prefixes = process.platform === "win32" ? [
        process.env.LOCALAPPDATA,
        process.env.PROGRAMFILES,
        process.env["PROGRAMFILES(X86)"],
        // In some cases there is no PROGRAMFILES/(86) env var set but HOMEDRIVE is set.
        process.env.HOMEDRIVE + "\\Program Files",
        process.env.HOMEDRIVE + "\\Program Files (x86)"
      ].filter(Boolean) : [""];
      for (const prefix of prefixes) {
        const executablePath2 = path9.join(prefix, suffix);
        if (canAccessFile(executablePath2))
          return executablePath2;
      }
      if (!shouldThrow)
        return void 0;
      const location2 = prefixes.length ? ` at ${path9.join(prefixes[0], suffix)}` : ``;
      const installation = install ? `
Run "${buildPlaywrightCLICommand(sdkLanguage, "install " + name)}"` : "";
      throw new Error(`Chromium distribution '${name}' is not found${location2}${installation}`);
    }, "executablePath");
    return {
      type: "channel",
      name,
      browserName: "bidi",
      directory: void 0,
      executablePath: /* @__PURE__ */ __name((sdkLanguage) => executablePath(sdkLanguage, false), "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePath(sdkLanguage, true), "executablePathOrDie"),
      installType: install ? "install-script" : "none",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      _isHermeticInstallation: false,
      _install: install
    };
  }
  executables() {
    return this._executables;
  }
  findExecutable(name) {
    return this._executables.find((b) => b.name === name);
  }
  defaultExecutables() {
    return this._executables.filter((e) => e.installType === "download-by-default");
  }
  _dedupe(executables) {
    return Array.from(new Set(executables));
  }
  async _validateHostRequirements(sdkLanguage, browserDirectory, linuxLddDirectories, dlOpenLibraries, windowsExeAndDllDirectories) {
    if (os_default.platform() === "linux")
      return await validateDependenciesLinux(sdkLanguage, linuxLddDirectories.map((d) => path9.join(browserDirectory, d)), dlOpenLibraries);
    if (os_default.platform() === "win32" && os_default.arch() === "x64")
      return await validateDependenciesWindows(sdkLanguage, windowsExeAndDllDirectories.map((d) => path9.join(browserDirectory, d)));
  }
  async installDeps(executablesToInstallDeps, dryRun) {
    const executables = this._dedupe(executablesToInstallDeps);
    const targets = /* @__PURE__ */ new Set();
    for (const executable of executables) {
      if (executable._dependencyGroup)
        targets.add(executable._dependencyGroup);
    }
    targets.add("tools");
    if (os_default.platform() === "win32")
      return await installDependenciesWindows(targets, dryRun);
    if (os_default.platform() === "linux")
      return await installDependenciesLinux(targets, dryRun);
  }
  async install(executablesToInstall, forceReinstall) {
    const executables = this._dedupe(executablesToInstall);
    await fs.promises.mkdir(registryDirectory, { recursive: true });
    const lockfilePath = path9.join(registryDirectory, "__dirlock");
    const linksDir = path9.join(registryDirectory, ".links");
    let releaseLock;
    try {
      releaseLock = await lockfile2.lock(registryDirectory, {
        retries: {
          // Retry 20 times during 10 minutes with
          // exponential back-off.
          // See documentation at: https://www.npmjs.com/package/retry#retrytimeoutsoptions
          retries: 20,
          factor: 1.27579
        },
        onCompromised: /* @__PURE__ */ __name((err) => {
          throw new Error(`${err.message} Path: ${lockfilePath}`);
        }, "onCompromised"),
        lockfilePath
      });
      await fs.promises.mkdir(linksDir, { recursive: true });
      await fs.promises.writeFile(path9.join(linksDir, calculateSha1(PACKAGE_PATH)), PACKAGE_PATH);
      await this._validateInstallationCache(linksDir);
      for (const executable of executables) {
        if (!executable._install)
          throw new Error(`ERROR: Playwright does not support installing ${executable.name}`);
        const { embedderName } = getEmbedderName();
        if (!getAsBooleanFromENV("CI") && !executable._isHermeticInstallation && !forceReinstall && executable.executablePath(embedderName)) {
          const command2 = buildPlaywrightCLICommand(embedderName, "install --force " + executable.name);
          throw new Error("\n" + wrapInASCIIBox([
            `ATTENTION: "${executable.name}" is already installed on the system!`,
            ``,
            `"${executable.name}" installation is not hermetic; installing newer version`,
            `requires *removal* of a current installation first.`,
            ``,
            `To *uninstall* current version and re-install latest "${executable.name}":`,
            ``,
            `- Close all running instances of "${executable.name}", if any`,
            `- Use "--force" to install browser:`,
            ``,
            `    ${command2}`,
            ``,
            `<3 Playwright Team`
          ].join("\n"), 1));
        }
        await executable._install();
      }
    } catch (e) {
      if (e.code === "ELOCKED") {
        const rmCommand = process.platform === "win32" ? "rm -R" : "rm -rf";
        throw new Error("\n" + wrapInASCIIBox([
          `An active lockfile is found at:`,
          ``,
          `  ${lockfilePath}`,
          ``,
          `Either:`,
          `- wait a few minutes if other Playwright is installing browsers in parallel`,
          `- remove lock manually with:`,
          ``,
          `    ${rmCommand} ${lockfilePath}`,
          ``,
          `<3 Playwright Team`
        ].join("\n"), 1));
      } else {
        throw e;
      }
    } finally {
      if (releaseLock)
        await releaseLock();
    }
  }
  async uninstall(all) {
    const linksDir = path9.join(registryDirectory, ".links");
    if (all) {
      const links = await fs.promises.readdir(linksDir).catch(() => []);
      for (const link2 of links)
        await fs.promises.unlink(path9.join(linksDir, link2));
    } else {
      await fs.promises.unlink(path9.join(linksDir, calculateSha1(PACKAGE_PATH))).catch(() => {
      });
    }
    await this._validateInstallationCache(linksDir);
    return {
      numberOfBrowsersLeft: (await fs.promises.readdir(registryDirectory).catch(() => [])).filter((browserDirectory) => isBrowserDirectory(browserDirectory)).length
    };
  }
  async validateHostRequirementsForExecutablesIfNeeded(executables, sdkLanguage) {
    if (getAsBooleanFromENV("PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS")) {
      process.stderr.write("Skipping host requirements validation logic because `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS` env variable is set.\n");
      return;
    }
    for (const executable of executables)
      await this._validateHostRequirementsForExecutableIfNeeded(executable, sdkLanguage);
  }
  async _validateHostRequirementsForExecutableIfNeeded(executable, sdkLanguage) {
    const kMaximumReValidationPeriod = 30 * 24 * 60 * 60 * 1e3;
    if (!executable.directory)
      return;
    const markerFile = path9.join(executable.directory, "DEPENDENCIES_VALIDATED");
    if (await fs.promises.stat(markerFile).then((stat2) => Date.now() - stat2.mtime.getTime() < kMaximumReValidationPeriod).catch(() => false))
      return;
    debugLogger.log("install", `validating host requirements for "${executable.name}"`);
    try {
      await executable._validateHostRequirements(sdkLanguage);
      debugLogger.log("install", `validation passed for ${executable.name}`);
    } catch (error4) {
      debugLogger.log("install", `validation failed for ${executable.name}`);
      throw error4;
    }
    await fs.promises.writeFile(markerFile, "").catch(() => {
    });
  }
  _downloadURLs(descriptor) {
    const paths = DOWNLOAD_PATHS[descriptor.name];
    const downloadPathTemplate = paths[hostPlatform] || paths["<unknown>"];
    if (!downloadPathTemplate)
      return [];
    const downloadPath = format(downloadPathTemplate, descriptor.revision);
    let downloadURLs = PLAYWRIGHT_CDN_MIRRORS.map((mirror) => `${mirror}/${downloadPath}`);
    let downloadHostEnv;
    if (descriptor.name.startsWith("chromium"))
      downloadHostEnv = "PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST";
    else if (descriptor.name.startsWith("firefox"))
      downloadHostEnv = "PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST";
    else if (descriptor.name.startsWith("webkit"))
      downloadHostEnv = "PLAYWRIGHT_WEBKIT_DOWNLOAD_HOST";
    const customHostOverride = downloadHostEnv && getFromENV(downloadHostEnv) || getFromENV("PLAYWRIGHT_DOWNLOAD_HOST");
    if (customHostOverride)
      downloadURLs = [`${customHostOverride}/${downloadPath}`];
    return downloadURLs;
  }
  async _downloadExecutable(descriptor, executablePath) {
    const downloadURLs = this._downloadURLs(descriptor);
    if (!downloadURLs.length)
      throw new Error(`ERROR: Playwright does not support ${descriptor.name} on ${hostPlatform}`);
    if (!isOfficiallySupportedPlatform)
      logPolitely(`BEWARE: your OS is not officially supported by Playwright; downloading fallback build for ${hostPlatform}.`);
    if (descriptor.hasRevisionOverride) {
      const message = `You are using a frozen ${descriptor.name} browser which does not receive updates anymore on ${hostPlatform}. Please update to the latest version of your operating system to test up-to-date browsers.`;
      if (process.env.GITHUB_ACTIONS)
        console.log(`::warning title=Playwright::${message}`);
      else
        logPolitely(message);
    }
    const displayName = descriptor.name.split("-").map((word) => {
      return word === "ffmpeg" ? "FFMPEG" : word.charAt(0).toUpperCase() + word.slice(1);
    }).join(" ");
    const title2 = descriptor.browserVersion ? `${displayName} ${descriptor.browserVersion} (playwright build v${descriptor.revision})` : `${displayName} playwright build v${descriptor.revision}`;
    const downloadFileName = `playwright-download-${descriptor.name}-${hostPlatform}-${descriptor.revision}.zip`;
    const downloadSocketTimeoutEnv = getFromENV("PLAYWRIGHT_DOWNLOAD_CONNECTION_TIMEOUT");
    const downloadSocketTimeout = +(downloadSocketTimeoutEnv || "0") || 3e4;
    await downloadBrowserWithProgressBar(title2, descriptor.dir, executablePath, downloadURLs, downloadFileName, downloadSocketTimeout).catch((e) => {
      throw new Error(`Failed to download ${title2}, caused by
${e.stack}`);
    });
  }
  async _installMSEdgeChannel(channel2, scripts) {
    const scriptArgs = [];
    if (process.platform !== "linux") {
      const products = lowercaseAllKeys(JSON.parse(await fetchData({ url: "https://edgeupdates.microsoft.com/api/products" })));
      const productName = {
        "msedge": "Stable",
        "msedge-beta": "Beta",
        "msedge-dev": "Dev"
      }[channel2];
      const product = products.find((product2) => product2.product === productName);
      const searchConfig = {
        darwin: { platform: "MacOS", arch: "universal", artifact: "pkg" },
        win32: { platform: "Windows", arch: "x64", artifact: "msi" }
      }[process.platform];
      const release3 = searchConfig ? product.releases.find((release22) => release22.platform === searchConfig.platform && release22.architecture === searchConfig.arch && release22.artifacts.length > 0) : null;
      const artifact = release3 ? release3.artifacts.find((artifact2) => artifact2.artifactname === searchConfig.artifact) : null;
      if (artifact)
        scriptArgs.push(
          artifact.location
          /* url */
        );
      else
        throw new Error(`Cannot install ${channel2} on ${process.platform}`);
    }
    await this._installChromiumChannel(channel2, scripts, scriptArgs);
  }
  async _installChromiumChannel(channel2, scripts, scriptArgs = []) {
    const scriptName = scripts[process.platform];
    if (!scriptName)
      throw new Error(`Cannot install ${channel2} on ${process.platform}`);
    const cwd2 = BIN_PATH;
    const isPowerShell = scriptName.endsWith(".ps1");
    if (isPowerShell) {
      const args = [
        "-ExecutionPolicy",
        "Bypass",
        "-File",
        path9.join(BIN_PATH, scriptName),
        ...scriptArgs
      ];
      const { code } = await spawnAsync("powershell.exe", args, { cwd: cwd2, stdio: "inherit" });
      if (code !== 0)
        throw new Error(`Failed to install ${channel2}`);
    } else {
      const { command: command2, args, elevatedPermissions } = await transformCommandsForRoot([`bash "${path9.join(BIN_PATH, scriptName)}" ${scriptArgs.join("")}`]);
      if (elevatedPermissions)
        console.log("Switching to root user to install dependencies...");
      const { code } = await spawnAsync(command2, args, { cwd: cwd2, stdio: "inherit" });
      if (code !== 0)
        throw new Error(`Failed to install ${channel2}`);
    }
  }
  async _validateInstallationCache(linksDir) {
    const usedBrowserPaths = /* @__PURE__ */ new Set();
    for (const fileName of await fs.promises.readdir(linksDir)) {
      const linkPath = path9.join(linksDir, fileName);
      let linkTarget = "";
      try {
        linkTarget = (await fs.promises.readFile(linkPath)).toString();
        const browsersJSON = commonjsRequire(path9.join(linkTarget, "browsers.json"));
        const descriptors = readDescriptors(browsersJSON);
        for (const browserName of allDownloadable) {
          const descriptor = descriptors.find((d) => d.name === browserName);
          if (!descriptor)
            continue;
          const usedBrowserPath = descriptor.dir;
          const browserRevision = parseInt(descriptor.revision, 10);
          const shouldHaveMarkerFile = browserName === "chromium" && (browserRevision >= 786218 || browserRevision < 3e5) || browserName === "firefox" && browserRevision >= 1128 || browserName === "webkit" && browserRevision >= 1307 || // All new applications have a marker file right away.
          browserName !== "firefox" && browserName !== "chromium" && browserName !== "webkit";
          if (!shouldHaveMarkerFile || await existsAsync(browserDirectoryToMarkerFilePath(usedBrowserPath)))
            usedBrowserPaths.add(usedBrowserPath);
        }
      } catch (e) {
        await fs.promises.unlink(linkPath).catch((e2) => {
        });
      }
    }
    if (!getAsBooleanFromENV("PLAYWRIGHT_SKIP_BROWSER_GC")) {
      let downloadedBrowsers = (await fs.promises.readdir(registryDirectory)).map((file) => path9.join(registryDirectory, file));
      downloadedBrowsers = downloadedBrowsers.filter((file) => isBrowserDirectory(file));
      const directories = new Set(downloadedBrowsers);
      for (const browserDirectory of usedBrowserPaths)
        directories.delete(browserDirectory);
      for (const directory of directories)
        logPolitely("Removing unused browser at " + directory);
      await removeFolders([...directories]);
    }
  }
};
function browserDirectoryToMarkerFilePath(browserDirectory) {
  return path9.join(browserDirectory, "INSTALLATION_COMPLETE");
}
__name(browserDirectoryToMarkerFilePath, "browserDirectoryToMarkerFilePath");
function buildPlaywrightCLICommand(sdkLanguage, parameters) {
  switch (sdkLanguage) {
    case "python":
      return `playwright ${parameters}`;
    case "java":
      return `mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args="${parameters}"`;
    case "csharp":
      return `pwsh bin/Debug/netX/playwright.ps1 ${parameters}`;
    default: {
      const packageManagerCommand = getPackageManagerExecCommand();
      return `${packageManagerCommand} playwright ${parameters}`;
    }
  }
}
__name(buildPlaywrightCLICommand, "buildPlaywrightCLICommand");
function findChromiumChannel(sdkLanguage) {
  let channel2 = null;
  for (const name of ["chromium", "chrome", "msedge"]) {
    try {
      registry.findExecutable(name).executablePathOrDie(sdkLanguage);
      channel2 = name === "chromium" ? void 0 : name;
      break;
    } catch (e) {
    }
  }
  if (channel2 === null) {
    const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install chromium`);
    const prettyMessage = [
      `No chromium-based browser found on the system.`,
      `Please run the following command to download one:`,
      ``,
      `    ${installCommand}`,
      ``,
      `<3 Playwright Team`
    ].join("\n");
    throw new Error("\n" + wrapInASCIIBox(prettyMessage, 1));
  }
  return channel2;
}
__name(findChromiumChannel, "findChromiumChannel");
function lowercaseAllKeys(json) {
  if (typeof json !== "object" || !json)
    return json;
  if (Array.isArray(json))
    return json.map(lowercaseAllKeys);
  const result = {};
  for (const [key, value] of Object.entries(json))
    result[key.toLowerCase()] = lowercaseAllKeys(value);
  return result;
}
__name(lowercaseAllKeys, "lowercaseAllKeys");
var registry = new Registry(require$$03);

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/dispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter6 } from "node:events";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/eventsHelper.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var EventsHelper = class {
  static {
    __name(this, "EventsHelper");
  }
  static addEventListener(emitter, eventName, handler) {
    emitter.on(eventName, handler);
    return { emitter, eventName, handler };
  }
  static removeEventListeners(listeners2) {
    for (const listener of listeners2)
      listener.emitter.removeListener(listener.eventName, listener.handler);
    listeners2.splice(0, listeners2.length);
  }
};
var eventsHelper = EventsHelper;

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/protocol/validator.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/protocol/validatorPrimitives.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ValidationError = class extends Error {
  static {
    __name(this, "ValidationError");
  }
};
var scheme = {};
function findValidator(type2, method, kind) {
  const validator = maybeFindValidator(type2, method, kind);
  if (!validator)
    throw new ValidationError(`Unknown scheme for ${kind}: ${type2}.${method}`);
  return validator;
}
__name(findValidator, "findValidator");
function maybeFindValidator(type2, method, kind) {
  const schemeName = type2 + (kind === "Initializer" ? "" : method[0].toUpperCase() + method.substring(1)) + kind;
  return scheme[schemeName];
}
__name(maybeFindValidator, "maybeFindValidator");
function createMetadataValidator() {
  return tOptional(scheme["Metadata"]);
}
__name(createMetadataValidator, "createMetadataValidator");
var tNumber = /* @__PURE__ */ __name((arg, path31, context2) => {
  if (arg instanceof Number)
    return arg.valueOf();
  if (typeof arg === "number")
    return arg;
  throw new ValidationError(`${path31}: expected number, got ${typeof arg}`);
}, "tNumber");
var tBoolean = /* @__PURE__ */ __name((arg, path31, context2) => {
  if (arg instanceof Boolean)
    return arg.valueOf();
  if (typeof arg === "boolean")
    return arg;
  throw new ValidationError(`${path31}: expected boolean, got ${typeof arg}`);
}, "tBoolean");
var tString = /* @__PURE__ */ __name((arg, path31, context2) => {
  if (arg instanceof String)
    return arg.valueOf();
  if (typeof arg === "string")
    return arg;
  throw new ValidationError(`${path31}: expected string, got ${typeof arg}`);
}, "tString");
var tBinary = /* @__PURE__ */ __name((arg, path31, context2) => {
  if (context2.binary === "fromBase64") {
    if (arg instanceof String)
      return Buffer.from(arg.valueOf(), "base64");
    if (typeof arg === "string")
      return Buffer.from(arg, "base64");
    throw new ValidationError(`${path31}: expected base64-encoded buffer, got ${typeof arg}`);
  }
  if (context2.binary === "toBase64") {
    if (!(arg instanceof Buffer))
      throw new ValidationError(`${path31}: expected Buffer, got ${typeof arg}`);
    return arg.toString("base64");
  }
  if (context2.binary === "buffer") {
    if (!(arg instanceof Buffer))
      throw new ValidationError(`${path31}: expected Buffer, got ${typeof arg}`);
    return arg;
  }
  throw new ValidationError(`Unsupported binary behavior "${context2.binary}"`);
}, "tBinary");
var tAny = /* @__PURE__ */ __name((arg, path31, context2) => {
  return arg;
}, "tAny");
var tOptional = /* @__PURE__ */ __name((v) => {
  return (arg, path31, context2) => {
    if (Object.is(arg, void 0))
      return arg;
    return v(arg, path31, context2);
  };
}, "tOptional");
var tArray = /* @__PURE__ */ __name((v) => {
  return (arg, path31, context2) => {
    if (!Array.isArray(arg))
      throw new ValidationError(`${path31}: expected array, got ${typeof arg}`);
    return arg.map((x, index2) => v(x, path31 + "[" + index2 + "]", context2));
  };
}, "tArray");
var tObject = /* @__PURE__ */ __name((s) => {
  return (arg, path31, context2) => {
    if (Object.is(arg, null))
      throw new ValidationError(`${path31}: expected object, got null`);
    if (typeof arg !== "object")
      throw new ValidationError(`${path31}: expected object, got ${typeof arg}`);
    const result = {};
    for (const [key, v] of Object.entries(s)) {
      const value = v(arg[key], path31 ? path31 + "." + key : key, context2);
      if (!Object.is(value, void 0))
        result[key] = value;
    }
    if (context2.isUnderTest()) {
      for (const [key, value] of Object.entries(arg)) {
        if (key.startsWith("__testHook"))
          result[key] = value;
      }
    }
    return result;
  };
}, "tObject");
var tEnum = /* @__PURE__ */ __name((e) => {
  return (arg, path31, context2) => {
    if (!e.includes(arg))
      throw new ValidationError(`${path31}: expected one of (${e.join("|")})`);
    return arg;
  };
}, "tEnum");
var tChannel = /* @__PURE__ */ __name((names) => {
  return (arg, path31, context2) => {
    return context2.tChannelImpl(names, arg, path31, context2);
  };
}, "tChannel");
var tType = /* @__PURE__ */ __name((name) => {
  return (arg, path31, context2) => {
    const v = scheme[name];
    if (!v)
      throw new ValidationError(path31 + ': unknown type "' + name + '"');
    return v(arg, path31, context2);
  };
}, "tType");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/protocol/validator.js
scheme.StackFrame = tObject({
  file: tString,
  line: tNumber,
  column: tNumber,
  function: tOptional(tString)
});
scheme.Metadata = tObject({
  location: tOptional(tObject({
    file: tString,
    line: tOptional(tNumber),
    column: tOptional(tNumber)
  })),
  apiName: tOptional(tString),
  internal: tOptional(tBoolean),
  stepId: tOptional(tString)
});
scheme.ClientSideCallMetadata = tObject({
  id: tNumber,
  stack: tOptional(tArray(tType("StackFrame")))
});
scheme.Point = tObject({
  x: tNumber,
  y: tNumber
});
scheme.Rect = tObject({
  x: tNumber,
  y: tNumber,
  width: tNumber,
  height: tNumber
});
scheme.SerializedValue = tObject({
  n: tOptional(tNumber),
  b: tOptional(tBoolean),
  s: tOptional(tString),
  v: tOptional(tEnum(["null", "undefined", "NaN", "Infinity", "-Infinity", "-0"])),
  d: tOptional(tString),
  u: tOptional(tString),
  bi: tOptional(tString),
  ta: tOptional(tObject({
    b: tBinary,
    k: tEnum(["i8", "ui8", "ui8c", "i16", "ui16", "i32", "ui32", "f32", "f64", "bi64", "bui64"])
  })),
  e: tOptional(tObject({
    m: tString,
    n: tString,
    s: tString
  })),
  r: tOptional(tObject({
    p: tString,
    f: tString
  })),
  a: tOptional(tArray(tType("SerializedValue"))),
  o: tOptional(tArray(tObject({
    k: tString,
    v: tType("SerializedValue")
  }))),
  h: tOptional(tNumber),
  id: tOptional(tNumber),
  ref: tOptional(tNumber)
});
scheme.SerializedArgument = tObject({
  value: tType("SerializedValue"),
  handles: tArray(tChannel("*"))
});
scheme.ExpectedTextValue = tObject({
  string: tOptional(tString),
  regexSource: tOptional(tString),
  regexFlags: tOptional(tString),
  matchSubstring: tOptional(tBoolean),
  ignoreCase: tOptional(tBoolean),
  normalizeWhiteSpace: tOptional(tBoolean)
});
scheme.AXNode = tObject({
  role: tString,
  name: tString,
  valueString: tOptional(tString),
  valueNumber: tOptional(tNumber),
  description: tOptional(tString),
  keyshortcuts: tOptional(tString),
  roledescription: tOptional(tString),
  valuetext: tOptional(tString),
  disabled: tOptional(tBoolean),
  expanded: tOptional(tBoolean),
  focused: tOptional(tBoolean),
  modal: tOptional(tBoolean),
  multiline: tOptional(tBoolean),
  multiselectable: tOptional(tBoolean),
  readonly: tOptional(tBoolean),
  required: tOptional(tBoolean),
  selected: tOptional(tBoolean),
  checked: tOptional(tEnum(["checked", "unchecked", "mixed"])),
  pressed: tOptional(tEnum(["pressed", "released", "mixed"])),
  level: tOptional(tNumber),
  valuemin: tOptional(tNumber),
  valuemax: tOptional(tNumber),
  autocomplete: tOptional(tString),
  haspopup: tOptional(tString),
  invalid: tOptional(tString),
  orientation: tOptional(tString),
  children: tOptional(tArray(tType("AXNode")))
});
scheme.SetNetworkCookie = tObject({
  name: tString,
  value: tString,
  url: tOptional(tString),
  domain: tOptional(tString),
  path: tOptional(tString),
  expires: tOptional(tNumber),
  httpOnly: tOptional(tBoolean),
  secure: tOptional(tBoolean),
  sameSite: tOptional(tEnum(["Strict", "Lax", "None"]))
});
scheme.NetworkCookie = tObject({
  name: tString,
  value: tString,
  domain: tString,
  path: tString,
  expires: tNumber,
  httpOnly: tBoolean,
  secure: tBoolean,
  sameSite: tEnum(["Strict", "Lax", "None"])
});
scheme.NameValue = tObject({
  name: tString,
  value: tString
});
scheme.IndexedDBDatabase = tObject({
  name: tString,
  version: tNumber,
  stores: tArray(tObject({
    name: tString,
    autoIncrement: tBoolean,
    keyPath: tOptional(tString),
    keyPathArray: tOptional(tArray(tString)),
    records: tArray(tObject({
      key: tOptional(tAny),
      keyEncoded: tOptional(tAny),
      value: tOptional(tAny),
      valueEncoded: tOptional(tAny)
    })),
    indexes: tArray(tObject({
      name: tString,
      keyPath: tOptional(tString),
      keyPathArray: tOptional(tArray(tString)),
      multiEntry: tBoolean,
      unique: tBoolean
    }))
  }))
});
scheme.SetOriginStorage = tObject({
  origin: tString,
  localStorage: tArray(tType("NameValue")),
  indexedDB: tOptional(tArray(tType("IndexedDBDatabase")))
});
scheme.OriginStorage = tObject({
  origin: tString,
  localStorage: tArray(tType("NameValue")),
  indexedDB: tOptional(tArray(tType("IndexedDBDatabase")))
});
scheme.SerializedError = tObject({
  error: tOptional(tObject({
    message: tString,
    name: tString,
    stack: tOptional(tString)
  })),
  value: tOptional(tType("SerializedValue"))
});
scheme.RecordHarOptions = tObject({
  path: tString,
  content: tOptional(tEnum(["embed", "attach", "omit"])),
  mode: tOptional(tEnum(["full", "minimal"])),
  urlGlob: tOptional(tString),
  urlRegexSource: tOptional(tString),
  urlRegexFlags: tOptional(tString)
});
scheme.FormField = tObject({
  name: tString,
  value: tOptional(tString),
  file: tOptional(tObject({
    name: tString,
    mimeType: tOptional(tString),
    buffer: tBinary
  }))
});
scheme.APIRequestContextInitializer = tObject({
  tracing: tChannel(["Tracing"])
});
scheme.APIRequestContextFetchParams = tObject({
  url: tString,
  encodedParams: tOptional(tString),
  params: tOptional(tArray(tType("NameValue"))),
  method: tOptional(tString),
  headers: tOptional(tArray(tType("NameValue"))),
  postData: tOptional(tBinary),
  jsonData: tOptional(tString),
  formData: tOptional(tArray(tType("NameValue"))),
  multipartData: tOptional(tArray(tType("FormField"))),
  timeout: tOptional(tNumber),
  failOnStatusCode: tOptional(tBoolean),
  ignoreHTTPSErrors: tOptional(tBoolean),
  maxRedirects: tOptional(tNumber),
  maxRetries: tOptional(tNumber)
});
scheme.APIRequestContextFetchResult = tObject({
  response: tType("APIResponse")
});
scheme.APIRequestContextFetchResponseBodyParams = tObject({
  fetchUid: tString
});
scheme.APIRequestContextFetchResponseBodyResult = tObject({
  binary: tOptional(tBinary)
});
scheme.APIRequestContextFetchLogParams = tObject({
  fetchUid: tString
});
scheme.APIRequestContextFetchLogResult = tObject({
  log: tArray(tString)
});
scheme.APIRequestContextStorageStateParams = tObject({
  indexedDB: tOptional(tBoolean)
});
scheme.APIRequestContextStorageStateResult = tObject({
  cookies: tArray(tType("NetworkCookie")),
  origins: tArray(tType("OriginStorage"))
});
scheme.APIRequestContextDisposeAPIResponseParams = tObject({
  fetchUid: tString
});
scheme.APIRequestContextDisposeAPIResponseResult = tOptional(tObject({}));
scheme.APIRequestContextDisposeParams = tObject({
  reason: tOptional(tString)
});
scheme.APIRequestContextDisposeResult = tOptional(tObject({}));
scheme.APIResponse = tObject({
  fetchUid: tString,
  url: tString,
  status: tNumber,
  statusText: tString,
  headers: tArray(tType("NameValue"))
});
scheme.LifecycleEvent = tEnum(["load", "domcontentloaded", "networkidle", "commit"]);
scheme.LocalUtilsInitializer = tObject({
  deviceDescriptors: tArray(tObject({
    name: tString,
    descriptor: tObject({
      userAgent: tString,
      viewport: tObject({
        width: tNumber,
        height: tNumber
      }),
      screen: tOptional(tObject({
        width: tNumber,
        height: tNumber
      })),
      deviceScaleFactor: tNumber,
      isMobile: tBoolean,
      hasTouch: tBoolean,
      defaultBrowserType: tEnum(["chromium", "firefox", "webkit"])
    })
  }))
});
scheme.LocalUtilsZipParams = tObject({
  zipFile: tString,
  entries: tArray(tType("NameValue")),
  stacksId: tOptional(tString),
  mode: tEnum(["write", "append"]),
  includeSources: tBoolean
});
scheme.LocalUtilsZipResult = tOptional(tObject({}));
scheme.LocalUtilsHarOpenParams = tObject({
  file: tString
});
scheme.LocalUtilsHarOpenResult = tObject({
  harId: tOptional(tString),
  error: tOptional(tString)
});
scheme.LocalUtilsHarLookupParams = tObject({
  harId: tString,
  url: tString,
  method: tString,
  headers: tArray(tType("NameValue")),
  postData: tOptional(tBinary),
  isNavigationRequest: tBoolean
});
scheme.LocalUtilsHarLookupResult = tObject({
  action: tEnum(["error", "redirect", "fulfill", "noentry"]),
  message: tOptional(tString),
  redirectURL: tOptional(tString),
  status: tOptional(tNumber),
  headers: tOptional(tArray(tType("NameValue"))),
  body: tOptional(tBinary)
});
scheme.LocalUtilsHarCloseParams = tObject({
  harId: tString
});
scheme.LocalUtilsHarCloseResult = tOptional(tObject({}));
scheme.LocalUtilsHarUnzipParams = tObject({
  zipFile: tString,
  harFile: tString
});
scheme.LocalUtilsHarUnzipResult = tOptional(tObject({}));
scheme.LocalUtilsConnectParams = tObject({
  wsEndpoint: tString,
  headers: tOptional(tAny),
  exposeNetwork: tOptional(tString),
  slowMo: tOptional(tNumber),
  timeout: tOptional(tNumber),
  socksProxyRedirectPortForTest: tOptional(tNumber)
});
scheme.LocalUtilsConnectResult = tObject({
  pipe: tChannel(["JsonPipe"]),
  headers: tArray(tType("NameValue"))
});
scheme.LocalUtilsTracingStartedParams = tObject({
  tracesDir: tOptional(tString),
  traceName: tString
});
scheme.LocalUtilsTracingStartedResult = tObject({
  stacksId: tString
});
scheme.LocalUtilsAddStackToTracingNoReplyParams = tObject({
  callData: tType("ClientSideCallMetadata")
});
scheme.LocalUtilsAddStackToTracingNoReplyResult = tOptional(tObject({}));
scheme.LocalUtilsTraceDiscardedParams = tObject({
  stacksId: tString
});
scheme.LocalUtilsTraceDiscardedResult = tOptional(tObject({}));
scheme.LocalUtilsGlobToRegexParams = tObject({
  glob: tString,
  baseURL: tOptional(tString),
  webSocketUrl: tOptional(tBoolean)
});
scheme.LocalUtilsGlobToRegexResult = tObject({
  regex: tString
});
scheme.RootInitializer = tOptional(tObject({}));
scheme.RootInitializeParams = tObject({
  sdkLanguage: tEnum(["javascript", "python", "java", "csharp"])
});
scheme.RootInitializeResult = tObject({
  playwright: tChannel(["Playwright"])
});
scheme.PlaywrightInitializer = tObject({
  chromium: tChannel(["BrowserType"]),
  firefox: tChannel(["BrowserType"]),
  webkit: tChannel(["BrowserType"]),
  bidiChromium: tChannel(["BrowserType"]),
  bidiFirefox: tChannel(["BrowserType"]),
  android: tChannel(["Android"]),
  electron: tChannel(["Electron"]),
  utils: tOptional(tChannel(["LocalUtils"])),
  selectors: tChannel(["Selectors"]),
  preLaunchedBrowser: tOptional(tChannel(["Browser"])),
  preConnectedAndroidDevice: tOptional(tChannel(["AndroidDevice"])),
  socksSupport: tOptional(tChannel(["SocksSupport"]))
});
scheme.PlaywrightNewRequestParams = tObject({
  baseURL: tOptional(tString),
  userAgent: tOptional(tString),
  ignoreHTTPSErrors: tOptional(tBoolean),
  extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
  failOnStatusCode: tOptional(tBoolean),
  clientCertificates: tOptional(tArray(tObject({
    origin: tString,
    cert: tOptional(tBinary),
    key: tOptional(tBinary),
    passphrase: tOptional(tString),
    pfx: tOptional(tBinary)
  }))),
  maxRedirects: tOptional(tNumber),
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString),
    send: tOptional(tEnum(["always", "unauthorized"]))
  })),
  proxy: tOptional(tObject({
    server: tString,
    bypass: tOptional(tString),
    username: tOptional(tString),
    password: tOptional(tString)
  })),
  timeout: tOptional(tNumber),
  storageState: tOptional(tObject({
    cookies: tOptional(tArray(tType("NetworkCookie"))),
    origins: tOptional(tArray(tType("SetOriginStorage")))
  })),
  tracesDir: tOptional(tString)
});
scheme.PlaywrightNewRequestResult = tObject({
  request: tChannel(["APIRequestContext"])
});
scheme.RecorderSource = tObject({
  isRecorded: tBoolean,
  id: tString,
  label: tString,
  text: tString,
  language: tString,
  highlight: tArray(tObject({
    line: tNumber,
    type: tString
  })),
  revealLine: tOptional(tNumber),
  group: tOptional(tString)
});
scheme.DebugControllerInitializer = tOptional(tObject({}));
scheme.DebugControllerInspectRequestedEvent = tObject({
  selector: tString,
  locator: tString,
  ariaSnapshot: tString
});
scheme.DebugControllerSetModeRequestedEvent = tObject({
  mode: tString
});
scheme.DebugControllerStateChangedEvent = tObject({
  pageCount: tNumber
});
scheme.DebugControllerSourceChangedEvent = tObject({
  text: tString,
  header: tOptional(tString),
  footer: tOptional(tString),
  actions: tOptional(tArray(tString))
});
scheme.DebugControllerPausedEvent = tObject({
  paused: tBoolean
});
scheme.DebugControllerInitializeParams = tObject({
  codegenId: tString,
  sdkLanguage: tEnum(["javascript", "python", "java", "csharp"])
});
scheme.DebugControllerInitializeResult = tOptional(tObject({}));
scheme.DebugControllerSetReportStateChangedParams = tObject({
  enabled: tBoolean
});
scheme.DebugControllerSetReportStateChangedResult = tOptional(tObject({}));
scheme.DebugControllerResetForReuseParams = tOptional(tObject({}));
scheme.DebugControllerResetForReuseResult = tOptional(tObject({}));
scheme.DebugControllerNavigateParams = tObject({
  url: tString
});
scheme.DebugControllerNavigateResult = tOptional(tObject({}));
scheme.DebugControllerSetRecorderModeParams = tObject({
  mode: tEnum(["inspecting", "recording", "none"]),
  testIdAttributeName: tOptional(tString)
});
scheme.DebugControllerSetRecorderModeResult = tOptional(tObject({}));
scheme.DebugControllerHighlightParams = tObject({
  selector: tOptional(tString),
  ariaTemplate: tOptional(tString)
});
scheme.DebugControllerHighlightResult = tOptional(tObject({}));
scheme.DebugControllerHideHighlightParams = tOptional(tObject({}));
scheme.DebugControllerHideHighlightResult = tOptional(tObject({}));
scheme.DebugControllerResumeParams = tOptional(tObject({}));
scheme.DebugControllerResumeResult = tOptional(tObject({}));
scheme.DebugControllerKillParams = tOptional(tObject({}));
scheme.DebugControllerKillResult = tOptional(tObject({}));
scheme.DebugControllerCloseAllBrowsersParams = tOptional(tObject({}));
scheme.DebugControllerCloseAllBrowsersResult = tOptional(tObject({}));
scheme.SocksSupportInitializer = tOptional(tObject({}));
scheme.SocksSupportSocksRequestedEvent = tObject({
  uid: tString,
  host: tString,
  port: tNumber
});
scheme.SocksSupportSocksDataEvent = tObject({
  uid: tString,
  data: tBinary
});
scheme.SocksSupportSocksClosedEvent = tObject({
  uid: tString
});
scheme.SocksSupportSocksConnectedParams = tObject({
  uid: tString,
  host: tString,
  port: tNumber
});
scheme.SocksSupportSocksConnectedResult = tOptional(tObject({}));
scheme.SocksSupportSocksFailedParams = tObject({
  uid: tString,
  errorCode: tString
});
scheme.SocksSupportSocksFailedResult = tOptional(tObject({}));
scheme.SocksSupportSocksDataParams = tObject({
  uid: tString,
  data: tBinary
});
scheme.SocksSupportSocksDataResult = tOptional(tObject({}));
scheme.SocksSupportSocksErrorParams = tObject({
  uid: tString,
  error: tString
});
scheme.SocksSupportSocksErrorResult = tOptional(tObject({}));
scheme.SocksSupportSocksEndParams = tObject({
  uid: tString
});
scheme.SocksSupportSocksEndResult = tOptional(tObject({}));
scheme.SelectorsInitializer = tOptional(tObject({}));
scheme.SelectorsRegisterParams = tObject({
  name: tString,
  source: tString,
  contentScript: tOptional(tBoolean)
});
scheme.SelectorsRegisterResult = tOptional(tObject({}));
scheme.SelectorsSetTestIdAttributeNameParams = tObject({
  testIdAttributeName: tString
});
scheme.SelectorsSetTestIdAttributeNameResult = tOptional(tObject({}));
scheme.BrowserTypeInitializer = tObject({
  executablePath: tString,
  name: tString
});
scheme.BrowserTypeLaunchParams = tObject({
  channel: tOptional(tString),
  executablePath: tOptional(tString),
  args: tOptional(tArray(tString)),
  ignoreAllDefaultArgs: tOptional(tBoolean),
  ignoreDefaultArgs: tOptional(tArray(tString)),
  handleSIGINT: tOptional(tBoolean),
  handleSIGTERM: tOptional(tBoolean),
  handleSIGHUP: tOptional(tBoolean),
  timeout: tOptional(tNumber),
  env: tOptional(tArray(tType("NameValue"))),
  headless: tOptional(tBoolean),
  devtools: tOptional(tBoolean),
  proxy: tOptional(tObject({
    server: tString,
    bypass: tOptional(tString),
    username: tOptional(tString),
    password: tOptional(tString)
  })),
  downloadsPath: tOptional(tString),
  tracesDir: tOptional(tString),
  chromiumSandbox: tOptional(tBoolean),
  firefoxUserPrefs: tOptional(tAny),
  slowMo: tOptional(tNumber)
});
scheme.BrowserTypeLaunchResult = tObject({
  browser: tChannel(["Browser"])
});
scheme.BrowserTypeLaunchPersistentContextParams = tObject({
  channel: tOptional(tString),
  executablePath: tOptional(tString),
  args: tOptional(tArray(tString)),
  ignoreAllDefaultArgs: tOptional(tBoolean),
  ignoreDefaultArgs: tOptional(tArray(tString)),
  handleSIGINT: tOptional(tBoolean),
  handleSIGTERM: tOptional(tBoolean),
  handleSIGHUP: tOptional(tBoolean),
  timeout: tOptional(tNumber),
  env: tOptional(tArray(tType("NameValue"))),
  headless: tOptional(tBoolean),
  devtools: tOptional(tBoolean),
  proxy: tOptional(tObject({
    server: tString,
    bypass: tOptional(tString),
    username: tOptional(tString),
    password: tOptional(tString)
  })),
  downloadsPath: tOptional(tString),
  tracesDir: tOptional(tString),
  chromiumSandbox: tOptional(tBoolean),
  firefoxUserPrefs: tOptional(tAny),
  noDefaultViewport: tOptional(tBoolean),
  viewport: tOptional(tObject({
    width: tNumber,
    height: tNumber
  })),
  screen: tOptional(tObject({
    width: tNumber,
    height: tNumber
  })),
  ignoreHTTPSErrors: tOptional(tBoolean),
  clientCertificates: tOptional(tArray(tObject({
    origin: tString,
    cert: tOptional(tBinary),
    key: tOptional(tBinary),
    passphrase: tOptional(tString),
    pfx: tOptional(tBinary)
  }))),
  javaScriptEnabled: tOptional(tBoolean),
  bypassCSP: tOptional(tBoolean),
  userAgent: tOptional(tString),
  locale: tOptional(tString),
  timezoneId: tOptional(tString),
  geolocation: tOptional(tObject({
    longitude: tNumber,
    latitude: tNumber,
    accuracy: tOptional(tNumber)
  })),
  permissions: tOptional(tArray(tString)),
  extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
  offline: tOptional(tBoolean),
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString),
    send: tOptional(tEnum(["always", "unauthorized"]))
  })),
  deviceScaleFactor: tOptional(tNumber),
  isMobile: tOptional(tBoolean),
  hasTouch: tOptional(tBoolean),
  colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
  reducedMotion: tOptional(tEnum(["reduce", "no-preference", "no-override"])),
  forcedColors: tOptional(tEnum(["active", "none", "no-override"])),
  acceptDownloads: tOptional(tEnum(["accept", "deny", "internal-browser-default"])),
  contrast: tOptional(tEnum(["no-preference", "more", "no-override"])),
  baseURL: tOptional(tString),
  recordVideo: tOptional(tObject({
    dir: tString,
    size: tOptional(tObject({
      width: tNumber,
      height: tNumber
    }))
  })),
  recordHar: tOptional(tType("RecordHarOptions")),
  strictSelectors: tOptional(tBoolean),
  serviceWorkers: tOptional(tEnum(["allow", "block"])),
  userDataDir: tString,
  slowMo: tOptional(tNumber)
});
scheme.BrowserTypeLaunchPersistentContextResult = tObject({
  context: tChannel(["BrowserContext"])
});
scheme.BrowserTypeConnectOverCDPParams = tObject({
  endpointURL: tString,
  headers: tOptional(tArray(tType("NameValue"))),
  slowMo: tOptional(tNumber),
  timeout: tOptional(tNumber)
});
scheme.BrowserTypeConnectOverCDPResult = tObject({
  browser: tChannel(["Browser"]),
  defaultContext: tOptional(tChannel(["BrowserContext"]))
});
scheme.BrowserInitializer = tObject({
  version: tString,
  name: tString
});
scheme.BrowserCloseEvent = tOptional(tObject({}));
scheme.BrowserCloseParams = tObject({
  reason: tOptional(tString)
});
scheme.BrowserCloseResult = tOptional(tObject({}));
scheme.BrowserKillForTestsParams = tOptional(tObject({}));
scheme.BrowserKillForTestsResult = tOptional(tObject({}));
scheme.BrowserDefaultUserAgentForTestParams = tOptional(tObject({}));
scheme.BrowserDefaultUserAgentForTestResult = tObject({
  userAgent: tString
});
scheme.BrowserNewContextParams = tObject({
  noDefaultViewport: tOptional(tBoolean),
  viewport: tOptional(tObject({
    width: tNumber,
    height: tNumber
  })),
  screen: tOptional(tObject({
    width: tNumber,
    height: tNumber
  })),
  ignoreHTTPSErrors: tOptional(tBoolean),
  clientCertificates: tOptional(tArray(tObject({
    origin: tString,
    cert: tOptional(tBinary),
    key: tOptional(tBinary),
    passphrase: tOptional(tString),
    pfx: tOptional(tBinary)
  }))),
  javaScriptEnabled: tOptional(tBoolean),
  bypassCSP: tOptional(tBoolean),
  userAgent: tOptional(tString),
  locale: tOptional(tString),
  timezoneId: tOptional(tString),
  geolocation: tOptional(tObject({
    longitude: tNumber,
    latitude: tNumber,
    accuracy: tOptional(tNumber)
  })),
  permissions: tOptional(tArray(tString)),
  extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
  offline: tOptional(tBoolean),
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString),
    send: tOptional(tEnum(["always", "unauthorized"]))
  })),
  deviceScaleFactor: tOptional(tNumber),
  isMobile: tOptional(tBoolean),
  hasTouch: tOptional(tBoolean),
  colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
  reducedMotion: tOptional(tEnum(["reduce", "no-preference", "no-override"])),
  forcedColors: tOptional(tEnum(["active", "none", "no-override"])),
  acceptDownloads: tOptional(tEnum(["accept", "deny", "internal-browser-default"])),
  contrast: tOptional(tEnum(["no-preference", "more", "no-override"])),
  baseURL: tOptional(tString),
  recordVideo: tOptional(tObject({
    dir: tString,
    size: tOptional(tObject({
      width: tNumber,
      height: tNumber
    }))
  })),
  recordHar: tOptional(tType("RecordHarOptions")),
  strictSelectors: tOptional(tBoolean),
  serviceWorkers: tOptional(tEnum(["allow", "block"])),
  proxy: tOptional(tObject({
    server: tString,
    bypass: tOptional(tString),
    username: tOptional(tString),
    password: tOptional(tString)
  })),
  storageState: tOptional(tObject({
    cookies: tOptional(tArray(tType("SetNetworkCookie"))),
    origins: tOptional(tArray(tType("SetOriginStorage")))
  }))
});
scheme.BrowserNewContextResult = tObject({
  context: tChannel(["BrowserContext"])
});
scheme.BrowserNewContextForReuseParams = tObject({
  noDefaultViewport: tOptional(tBoolean),
  viewport: tOptional(tObject({
    width: tNumber,
    height: tNumber
  })),
  screen: tOptional(tObject({
    width: tNumber,
    height: tNumber
  })),
  ignoreHTTPSErrors: tOptional(tBoolean),
  clientCertificates: tOptional(tArray(tObject({
    origin: tString,
    cert: tOptional(tBinary),
    key: tOptional(tBinary),
    passphrase: tOptional(tString),
    pfx: tOptional(tBinary)
  }))),
  javaScriptEnabled: tOptional(tBoolean),
  bypassCSP: tOptional(tBoolean),
  userAgent: tOptional(tString),
  locale: tOptional(tString),
  timezoneId: tOptional(tString),
  geolocation: tOptional(tObject({
    longitude: tNumber,
    latitude: tNumber,
    accuracy: tOptional(tNumber)
  })),
  permissions: tOptional(tArray(tString)),
  extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
  offline: tOptional(tBoolean),
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString),
    send: tOptional(tEnum(["always", "unauthorized"]))
  })),
  deviceScaleFactor: tOptional(tNumber),
  isMobile: tOptional(tBoolean),
  hasTouch: tOptional(tBoolean),
  colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
  reducedMotion: tOptional(tEnum(["reduce", "no-preference", "no-override"])),
  forcedColors: tOptional(tEnum(["active", "none", "no-override"])),
  acceptDownloads: tOptional(tEnum(["accept", "deny", "internal-browser-default"])),
  contrast: tOptional(tEnum(["no-preference", "more", "no-override"])),
  baseURL: tOptional(tString),
  recordVideo: tOptional(tObject({
    dir: tString,
    size: tOptional(tObject({
      width: tNumber,
      height: tNumber
    }))
  })),
  recordHar: tOptional(tType("RecordHarOptions")),
  strictSelectors: tOptional(tBoolean),
  serviceWorkers: tOptional(tEnum(["allow", "block"])),
  proxy: tOptional(tObject({
    server: tString,
    bypass: tOptional(tString),
    username: tOptional(tString),
    password: tOptional(tString)
  })),
  storageState: tOptional(tObject({
    cookies: tOptional(tArray(tType("SetNetworkCookie"))),
    origins: tOptional(tArray(tType("SetOriginStorage")))
  }))
});
scheme.BrowserNewContextForReuseResult = tObject({
  context: tChannel(["BrowserContext"])
});
scheme.BrowserStopPendingOperationsParams = tObject({
  reason: tString
});
scheme.BrowserStopPendingOperationsResult = tOptional(tObject({}));
scheme.BrowserNewBrowserCDPSessionParams = tOptional(tObject({}));
scheme.BrowserNewBrowserCDPSessionResult = tObject({
  session: tChannel(["CDPSession"])
});
scheme.BrowserStartTracingParams = tObject({
  page: tOptional(tChannel(["Page"])),
  screenshots: tOptional(tBoolean),
  categories: tOptional(tArray(tString))
});
scheme.BrowserStartTracingResult = tOptional(tObject({}));
scheme.BrowserStopTracingParams = tOptional(tObject({}));
scheme.BrowserStopTracingResult = tObject({
  artifact: tChannel(["Artifact"])
});
scheme.EventTargetInitializer = tOptional(tObject({}));
scheme.EventTargetWaitForEventInfoParams = tObject({
  info: tObject({
    waitId: tString,
    phase: tEnum(["before", "after", "log"]),
    event: tOptional(tString),
    message: tOptional(tString),
    error: tOptional(tString)
  })
});
scheme.BrowserContextWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
scheme.PageWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
scheme.WebSocketWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
scheme.ElectronApplicationWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
scheme.AndroidDeviceWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
scheme.EventTargetWaitForEventInfoResult = tOptional(tObject({}));
scheme.BrowserContextWaitForEventInfoResult = tType("EventTargetWaitForEventInfoResult");
scheme.PageWaitForEventInfoResult = tType("EventTargetWaitForEventInfoResult");
scheme.WebSocketWaitForEventInfoResult = tType("EventTargetWaitForEventInfoResult");
scheme.ElectronApplicationWaitForEventInfoResult = tType("EventTargetWaitForEventInfoResult");
scheme.AndroidDeviceWaitForEventInfoResult = tType("EventTargetWaitForEventInfoResult");
scheme.BrowserContextInitializer = tObject({
  isChromium: tBoolean,
  requestContext: tChannel(["APIRequestContext"]),
  tracing: tChannel(["Tracing"])
});
scheme.BrowserContextBindingCallEvent = tObject({
  binding: tChannel(["BindingCall"])
});
scheme.BrowserContextConsoleEvent = tObject({
  type: tString,
  text: tString,
  args: tArray(tChannel(["ElementHandle", "JSHandle"])),
  location: tObject({
    url: tString,
    lineNumber: tNumber,
    columnNumber: tNumber
  }),
  page: tChannel(["Page"])
});
scheme.BrowserContextCloseEvent = tOptional(tObject({}));
scheme.BrowserContextDialogEvent = tObject({
  dialog: tChannel(["Dialog"])
});
scheme.BrowserContextPageEvent = tObject({
  page: tChannel(["Page"])
});
scheme.BrowserContextPageErrorEvent = tObject({
  error: tType("SerializedError"),
  page: tChannel(["Page"])
});
scheme.BrowserContextRouteEvent = tObject({
  route: tChannel(["Route"])
});
scheme.BrowserContextWebSocketRouteEvent = tObject({
  webSocketRoute: tChannel(["WebSocketRoute"])
});
scheme.BrowserContextVideoEvent = tObject({
  artifact: tChannel(["Artifact"])
});
scheme.BrowserContextBackgroundPageEvent = tObject({
  page: tChannel(["Page"])
});
scheme.BrowserContextServiceWorkerEvent = tObject({
  worker: tChannel(["Worker"])
});
scheme.BrowserContextRequestEvent = tObject({
  request: tChannel(["Request"]),
  page: tOptional(tChannel(["Page"]))
});
scheme.BrowserContextRequestFailedEvent = tObject({
  request: tChannel(["Request"]),
  failureText: tOptional(tString),
  responseEndTiming: tNumber,
  page: tOptional(tChannel(["Page"]))
});
scheme.BrowserContextRequestFinishedEvent = tObject({
  request: tChannel(["Request"]),
  response: tOptional(tChannel(["Response"])),
  responseEndTiming: tNumber,
  page: tOptional(tChannel(["Page"]))
});
scheme.BrowserContextResponseEvent = tObject({
  response: tChannel(["Response"]),
  page: tOptional(tChannel(["Page"]))
});
scheme.BrowserContextAddCookiesParams = tObject({
  cookies: tArray(tType("SetNetworkCookie"))
});
scheme.BrowserContextAddCookiesResult = tOptional(tObject({}));
scheme.BrowserContextAddInitScriptParams = tObject({
  source: tString
});
scheme.BrowserContextAddInitScriptResult = tOptional(tObject({}));
scheme.BrowserContextClearCookiesParams = tObject({
  name: tOptional(tString),
  nameRegexSource: tOptional(tString),
  nameRegexFlags: tOptional(tString),
  domain: tOptional(tString),
  domainRegexSource: tOptional(tString),
  domainRegexFlags: tOptional(tString),
  path: tOptional(tString),
  pathRegexSource: tOptional(tString),
  pathRegexFlags: tOptional(tString)
});
scheme.BrowserContextClearCookiesResult = tOptional(tObject({}));
scheme.BrowserContextClearPermissionsParams = tOptional(tObject({}));
scheme.BrowserContextClearPermissionsResult = tOptional(tObject({}));
scheme.BrowserContextCloseParams = tObject({
  reason: tOptional(tString)
});
scheme.BrowserContextCloseResult = tOptional(tObject({}));
scheme.BrowserContextCookiesParams = tObject({
  urls: tArray(tString)
});
scheme.BrowserContextCookiesResult = tObject({
  cookies: tArray(tType("NetworkCookie"))
});
scheme.BrowserContextExposeBindingParams = tObject({
  name: tString,
  needsHandle: tOptional(tBoolean)
});
scheme.BrowserContextExposeBindingResult = tOptional(tObject({}));
scheme.BrowserContextGrantPermissionsParams = tObject({
  permissions: tArray(tString),
  origin: tOptional(tString)
});
scheme.BrowserContextGrantPermissionsResult = tOptional(tObject({}));
scheme.BrowserContextNewPageParams = tOptional(tObject({}));
scheme.BrowserContextNewPageResult = tObject({
  page: tChannel(["Page"])
});
scheme.BrowserContextSetDefaultNavigationTimeoutNoReplyParams = tObject({
  timeout: tOptional(tNumber)
});
scheme.BrowserContextSetDefaultNavigationTimeoutNoReplyResult = tOptional(tObject({}));
scheme.BrowserContextSetDefaultTimeoutNoReplyParams = tObject({
  timeout: tOptional(tNumber)
});
scheme.BrowserContextSetDefaultTimeoutNoReplyResult = tOptional(tObject({}));
scheme.BrowserContextSetExtraHTTPHeadersParams = tObject({
  headers: tArray(tType("NameValue"))
});
scheme.BrowserContextSetExtraHTTPHeadersResult = tOptional(tObject({}));
scheme.BrowserContextSetGeolocationParams = tObject({
  geolocation: tOptional(tObject({
    longitude: tNumber,
    latitude: tNumber,
    accuracy: tOptional(tNumber)
  }))
});
scheme.BrowserContextSetGeolocationResult = tOptional(tObject({}));
scheme.BrowserContextSetHTTPCredentialsParams = tObject({
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString)
  }))
});
scheme.BrowserContextSetHTTPCredentialsResult = tOptional(tObject({}));
scheme.BrowserContextSetNetworkInterceptionPatternsParams = tObject({
  patterns: tArray(tObject({
    glob: tOptional(tString),
    regexSource: tOptional(tString),
    regexFlags: tOptional(tString)
  }))
});
scheme.BrowserContextSetNetworkInterceptionPatternsResult = tOptional(tObject({}));
scheme.BrowserContextSetWebSocketInterceptionPatternsParams = tObject({
  patterns: tArray(tObject({
    glob: tOptional(tString),
    regexSource: tOptional(tString),
    regexFlags: tOptional(tString)
  }))
});
scheme.BrowserContextSetWebSocketInterceptionPatternsResult = tOptional(tObject({}));
scheme.BrowserContextSetOfflineParams = tObject({
  offline: tBoolean
});
scheme.BrowserContextSetOfflineResult = tOptional(tObject({}));
scheme.BrowserContextStorageStateParams = tObject({
  indexedDB: tOptional(tBoolean)
});
scheme.BrowserContextStorageStateResult = tObject({
  cookies: tArray(tType("NetworkCookie")),
  origins: tArray(tType("OriginStorage"))
});
scheme.BrowserContextPauseParams = tOptional(tObject({}));
scheme.BrowserContextPauseResult = tOptional(tObject({}));
scheme.BrowserContextEnableRecorderParams = tObject({
  language: tOptional(tString),
  mode: tOptional(tEnum(["inspecting", "recording"])),
  pauseOnNextStatement: tOptional(tBoolean),
  testIdAttributeName: tOptional(tString),
  launchOptions: tOptional(tAny),
  contextOptions: tOptional(tAny),
  device: tOptional(tString),
  saveStorage: tOptional(tString),
  outputFile: tOptional(tString),
  handleSIGINT: tOptional(tBoolean),
  omitCallTracking: tOptional(tBoolean)
});
scheme.BrowserContextEnableRecorderResult = tOptional(tObject({}));
scheme.BrowserContextNewCDPSessionParams = tObject({
  page: tOptional(tChannel(["Page"])),
  frame: tOptional(tChannel(["Frame"]))
});
scheme.BrowserContextNewCDPSessionResult = tObject({
  session: tChannel(["CDPSession"])
});
scheme.BrowserContextHarStartParams = tObject({
  page: tOptional(tChannel(["Page"])),
  options: tType("RecordHarOptions")
});
scheme.BrowserContextHarStartResult = tObject({
  harId: tString
});
scheme.BrowserContextHarExportParams = tObject({
  harId: tOptional(tString)
});
scheme.BrowserContextHarExportResult = tObject({
  artifact: tChannel(["Artifact"])
});
scheme.BrowserContextCreateTempFilesParams = tObject({
  rootDirName: tOptional(tString),
  items: tArray(tObject({
    name: tString,
    lastModifiedMs: tOptional(tNumber)
  }))
});
scheme.BrowserContextCreateTempFilesResult = tObject({
  rootDir: tOptional(tChannel(["WritableStream"])),
  writableStreams: tArray(tChannel(["WritableStream"]))
});
scheme.BrowserContextUpdateSubscriptionParams = tObject({
  event: tEnum(["console", "dialog", "request", "response", "requestFinished", "requestFailed"]),
  enabled: tBoolean
});
scheme.BrowserContextUpdateSubscriptionResult = tOptional(tObject({}));
scheme.BrowserContextClockFastForwardParams = tObject({
  ticksNumber: tOptional(tNumber),
  ticksString: tOptional(tString)
});
scheme.BrowserContextClockFastForwardResult = tOptional(tObject({}));
scheme.BrowserContextClockInstallParams = tObject({
  timeNumber: tOptional(tNumber),
  timeString: tOptional(tString)
});
scheme.BrowserContextClockInstallResult = tOptional(tObject({}));
scheme.BrowserContextClockPauseAtParams = tObject({
  timeNumber: tOptional(tNumber),
  timeString: tOptional(tString)
});
scheme.BrowserContextClockPauseAtResult = tOptional(tObject({}));
scheme.BrowserContextClockResumeParams = tOptional(tObject({}));
scheme.BrowserContextClockResumeResult = tOptional(tObject({}));
scheme.BrowserContextClockRunForParams = tObject({
  ticksNumber: tOptional(tNumber),
  ticksString: tOptional(tString)
});
scheme.BrowserContextClockRunForResult = tOptional(tObject({}));
scheme.BrowserContextClockSetFixedTimeParams = tObject({
  timeNumber: tOptional(tNumber),
  timeString: tOptional(tString)
});
scheme.BrowserContextClockSetFixedTimeResult = tOptional(tObject({}));
scheme.BrowserContextClockSetSystemTimeParams = tObject({
  timeNumber: tOptional(tNumber),
  timeString: tOptional(tString)
});
scheme.BrowserContextClockSetSystemTimeResult = tOptional(tObject({}));
scheme.PageInitializer = tObject({
  mainFrame: tChannel(["Frame"]),
  viewportSize: tOptional(tObject({
    width: tNumber,
    height: tNumber
  })),
  isClosed: tBoolean,
  opener: tOptional(tChannel(["Page"]))
});
scheme.PageBindingCallEvent = tObject({
  binding: tChannel(["BindingCall"])
});
scheme.PageCloseEvent = tOptional(tObject({}));
scheme.PageCrashEvent = tOptional(tObject({}));
scheme.PageDownloadEvent = tObject({
  url: tString,
  suggestedFilename: tString,
  artifact: tChannel(["Artifact"])
});
scheme.PageFileChooserEvent = tObject({
  element: tChannel(["ElementHandle"]),
  isMultiple: tBoolean
});
scheme.PageFrameAttachedEvent = tObject({
  frame: tChannel(["Frame"])
});
scheme.PageFrameDetachedEvent = tObject({
  frame: tChannel(["Frame"])
});
scheme.PageLocatorHandlerTriggeredEvent = tObject({
  uid: tNumber
});
scheme.PageRouteEvent = tObject({
  route: tChannel(["Route"])
});
scheme.PageWebSocketRouteEvent = tObject({
  webSocketRoute: tChannel(["WebSocketRoute"])
});
scheme.PageVideoEvent = tObject({
  artifact: tChannel(["Artifact"])
});
scheme.PageWebSocketEvent = tObject({
  webSocket: tChannel(["WebSocket"])
});
scheme.PageWorkerEvent = tObject({
  worker: tChannel(["Worker"])
});
scheme.PageSetDefaultNavigationTimeoutNoReplyParams = tObject({
  timeout: tOptional(tNumber)
});
scheme.PageSetDefaultNavigationTimeoutNoReplyResult = tOptional(tObject({}));
scheme.PageSetDefaultTimeoutNoReplyParams = tObject({
  timeout: tOptional(tNumber)
});
scheme.PageSetDefaultTimeoutNoReplyResult = tOptional(tObject({}));
scheme.PageAddInitScriptParams = tObject({
  source: tString
});
scheme.PageAddInitScriptResult = tOptional(tObject({}));
scheme.PageCloseParams = tObject({
  runBeforeUnload: tOptional(tBoolean),
  reason: tOptional(tString)
});
scheme.PageCloseResult = tOptional(tObject({}));
scheme.PageEmulateMediaParams = tObject({
  media: tOptional(tEnum(["screen", "print", "no-override"])),
  colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
  reducedMotion: tOptional(tEnum(["reduce", "no-preference", "no-override"])),
  forcedColors: tOptional(tEnum(["active", "none", "no-override"])),
  contrast: tOptional(tEnum(["no-preference", "more", "no-override"]))
});
scheme.PageEmulateMediaResult = tOptional(tObject({}));
scheme.PageExposeBindingParams = tObject({
  name: tString,
  needsHandle: tOptional(tBoolean)
});
scheme.PageExposeBindingResult = tOptional(tObject({}));
scheme.PageGoBackParams = tObject({
  timeout: tOptional(tNumber),
  waitUntil: tOptional(tType("LifecycleEvent"))
});
scheme.PageGoBackResult = tObject({
  response: tOptional(tChannel(["Response"]))
});
scheme.PageGoForwardParams = tObject({
  timeout: tOptional(tNumber),
  waitUntil: tOptional(tType("LifecycleEvent"))
});
scheme.PageGoForwardResult = tObject({
  response: tOptional(tChannel(["Response"]))
});
scheme.PageRequestGCParams = tOptional(tObject({}));
scheme.PageRequestGCResult = tOptional(tObject({}));
scheme.PageRegisterLocatorHandlerParams = tObject({
  selector: tString,
  noWaitAfter: tOptional(tBoolean)
});
scheme.PageRegisterLocatorHandlerResult = tObject({
  uid: tNumber
});
scheme.PageResolveLocatorHandlerNoReplyParams = tObject({
  uid: tNumber,
  remove: tOptional(tBoolean)
});
scheme.PageResolveLocatorHandlerNoReplyResult = tOptional(tObject({}));
scheme.PageUnregisterLocatorHandlerParams = tObject({
  uid: tNumber
});
scheme.PageUnregisterLocatorHandlerResult = tOptional(tObject({}));
scheme.PageReloadParams = tObject({
  timeout: tOptional(tNumber),
  waitUntil: tOptional(tType("LifecycleEvent"))
});
scheme.PageReloadResult = tObject({
  response: tOptional(tChannel(["Response"]))
});
scheme.PageExpectScreenshotParams = tObject({
  expected: tOptional(tBinary),
  timeout: tNumber,
  isNot: tBoolean,
  locator: tOptional(tObject({
    frame: tChannel(["Frame"]),
    selector: tString
  })),
  comparator: tOptional(tString),
  maxDiffPixels: tOptional(tNumber),
  maxDiffPixelRatio: tOptional(tNumber),
  threshold: tOptional(tNumber),
  fullPage: tOptional(tBoolean),
  clip: tOptional(tType("Rect")),
  omitBackground: tOptional(tBoolean),
  caret: tOptional(tEnum(["hide", "initial"])),
  animations: tOptional(tEnum(["disabled", "allow"])),
  scale: tOptional(tEnum(["css", "device"])),
  mask: tOptional(tArray(tObject({
    frame: tChannel(["Frame"]),
    selector: tString
  }))),
  maskColor: tOptional(tString),
  style: tOptional(tString)
});
scheme.PageExpectScreenshotResult = tObject({
  diff: tOptional(tBinary),
  errorMessage: tOptional(tString),
  actual: tOptional(tBinary),
  previous: tOptional(tBinary),
  timedOut: tOptional(tBoolean),
  log: tOptional(tArray(tString))
});
scheme.PageScreenshotParams = tObject({
  timeout: tOptional(tNumber),
  type: tOptional(tEnum(["png", "jpeg"])),
  quality: tOptional(tNumber),
  fullPage: tOptional(tBoolean),
  clip: tOptional(tType("Rect")),
  omitBackground: tOptional(tBoolean),
  caret: tOptional(tEnum(["hide", "initial"])),
  animations: tOptional(tEnum(["disabled", "allow"])),
  scale: tOptional(tEnum(["css", "device"])),
  mask: tOptional(tArray(tObject({
    frame: tChannel(["Frame"]),
    selector: tString
  }))),
  maskColor: tOptional(tString),
  style: tOptional(tString)
});
scheme.PageScreenshotResult = tObject({
  binary: tBinary
});
scheme.PageSetExtraHTTPHeadersParams = tObject({
  headers: tArray(tType("NameValue"))
});
scheme.PageSetExtraHTTPHeadersResult = tOptional(tObject({}));
scheme.PageSetNetworkInterceptionPatternsParams = tObject({
  patterns: tArray(tObject({
    glob: tOptional(tString),
    regexSource: tOptional(tString),
    regexFlags: tOptional(tString)
  }))
});
scheme.PageSetNetworkInterceptionPatternsResult = tOptional(tObject({}));
scheme.PageSetWebSocketInterceptionPatternsParams = tObject({
  patterns: tArray(tObject({
    glob: tOptional(tString),
    regexSource: tOptional(tString),
    regexFlags: tOptional(tString)
  }))
});
scheme.PageSetWebSocketInterceptionPatternsResult = tOptional(tObject({}));
scheme.PageSetViewportSizeParams = tObject({
  viewportSize: tObject({
    width: tNumber,
    height: tNumber
  })
});
scheme.PageSetViewportSizeResult = tOptional(tObject({}));
scheme.PageKeyboardDownParams = tObject({
  key: tString
});
scheme.PageKeyboardDownResult = tOptional(tObject({}));
scheme.PageKeyboardUpParams = tObject({
  key: tString
});
scheme.PageKeyboardUpResult = tOptional(tObject({}));
scheme.PageKeyboardInsertTextParams = tObject({
  text: tString
});
scheme.PageKeyboardInsertTextResult = tOptional(tObject({}));
scheme.PageKeyboardTypeParams = tObject({
  text: tString,
  delay: tOptional(tNumber)
});
scheme.PageKeyboardTypeResult = tOptional(tObject({}));
scheme.PageKeyboardPressParams = tObject({
  key: tString,
  delay: tOptional(tNumber)
});
scheme.PageKeyboardPressResult = tOptional(tObject({}));
scheme.PageMouseMoveParams = tObject({
  x: tNumber,
  y: tNumber,
  steps: tOptional(tNumber)
});
scheme.PageMouseMoveResult = tOptional(tObject({}));
scheme.PageMouseDownParams = tObject({
  button: tOptional(tEnum(["left", "right", "middle"])),
  clickCount: tOptional(tNumber)
});
scheme.PageMouseDownResult = tOptional(tObject({}));
scheme.PageMouseUpParams = tObject({
  button: tOptional(tEnum(["left", "right", "middle"])),
  clickCount: tOptional(tNumber)
});
scheme.PageMouseUpResult = tOptional(tObject({}));
scheme.PageMouseClickParams = tObject({
  x: tNumber,
  y: tNumber,
  delay: tOptional(tNumber),
  button: tOptional(tEnum(["left", "right", "middle"])),
  clickCount: tOptional(tNumber)
});
scheme.PageMouseClickResult = tOptional(tObject({}));
scheme.PageMouseWheelParams = tObject({
  deltaX: tNumber,
  deltaY: tNumber
});
scheme.PageMouseWheelResult = tOptional(tObject({}));
scheme.PageTouchscreenTapParams = tObject({
  x: tNumber,
  y: tNumber
});
scheme.PageTouchscreenTapResult = tOptional(tObject({}));
scheme.PageAccessibilitySnapshotParams = tObject({
  interestingOnly: tOptional(tBoolean),
  root: tOptional(tChannel(["ElementHandle"]))
});
scheme.PageAccessibilitySnapshotResult = tObject({
  rootAXNode: tOptional(tType("AXNode"))
});
scheme.PagePdfParams = tObject({
  scale: tOptional(tNumber),
  displayHeaderFooter: tOptional(tBoolean),
  headerTemplate: tOptional(tString),
  footerTemplate: tOptional(tString),
  printBackground: tOptional(tBoolean),
  landscape: tOptional(tBoolean),
  pageRanges: tOptional(tString),
  format: tOptional(tString),
  width: tOptional(tString),
  height: tOptional(tString),
  preferCSSPageSize: tOptional(tBoolean),
  margin: tOptional(tObject({
    top: tOptional(tString),
    bottom: tOptional(tString),
    left: tOptional(tString),
    right: tOptional(tString)
  })),
  tagged: tOptional(tBoolean),
  outline: tOptional(tBoolean)
});
scheme.PagePdfResult = tObject({
  pdf: tBinary
});
scheme.PageStartJSCoverageParams = tObject({
  resetOnNavigation: tOptional(tBoolean),
  reportAnonymousScripts: tOptional(tBoolean)
});
scheme.PageStartJSCoverageResult = tOptional(tObject({}));
scheme.PageStopJSCoverageParams = tOptional(tObject({}));
scheme.PageStopJSCoverageResult = tObject({
  entries: tArray(tObject({
    url: tString,
    scriptId: tString,
    source: tOptional(tString),
    functions: tArray(tObject({
      functionName: tString,
      isBlockCoverage: tBoolean,
      ranges: tArray(tObject({
        startOffset: tNumber,
        endOffset: tNumber,
        count: tNumber
      }))
    }))
  }))
});
scheme.PageStartCSSCoverageParams = tObject({
  resetOnNavigation: tOptional(tBoolean)
});
scheme.PageStartCSSCoverageResult = tOptional(tObject({}));
scheme.PageStopCSSCoverageParams = tOptional(tObject({}));
scheme.PageStopCSSCoverageResult = tObject({
  entries: tArray(tObject({
    url: tString,
    text: tOptional(tString),
    ranges: tArray(tObject({
      start: tNumber,
      end: tNumber
    }))
  }))
});
scheme.PageBringToFrontParams = tOptional(tObject({}));
scheme.PageBringToFrontResult = tOptional(tObject({}));
scheme.PageUpdateSubscriptionParams = tObject({
  event: tEnum(["console", "dialog", "fileChooser", "request", "response", "requestFinished", "requestFailed"]),
  enabled: tBoolean
});
scheme.PageUpdateSubscriptionResult = tOptional(tObject({}));
scheme.FrameInitializer = tObject({
  url: tString,
  name: tString,
  parentFrame: tOptional(tChannel(["Frame"])),
  loadStates: tArray(tType("LifecycleEvent"))
});
scheme.FrameLoadstateEvent = tObject({
  add: tOptional(tType("LifecycleEvent")),
  remove: tOptional(tType("LifecycleEvent"))
});
scheme.FrameNavigatedEvent = tObject({
  url: tString,
  name: tString,
  newDocument: tOptional(tObject({
    request: tOptional(tChannel(["Request"]))
  })),
  error: tOptional(tString)
});
scheme.FrameEvalOnSelectorParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.FrameEvalOnSelectorResult = tObject({
  value: tType("SerializedValue")
});
scheme.FrameEvalOnSelectorAllParams = tObject({
  selector: tString,
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.FrameEvalOnSelectorAllResult = tObject({
  value: tType("SerializedValue")
});
scheme.FrameAddScriptTagParams = tObject({
  url: tOptional(tString),
  content: tOptional(tString),
  type: tOptional(tString)
});
scheme.FrameAddScriptTagResult = tObject({
  element: tChannel(["ElementHandle"])
});
scheme.FrameAddStyleTagParams = tObject({
  url: tOptional(tString),
  content: tOptional(tString)
});
scheme.FrameAddStyleTagResult = tObject({
  element: tChannel(["ElementHandle"])
});
scheme.FrameAriaSnapshotParams = tObject({
  selector: tString,
  ref: tOptional(tBoolean),
  emitGeneric: tOptional(tBoolean),
  mode: tOptional(tEnum(["raw", "regex"])),
  timeout: tOptional(tNumber)
});
scheme.FrameAriaSnapshotResult = tObject({
  snapshot: tString
});
scheme.FrameBlurParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FrameBlurResult = tOptional(tObject({}));
scheme.FrameCheckParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  force: tOptional(tBoolean),
  position: tOptional(tType("Point")),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean)
});
scheme.FrameCheckResult = tOptional(tObject({}));
scheme.FrameClickParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  force: tOptional(tBoolean),
  noWaitAfter: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  delay: tOptional(tNumber),
  button: tOptional(tEnum(["left", "right", "middle"])),
  clickCount: tOptional(tNumber),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean)
});
scheme.FrameClickResult = tOptional(tObject({}));
scheme.FrameContentParams = tOptional(tObject({}));
scheme.FrameContentResult = tObject({
  value: tString
});
scheme.FrameDragAndDropParams = tObject({
  source: tString,
  target: tString,
  force: tOptional(tBoolean),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean),
  sourcePosition: tOptional(tType("Point")),
  targetPosition: tOptional(tType("Point")),
  strict: tOptional(tBoolean)
});
scheme.FrameDragAndDropResult = tOptional(tObject({}));
scheme.FrameDblclickParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  force: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  delay: tOptional(tNumber),
  button: tOptional(tEnum(["left", "right", "middle"])),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean)
});
scheme.FrameDblclickResult = tOptional(tObject({}));
scheme.FrameDispatchEventParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  type: tString,
  eventInit: tType("SerializedArgument"),
  timeout: tOptional(tNumber)
});
scheme.FrameDispatchEventResult = tOptional(tObject({}));
scheme.FrameEvaluateExpressionParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.FrameEvaluateExpressionResult = tObject({
  value: tType("SerializedValue")
});
scheme.FrameEvaluateExpressionHandleParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.FrameEvaluateExpressionHandleResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.FrameFillParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  value: tString,
  force: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FrameFillResult = tOptional(tObject({}));
scheme.FrameFocusParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FrameFocusResult = tOptional(tObject({}));
scheme.FrameFrameElementParams = tOptional(tObject({}));
scheme.FrameFrameElementResult = tObject({
  element: tChannel(["ElementHandle"])
});
scheme.FrameHighlightParams = tObject({
  selector: tString
});
scheme.FrameHighlightResult = tOptional(tObject({}));
scheme.FrameGetAttributeParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  name: tString,
  timeout: tOptional(tNumber)
});
scheme.FrameGetAttributeResult = tObject({
  value: tOptional(tString)
});
scheme.FrameGotoParams = tObject({
  url: tString,
  timeout: tOptional(tNumber),
  waitUntil: tOptional(tType("LifecycleEvent")),
  referer: tOptional(tString)
});
scheme.FrameGotoResult = tObject({
  response: tOptional(tChannel(["Response"]))
});
scheme.FrameHoverParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  force: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean)
});
scheme.FrameHoverResult = tOptional(tObject({}));
scheme.FrameInnerHTMLParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FrameInnerHTMLResult = tObject({
  value: tString
});
scheme.FrameInnerTextParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FrameInnerTextResult = tObject({
  value: tString
});
scheme.FrameInputValueParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FrameInputValueResult = tObject({
  value: tString
});
scheme.FrameIsCheckedParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FrameIsCheckedResult = tObject({
  value: tBoolean
});
scheme.FrameIsDisabledParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FrameIsDisabledResult = tObject({
  value: tBoolean
});
scheme.FrameIsEnabledParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FrameIsEnabledResult = tObject({
  value: tBoolean
});
scheme.FrameIsHiddenParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean)
});
scheme.FrameIsHiddenResult = tObject({
  value: tBoolean
});
scheme.FrameIsVisibleParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean)
});
scheme.FrameIsVisibleResult = tObject({
  value: tBoolean
});
scheme.FrameIsEditableParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FrameIsEditableResult = tObject({
  value: tBoolean
});
scheme.FramePressParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  key: tString,
  delay: tOptional(tNumber),
  noWaitAfter: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FramePressResult = tOptional(tObject({}));
scheme.FrameQuerySelectorParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean)
});
scheme.FrameQuerySelectorResult = tObject({
  element: tOptional(tChannel(["ElementHandle"]))
});
scheme.FrameQuerySelectorAllParams = tObject({
  selector: tString
});
scheme.FrameQuerySelectorAllResult = tObject({
  elements: tArray(tChannel(["ElementHandle"]))
});
scheme.FrameQueryCountParams = tObject({
  selector: tString
});
scheme.FrameQueryCountResult = tObject({
  value: tNumber
});
scheme.FrameSelectOptionParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  elements: tOptional(tArray(tChannel(["ElementHandle"]))),
  options: tOptional(tArray(tObject({
    valueOrLabel: tOptional(tString),
    value: tOptional(tString),
    label: tOptional(tString),
    index: tOptional(tNumber)
  }))),
  force: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FrameSelectOptionResult = tObject({
  values: tArray(tString)
});
scheme.FrameSetContentParams = tObject({
  html: tString,
  timeout: tOptional(tNumber),
  waitUntil: tOptional(tType("LifecycleEvent"))
});
scheme.FrameSetContentResult = tOptional(tObject({}));
scheme.FrameSetInputFilesParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  payloads: tOptional(tArray(tObject({
    name: tString,
    mimeType: tOptional(tString),
    buffer: tBinary
  }))),
  localDirectory: tOptional(tString),
  directoryStream: tOptional(tChannel(["WritableStream"])),
  localPaths: tOptional(tArray(tString)),
  streams: tOptional(tArray(tChannel(["WritableStream"]))),
  timeout: tOptional(tNumber)
});
scheme.FrameSetInputFilesResult = tOptional(tObject({}));
scheme.FrameTapParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  force: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean)
});
scheme.FrameTapResult = tOptional(tObject({}));
scheme.FrameTextContentParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.FrameTextContentResult = tObject({
  value: tOptional(tString)
});
scheme.FrameTitleParams = tOptional(tObject({}));
scheme.FrameTitleResult = tObject({
  value: tString
});
scheme.FrameTypeParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  text: tString,
  delay: tOptional(tNumber),
  timeout: tOptional(tNumber)
});
scheme.FrameTypeResult = tOptional(tObject({}));
scheme.FrameUncheckParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  force: tOptional(tBoolean),
  position: tOptional(tType("Point")),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean)
});
scheme.FrameUncheckResult = tOptional(tObject({}));
scheme.FrameWaitForTimeoutParams = tObject({
  timeout: tNumber
});
scheme.FrameWaitForTimeoutResult = tOptional(tObject({}));
scheme.FrameWaitForFunctionParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument"),
  timeout: tOptional(tNumber),
  pollingInterval: tOptional(tNumber)
});
scheme.FrameWaitForFunctionResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.FrameWaitForSelectorParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tOptional(tNumber),
  state: tOptional(tEnum(["attached", "detached", "visible", "hidden"])),
  omitReturnValue: tOptional(tBoolean)
});
scheme.FrameWaitForSelectorResult = tObject({
  element: tOptional(tChannel(["ElementHandle"]))
});
scheme.FrameExpectParams = tObject({
  selector: tString,
  expression: tString,
  expressionArg: tOptional(tAny),
  expectedText: tOptional(tArray(tType("ExpectedTextValue"))),
  expectedNumber: tOptional(tNumber),
  expectedValue: tOptional(tType("SerializedArgument")),
  useInnerText: tOptional(tBoolean),
  isNot: tBoolean,
  timeout: tNumber
});
scheme.FrameExpectResult = tObject({
  matches: tBoolean,
  received: tOptional(tType("SerializedValue")),
  timedOut: tOptional(tBoolean),
  log: tOptional(tArray(tString))
});
scheme.WorkerInitializer = tObject({
  url: tString
});
scheme.WorkerCloseEvent = tOptional(tObject({}));
scheme.WorkerEvaluateExpressionParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.WorkerEvaluateExpressionResult = tObject({
  value: tType("SerializedValue")
});
scheme.WorkerEvaluateExpressionHandleParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.WorkerEvaluateExpressionHandleResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.JSHandleInitializer = tObject({
  preview: tString
});
scheme.JSHandlePreviewUpdatedEvent = tObject({
  preview: tString
});
scheme.ElementHandlePreviewUpdatedEvent = tType("JSHandlePreviewUpdatedEvent");
scheme.JSHandleDisposeParams = tOptional(tObject({}));
scheme.ElementHandleDisposeParams = tType("JSHandleDisposeParams");
scheme.JSHandleDisposeResult = tOptional(tObject({}));
scheme.ElementHandleDisposeResult = tType("JSHandleDisposeResult");
scheme.JSHandleEvaluateExpressionParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.ElementHandleEvaluateExpressionParams = tType("JSHandleEvaluateExpressionParams");
scheme.JSHandleEvaluateExpressionResult = tObject({
  value: tType("SerializedValue")
});
scheme.ElementHandleEvaluateExpressionResult = tType("JSHandleEvaluateExpressionResult");
scheme.JSHandleEvaluateExpressionHandleParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.ElementHandleEvaluateExpressionHandleParams = tType("JSHandleEvaluateExpressionHandleParams");
scheme.JSHandleEvaluateExpressionHandleResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.ElementHandleEvaluateExpressionHandleResult = tType("JSHandleEvaluateExpressionHandleResult");
scheme.JSHandleGetPropertyListParams = tOptional(tObject({}));
scheme.ElementHandleGetPropertyListParams = tType("JSHandleGetPropertyListParams");
scheme.JSHandleGetPropertyListResult = tObject({
  properties: tArray(tObject({
    name: tString,
    value: tChannel(["ElementHandle", "JSHandle"])
  }))
});
scheme.ElementHandleGetPropertyListResult = tType("JSHandleGetPropertyListResult");
scheme.JSHandleGetPropertyParams = tObject({
  name: tString
});
scheme.ElementHandleGetPropertyParams = tType("JSHandleGetPropertyParams");
scheme.JSHandleGetPropertyResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.ElementHandleGetPropertyResult = tType("JSHandleGetPropertyResult");
scheme.JSHandleJsonValueParams = tOptional(tObject({}));
scheme.ElementHandleJsonValueParams = tType("JSHandleJsonValueParams");
scheme.JSHandleJsonValueResult = tObject({
  value: tType("SerializedValue")
});
scheme.ElementHandleJsonValueResult = tType("JSHandleJsonValueResult");
scheme.ElementHandleInitializer = tObject({
  preview: tString
});
scheme.ElementHandleEvalOnSelectorParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.ElementHandleEvalOnSelectorResult = tObject({
  value: tType("SerializedValue")
});
scheme.ElementHandleEvalOnSelectorAllParams = tObject({
  selector: tString,
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.ElementHandleEvalOnSelectorAllResult = tObject({
  value: tType("SerializedValue")
});
scheme.ElementHandleBoundingBoxParams = tOptional(tObject({}));
scheme.ElementHandleBoundingBoxResult = tObject({
  value: tOptional(tType("Rect"))
});
scheme.ElementHandleCheckParams = tObject({
  force: tOptional(tBoolean),
  position: tOptional(tType("Point")),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean)
});
scheme.ElementHandleCheckResult = tOptional(tObject({}));
scheme.ElementHandleClickParams = tObject({
  force: tOptional(tBoolean),
  noWaitAfter: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  delay: tOptional(tNumber),
  button: tOptional(tEnum(["left", "right", "middle"])),
  clickCount: tOptional(tNumber),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean)
});
scheme.ElementHandleClickResult = tOptional(tObject({}));
scheme.ElementHandleContentFrameParams = tOptional(tObject({}));
scheme.ElementHandleContentFrameResult = tObject({
  frame: tOptional(tChannel(["Frame"]))
});
scheme.ElementHandleDblclickParams = tObject({
  force: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  delay: tOptional(tNumber),
  button: tOptional(tEnum(["left", "right", "middle"])),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean)
});
scheme.ElementHandleDblclickResult = tOptional(tObject({}));
scheme.ElementHandleDispatchEventParams = tObject({
  type: tString,
  eventInit: tType("SerializedArgument")
});
scheme.ElementHandleDispatchEventResult = tOptional(tObject({}));
scheme.ElementHandleFillParams = tObject({
  value: tString,
  force: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.ElementHandleFillResult = tOptional(tObject({}));
scheme.ElementHandleFocusParams = tOptional(tObject({}));
scheme.ElementHandleFocusResult = tOptional(tObject({}));
scheme.ElementHandleGenerateLocatorStringParams = tOptional(tObject({}));
scheme.ElementHandleGenerateLocatorStringResult = tObject({
  value: tOptional(tString)
});
scheme.ElementHandleGetAttributeParams = tObject({
  name: tString
});
scheme.ElementHandleGetAttributeResult = tObject({
  value: tOptional(tString)
});
scheme.ElementHandleHoverParams = tObject({
  force: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean)
});
scheme.ElementHandleHoverResult = tOptional(tObject({}));
scheme.ElementHandleInnerHTMLParams = tOptional(tObject({}));
scheme.ElementHandleInnerHTMLResult = tObject({
  value: tString
});
scheme.ElementHandleInnerTextParams = tOptional(tObject({}));
scheme.ElementHandleInnerTextResult = tObject({
  value: tString
});
scheme.ElementHandleInputValueParams = tOptional(tObject({}));
scheme.ElementHandleInputValueResult = tObject({
  value: tString
});
scheme.ElementHandleIsCheckedParams = tOptional(tObject({}));
scheme.ElementHandleIsCheckedResult = tObject({
  value: tBoolean
});
scheme.ElementHandleIsDisabledParams = tOptional(tObject({}));
scheme.ElementHandleIsDisabledResult = tObject({
  value: tBoolean
});
scheme.ElementHandleIsEditableParams = tOptional(tObject({}));
scheme.ElementHandleIsEditableResult = tObject({
  value: tBoolean
});
scheme.ElementHandleIsEnabledParams = tOptional(tObject({}));
scheme.ElementHandleIsEnabledResult = tObject({
  value: tBoolean
});
scheme.ElementHandleIsHiddenParams = tOptional(tObject({}));
scheme.ElementHandleIsHiddenResult = tObject({
  value: tBoolean
});
scheme.ElementHandleIsVisibleParams = tOptional(tObject({}));
scheme.ElementHandleIsVisibleResult = tObject({
  value: tBoolean
});
scheme.ElementHandleOwnerFrameParams = tOptional(tObject({}));
scheme.ElementHandleOwnerFrameResult = tObject({
  frame: tOptional(tChannel(["Frame"]))
});
scheme.ElementHandlePressParams = tObject({
  key: tString,
  delay: tOptional(tNumber),
  timeout: tOptional(tNumber),
  noWaitAfter: tOptional(tBoolean)
});
scheme.ElementHandlePressResult = tOptional(tObject({}));
scheme.ElementHandleQuerySelectorParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean)
});
scheme.ElementHandleQuerySelectorResult = tObject({
  element: tOptional(tChannel(["ElementHandle"]))
});
scheme.ElementHandleQuerySelectorAllParams = tObject({
  selector: tString
});
scheme.ElementHandleQuerySelectorAllResult = tObject({
  elements: tArray(tChannel(["ElementHandle"]))
});
scheme.ElementHandleScreenshotParams = tObject({
  timeout: tOptional(tNumber),
  type: tOptional(tEnum(["png", "jpeg"])),
  quality: tOptional(tNumber),
  omitBackground: tOptional(tBoolean),
  caret: tOptional(tEnum(["hide", "initial"])),
  animations: tOptional(tEnum(["disabled", "allow"])),
  scale: tOptional(tEnum(["css", "device"])),
  mask: tOptional(tArray(tObject({
    frame: tChannel(["Frame"]),
    selector: tString
  }))),
  maskColor: tOptional(tString),
  style: tOptional(tString)
});
scheme.ElementHandleScreenshotResult = tObject({
  binary: tBinary
});
scheme.ElementHandleScrollIntoViewIfNeededParams = tObject({
  timeout: tOptional(tNumber)
});
scheme.ElementHandleScrollIntoViewIfNeededResult = tOptional(tObject({}));
scheme.ElementHandleSelectOptionParams = tObject({
  elements: tOptional(tArray(tChannel(["ElementHandle"]))),
  options: tOptional(tArray(tObject({
    valueOrLabel: tOptional(tString),
    value: tOptional(tString),
    label: tOptional(tString),
    index: tOptional(tNumber)
  }))),
  force: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.ElementHandleSelectOptionResult = tObject({
  values: tArray(tString)
});
scheme.ElementHandleSelectTextParams = tObject({
  force: tOptional(tBoolean),
  timeout: tOptional(tNumber)
});
scheme.ElementHandleSelectTextResult = tOptional(tObject({}));
scheme.ElementHandleSetInputFilesParams = tObject({
  payloads: tOptional(tArray(tObject({
    name: tString,
    mimeType: tOptional(tString),
    buffer: tBinary
  }))),
  localDirectory: tOptional(tString),
  directoryStream: tOptional(tChannel(["WritableStream"])),
  localPaths: tOptional(tArray(tString)),
  streams: tOptional(tArray(tChannel(["WritableStream"]))),
  timeout: tOptional(tNumber)
});
scheme.ElementHandleSetInputFilesResult = tOptional(tObject({}));
scheme.ElementHandleTapParams = tObject({
  force: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean)
});
scheme.ElementHandleTapResult = tOptional(tObject({}));
scheme.ElementHandleTextContentParams = tOptional(tObject({}));
scheme.ElementHandleTextContentResult = tObject({
  value: tOptional(tString)
});
scheme.ElementHandleTypeParams = tObject({
  text: tString,
  delay: tOptional(tNumber),
  timeout: tOptional(tNumber)
});
scheme.ElementHandleTypeResult = tOptional(tObject({}));
scheme.ElementHandleUncheckParams = tObject({
  force: tOptional(tBoolean),
  position: tOptional(tType("Point")),
  timeout: tOptional(tNumber),
  trial: tOptional(tBoolean)
});
scheme.ElementHandleUncheckResult = tOptional(tObject({}));
scheme.ElementHandleWaitForElementStateParams = tObject({
  state: tEnum(["visible", "hidden", "stable", "enabled", "disabled", "editable"]),
  timeout: tOptional(tNumber)
});
scheme.ElementHandleWaitForElementStateResult = tOptional(tObject({}));
scheme.ElementHandleWaitForSelectorParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tOptional(tNumber),
  state: tOptional(tEnum(["attached", "detached", "visible", "hidden"]))
});
scheme.ElementHandleWaitForSelectorResult = tObject({
  element: tOptional(tChannel(["ElementHandle"]))
});
scheme.RequestInitializer = tObject({
  frame: tOptional(tChannel(["Frame"])),
  serviceWorker: tOptional(tChannel(["Worker"])),
  url: tString,
  resourceType: tString,
  method: tString,
  postData: tOptional(tBinary),
  headers: tArray(tType("NameValue")),
  isNavigationRequest: tBoolean,
  redirectedFrom: tOptional(tChannel(["Request"]))
});
scheme.RequestResponseParams = tOptional(tObject({}));
scheme.RequestResponseResult = tObject({
  response: tOptional(tChannel(["Response"]))
});
scheme.RequestRawRequestHeadersParams = tOptional(tObject({}));
scheme.RequestRawRequestHeadersResult = tObject({
  headers: tArray(tType("NameValue"))
});
scheme.RouteInitializer = tObject({
  request: tChannel(["Request"])
});
scheme.RouteRedirectNavigationRequestParams = tObject({
  url: tString
});
scheme.RouteRedirectNavigationRequestResult = tOptional(tObject({}));
scheme.RouteAbortParams = tObject({
  errorCode: tOptional(tString)
});
scheme.RouteAbortResult = tOptional(tObject({}));
scheme.RouteContinueParams = tObject({
  url: tOptional(tString),
  method: tOptional(tString),
  headers: tOptional(tArray(tType("NameValue"))),
  postData: tOptional(tBinary),
  isFallback: tBoolean
});
scheme.RouteContinueResult = tOptional(tObject({}));
scheme.RouteFulfillParams = tObject({
  status: tOptional(tNumber),
  headers: tOptional(tArray(tType("NameValue"))),
  body: tOptional(tString),
  isBase64: tOptional(tBoolean),
  fetchResponseUid: tOptional(tString)
});
scheme.RouteFulfillResult = tOptional(tObject({}));
scheme.WebSocketRouteInitializer = tObject({
  url: tString
});
scheme.WebSocketRouteMessageFromPageEvent = tObject({
  message: tString,
  isBase64: tBoolean
});
scheme.WebSocketRouteMessageFromServerEvent = tObject({
  message: tString,
  isBase64: tBoolean
});
scheme.WebSocketRouteClosePageEvent = tObject({
  code: tOptional(tNumber),
  reason: tOptional(tString),
  wasClean: tBoolean
});
scheme.WebSocketRouteCloseServerEvent = tObject({
  code: tOptional(tNumber),
  reason: tOptional(tString),
  wasClean: tBoolean
});
scheme.WebSocketRouteConnectParams = tOptional(tObject({}));
scheme.WebSocketRouteConnectResult = tOptional(tObject({}));
scheme.WebSocketRouteEnsureOpenedParams = tOptional(tObject({}));
scheme.WebSocketRouteEnsureOpenedResult = tOptional(tObject({}));
scheme.WebSocketRouteSendToPageParams = tObject({
  message: tString,
  isBase64: tBoolean
});
scheme.WebSocketRouteSendToPageResult = tOptional(tObject({}));
scheme.WebSocketRouteSendToServerParams = tObject({
  message: tString,
  isBase64: tBoolean
});
scheme.WebSocketRouteSendToServerResult = tOptional(tObject({}));
scheme.WebSocketRouteClosePageParams = tObject({
  code: tOptional(tNumber),
  reason: tOptional(tString),
  wasClean: tBoolean
});
scheme.WebSocketRouteClosePageResult = tOptional(tObject({}));
scheme.WebSocketRouteCloseServerParams = tObject({
  code: tOptional(tNumber),
  reason: tOptional(tString),
  wasClean: tBoolean
});
scheme.WebSocketRouteCloseServerResult = tOptional(tObject({}));
scheme.ResourceTiming = tObject({
  startTime: tNumber,
  domainLookupStart: tNumber,
  domainLookupEnd: tNumber,
  connectStart: tNumber,
  secureConnectionStart: tNumber,
  connectEnd: tNumber,
  requestStart: tNumber,
  responseStart: tNumber
});
scheme.ResponseInitializer = tObject({
  request: tChannel(["Request"]),
  url: tString,
  status: tNumber,
  statusText: tString,
  headers: tArray(tType("NameValue")),
  timing: tType("ResourceTiming"),
  fromServiceWorker: tBoolean
});
scheme.ResponseBodyParams = tOptional(tObject({}));
scheme.ResponseBodyResult = tObject({
  binary: tBinary
});
scheme.ResponseSecurityDetailsParams = tOptional(tObject({}));
scheme.ResponseSecurityDetailsResult = tObject({
  value: tOptional(tType("SecurityDetails"))
});
scheme.ResponseServerAddrParams = tOptional(tObject({}));
scheme.ResponseServerAddrResult = tObject({
  value: tOptional(tType("RemoteAddr"))
});
scheme.ResponseRawResponseHeadersParams = tOptional(tObject({}));
scheme.ResponseRawResponseHeadersResult = tObject({
  headers: tArray(tType("NameValue"))
});
scheme.ResponseSizesParams = tOptional(tObject({}));
scheme.ResponseSizesResult = tObject({
  sizes: tType("RequestSizes")
});
scheme.SecurityDetails = tObject({
  issuer: tOptional(tString),
  protocol: tOptional(tString),
  subjectName: tOptional(tString),
  validFrom: tOptional(tNumber),
  validTo: tOptional(tNumber)
});
scheme.RequestSizes = tObject({
  requestBodySize: tNumber,
  requestHeadersSize: tNumber,
  responseBodySize: tNumber,
  responseHeadersSize: tNumber
});
scheme.RemoteAddr = tObject({
  ipAddress: tString,
  port: tNumber
});
scheme.WebSocketInitializer = tObject({
  url: tString
});
scheme.WebSocketOpenEvent = tOptional(tObject({}));
scheme.WebSocketFrameSentEvent = tObject({
  opcode: tNumber,
  data: tString
});
scheme.WebSocketFrameReceivedEvent = tObject({
  opcode: tNumber,
  data: tString
});
scheme.WebSocketSocketErrorEvent = tObject({
  error: tString
});
scheme.WebSocketCloseEvent = tOptional(tObject({}));
scheme.BindingCallInitializer = tObject({
  frame: tChannel(["Frame"]),
  name: tString,
  args: tOptional(tArray(tType("SerializedValue"))),
  handle: tOptional(tChannel(["ElementHandle", "JSHandle"]))
});
scheme.BindingCallRejectParams = tObject({
  error: tType("SerializedError")
});
scheme.BindingCallRejectResult = tOptional(tObject({}));
scheme.BindingCallResolveParams = tObject({
  result: tType("SerializedArgument")
});
scheme.BindingCallResolveResult = tOptional(tObject({}));
scheme.DialogInitializer = tObject({
  page: tOptional(tChannel(["Page"])),
  type: tString,
  message: tString,
  defaultValue: tString
});
scheme.DialogAcceptParams = tObject({
  promptText: tOptional(tString)
});
scheme.DialogAcceptResult = tOptional(tObject({}));
scheme.DialogDismissParams = tOptional(tObject({}));
scheme.DialogDismissResult = tOptional(tObject({}));
scheme.TracingInitializer = tOptional(tObject({}));
scheme.TracingTracingStartParams = tObject({
  name: tOptional(tString),
  snapshots: tOptional(tBoolean),
  screenshots: tOptional(tBoolean),
  live: tOptional(tBoolean)
});
scheme.TracingTracingStartResult = tOptional(tObject({}));
scheme.TracingTracingStartChunkParams = tObject({
  name: tOptional(tString),
  title: tOptional(tString)
});
scheme.TracingTracingStartChunkResult = tObject({
  traceName: tString
});
scheme.TracingTracingGroupParams = tObject({
  name: tString,
  location: tOptional(tObject({
    file: tString,
    line: tOptional(tNumber),
    column: tOptional(tNumber)
  }))
});
scheme.TracingTracingGroupResult = tOptional(tObject({}));
scheme.TracingTracingGroupEndParams = tOptional(tObject({}));
scheme.TracingTracingGroupEndResult = tOptional(tObject({}));
scheme.TracingTracingStopChunkParams = tObject({
  mode: tEnum(["archive", "discard", "entries"])
});
scheme.TracingTracingStopChunkResult = tObject({
  artifact: tOptional(tChannel(["Artifact"])),
  entries: tOptional(tArray(tType("NameValue")))
});
scheme.TracingTracingStopParams = tOptional(tObject({}));
scheme.TracingTracingStopResult = tOptional(tObject({}));
scheme.ArtifactInitializer = tObject({
  absolutePath: tString
});
scheme.ArtifactPathAfterFinishedParams = tOptional(tObject({}));
scheme.ArtifactPathAfterFinishedResult = tObject({
  value: tString
});
scheme.ArtifactSaveAsParams = tObject({
  path: tString
});
scheme.ArtifactSaveAsResult = tOptional(tObject({}));
scheme.ArtifactSaveAsStreamParams = tOptional(tObject({}));
scheme.ArtifactSaveAsStreamResult = tObject({
  stream: tChannel(["Stream"])
});
scheme.ArtifactFailureParams = tOptional(tObject({}));
scheme.ArtifactFailureResult = tObject({
  error: tOptional(tString)
});
scheme.ArtifactStreamParams = tOptional(tObject({}));
scheme.ArtifactStreamResult = tObject({
  stream: tChannel(["Stream"])
});
scheme.ArtifactCancelParams = tOptional(tObject({}));
scheme.ArtifactCancelResult = tOptional(tObject({}));
scheme.ArtifactDeleteParams = tOptional(tObject({}));
scheme.ArtifactDeleteResult = tOptional(tObject({}));
scheme.StreamInitializer = tOptional(tObject({}));
scheme.StreamReadParams = tObject({
  size: tOptional(tNumber)
});
scheme.StreamReadResult = tObject({
  binary: tBinary
});
scheme.StreamCloseParams = tOptional(tObject({}));
scheme.StreamCloseResult = tOptional(tObject({}));
scheme.WritableStreamInitializer = tOptional(tObject({}));
scheme.WritableStreamWriteParams = tObject({
  binary: tBinary
});
scheme.WritableStreamWriteResult = tOptional(tObject({}));
scheme.WritableStreamCloseParams = tOptional(tObject({}));
scheme.WritableStreamCloseResult = tOptional(tObject({}));
scheme.CDPSessionInitializer = tOptional(tObject({}));
scheme.CDPSessionEventEvent = tObject({
  method: tString,
  params: tOptional(tAny)
});
scheme.CDPSessionSendParams = tObject({
  method: tString,
  params: tOptional(tAny)
});
scheme.CDPSessionSendResult = tObject({
  result: tAny
});
scheme.CDPSessionDetachParams = tOptional(tObject({}));
scheme.CDPSessionDetachResult = tOptional(tObject({}));
scheme.ElectronInitializer = tOptional(tObject({}));
scheme.ElectronLaunchParams = tObject({
  executablePath: tOptional(tString),
  args: tOptional(tArray(tString)),
  cwd: tOptional(tString),
  env: tOptional(tArray(tType("NameValue"))),
  timeout: tOptional(tNumber),
  acceptDownloads: tOptional(tEnum(["accept", "deny", "internal-browser-default"])),
  bypassCSP: tOptional(tBoolean),
  colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
  extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
  geolocation: tOptional(tObject({
    longitude: tNumber,
    latitude: tNumber,
    accuracy: tOptional(tNumber)
  })),
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString)
  })),
  ignoreHTTPSErrors: tOptional(tBoolean),
  locale: tOptional(tString),
  offline: tOptional(tBoolean),
  recordHar: tOptional(tType("RecordHarOptions")),
  recordVideo: tOptional(tObject({
    dir: tString,
    size: tOptional(tObject({
      width: tNumber,
      height: tNumber
    }))
  })),
  strictSelectors: tOptional(tBoolean),
  timezoneId: tOptional(tString),
  tracesDir: tOptional(tString)
});
scheme.ElectronLaunchResult = tObject({
  electronApplication: tChannel(["ElectronApplication"])
});
scheme.ElectronApplicationInitializer = tObject({
  context: tChannel(["BrowserContext"])
});
scheme.ElectronApplicationCloseEvent = tOptional(tObject({}));
scheme.ElectronApplicationConsoleEvent = tObject({
  type: tString,
  text: tString,
  args: tArray(tChannel(["ElementHandle", "JSHandle"])),
  location: tObject({
    url: tString,
    lineNumber: tNumber,
    columnNumber: tNumber
  })
});
scheme.ElectronApplicationBrowserWindowParams = tObject({
  page: tChannel(["Page"])
});
scheme.ElectronApplicationBrowserWindowResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.ElectronApplicationEvaluateExpressionParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.ElectronApplicationEvaluateExpressionResult = tObject({
  value: tType("SerializedValue")
});
scheme.ElectronApplicationEvaluateExpressionHandleParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.ElectronApplicationEvaluateExpressionHandleResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.ElectronApplicationUpdateSubscriptionParams = tObject({
  event: tEnum(["console"]),
  enabled: tBoolean
});
scheme.ElectronApplicationUpdateSubscriptionResult = tOptional(tObject({}));
scheme.AndroidInitializer = tOptional(tObject({}));
scheme.AndroidDevicesParams = tObject({
  host: tOptional(tString),
  port: tOptional(tNumber),
  omitDriverInstall: tOptional(tBoolean)
});
scheme.AndroidDevicesResult = tObject({
  devices: tArray(tChannel(["AndroidDevice"]))
});
scheme.AndroidSetDefaultTimeoutNoReplyParams = tObject({
  timeout: tNumber
});
scheme.AndroidSetDefaultTimeoutNoReplyResult = tOptional(tObject({}));
scheme.AndroidSocketInitializer = tOptional(tObject({}));
scheme.AndroidSocketDataEvent = tObject({
  data: tBinary
});
scheme.AndroidSocketCloseEvent = tOptional(tObject({}));
scheme.AndroidSocketWriteParams = tObject({
  data: tBinary
});
scheme.AndroidSocketWriteResult = tOptional(tObject({}));
scheme.AndroidSocketCloseParams = tOptional(tObject({}));
scheme.AndroidSocketCloseResult = tOptional(tObject({}));
scheme.AndroidDeviceInitializer = tObject({
  model: tString,
  serial: tString
});
scheme.AndroidDeviceCloseEvent = tOptional(tObject({}));
scheme.AndroidDeviceWebViewAddedEvent = tObject({
  webView: tType("AndroidWebView")
});
scheme.AndroidDeviceWebViewRemovedEvent = tObject({
  socketName: tString
});
scheme.AndroidDeviceWaitParams = tObject({
  selector: tType("AndroidSelector"),
  state: tOptional(tEnum(["gone"])),
  timeout: tOptional(tNumber)
});
scheme.AndroidDeviceWaitResult = tOptional(tObject({}));
scheme.AndroidDeviceFillParams = tObject({
  selector: tType("AndroidSelector"),
  text: tString,
  timeout: tOptional(tNumber)
});
scheme.AndroidDeviceFillResult = tOptional(tObject({}));
scheme.AndroidDeviceTapParams = tObject({
  selector: tType("AndroidSelector"),
  duration: tOptional(tNumber),
  timeout: tOptional(tNumber)
});
scheme.AndroidDeviceTapResult = tOptional(tObject({}));
scheme.AndroidDeviceDragParams = tObject({
  selector: tType("AndroidSelector"),
  dest: tType("Point"),
  speed: tOptional(tNumber),
  timeout: tOptional(tNumber)
});
scheme.AndroidDeviceDragResult = tOptional(tObject({}));
scheme.AndroidDeviceFlingParams = tObject({
  selector: tType("AndroidSelector"),
  direction: tEnum(["up", "down", "left", "right"]),
  speed: tOptional(tNumber),
  timeout: tOptional(tNumber)
});
scheme.AndroidDeviceFlingResult = tOptional(tObject({}));
scheme.AndroidDeviceLongTapParams = tObject({
  selector: tType("AndroidSelector"),
  timeout: tOptional(tNumber)
});
scheme.AndroidDeviceLongTapResult = tOptional(tObject({}));
scheme.AndroidDevicePinchCloseParams = tObject({
  selector: tType("AndroidSelector"),
  percent: tNumber,
  speed: tOptional(tNumber),
  timeout: tOptional(tNumber)
});
scheme.AndroidDevicePinchCloseResult = tOptional(tObject({}));
scheme.AndroidDevicePinchOpenParams = tObject({
  selector: tType("AndroidSelector"),
  percent: tNumber,
  speed: tOptional(tNumber),
  timeout: tOptional(tNumber)
});
scheme.AndroidDevicePinchOpenResult = tOptional(tObject({}));
scheme.AndroidDeviceScrollParams = tObject({
  selector: tType("AndroidSelector"),
  direction: tEnum(["up", "down", "left", "right"]),
  percent: tNumber,
  speed: tOptional(tNumber),
  timeout: tOptional(tNumber)
});
scheme.AndroidDeviceScrollResult = tOptional(tObject({}));
scheme.AndroidDeviceSwipeParams = tObject({
  selector: tType("AndroidSelector"),
  direction: tEnum(["up", "down", "left", "right"]),
  percent: tNumber,
  speed: tOptional(tNumber),
  timeout: tOptional(tNumber)
});
scheme.AndroidDeviceSwipeResult = tOptional(tObject({}));
scheme.AndroidDeviceInfoParams = tObject({
  selector: tType("AndroidSelector")
});
scheme.AndroidDeviceInfoResult = tObject({
  info: tType("AndroidElementInfo")
});
scheme.AndroidDeviceScreenshotParams = tOptional(tObject({}));
scheme.AndroidDeviceScreenshotResult = tObject({
  binary: tBinary
});
scheme.AndroidDeviceInputTypeParams = tObject({
  text: tString
});
scheme.AndroidDeviceInputTypeResult = tOptional(tObject({}));
scheme.AndroidDeviceInputPressParams = tObject({
  key: tString
});
scheme.AndroidDeviceInputPressResult = tOptional(tObject({}));
scheme.AndroidDeviceInputTapParams = tObject({
  point: tType("Point")
});
scheme.AndroidDeviceInputTapResult = tOptional(tObject({}));
scheme.AndroidDeviceInputSwipeParams = tObject({
  segments: tArray(tType("Point")),
  steps: tNumber
});
scheme.AndroidDeviceInputSwipeResult = tOptional(tObject({}));
scheme.AndroidDeviceInputDragParams = tObject({
  from: tType("Point"),
  to: tType("Point"),
  steps: tNumber
});
scheme.AndroidDeviceInputDragResult = tOptional(tObject({}));
scheme.AndroidDeviceLaunchBrowserParams = tObject({
  noDefaultViewport: tOptional(tBoolean),
  viewport: tOptional(tObject({
    width: tNumber,
    height: tNumber
  })),
  screen: tOptional(tObject({
    width: tNumber,
    height: tNumber
  })),
  ignoreHTTPSErrors: tOptional(tBoolean),
  clientCertificates: tOptional(tArray(tObject({
    origin: tString,
    cert: tOptional(tBinary),
    key: tOptional(tBinary),
    passphrase: tOptional(tString),
    pfx: tOptional(tBinary)
  }))),
  javaScriptEnabled: tOptional(tBoolean),
  bypassCSP: tOptional(tBoolean),
  userAgent: tOptional(tString),
  locale: tOptional(tString),
  timezoneId: tOptional(tString),
  geolocation: tOptional(tObject({
    longitude: tNumber,
    latitude: tNumber,
    accuracy: tOptional(tNumber)
  })),
  permissions: tOptional(tArray(tString)),
  extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
  offline: tOptional(tBoolean),
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString),
    send: tOptional(tEnum(["always", "unauthorized"]))
  })),
  deviceScaleFactor: tOptional(tNumber),
  isMobile: tOptional(tBoolean),
  hasTouch: tOptional(tBoolean),
  colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
  reducedMotion: tOptional(tEnum(["reduce", "no-preference", "no-override"])),
  forcedColors: tOptional(tEnum(["active", "none", "no-override"])),
  acceptDownloads: tOptional(tEnum(["accept", "deny", "internal-browser-default"])),
  contrast: tOptional(tEnum(["no-preference", "more", "no-override"])),
  baseURL: tOptional(tString),
  recordVideo: tOptional(tObject({
    dir: tString,
    size: tOptional(tObject({
      width: tNumber,
      height: tNumber
    }))
  })),
  recordHar: tOptional(tType("RecordHarOptions")),
  strictSelectors: tOptional(tBoolean),
  serviceWorkers: tOptional(tEnum(["allow", "block"])),
  pkg: tOptional(tString),
  args: tOptional(tArray(tString)),
  proxy: tOptional(tObject({
    server: tString,
    bypass: tOptional(tString),
    username: tOptional(tString),
    password: tOptional(tString)
  }))
});
scheme.AndroidDeviceLaunchBrowserResult = tObject({
  context: tChannel(["BrowserContext"])
});
scheme.AndroidDeviceOpenParams = tObject({
  command: tString
});
scheme.AndroidDeviceOpenResult = tObject({
  socket: tChannel(["AndroidSocket"])
});
scheme.AndroidDeviceShellParams = tObject({
  command: tString
});
scheme.AndroidDeviceShellResult = tObject({
  result: tBinary
});
scheme.AndroidDeviceInstallApkParams = tObject({
  file: tBinary,
  args: tOptional(tArray(tString))
});
scheme.AndroidDeviceInstallApkResult = tOptional(tObject({}));
scheme.AndroidDevicePushParams = tObject({
  file: tBinary,
  path: tString,
  mode: tOptional(tNumber)
});
scheme.AndroidDevicePushResult = tOptional(tObject({}));
scheme.AndroidDeviceSetDefaultTimeoutNoReplyParams = tObject({
  timeout: tNumber
});
scheme.AndroidDeviceSetDefaultTimeoutNoReplyResult = tOptional(tObject({}));
scheme.AndroidDeviceConnectToWebViewParams = tObject({
  socketName: tString
});
scheme.AndroidDeviceConnectToWebViewResult = tObject({
  context: tChannel(["BrowserContext"])
});
scheme.AndroidDeviceCloseParams = tOptional(tObject({}));
scheme.AndroidDeviceCloseResult = tOptional(tObject({}));
scheme.AndroidWebView = tObject({
  pid: tNumber,
  pkg: tString,
  socketName: tString
});
scheme.AndroidSelector = tObject({
  checkable: tOptional(tBoolean),
  checked: tOptional(tBoolean),
  clazz: tOptional(tString),
  clickable: tOptional(tBoolean),
  depth: tOptional(tNumber),
  desc: tOptional(tString),
  enabled: tOptional(tBoolean),
  focusable: tOptional(tBoolean),
  focused: tOptional(tBoolean),
  hasChild: tOptional(tObject({
    selector: tType("AndroidSelector")
  })),
  hasDescendant: tOptional(tObject({
    selector: tType("AndroidSelector"),
    maxDepth: tOptional(tNumber)
  })),
  longClickable: tOptional(tBoolean),
  pkg: tOptional(tString),
  res: tOptional(tString),
  scrollable: tOptional(tBoolean),
  selected: tOptional(tBoolean),
  text: tOptional(tString)
});
scheme.AndroidElementInfo = tObject({
  children: tOptional(tArray(tType("AndroidElementInfo"))),
  clazz: tString,
  desc: tString,
  res: tString,
  pkg: tString,
  text: tString,
  bounds: tType("Rect"),
  checkable: tBoolean,
  checked: tBoolean,
  clickable: tBoolean,
  enabled: tBoolean,
  focusable: tBoolean,
  focused: tBoolean,
  longClickable: tBoolean,
  scrollable: tBoolean,
  selected: tBoolean
});
scheme.JsonPipeInitializer = tOptional(tObject({}));
scheme.JsonPipeMessageEvent = tObject({
  message: tAny
});
scheme.JsonPipeClosedEvent = tObject({
  reason: tOptional(tString)
});
scheme.JsonPipeSendParams = tObject({
  message: tAny
});
scheme.JsonPipeSendResult = tOptional(tObject({}));
scheme.JsonPipeCloseParams = tOptional(tObject({}));
scheme.JsonPipeCloseResult = tOptional(tObject({}));

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/dispatcher.js
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/protocol/serializers.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseSerializedValue(value, handles) {
  return innerParseSerializedValue(value, handles, /* @__PURE__ */ new Map(), []);
}
__name(parseSerializedValue, "parseSerializedValue");
function innerParseSerializedValue(value, handles, refs, accessChain) {
  if (value.ref !== void 0)
    return refs.get(value.ref);
  if (value.n !== void 0)
    return value.n;
  if (value.s !== void 0)
    return value.s;
  if (value.b !== void 0)
    return value.b;
  if (value.v !== void 0) {
    if (value.v === "undefined")
      return void 0;
    if (value.v === "null")
      return null;
    if (value.v === "NaN")
      return NaN;
    if (value.v === "Infinity")
      return Infinity;
    if (value.v === "-Infinity")
      return -Infinity;
    if (value.v === "-0")
      return -0;
  }
  if (value.d !== void 0)
    return new Date(value.d);
  if (value.u !== void 0)
    return new URL(value.u);
  if (value.bi !== void 0)
    return BigInt(value.bi);
  if (value.e !== void 0) {
    const error4 = new Error(value.e.m);
    error4.name = value.e.n;
    error4.stack = value.e.s;
    return error4;
  }
  if (value.r !== void 0)
    return new RegExp(value.r.p, value.r.f);
  if (value.ta !== void 0) {
    const ctor = typedArrayKindToConstructor[value.ta.k];
    return new ctor(value.ta.b.buffer, value.ta.b.byteOffset, value.ta.b.length / ctor.BYTES_PER_ELEMENT);
  }
  if (value.a !== void 0) {
    const result = [];
    refs.set(value.id, result);
    for (let i = 0; i < value.a.length; i++)
      result.push(innerParseSerializedValue(value.a[i], handles, refs, [...accessChain, i]));
    return result;
  }
  if (value.o !== void 0) {
    const result = {};
    refs.set(value.id, result);
    for (const { k, v } of value.o)
      result[k] = innerParseSerializedValue(v, handles, refs, [...accessChain, k]);
    return result;
  }
  if (value.h !== void 0) {
    if (handles === void 0)
      throw new Error("Unexpected handle");
    return handles[value.h];
  }
  throw new Error(`Attempting to deserialize unexpected value${accessChainToDisplayString(accessChain)}: ${value}`);
}
__name(innerParseSerializedValue, "innerParseSerializedValue");
function serializeValue(value, handleSerializer) {
  return innerSerializeValue(value, handleSerializer, { lastId: 0, visited: /* @__PURE__ */ new Map() }, []);
}
__name(serializeValue, "serializeValue");
function innerSerializeValue(value, handleSerializer, visitorInfo, accessChain) {
  const handle = handleSerializer(value);
  if ("fallThrough" in handle)
    value = handle.fallThrough;
  else
    return handle;
  if (typeof value === "symbol")
    return { v: "undefined" };
  if (Object.is(value, void 0))
    return { v: "undefined" };
  if (Object.is(value, null))
    return { v: "null" };
  if (Object.is(value, NaN))
    return { v: "NaN" };
  if (Object.is(value, Infinity))
    return { v: "Infinity" };
  if (Object.is(value, -Infinity))
    return { v: "-Infinity" };
  if (Object.is(value, -0))
    return { v: "-0" };
  if (typeof value === "boolean")
    return { b: value };
  if (typeof value === "number")
    return { n: value };
  if (typeof value === "string")
    return { s: value };
  if (typeof value === "bigint")
    return { bi: value.toString() };
  if (isError2(value))
    return { e: { n: value.name, m: value.message, s: value.stack || "" } };
  if (isDate2(value))
    return { d: value.toJSON() };
  if (isURL(value))
    return { u: value.toJSON() };
  if (isRegExp3(value))
    return { r: { p: value.source, f: value.flags } };
  const typedArrayKind = constructorToTypedArrayKind.get(value.constructor);
  if (typedArrayKind)
    return { ta: { b: Buffer.from(value.buffer, value.byteOffset, value.byteLength), k: typedArrayKind } };
  const id = visitorInfo.visited.get(value);
  if (id)
    return { ref: id };
  if (Array.isArray(value)) {
    const a = [];
    const id2 = ++visitorInfo.lastId;
    visitorInfo.visited.set(value, id2);
    for (let i = 0; i < value.length; ++i)
      a.push(innerSerializeValue(value[i], handleSerializer, visitorInfo, [...accessChain, i]));
    return { a, id: id2 };
  }
  if (typeof value === "object") {
    const o = [];
    const id2 = ++visitorInfo.lastId;
    visitorInfo.visited.set(value, id2);
    for (const name of Object.keys(value))
      o.push({ k: name, v: innerSerializeValue(value[name], handleSerializer, visitorInfo, [...accessChain, name]) });
    return { o, id: id2 };
  }
  throw new Error(`Attempting to serialize unexpected value${accessChainToDisplayString(accessChain)}: ${value}`);
}
__name(innerSerializeValue, "innerSerializeValue");
function accessChainToDisplayString(accessChain) {
  const chainString = accessChain.map((accessor, i) => {
    if (typeof accessor === "string")
      return i ? `.${accessor}` : accessor;
    return `[${accessor}]`;
  }).join("");
  return chainString.length > 0 ? ` at position "${chainString}"` : "";
}
__name(accessChainToDisplayString, "accessChainToDisplayString");
function isRegExp3(obj) {
  return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp3, "isRegExp");
function isDate2(obj) {
  return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
}
__name(isDate2, "isDate");
function isURL(obj) {
  return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";
}
__name(isURL, "isURL");
function isError2(obj) {
  const proto = obj ? Object.getPrototypeOf(obj) : null;
  return obj instanceof Error || proto?.name === "Error" || proto && isError2(proto);
}
__name(isError2, "isError");
var typedArrayKindToConstructor = {
  i8: Int8Array,
  ui8: Uint8Array,
  ui8c: Uint8ClampedArray,
  i16: Int16Array,
  ui16: Uint16Array,
  i32: Int32Array,
  ui32: Uint32Array,
  f32: Float32Array,
  f64: Float64Array,
  bi64: BigInt64Array,
  bui64: BigUint64Array
};
var constructorToTypedArrayKind = new Map(Object.entries(typedArrayKindToConstructor).map(([k, v]) => [v, k]));

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/rtti.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isRegExp4(obj) {
  return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp4, "isRegExp");
function isObject2(obj) {
  return typeof obj === "object" && obj !== null;
}
__name(isObject2, "isObject");
function isError3(obj) {
  return obj instanceof Error || obj && Object.getPrototypeOf(obj)?.name === "Error";
}
__name(isError3, "isError");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/errors.js
import "node:path";
import "node:url";
var CustomError = class extends Error {
  static {
    __name(this, "CustomError");
  }
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
};
var TimeoutError = class extends CustomError {
  static {
    __name(this, "TimeoutError");
  }
};
var TargetClosedError = class extends CustomError {
  static {
    __name(this, "TargetClosedError");
  }
  constructor(cause, logs) {
    super((cause || "Target page, context or browser has been closed") + (logs || ""));
  }
};
function isTargetClosedError(error4) {
  return error4 instanceof TargetClosedError || error4.name === "TargetClosedError";
}
__name(isTargetClosedError, "isTargetClosedError");
function serializeError(e) {
  if (isError3(e))
    return { error: { message: e.message, stack: e.stack, name: e.name } };
  return { value: serializeValue(e, (value) => ({ fallThrough: value })) };
}
__name(serializeError, "serializeError");
function parseError(error4) {
  if (!error4.error) {
    if (error4.value === void 0)
      throw new Error("Serialized error must have either an error or a value");
    return parseSerializedValue(error4.value, void 0);
  }
  const e = new Error(error4.error.message);
  e.stack = error4.error.stack || "";
  e.name = error4.error.name;
  return e;
}
__name(parseError, "parseError");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/instrumentation.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter5 } from "node:events";
var SdkObject = class extends EventEmitter5 {
  static {
    __name(this, "SdkObject");
  }
  constructor(parent, guidPrefix, guid) {
    super();
    this.guid = guid || `${guidPrefix || ""}@${createGuid()}`;
    this.setMaxListeners(0);
    this.attribution = { ...parent.attribution };
    this.instrumentation = parent.instrumentation;
  }
};
function createInstrumentation() {
  const listeners2 = /* @__PURE__ */ new Map();
  return new Proxy({}, {
    get: /* @__PURE__ */ __name((obj, prop) => {
      if (typeof prop !== "string")
        return obj[prop];
      if (prop === "addListener")
        return (listener, context2) => listeners2.set(listener, context2);
      if (prop === "removeListener")
        return (listener) => listeners2.delete(listener);
      if (!prop.startsWith("on"))
        return obj[prop];
      return async (sdkObject, ...params) => {
        for (const [listener, context2] of listeners2) {
          if (!context2 || sdkObject.attribution.context === context2)
            await listener[prop]?.(sdkObject, ...params);
        }
      };
    }, "get")
  });
}
__name(createInstrumentation, "createInstrumentation");
function serverSideCallMetadata() {
  return {
    id: "",
    startTime: 0,
    endTime: 0,
    type: "Internal",
    method: "",
    params: {},
    log: [],
    isServerSide: true
  };
}
__name(serverSideCallMetadata, "serverSideCallMetadata");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/protocolError.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ProtocolError = class extends Error {
  static {
    __name(this, "ProtocolError");
  }
  constructor(type2, method, logs) {
    super();
    this.type = type2;
    this.method = method;
    this.logs = logs;
  }
  setMessage(message) {
    rewriteErrorMessage(this, `Protocol error (${this.method}): ${message}`);
  }
  browserLogMessage() {
    return this.logs ? "\nBrowser logs:\n" + this.logs : "";
  }
};
function isProtocolError(e) {
  return e instanceof ProtocolError;
}
__name(isProtocolError, "isProtocolError");
function isSessionClosedError(e) {
  return e instanceof ProtocolError && (e.type === "closed" || e.type === "crashed");
}
__name(isSessionClosedError, "isSessionClosedError");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/callLog.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function compressCallLog(log4) {
  const lines = [];
  for (const block of findRepeatedSubsequences(log4)) {
    for (let i = 0; i < block.sequence.length; i++) {
      const line = block.sequence[i];
      const leadingWhitespace = line.match(/^\s*/);
      const whitespacePrefix = "  " + leadingWhitespace?.[0] || "";
      const countPrefix = `${block.count} \xD7 `;
      if (block.count > 1 && i === 0)
        lines.push(whitespacePrefix + countPrefix + line.trim());
      else if (block.count > 1)
        lines.push(whitespacePrefix + " ".repeat(countPrefix.length - 2) + "- " + line.trim());
      else
        lines.push(whitespacePrefix + "- " + line.trim());
    }
  }
  return lines;
}
__name(compressCallLog, "compressCallLog");
function findRepeatedSubsequences(s) {
  const n = s.length;
  const result = [];
  let i = 0;
  const arraysEqual = /* @__PURE__ */ __name((a1, a2) => {
    if (a1.length !== a2.length)
      return false;
    for (let j = 0; j < a1.length; j++) {
      if (a1[j] !== a2[j])
        return false;
    }
    return true;
  }, "arraysEqual");
  while (i < n) {
    let maxRepeatCount = 1;
    let maxRepeatSubstr = [s[i]];
    let maxRepeatLength = 1;
    for (let p = 1; p <= n - i; p++) {
      const substr = s.slice(i, i + p);
      let k = 1;
      while (i + p * k <= n && arraysEqual(s.slice(i + p * (k - 1), i + p * k), substr))
        k += 1;
      k -= 1;
      if (k > 1 && k * p > maxRepeatCount * maxRepeatLength) {
        maxRepeatCount = k;
        maxRepeatSubstr = substr;
        maxRepeatLength = p;
      }
    }
    result.push({ sequence: maxRepeatSubstr, count: maxRepeatCount });
    i += maxRepeatLength * maxRepeatCount;
  }
  return result;
}
__name(findRepeatedSubsequences, "findRepeatedSubsequences");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/dispatcher.js
var dispatcherSymbol = Symbol("dispatcher");
var metadataValidator = createMetadataValidator();
function existingDispatcher(object) {
  return object[dispatcherSymbol];
}
__name(existingDispatcher, "existingDispatcher");
function maxDispatchersForBucket(gcBucket) {
  return {
    "JSHandle": 1e5,
    "ElementHandle": 1e5
  }[gcBucket] ?? 1e4;
}
__name(maxDispatchersForBucket, "maxDispatchersForBucket");
var Dispatcher = class extends EventEmitter6 {
  static {
    __name(this, "Dispatcher");
  }
  constructor(parent, object, type2, initializer, gcBucket) {
    super();
    this._dispatchers = /* @__PURE__ */ new Map();
    this._disposed = false;
    this._eventListeners = [];
    this._openScope = new LongStandingScope();
    this._connection = parent instanceof DispatcherConnection ? parent : parent._connection;
    this._parent = parent instanceof DispatcherConnection ? void 0 : parent;
    const guid = object.guid;
    this._guid = guid;
    this._type = type2;
    this._object = object;
    this._gcBucket = gcBucket ?? type2;
    object[dispatcherSymbol] = this;
    this._connection.registerDispatcher(this);
    if (this._parent) {
      assert3(!this._parent._dispatchers.has(guid));
      this._parent._dispatchers.set(guid, this);
    }
    if (this._parent)
      this._connection.sendCreate(this._parent, type2, guid, initializer);
    this._connection.maybeDisposeStaleDispatchers(this._gcBucket);
  }
  parentScope() {
    return this._parent;
  }
  addObjectListener(eventName, handler) {
    this._eventListeners.push(eventsHelper.addEventListener(this._object, eventName, handler));
  }
  adopt(child) {
    if (child._parent === this)
      return;
    const oldParent = child._parent;
    oldParent._dispatchers.delete(child._guid);
    this._dispatchers.set(child._guid, child);
    child._parent = this;
    this._connection.sendAdopt(this, child);
  }
  async _handleCommand(callMetadata, method, validParams) {
    const commandPromise = this[method](validParams, callMetadata);
    if (callMetadata.potentiallyClosesScope)
      return await commandPromise;
    try {
      return await this._openScope.race(commandPromise);
    } catch (e) {
      if (callMetadata.potentiallyClosesScope && isTargetClosedError(e))
        return await commandPromise;
      throw e;
    }
  }
  _dispatchEvent(method, params) {
    if (this._disposed) {
      if (isUnderTest())
        throw new Error(`${this._guid} is sending "${String(method)}" event after being disposed`);
      return;
    }
    this._connection.sendEvent(this, method, params);
  }
  _dispose(reason) {
    this._disposeRecursively(new TargetClosedError());
    this._connection.sendDispose(this, reason);
  }
  _onDispose() {
  }
  _disposeRecursively(error4) {
    assert3(!this._disposed, `${this._guid} is disposed more than once`);
    this._onDispose();
    this._disposed = true;
    eventsHelper.removeEventListeners(this._eventListeners);
    this._parent?._dispatchers.delete(this._guid);
    const list = this._connection._dispatchersByBucket.get(this._gcBucket);
    list?.delete(this._guid);
    this._connection._dispatchers.delete(this._guid);
    for (const dispatcher of [...this._dispatchers.values()])
      dispatcher._disposeRecursively(error4);
    this._dispatchers.clear();
    delete this._object[dispatcherSymbol];
    this._openScope.close(error4);
  }
  _debugScopeState() {
    return {
      _guid: this._guid,
      objects: Array.from(this._dispatchers.values()).map((o) => o._debugScopeState())
    };
  }
  async waitForEventInfo() {
  }
};
var RootDispatcher = class extends Dispatcher {
  static {
    __name(this, "RootDispatcher");
  }
  constructor(connection, createPlaywright2) {
    super(connection, { guid: "" }, "Root", {});
    this.createPlaywright = createPlaywright2;
    this._initialized = false;
  }
  async initialize(params) {
    assert3(this.createPlaywright);
    assert3(!this._initialized);
    this._initialized = true;
    return {
      playwright: await this.createPlaywright(this, params)
    };
  }
};
var DispatcherConnection = class {
  static {
    __name(this, "DispatcherConnection");
  }
  constructor(isLocal) {
    this._dispatchers = /* @__PURE__ */ new Map();
    this._dispatchersByBucket = /* @__PURE__ */ new Map();
    this.onmessage = (message) => {
    };
    this._waitOperations = /* @__PURE__ */ new Map();
    this._isLocal = !!isLocal;
  }
  sendEvent(dispatcher, event, params) {
    const validator = findValidator(dispatcher._type, event, "Event");
    params = validator(params, "", this._validatorToWireContext());
    this.onmessage({ guid: dispatcher._guid, method: event, params });
  }
  sendCreate(parent, type2, guid, initializer) {
    const validator = findValidator(type2, "", "Initializer");
    initializer = validator(initializer, "", this._validatorToWireContext());
    this.onmessage({ guid: parent._guid, method: "__create__", params: { type: type2, initializer, guid } });
  }
  sendAdopt(parent, dispatcher) {
    this.onmessage({ guid: parent._guid, method: "__adopt__", params: { guid: dispatcher._guid } });
  }
  sendDispose(dispatcher, reason) {
    this.onmessage({ guid: dispatcher._guid, method: "__dispose__", params: { reason } });
  }
  _validatorToWireContext() {
    return {
      tChannelImpl: this._tChannelImplToWire.bind(this),
      binary: this._isLocal ? "buffer" : "toBase64",
      isUnderTest
    };
  }
  _validatorFromWireContext() {
    return {
      tChannelImpl: this._tChannelImplFromWire.bind(this),
      binary: this._isLocal ? "buffer" : "fromBase64",
      isUnderTest
    };
  }
  _tChannelImplFromWire(names, arg, path31, context2) {
    if (arg && typeof arg === "object" && typeof arg.guid === "string") {
      const guid = arg.guid;
      const dispatcher = this._dispatchers.get(guid);
      if (!dispatcher)
        throw new ValidationError(`${path31}: no object with guid ${guid}`);
      if (names !== "*" && !names.includes(dispatcher._type))
        throw new ValidationError(`${path31}: object with guid ${guid} has type ${dispatcher._type}, expected ${names.toString()}`);
      return dispatcher;
    }
    throw new ValidationError(`${path31}: expected guid for ${names.toString()}`);
  }
  _tChannelImplToWire(names, arg, path31, context2) {
    if (arg instanceof Dispatcher) {
      if (names !== "*" && !names.includes(arg._type))
        throw new ValidationError(`${path31}: dispatcher with guid ${arg._guid} has type ${arg._type}, expected ${names.toString()}`);
      return { guid: arg._guid };
    }
    throw new ValidationError(`${path31}: expected dispatcher ${names.toString()}`);
  }
  registerDispatcher(dispatcher) {
    assert3(!this._dispatchers.has(dispatcher._guid));
    this._dispatchers.set(dispatcher._guid, dispatcher);
    let list = this._dispatchersByBucket.get(dispatcher._gcBucket);
    if (!list) {
      list = /* @__PURE__ */ new Set();
      this._dispatchersByBucket.set(dispatcher._gcBucket, list);
    }
    list.add(dispatcher._guid);
  }
  maybeDisposeStaleDispatchers(gcBucket) {
    const maxDispatchers = maxDispatchersForBucket(gcBucket);
    const list = this._dispatchersByBucket.get(gcBucket);
    if (!list || list.size <= maxDispatchers)
      return;
    const dispatchersArray = [...list];
    const disposeCount = maxDispatchers / 10 | 0;
    this._dispatchersByBucket.set(gcBucket, new Set(dispatchersArray.slice(disposeCount)));
    for (let i = 0; i < disposeCount; ++i) {
      const d = this._dispatchers.get(dispatchersArray[i]);
      if (!d)
        continue;
      d._dispose("gc");
    }
  }
  async dispatch(message) {
    const { id, guid, method, params, metadata } = message;
    const dispatcher = this._dispatchers.get(guid);
    if (!dispatcher) {
      this.onmessage({ id, error: serializeError(new TargetClosedError()) });
      return;
    }
    let validParams;
    let validMetadata;
    try {
      const validator = findValidator(dispatcher._type, method, "Params");
      const validatorContext = this._validatorFromWireContext();
      validParams = validator(params, "", validatorContext);
      validMetadata = metadataValidator(metadata, "", validatorContext);
      if (typeof dispatcher[method] !== "function")
        throw new Error(`Mismatching dispatcher: "${dispatcher._type}" does not implement "${method}"`);
    } catch (e) {
      this.onmessage({ id, error: serializeError(e) });
      return;
    }
    const sdkObject = dispatcher._object instanceof SdkObject ? dispatcher._object : void 0;
    const callMetadata = {
      id: `call@${id}`,
      location: validMetadata.location,
      apiName: validMetadata.apiName,
      internal: validMetadata.internal,
      stepId: validMetadata.stepId,
      objectId: sdkObject?.guid,
      pageId: sdkObject?.attribution?.page?.guid,
      frameId: sdkObject?.attribution?.frame?.guid,
      startTime: monotonicTime(),
      endTime: 0,
      type: dispatcher._type,
      method,
      params: params || {},
      log: []
    };
    if (sdkObject && params?.info?.waitId) {
      const info3 = params.info;
      switch (info3.phase) {
        case "before": {
          this._waitOperations.set(info3.waitId, callMetadata);
          await sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
          this.onmessage({ id });
          return;
        }
        case "log": {
          const originalMetadata = this._waitOperations.get(info3.waitId);
          originalMetadata.log.push(info3.message);
          sdkObject.instrumentation.onCallLog(sdkObject, originalMetadata, "api", info3.message);
          this.onmessage({ id });
          return;
        }
        case "after": {
          const originalMetadata = this._waitOperations.get(info3.waitId);
          originalMetadata.endTime = monotonicTime();
          originalMetadata.error = info3.error ? { error: { name: "Error", message: info3.error } } : void 0;
          this._waitOperations.delete(info3.waitId);
          await sdkObject.instrumentation.onAfterCall(sdkObject, originalMetadata);
          this.onmessage({ id });
          return;
        }
      }
    }
    await sdkObject?.instrumentation.onBeforeCall(sdkObject, callMetadata);
    const response = { id };
    try {
      const result = await dispatcher._handleCommand(callMetadata, method, validParams);
      const validator = findValidator(dispatcher._type, method, "Result");
      response.result = validator(result, "", this._validatorToWireContext());
      callMetadata.result = result;
    } catch (e) {
      if (isTargetClosedError(e) && sdkObject) {
        const reason = closeReason(sdkObject);
        if (reason)
          rewriteErrorMessage(e, reason);
      } else if (isProtocolError(e)) {
        if (e.type === "closed") {
          const reason = sdkObject ? closeReason(sdkObject) : void 0;
          e = new TargetClosedError(reason, e.browserLogMessage());
        } else if (e.type === "crashed") {
          rewriteErrorMessage(e, "Target crashed " + e.browserLogMessage());
        }
      }
      response.error = serializeError(e);
      callMetadata.error = response.error;
    } finally {
      callMetadata.endTime = monotonicTime();
      await sdkObject?.instrumentation.onAfterCall(sdkObject, callMetadata);
    }
    if (response.error)
      response.log = compressCallLog(callMetadata.log);
    this.onmessage(response);
  }
};
function closeReason(sdkObject) {
  return sdkObject.attribution.page?._closeReason || sdkObject.attribution.context?._closeReason || sdkObject.attribution.browser?._closeReason;
}
__name(closeReason, "closeReason");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/playwrightDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/fetch.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { pipeline as pipeline2, Transform } from "node:stream";
import * as zlib from "node:zlib";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/timeoutSettings.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DEFAULT_TIMEOUT = 3e4;
var DEFAULT_LAUNCH_TIMEOUT = 3 * 60 * 1e3;
var TimeoutSettings = class {
  static {
    __name(this, "TimeoutSettings");
  }
  constructor(parent) {
    this._parent = parent;
  }
  setDefaultTimeout(timeout) {
    this._defaultTimeout = timeout;
  }
  setDefaultNavigationTimeout(timeout) {
    this._defaultNavigationTimeout = timeout;
  }
  defaultNavigationTimeout() {
    return this._defaultNavigationTimeout;
  }
  defaultTimeout() {
    return this._defaultTimeout;
  }
  navigationTimeout(options2) {
    if (typeof options2.timeout === "number")
      return options2.timeout;
    if (this._defaultNavigationTimeout !== void 0)
      return this._defaultNavigationTimeout;
    if (debugMode())
      return 0;
    if (this._defaultTimeout !== void 0)
      return this._defaultTimeout;
    if (this._parent)
      return this._parent.navigationTimeout(options2);
    return DEFAULT_TIMEOUT;
  }
  timeout(options2) {
    if (typeof options2.timeout === "number")
      return options2.timeout;
    if (debugMode())
      return 0;
    if (this._defaultTimeout !== void 0)
      return this._defaultTimeout;
    if (this._parent)
      return this._parent.timeout(options2);
    return DEFAULT_TIMEOUT;
  }
  static timeout(options2) {
    if (typeof options2.timeout === "number")
      return options2.timeout;
    if (debugMode())
      return 0;
    return DEFAULT_TIMEOUT;
  }
  static launchTimeout(options2) {
    if (typeof options2.timeout === "number")
      return options2.timeout;
    if (debugMode())
      return 0;
    return DEFAULT_LAUNCH_TIMEOUT;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/fetch.js
import "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/browserContext.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path15 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/clock.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/generated/clockSource.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source = '\nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, \'default\': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/clock.ts\nvar clock_exports = {};\n__export(clock_exports, {\n  ClockController: () => ClockController,\n  createClock: () => createClock,\n  inject: () => inject,\n  install: () => install\n});\nmodule.exports = __toCommonJS(clock_exports);\n\n// packages/playwright-core/src/utils/isomorphic/builtins.ts\nfunction builtins(global) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  global = global != null ? global : globalThis;\n  if (!global["__playwright_builtins__"]) {\n    const builtins2 = {\n      setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),\n      clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),\n      setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\n      clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\n      requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\n      cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\n      requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\n      cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\n      performance: global.performance,\n      eval: (_i = global.eval) == null ? void 0 : _i.bind(global),\n      Intl: global.Intl,\n      Date: global.Date,\n      Map: global.Map,\n      Set: global.Set\n    };\n    Object.defineProperty(global, "__playwright_builtins__", { value: builtins2, configurable: false, enumerable: false, writable: false });\n  }\n  return global["__playwright_builtins__"];\n}\nvar instance = builtins();\nvar setTimeout = instance.setTimeout;\nvar clearTimeout = instance.clearTimeout;\nvar setInterval = instance.setInterval;\nvar clearInterval = instance.clearInterval;\nvar requestAnimationFrame = instance.requestAnimationFrame;\nvar cancelAnimationFrame = instance.cancelAnimationFrame;\nvar requestIdleCallback = instance.requestIdleCallback;\nvar cancelIdleCallback = instance.cancelIdleCallback;\nvar performance = instance.performance;\nvar Intl = instance.Intl;\nvar Date = instance.Date;\nvar Map = instance.Map;\nvar Set = instance.Set;\n\n// packages/injected/src/clock.ts\nvar ClockController = class {\n  constructor(embedder) {\n    this._duringTick = false;\n    this._uniqueTimerId = idCounterStart;\n    this.disposables = [];\n    this._log = [];\n    this._timers = new Map();\n    this._now = { time: asWallTime(0), isFixedTime: false, ticks: 0, origin: asWallTime(-1) };\n    this._embedder = embedder;\n  }\n  uninstall() {\n    this.disposables.forEach((dispose) => dispose());\n    this.disposables.length = 0;\n  }\n  now() {\n    this._replayLogOnce();\n    this._syncRealTime();\n    return this._now.time;\n  }\n  install(time) {\n    this._replayLogOnce();\n    this._innerSetTime(asWallTime(time));\n  }\n  setSystemTime(time) {\n    this._replayLogOnce();\n    this._innerSetTime(asWallTime(time));\n  }\n  setFixedTime(time) {\n    this._replayLogOnce();\n    this._innerSetFixedTime(asWallTime(time));\n  }\n  performanceNow() {\n    this._replayLogOnce();\n    this._syncRealTime();\n    return this._now.ticks;\n  }\n  _syncRealTime() {\n    if (!this._realTime)\n      return;\n    const now = this._embedder.performanceNow();\n    const sinceLastSync = now - this._realTime.lastSyncTicks;\n    if (sinceLastSync > 0) {\n      this._advanceNow(shiftTicks(this._now.ticks, sinceLastSync));\n      this._realTime.lastSyncTicks = now;\n    }\n  }\n  _innerSetTime(time) {\n    this._now.time = time;\n    this._now.isFixedTime = false;\n    if (this._now.origin < 0)\n      this._now.origin = this._now.time;\n  }\n  _innerSetFixedTime(time) {\n    this._innerSetTime(time);\n    this._now.isFixedTime = true;\n  }\n  _advanceNow(to) {\n    if (!this._now.isFixedTime)\n      this._now.time = asWallTime(this._now.time + to - this._now.ticks);\n    this._now.ticks = to;\n  }\n  async log(type, time, param) {\n    this._log.push({ type, time, param });\n  }\n  async runFor(ticks) {\n    this._replayLogOnce();\n    if (ticks < 0)\n      throw new TypeError("Negative ticks are not supported");\n    await this._runTo(shiftTicks(this._now.ticks, ticks));\n  }\n  async _runTo(to) {\n    to = Math.ceil(to);\n    if (this._now.ticks > to)\n      return;\n    let firstException;\n    while (true) {\n      const result = await this._callFirstTimer(to);\n      if (!result.timerFound)\n        break;\n      firstException = firstException || result.error;\n    }\n    this._advanceNow(to);\n    if (firstException)\n      throw firstException;\n  }\n  async pauseAt(time) {\n    this._replayLogOnce();\n    this._innerPause();\n    const toConsume = time - this._now.time;\n    await this._innerFastForwardTo(shiftTicks(this._now.ticks, toConsume));\n    return toConsume;\n  }\n  _innerPause() {\n    this._realTime = void 0;\n    this._updateRealTimeTimer();\n  }\n  resume() {\n    this._replayLogOnce();\n    this._innerResume();\n  }\n  _innerResume() {\n    const now = this._embedder.performanceNow();\n    this._realTime = { startTicks: now, lastSyncTicks: now };\n    this._updateRealTimeTimer();\n  }\n  _updateRealTimeTimer() {\n    var _a;\n    if (!this._realTime) {\n      (_a = this._currentRealTimeTimer) == null ? void 0 : _a.dispose();\n      this._currentRealTimeTimer = void 0;\n      return;\n    }\n    const firstTimer = this._firstTimer();\n    const callAt = Math.min(firstTimer ? firstTimer.callAt : this._now.ticks + maxTimeout, this._now.ticks + 100);\n    if (this._currentRealTimeTimer && this._currentRealTimeTimer.callAt < callAt)\n      return;\n    if (this._currentRealTimeTimer) {\n      this._currentRealTimeTimer.dispose();\n      this._currentRealTimeTimer = void 0;\n    }\n    this._currentRealTimeTimer = {\n      callAt,\n      dispose: this._embedder.setTimeout(() => {\n        this._currentRealTimeTimer = void 0;\n        this._syncRealTime();\n        void this._runTo(this._now.ticks).catch((e) => console.error(e)).then(() => this._updateRealTimeTimer());\n      }, callAt - this._now.ticks)\n    };\n  }\n  async fastForward(ticks) {\n    this._replayLogOnce();\n    await this._innerFastForwardTo(shiftTicks(this._now.ticks, ticks | 0));\n  }\n  async _innerFastForwardTo(to) {\n    if (to < this._now.ticks)\n      throw new Error("Cannot fast-forward to the past");\n    for (const timer of this._timers.values()) {\n      if (to > timer.callAt)\n        timer.callAt = to;\n    }\n    await this._runTo(to);\n  }\n  addTimer(options) {\n    this._replayLogOnce();\n    if (options.type === "AnimationFrame" /* AnimationFrame */ && !options.func)\n      throw new Error("Callback must be provided to requestAnimationFrame calls");\n    if (options.type === "IdleCallback" /* IdleCallback */ && !options.func)\n      throw new Error("Callback must be provided to requestIdleCallback calls");\n    if (["Timeout" /* Timeout */, "Interval" /* Interval */].includes(options.type) && !options.func && options.delay === void 0)\n      throw new Error("Callback must be provided to timer calls");\n    let delay = options.delay ? +options.delay : 0;\n    if (!Number.isFinite(delay))\n      delay = 0;\n    delay = delay > maxTimeout ? 1 : delay;\n    delay = Math.max(0, delay);\n    const timer = {\n      type: options.type,\n      func: options.func,\n      args: options.args || [],\n      delay,\n      callAt: shiftTicks(this._now.ticks, delay || (this._duringTick ? 1 : 0)),\n      createdAt: this._now.ticks,\n      id: this._uniqueTimerId++,\n      error: new Error()\n    };\n    this._timers.set(timer.id, timer);\n    if (this._realTime)\n      this._updateRealTimeTimer();\n    return timer.id;\n  }\n  countTimers() {\n    return this._timers.size;\n  }\n  _firstTimer(beforeTick) {\n    let firstTimer = null;\n    for (const timer of this._timers.values()) {\n      const isInRange = beforeTick === void 0 || timer.callAt <= beforeTick;\n      if (isInRange && (!firstTimer || compareTimers(firstTimer, timer) === 1))\n        firstTimer = timer;\n    }\n    return firstTimer;\n  }\n  _takeFirstTimer(beforeTick) {\n    const timer = this._firstTimer(beforeTick);\n    if (!timer)\n      return null;\n    this._advanceNow(timer.callAt);\n    if (timer.type === "Interval" /* Interval */)\n      timer.callAt = shiftTicks(timer.callAt, timer.delay);\n    else\n      this._timers.delete(timer.id);\n    return timer;\n  }\n  async _callFirstTimer(beforeTick) {\n    const timer = this._takeFirstTimer(beforeTick);\n    if (!timer)\n      return { timerFound: false };\n    this._duringTick = true;\n    try {\n      if (typeof timer.func !== "function") {\n        let error2;\n        try {\n          (() => {\n            globalThis.eval(timer.func);\n          })();\n        } catch (e) {\n          error2 = e;\n        }\n        await new Promise((f) => this._embedder.setTimeout(f));\n        return { timerFound: true, error: error2 };\n      }\n      let args = timer.args;\n      if (timer.type === "AnimationFrame" /* AnimationFrame */)\n        args = [this._now.ticks];\n      else if (timer.type === "IdleCallback" /* IdleCallback */)\n        args = [{ didTimeout: false, timeRemaining: () => 0 }];\n      let error;\n      try {\n        timer.func.apply(null, args);\n      } catch (e) {\n        error = e;\n      }\n      await new Promise((f) => this._embedder.setTimeout(f));\n      return { timerFound: true, error };\n    } finally {\n      this._duringTick = false;\n    }\n  }\n  getTimeToNextFrame() {\n    return 16 - this._now.ticks % 16;\n  }\n  clearTimer(timerId, type) {\n    this._replayLogOnce();\n    if (!timerId) {\n      return;\n    }\n    const id = Number(timerId);\n    if (Number.isNaN(id) || id < idCounterStart) {\n      const handlerName = getClearHandler(type);\n      new Error(`Clock: ${handlerName} was invoked to clear a native timer instead of one created by the clock library.`);\n    }\n    const timer = this._timers.get(id);\n    if (timer) {\n      if (timer.type === type || timer.type === "Timeout" && type === "Interval" || timer.type === "Interval" && type === "Timeout") {\n        this._timers.delete(id);\n      } else {\n        const clear = getClearHandler(type);\n        const schedule = getScheduleHandler(timer.type);\n        throw new Error(\n          `Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`\n        );\n      }\n    }\n  }\n  _replayLogOnce() {\n    if (!this._log.length)\n      return;\n    let lastLogTime = -1;\n    let isPaused = false;\n    for (const { type, time, param } of this._log) {\n      if (!isPaused && lastLogTime !== -1)\n        this._advanceNow(shiftTicks(this._now.ticks, time - lastLogTime));\n      lastLogTime = time;\n      if (type === "install") {\n        this._innerSetTime(asWallTime(param));\n      } else if (type === "fastForward" || type === "runFor") {\n        this._advanceNow(shiftTicks(this._now.ticks, param));\n      } else if (type === "pauseAt") {\n        isPaused = true;\n        this._innerPause();\n        this._innerSetTime(asWallTime(param));\n      } else if (type === "resume") {\n        this._innerResume();\n        isPaused = false;\n      } else if (type === "setFixedTime") {\n        this._innerSetFixedTime(asWallTime(param));\n      } else if (type === "setSystemTime") {\n        this._innerSetTime(asWallTime(param));\n      }\n    }\n    if (!isPaused && lastLogTime > 0)\n      this._advanceNow(shiftTicks(this._now.ticks, this._embedder.dateNow() - lastLogTime));\n    this._log.length = 0;\n  }\n};\nfunction mirrorDateProperties(target, source) {\n  for (const prop in source) {\n    if (source.hasOwnProperty(prop))\n      target[prop] = source[prop];\n  }\n  target.toString = () => source.toString();\n  target.prototype = source.prototype;\n  target.parse = source.parse;\n  target.UTC = source.UTC;\n  target.prototype.toUTCString = source.prototype.toUTCString;\n  target.isFake = true;\n  return target;\n}\nfunction createDate(clock, NativeDate) {\n  function ClockDate(year, month, date, hour, minute, second, ms) {\n    if (!(this instanceof ClockDate))\n      return new NativeDate(clock.now()).toString();\n    switch (arguments.length) {\n      case 0:\n        return new NativeDate(clock.now());\n      case 1:\n        return new NativeDate(year);\n      case 2:\n        return new NativeDate(year, month);\n      case 3:\n        return new NativeDate(year, month, date);\n      case 4:\n        return new NativeDate(year, month, date, hour);\n      case 5:\n        return new NativeDate(year, month, date, hour, minute);\n      case 6:\n        return new NativeDate(\n          year,\n          month,\n          date,\n          hour,\n          minute,\n          second\n        );\n      default:\n        return new NativeDate(\n          year,\n          month,\n          date,\n          hour,\n          minute,\n          second,\n          ms\n        );\n    }\n  }\n  ClockDate.now = () => clock.now();\n  return mirrorDateProperties(ClockDate, NativeDate);\n}\nfunction createIntl(clock, NativeIntl) {\n  const ClockIntl = {};\n  for (const key of Object.getOwnPropertyNames(NativeIntl))\n    ClockIntl[key] = NativeIntl[key];\n  ClockIntl.DateTimeFormat = function(...args) {\n    const realFormatter = new NativeIntl.DateTimeFormat(...args);\n    const formatter = {\n      formatRange: realFormatter.formatRange.bind(realFormatter),\n      formatRangeToParts: realFormatter.formatRangeToParts.bind(realFormatter),\n      resolvedOptions: realFormatter.resolvedOptions.bind(realFormatter),\n      format: (date) => realFormatter.format(date || clock.now()),\n      formatToParts: (date) => realFormatter.formatToParts(date || clock.now())\n    };\n    return formatter;\n  };\n  ClockIntl.DateTimeFormat.prototype = Object.create(\n    NativeIntl.DateTimeFormat.prototype\n  );\n  ClockIntl.DateTimeFormat.supportedLocalesOf = NativeIntl.DateTimeFormat.supportedLocalesOf;\n  return ClockIntl;\n}\nfunction compareTimers(a, b) {\n  if (a.callAt < b.callAt)\n    return -1;\n  if (a.callAt > b.callAt)\n    return 1;\n  if (a.type === "Immediate" /* Immediate */ && b.type !== "Immediate" /* Immediate */)\n    return -1;\n  if (a.type !== "Immediate" /* Immediate */ && b.type === "Immediate" /* Immediate */)\n    return 1;\n  if (a.createdAt < b.createdAt)\n    return -1;\n  if (a.createdAt > b.createdAt)\n    return 1;\n  if (a.id < b.id)\n    return -1;\n  if (a.id > b.id)\n    return 1;\n}\nvar maxTimeout = Math.pow(2, 31) - 1;\nvar idCounterStart = 1e12;\nfunction platformOriginals(globalObject) {\n  const raw = {\n    setTimeout: globalObject.setTimeout,\n    clearTimeout: globalObject.clearTimeout,\n    setInterval: globalObject.setInterval,\n    clearInterval: globalObject.clearInterval,\n    requestAnimationFrame: globalObject.requestAnimationFrame ? globalObject.requestAnimationFrame : void 0,\n    cancelAnimationFrame: globalObject.cancelAnimationFrame ? globalObject.cancelAnimationFrame : void 0,\n    requestIdleCallback: globalObject.requestIdleCallback ? globalObject.requestIdleCallback : void 0,\n    cancelIdleCallback: globalObject.cancelIdleCallback ? globalObject.cancelIdleCallback : void 0,\n    Date: globalObject.Date,\n    performance: globalObject.performance,\n    Intl: globalObject.Intl\n  };\n  const bound = { ...raw };\n  for (const key of Object.keys(bound)) {\n    if (key !== "Date" && typeof bound[key] === "function")\n      bound[key] = bound[key].bind(globalObject);\n  }\n  return { raw, bound };\n}\nfunction getScheduleHandler(type) {\n  if (type === "IdleCallback" || type === "AnimationFrame")\n    return `request${type}`;\n  return `set${type}`;\n}\nfunction createApi(clock, originals) {\n  return {\n    setTimeout: (func, timeout, ...args) => {\n      const delay = timeout ? +timeout : timeout;\n      return clock.addTimer({\n        type: "Timeout" /* Timeout */,\n        func,\n        args,\n        delay\n      });\n    },\n    clearTimeout: (timerId) => {\n      if (timerId)\n        clock.clearTimer(timerId, "Timeout" /* Timeout */);\n    },\n    setInterval: (func, timeout, ...args) => {\n      const delay = timeout ? +timeout : timeout;\n      return clock.addTimer({\n        type: "Interval" /* Interval */,\n        func,\n        args,\n        delay\n      });\n    },\n    clearInterval: (timerId) => {\n      if (timerId)\n        return clock.clearTimer(timerId, "Interval" /* Interval */);\n    },\n    requestAnimationFrame: (callback) => {\n      return clock.addTimer({\n        type: "AnimationFrame" /* AnimationFrame */,\n        func: callback,\n        delay: clock.getTimeToNextFrame()\n      });\n    },\n    cancelAnimationFrame: (timerId) => {\n      if (timerId)\n        return clock.clearTimer(timerId, "AnimationFrame" /* AnimationFrame */);\n    },\n    requestIdleCallback: (callback, options) => {\n      let timeToNextIdlePeriod = 0;\n      if (clock.countTimers() > 0)\n        timeToNextIdlePeriod = 50;\n      return clock.addTimer({\n        type: "IdleCallback" /* IdleCallback */,\n        func: callback,\n        delay: (options == null ? void 0 : options.timeout) ? Math.min(options == null ? void 0 : options.timeout, timeToNextIdlePeriod) : timeToNextIdlePeriod\n      });\n    },\n    cancelIdleCallback: (timerId) => {\n      if (timerId)\n        return clock.clearTimer(timerId, "IdleCallback" /* IdleCallback */);\n    },\n    Intl: originals.Intl ? createIntl(clock, originals.Intl) : void 0,\n    Date: createDate(clock, originals.Date),\n    performance: originals.performance ? fakePerformance(clock, originals.performance) : void 0\n  };\n}\nfunction getClearHandler(type) {\n  if (type === "IdleCallback" || type === "AnimationFrame")\n    return `cancel${type}`;\n  return `clear${type}`;\n}\nfunction fakePerformance(clock, performance2) {\n  const result = {\n    now: () => clock.performanceNow()\n  };\n  result.__defineGetter__("timeOrigin", () => clock._now.origin || 0);\n  for (const key of Object.keys(performance2.__proto__)) {\n    if (key === "now" || key === "timeOrigin")\n      continue;\n    if (key === "getEntries" || key === "getEntriesByName" || key === "getEntriesByType")\n      result[key] = () => [];\n    else\n      result[key] = () => {\n      };\n  }\n  return result;\n}\nfunction createClock(globalObject) {\n  const originals = platformOriginals(globalObject);\n  const embedder = {\n    dateNow: () => originals.raw.Date.now(),\n    performanceNow: () => Math.ceil(originals.raw.performance.now()),\n    setTimeout: (task, timeout) => {\n      const timerId = originals.bound.setTimeout(task, timeout);\n      return () => originals.bound.clearTimeout(timerId);\n    },\n    setInterval: (task, delay) => {\n      const intervalId = originals.bound.setInterval(task, delay);\n      return () => originals.bound.clearInterval(intervalId);\n    }\n  };\n  const clock = new ClockController(embedder);\n  const api = createApi(clock, originals.bound);\n  return { clock, api, originals: originals.raw };\n}\nfunction install(globalObject, config = {}) {\n  var _a, _b;\n  if ((_a = globalObject.Date) == null ? void 0 : _a.isFake) {\n    throw new TypeError(`Can\'t install fake timers twice on the same global object.`);\n  }\n  const { clock, api, originals } = createClock(globalObject);\n  const toFake = ((_b = config.toFake) == null ? void 0 : _b.length) ? config.toFake : Object.keys(originals);\n  for (const method of toFake) {\n    if (method === "Date") {\n      globalObject.Date = mirrorDateProperties(api.Date, globalObject.Date);\n    } else if (method === "Intl") {\n      globalObject.Intl = api[method];\n    } else if (method === "performance") {\n      globalObject.performance = api[method];\n      const kEventTimeStamp = Symbol("playwrightEventTimeStamp");\n      Object.defineProperty(Event.prototype, "timeStamp", {\n        get() {\n          var _a2;\n          if (!this[kEventTimeStamp])\n            this[kEventTimeStamp] = (_a2 = api.performance) == null ? void 0 : _a2.now();\n          return this[kEventTimeStamp];\n        }\n      });\n    } else {\n      globalObject[method] = (...args) => {\n        return api[method].apply(api, args);\n      };\n    }\n    clock.disposables.push(() => {\n      globalObject[method] = originals[method];\n    });\n  }\n  return { clock, api, originals };\n}\nfunction inject(globalObject) {\n  const builtin = platformOriginals(globalObject).bound;\n  const { clock: controller } = install(globalObject);\n  controller.resume();\n  return {\n    controller,\n    builtin\n  };\n}\nfunction asWallTime(n) {\n  return n;\n}\nfunction shiftTicks(ticks, ms) {\n  return ticks + ms;\n}\n';

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/clock.js
var Clock = class {
  static {
    __name(this, "Clock");
  }
  constructor(browserContext) {
    this._scriptInstalled = false;
    this._browserContext = browserContext;
  }
  markAsUninstalled() {
    this._scriptInstalled = false;
  }
  async fastForward(ticks) {
    await this._installIfNeeded();
    const ticksMillis = parseTicks(ticks);
    await this._browserContext.addInitScript(`globalThis.__pwClock.controller.log('fastForward', ${Date.now()}, ${ticksMillis})`);
    await this._evaluateInFrames(`globalThis.__pwClock.controller.fastForward(${ticksMillis})`);
  }
  async install(time3) {
    await this._installIfNeeded();
    const timeMillis = time3 !== void 0 ? parseTime(time3) : Date.now();
    await this._browserContext.addInitScript(`globalThis.__pwClock.controller.log('install', ${Date.now()}, ${timeMillis})`);
    await this._evaluateInFrames(`globalThis.__pwClock.controller.install(${timeMillis})`);
  }
  async pauseAt(ticks) {
    await this._installIfNeeded();
    const timeMillis = parseTime(ticks);
    await this._browserContext.addInitScript(`globalThis.__pwClock.controller.log('pauseAt', ${Date.now()}, ${timeMillis})`);
    await this._evaluateInFrames(`globalThis.__pwClock.controller.pauseAt(${timeMillis})`);
  }
  async resume() {
    await this._installIfNeeded();
    await this._browserContext.addInitScript(`globalThis.__pwClock.controller.log('resume', ${Date.now()})`);
    await this._evaluateInFrames(`globalThis.__pwClock.controller.resume()`);
  }
  async setFixedTime(time3) {
    await this._installIfNeeded();
    const timeMillis = parseTime(time3);
    await this._browserContext.addInitScript(`globalThis.__pwClock.controller.log('setFixedTime', ${Date.now()}, ${timeMillis})`);
    await this._evaluateInFrames(`globalThis.__pwClock.controller.setFixedTime(${timeMillis})`);
  }
  async setSystemTime(time3) {
    await this._installIfNeeded();
    const timeMillis = parseTime(time3);
    await this._browserContext.addInitScript(`globalThis.__pwClock.controller.log('setSystemTime', ${Date.now()}, ${timeMillis})`);
    await this._evaluateInFrames(`globalThis.__pwClock.controller.setSystemTime(${timeMillis})`);
  }
  async runFor(ticks) {
    await this._installIfNeeded();
    const ticksMillis = parseTicks(ticks);
    await this._browserContext.addInitScript(`globalThis.__pwClock.controller.log('runFor', ${Date.now()}, ${ticksMillis})`);
    await this._evaluateInFrames(`globalThis.__pwClock.controller.runFor(${ticksMillis})`);
  }
  async _installIfNeeded() {
    if (this._scriptInstalled)
      return;
    this._scriptInstalled = true;
    const script = `(() => {
      const module = {};
      ${source}
      globalThis.__pwClock = (module.exports.inject())(globalThis);
    })();`;
    await this._browserContext.addInitScript(script);
    await this._evaluateInFrames(script);
  }
  async _evaluateInFrames(script) {
    await this._browserContext.safeNonStallingEvaluateInAllFrames(script, "main", { throwOnJSErrors: true });
  }
};
function parseTicks(value) {
  if (typeof value === "number")
    return value;
  if (!value)
    return 0;
  const str = value;
  const strings = str.split(":");
  const l = strings.length;
  let i = l;
  let ms3 = 0;
  let parsed;
  if (l > 3 || !/^(\d\d:){0,2}\d\d?$/.test(str)) {
    throw new Error(
      `Clock only understands numbers, 'mm:ss' and 'hh:mm:ss'`
    );
  }
  while (i--) {
    parsed = parseInt(strings[i], 10);
    if (parsed >= 60)
      throw new Error(`Invalid time ${str}`);
    ms3 += parsed * Math.pow(60, l - i - 1);
  }
  return ms3 * 1e3;
}
__name(parseTicks, "parseTicks");
function parseTime(epoch) {
  if (!epoch)
    return 0;
  if (typeof epoch === "number")
    return epoch;
  const parsed = new Date(epoch);
  if (!isFinite(parsed.getTime()))
    throw new Error(`Invalid date: ${epoch}`);
  return parsed.getTime();
}
__name(parseTime, "parseTime");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/debugger.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter7 } from "node:events";
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/protocol/debug.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var slowMoActions = /* @__PURE__ */ new Set([
  "Page.goBack",
  "Page.goForward",
  "Page.reload",
  "Page.keyboardDown",
  "Page.keyboardUp",
  "Page.keyboardInsertText",
  "Page.keyboardType",
  "Page.keyboardPress",
  "Page.mouseMove",
  "Page.mouseDown",
  "Page.mouseUp",
  "Page.mouseClick",
  "Page.mouseWheel",
  "Page.touchscreenTap",
  "Frame.blur",
  "Frame.check",
  "Frame.click",
  "Frame.dragAndDrop",
  "Frame.dblclick",
  "Frame.dispatchEvent",
  "Frame.fill",
  "Frame.focus",
  "Frame.goto",
  "Frame.hover",
  "Frame.press",
  "Frame.selectOption",
  "Frame.setInputFiles",
  "Frame.tap",
  "Frame.type",
  "Frame.uncheck",
  "ElementHandle.check",
  "ElementHandle.click",
  "ElementHandle.dblclick",
  "ElementHandle.dispatchEvent",
  "ElementHandle.fill",
  "ElementHandle.focus",
  "ElementHandle.hover",
  "ElementHandle.press",
  "ElementHandle.scrollIntoViewIfNeeded",
  "ElementHandle.selectOption",
  "ElementHandle.selectText",
  "ElementHandle.setInputFiles",
  "ElementHandle.tap",
  "ElementHandle.type",
  "ElementHandle.uncheck"
]);
var commandsWithTracingSnapshots = /* @__PURE__ */ new Set([
  "EventTarget.waitForEventInfo",
  "BrowserContext.waitForEventInfo",
  "Page.waitForEventInfo",
  "WebSocket.waitForEventInfo",
  "ElectronApplication.waitForEventInfo",
  "AndroidDevice.waitForEventInfo",
  "Page.emulateMedia",
  "Page.goBack",
  "Page.goForward",
  "Page.reload",
  "Page.expectScreenshot",
  "Page.screenshot",
  "Page.setViewportSize",
  "Page.keyboardDown",
  "Page.keyboardUp",
  "Page.keyboardInsertText",
  "Page.keyboardType",
  "Page.keyboardPress",
  "Page.mouseMove",
  "Page.mouseDown",
  "Page.mouseUp",
  "Page.mouseClick",
  "Page.mouseWheel",
  "Page.touchscreenTap",
  "Page.accessibilitySnapshot",
  "Frame.evalOnSelector",
  "Frame.evalOnSelectorAll",
  "Frame.addScriptTag",
  "Frame.addStyleTag",
  "Frame.ariaSnapshot",
  "Frame.blur",
  "Frame.check",
  "Frame.click",
  "Frame.content",
  "Frame.dragAndDrop",
  "Frame.dblclick",
  "Frame.dispatchEvent",
  "Frame.evaluateExpression",
  "Frame.evaluateExpressionHandle",
  "Frame.fill",
  "Frame.focus",
  "Frame.getAttribute",
  "Frame.goto",
  "Frame.hover",
  "Frame.innerHTML",
  "Frame.innerText",
  "Frame.inputValue",
  "Frame.isChecked",
  "Frame.isDisabled",
  "Frame.isEnabled",
  "Frame.isHidden",
  "Frame.isVisible",
  "Frame.isEditable",
  "Frame.press",
  "Frame.querySelector",
  "Frame.querySelectorAll",
  "Frame.queryCount",
  "Frame.selectOption",
  "Frame.setContent",
  "Frame.setInputFiles",
  "Frame.tap",
  "Frame.textContent",
  "Frame.type",
  "Frame.uncheck",
  "Frame.waitForTimeout",
  "Frame.waitForFunction",
  "Frame.waitForSelector",
  "Frame.expect",
  "JSHandle.evaluateExpression",
  "ElementHandle.evaluateExpression",
  "JSHandle.evaluateExpressionHandle",
  "ElementHandle.evaluateExpressionHandle",
  "ElementHandle.evalOnSelector",
  "ElementHandle.evalOnSelectorAll",
  "ElementHandle.boundingBox",
  "ElementHandle.check",
  "ElementHandle.click",
  "ElementHandle.contentFrame",
  "ElementHandle.dblclick",
  "ElementHandle.dispatchEvent",
  "ElementHandle.fill",
  "ElementHandle.focus",
  "ElementHandle.hover",
  "ElementHandle.innerHTML",
  "ElementHandle.innerText",
  "ElementHandle.inputValue",
  "ElementHandle.isChecked",
  "ElementHandle.isDisabled",
  "ElementHandle.isEditable",
  "ElementHandle.isEnabled",
  "ElementHandle.isHidden",
  "ElementHandle.isVisible",
  "ElementHandle.press",
  "ElementHandle.querySelector",
  "ElementHandle.querySelectorAll",
  "ElementHandle.screenshot",
  "ElementHandle.scrollIntoViewIfNeeded",
  "ElementHandle.selectOption",
  "ElementHandle.selectText",
  "ElementHandle.setInputFiles",
  "ElementHandle.tap",
  "ElementHandle.textContent",
  "ElementHandle.type",
  "ElementHandle.uncheck",
  "ElementHandle.waitForElementState",
  "ElementHandle.waitForSelector"
]);
var pausesBeforeInputActions = /* @__PURE__ */ new Set([
  "Frame.check",
  "Frame.click",
  "Frame.dragAndDrop",
  "Frame.dblclick",
  "Frame.fill",
  "Frame.hover",
  "Frame.press",
  "Frame.selectOption",
  "Frame.setInputFiles",
  "Frame.tap",
  "Frame.type",
  "Frame.uncheck",
  "ElementHandle.check",
  "ElementHandle.click",
  "ElementHandle.dblclick",
  "ElementHandle.fill",
  "ElementHandle.hover",
  "ElementHandle.press",
  "ElementHandle.selectOption",
  "ElementHandle.setInputFiles",
  "ElementHandle.tap",
  "ElementHandle.type",
  "ElementHandle.uncheck"
]);

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/debugger.js
var symbol = Symbol("Debugger");
var Debugger = class _Debugger extends EventEmitter7 {
  static {
    __name(this, "Debugger");
  }
  constructor(context2) {
    super();
    this._pauseOnNextStatement = false;
    this._pausedCallsMetadata = /* @__PURE__ */ new Map();
    this._muted = false;
    this._context = context2;
    this._context[symbol] = this;
    this._enabled = debugMode() === "inspector";
    if (this._enabled)
      this.pauseOnNextStatement();
    context2.instrumentation.addListener(this, context2);
    this._context.once(BrowserContext.Events.Close, () => {
      this._context.instrumentation.removeListener(this);
    });
    this._slowMo = this._context._browser.options.slowMo;
  }
  static {
    this.Events = {
      PausedStateChanged: "pausedstatechanged"
    };
  }
  async setMuted(muted) {
    this._muted = muted;
  }
  async onBeforeCall(sdkObject, metadata) {
    if (this._muted)
      return;
    if (shouldPauseOnCall(sdkObject, metadata) || this._pauseOnNextStatement && shouldPauseBeforeStep(metadata))
      await this.pause(sdkObject, metadata);
  }
  async _doSlowMo() {
    await new Promise((f) => setTimeout(f, this._slowMo));
  }
  async onAfterCall(sdkObject, metadata) {
    if (this._slowMo && shouldSlowMo(metadata))
      await this._doSlowMo();
  }
  async onBeforeInputAction(sdkObject, metadata) {
    if (this._muted)
      return;
    if (this._enabled && this._pauseOnNextStatement)
      await this.pause(sdkObject, metadata);
  }
  async pause(sdkObject, metadata) {
    if (this._muted)
      return;
    this._enabled = true;
    metadata.pauseStartTime = monotonicTime();
    const result = new Promise((resolve) => {
      this._pausedCallsMetadata.set(metadata, { resolve, sdkObject });
    });
    this.emit(_Debugger.Events.PausedStateChanged);
    return result;
  }
  resume(step) {
    if (!this.isPaused())
      return;
    this._pauseOnNextStatement = step;
    const endTime = monotonicTime();
    for (const [metadata, { resolve }] of this._pausedCallsMetadata) {
      metadata.pauseEndTime = endTime;
      resolve();
    }
    this._pausedCallsMetadata.clear();
    this.emit(_Debugger.Events.PausedStateChanged);
  }
  pauseOnNextStatement() {
    this._pauseOnNextStatement = true;
  }
  isPaused(metadata) {
    if (metadata)
      return this._pausedCallsMetadata.has(metadata);
    return !!this._pausedCallsMetadata.size;
  }
  pausedDetails() {
    const result = [];
    for (const [metadata, { sdkObject }] of this._pausedCallsMetadata)
      result.push({ metadata, sdkObject });
    return result;
  }
};
function shouldPauseOnCall(sdkObject, metadata) {
  if (sdkObject.attribution.playwright.options.isServer)
    return false;
  if (!sdkObject.attribution.browser?.options.headful && !isUnderTest())
    return false;
  return metadata.method === "pause";
}
__name(shouldPauseOnCall, "shouldPauseOnCall");
function shouldPauseBeforeStep(metadata) {
  if (!metadata.apiName)
    return false;
  if (metadata.method === "close")
    return true;
  if (metadata.method === "waitForSelector" || metadata.method === "waitForEventInfo" || metadata.method === "querySelector" || metadata.method === "querySelectorAll")
    return false;
  const step = metadata.type + "." + metadata.method;
  return commandsWithTracingSnapshots.has(step) && !pausesBeforeInputActions.has(metadata.type + "." + metadata.method);
}
__name(shouldPauseBeforeStep, "shouldPauseBeforeStep");
function shouldSlowMo(metadata) {
  return slowMoActions.has(metadata.type + "." + metadata.method);
}
__name(shouldSlowMo, "shouldSlowMo");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/har/harRecorder.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path11 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/artifact.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var Artifact = class extends SdkObject {
  static {
    __name(this, "Artifact");
  }
  constructor(parent, localPath, unaccessibleErrorMessage, cancelCallback) {
    super(parent, "artifact");
    this._finishedPromise = new ManualPromise();
    this._saveCallbacks = [];
    this._finished = false;
    this._deleted = false;
    this._localPath = localPath;
    this._unaccessibleErrorMessage = unaccessibleErrorMessage;
    this._cancelCallback = cancelCallback;
  }
  finishedPromise() {
    return this._finishedPromise;
  }
  localPath() {
    return this._localPath;
  }
  async localPathAfterFinished() {
    if (this._unaccessibleErrorMessage)
      throw new Error(this._unaccessibleErrorMessage);
    await this._finishedPromise;
    if (this._failureError)
      throw this._failureError;
    return this._localPath;
  }
  saveAs(saveCallback) {
    if (this._unaccessibleErrorMessage)
      throw new Error(this._unaccessibleErrorMessage);
    if (this._deleted)
      throw new Error(`File already deleted. Save before deleting.`);
    if (this._failureError)
      throw this._failureError;
    if (this._finished) {
      saveCallback(this._localPath).catch(() => {
      });
      return;
    }
    this._saveCallbacks.push(saveCallback);
  }
  async failureError() {
    if (this._unaccessibleErrorMessage)
      return this._unaccessibleErrorMessage;
    await this._finishedPromise;
    return this._failureError?.message || null;
  }
  async cancel() {
    assert3(this._cancelCallback !== void 0);
    return this._cancelCallback();
  }
  async delete() {
    if (this._unaccessibleErrorMessage)
      return;
    const fileName = await this.localPathAfterFinished();
    if (this._deleted)
      return;
    this._deleted = true;
    if (fileName)
      await fs.promises.unlink(fileName).catch((e) => {
      });
  }
  async deleteOnContextClose() {
    if (this._deleted)
      return;
    this._deleted = true;
    if (!this._unaccessibleErrorMessage)
      await fs.promises.unlink(this._localPath).catch((e) => {
      });
    await this.reportFinished(new TargetClosedError());
  }
  async reportFinished(error4) {
    if (this._finished)
      return;
    this._finished = true;
    this._failureError = error4;
    if (error4) {
      for (const callback of this._saveCallbacks)
        await callback("", error4);
    } else {
      for (const callback of this._saveCallbacks)
        await callback(this._localPath);
    }
    this._saveCallbacks = [];
    this._finishedPromise.resolve();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/har/harTracer.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/frames.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dom.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/javascript.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/generated/utilityScriptSource.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source2 = '\nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, \'default\': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/utilityScript.ts\nvar utilityScript_exports = {};\n__export(utilityScript_exports, {\n  UtilityScript: () => UtilityScript\n});\nmodule.exports = __toCommonJS(utilityScript_exports);\n\n// packages/playwright-core/src/utils/isomorphic/builtins.ts\nfunction builtins(global) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  global = global != null ? global : globalThis;\n  if (!global["__playwright_builtins__"]) {\n    const builtins2 = {\n      setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),\n      clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),\n      setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\n      clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\n      requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\n      cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\n      requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\n      cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\n      performance: global.performance,\n      eval: (_i = global.eval) == null ? void 0 : _i.bind(global),\n      Intl: global.Intl,\n      Date: global.Date,\n      Map: global.Map,\n      Set: global.Set\n    };\n    Object.defineProperty(global, "__playwright_builtins__", { value: builtins2, configurable: false, enumerable: false, writable: false });\n  }\n  return global["__playwright_builtins__"];\n}\nvar instance = builtins();\nvar setTimeout = instance.setTimeout;\nvar clearTimeout = instance.clearTimeout;\nvar setInterval = instance.setInterval;\nvar clearInterval = instance.clearInterval;\nvar requestAnimationFrame = instance.requestAnimationFrame;\nvar cancelAnimationFrame = instance.cancelAnimationFrame;\nvar requestIdleCallback = instance.requestIdleCallback;\nvar cancelIdleCallback = instance.cancelIdleCallback;\nvar performance = instance.performance;\nvar Intl = instance.Intl;\nvar Date = instance.Date;\nvar Map = instance.Map;\nvar Set = instance.Set;\n\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\nfunction source(builtins2) {\n  function isRegExp(obj) {\n    try {\n      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isDate(obj) {\n    try {\n      return obj instanceof builtins2.Date || Object.prototype.toString.call(obj) === "[object Date]";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isURL(obj) {\n    try {\n      return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isError(obj) {\n    var _a;\n    try {\n      return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === "Error";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isTypedArray(obj, constructor) {\n    try {\n      return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\n    } catch (error) {\n      return false;\n    }\n  }\n  const typedArrayConstructors = {\n    i8: Int8Array,\n    ui8: Uint8Array,\n    ui8c: Uint8ClampedArray,\n    i16: Int16Array,\n    ui16: Uint16Array,\n    i32: Int32Array,\n    ui32: Uint32Array,\n    // TODO: add Float16Array once it\'s in baseline\n    f32: Float32Array,\n    f64: Float64Array,\n    bi64: BigInt64Array,\n    bui64: BigUint64Array\n  };\n  function typedArrayToBase64(array) {\n    if ("toBase64" in array)\n      return array.toBase64();\n    const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join("");\n    return btoa(binary);\n  }\n  function base64ToTypedArray(base64, TypedArrayConstructor) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++)\n      bytes[i] = binary.charCodeAt(i);\n    return new TypedArrayConstructor(bytes.buffer);\n  }\n  function parseEvaluationResultValue(value, handles = [], refs = new builtins2.Map()) {\n    if (Object.is(value, void 0))\n      return void 0;\n    if (typeof value === "object" && value) {\n      if ("ref" in value)\n        return refs.get(value.ref);\n      if ("v" in value) {\n        if (value.v === "undefined")\n          return void 0;\n        if (value.v === "null")\n          return null;\n        if (value.v === "NaN")\n          return NaN;\n        if (value.v === "Infinity")\n          return Infinity;\n        if (value.v === "-Infinity")\n          return -Infinity;\n        if (value.v === "-0")\n          return -0;\n        return void 0;\n      }\n      if ("d" in value)\n        return new builtins2.Date(value.d);\n      if ("u" in value)\n        return new URL(value.u);\n      if ("bi" in value)\n        return BigInt(value.bi);\n      if ("e" in value) {\n        const error = new Error(value.e.m);\n        error.name = value.e.n;\n        error.stack = value.e.s;\n        return error;\n      }\n      if ("r" in value)\n        return new RegExp(value.r.p, value.r.f);\n      if ("a" in value) {\n        const result = [];\n        refs.set(value.id, result);\n        for (const a of value.a)\n          result.push(parseEvaluationResultValue(a, handles, refs));\n        return result;\n      }\n      if ("o" in value) {\n        const result = {};\n        refs.set(value.id, result);\n        for (const { k, v } of value.o)\n          result[k] = parseEvaluationResultValue(v, handles, refs);\n        return result;\n      }\n      if ("h" in value)\n        return handles[value.h];\n      if ("ta" in value)\n        return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);\n    }\n    return value;\n  }\n  function serializeAsCallArgument(value, handleSerializer) {\n    return serialize(value, handleSerializer, { visited: new builtins2.Map(), lastId: 0 });\n  }\n  function serialize(value, handleSerializer, visitorInfo) {\n    if (value && typeof value === "object") {\n      if (typeof globalThis.Window === "function" && value instanceof globalThis.Window)\n        return "ref: <Window>";\n      if (typeof globalThis.Document === "function" && value instanceof globalThis.Document)\n        return "ref: <Document>";\n      if (typeof globalThis.Node === "function" && value instanceof globalThis.Node)\n        return "ref: <Node>";\n    }\n    return innerSerialize(value, handleSerializer, visitorInfo);\n  }\n  function innerSerialize(value, handleSerializer, visitorInfo) {\n    var _a;\n    const result = handleSerializer(value);\n    if ("fallThrough" in result)\n      value = result.fallThrough;\n    else\n      return result;\n    if (typeof value === "symbol")\n      return { v: "undefined" };\n    if (Object.is(value, void 0))\n      return { v: "undefined" };\n    if (Object.is(value, null))\n      return { v: "null" };\n    if (Object.is(value, NaN))\n      return { v: "NaN" };\n    if (Object.is(value, Infinity))\n      return { v: "Infinity" };\n    if (Object.is(value, -Infinity))\n      return { v: "-Infinity" };\n    if (Object.is(value, -0))\n      return { v: "-0" };\n    if (typeof value === "boolean")\n      return value;\n    if (typeof value === "number")\n      return value;\n    if (typeof value === "string")\n      return value;\n    if (typeof value === "bigint")\n      return { bi: value.toString() };\n    if (isError(value)) {\n      let stack;\n      if ((_a = value.stack) == null ? void 0 : _a.startsWith(value.name + ": " + value.message)) {\n        stack = value.stack;\n      } else {\n        stack = `${value.name}: ${value.message}\n${value.stack}`;\n      }\n      return { e: { n: value.name, m: value.message, s: stack } };\n    }\n    if (isDate(value))\n      return { d: value.toJSON() };\n    if (isURL(value))\n      return { u: value.toJSON() };\n    if (isRegExp(value))\n      return { r: { p: value.source, f: value.flags } };\n    for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\n      if (isTypedArray(value, ctor))\n        return { ta: { b: typedArrayToBase64(value), k } };\n    }\n    const id = visitorInfo.visited.get(value);\n    if (id)\n      return { ref: id };\n    if (Array.isArray(value)) {\n      const a = [];\n      const id2 = ++visitorInfo.lastId;\n      visitorInfo.visited.set(value, id2);\n      for (let i = 0; i < value.length; ++i)\n        a.push(serialize(value[i], handleSerializer, visitorInfo));\n      return { a, id: id2 };\n    }\n    if (typeof value === "object") {\n      const o = [];\n      const id2 = ++visitorInfo.lastId;\n      visitorInfo.visited.set(value, id2);\n      for (const name of Object.keys(value)) {\n        let item;\n        try {\n          item = value[name];\n        } catch (e) {\n          continue;\n        }\n        if (name === "toJSON" && typeof item === "function")\n          o.push({ k: name, v: { o: [], id: 0 } });\n        else\n          o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\n      }\n      let jsonWrapper;\n      try {\n        if (o.length === 0 && value.toJSON && typeof value.toJSON === "function")\n          jsonWrapper = { value: value.toJSON() };\n      } catch (e) {\n      }\n      if (jsonWrapper)\n        return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\n      return { o, id: id2 };\n    }\n  }\n  return { parseEvaluationResultValue, serializeAsCallArgument };\n}\n\n// packages/injected/src/utilityScript.ts\nvar UtilityScript = class {\n  constructor(isUnderTest) {\n    if (isUnderTest) {\n      globalThis.builtins = builtins();\n    }\n    const result = source(builtins());\n    this.serializeAsCallArgument = result.serializeAsCallArgument;\n    this.parseEvaluationResultValue = result.parseEvaluationResultValue;\n  }\n  evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {\n    const args = argsAndHandles.slice(0, argCount);\n    const handles = argsAndHandles.slice(argCount);\n    const parameters = [];\n    for (let i = 0; i < args.length; i++)\n      parameters[i] = this.parseEvaluationResultValue(args[i], handles);\n    let result = builtins().eval(expression);\n    if (isFunction === true) {\n      result = result(...parameters);\n    } else if (isFunction === false) {\n      result = result;\n    } else {\n      if (typeof result === "function")\n        result = result(...parameters);\n    }\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result) : result;\n  }\n  jsonValue(returnByValue, value) {\n    if (value === void 0)\n      return void 0;\n    return this.serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\n  }\n  _promiseAwareJsonValueNoThrow(value) {\n    const safeJson = (value2) => {\n      try {\n        return this.jsonValue(true, value2);\n      } catch (e) {\n        return void 0;\n      }\n    };\n    if (value && typeof value === "object" && typeof value.then === "function") {\n      return (async () => {\n        const promiseValue = await value;\n        return safeJson(promiseValue);\n      })();\n    }\n    return safeJson(value);\n  }\n};\n';

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/javascript.js
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/utilityScriptSerializers.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function source3(builtins2) {
  function isRegExp7(obj) {
    try {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    } catch (error4) {
      return false;
    }
  }
  __name(isRegExp7, "isRegExp");
  function isDate4(obj) {
    try {
      return obj instanceof builtins2.Date || Object.prototype.toString.call(obj) === "[object Date]";
    } catch (error4) {
      return false;
    }
  }
  __name(isDate4, "isDate");
  function isURL2(obj) {
    try {
      return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";
    } catch (error4) {
      return false;
    }
  }
  __name(isURL2, "isURL");
  function isError4(obj) {
    try {
      return obj instanceof Error || obj && Object.getPrototypeOf(obj)?.name === "Error";
    } catch (error4) {
      return false;
    }
  }
  __name(isError4, "isError");
  function isTypedArray(obj, constructor) {
    try {
      return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;
    } catch (error4) {
      return false;
    }
  }
  __name(isTypedArray, "isTypedArray");
  const typedArrayConstructors = {
    i8: Int8Array,
    ui8: Uint8Array,
    ui8c: Uint8ClampedArray,
    i16: Int16Array,
    ui16: Uint16Array,
    i32: Int32Array,
    ui32: Uint32Array,
    // TODO: add Float16Array once it's in baseline
    f32: Float32Array,
    f64: Float64Array,
    bi64: BigInt64Array,
    bui64: BigUint64Array
  };
  function typedArrayToBase64(array) {
    if ("toBase64" in array)
      return array.toBase64();
    const binary2 = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join("");
    return btoa(binary2);
  }
  __name(typedArrayToBase64, "typedArrayToBase64");
  function base64ToTypedArray(base64, TypedArrayConstructor) {
    const binary2 = atob(base64);
    const bytes = new Uint8Array(binary2.length);
    for (let i = 0; i < binary2.length; i++)
      bytes[i] = binary2.charCodeAt(i);
    return new TypedArrayConstructor(bytes.buffer);
  }
  __name(base64ToTypedArray, "base64ToTypedArray");
  function parseEvaluationResultValue2(value, handles = [], refs = new builtins2.Map()) {
    if (Object.is(value, void 0))
      return void 0;
    if (typeof value === "object" && value) {
      if ("ref" in value)
        return refs.get(value.ref);
      if ("v" in value) {
        if (value.v === "undefined")
          return void 0;
        if (value.v === "null")
          return null;
        if (value.v === "NaN")
          return NaN;
        if (value.v === "Infinity")
          return Infinity;
        if (value.v === "-Infinity")
          return -Infinity;
        if (value.v === "-0")
          return -0;
        return void 0;
      }
      if ("d" in value)
        return new builtins2.Date(value.d);
      if ("u" in value)
        return new URL(value.u);
      if ("bi" in value)
        return BigInt(value.bi);
      if ("e" in value) {
        const error4 = new Error(value.e.m);
        error4.name = value.e.n;
        error4.stack = value.e.s;
        return error4;
      }
      if ("r" in value)
        return new RegExp(value.r.p, value.r.f);
      if ("a" in value) {
        const result = [];
        refs.set(value.id, result);
        for (const a of value.a)
          result.push(parseEvaluationResultValue2(a, handles, refs));
        return result;
      }
      if ("o" in value) {
        const result = {};
        refs.set(value.id, result);
        for (const { k, v } of value.o)
          result[k] = parseEvaluationResultValue2(v, handles, refs);
        return result;
      }
      if ("h" in value)
        return handles[value.h];
      if ("ta" in value)
        return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);
    }
    return value;
  }
  __name(parseEvaluationResultValue2, "parseEvaluationResultValue");
  function serializeAsCallArgument2(value, handleSerializer) {
    return serialize(value, handleSerializer, { visited: new builtins2.Map(), lastId: 0 });
  }
  __name(serializeAsCallArgument2, "serializeAsCallArgument");
  function serialize(value, handleSerializer, visitorInfo) {
    if (value && typeof value === "object") {
      if (typeof globalThis.Window === "function" && value instanceof globalThis.Window)
        return "ref: <Window>";
      if (typeof globalThis.Document === "function" && value instanceof globalThis.Document)
        return "ref: <Document>";
      if (typeof globalThis.Node === "function" && value instanceof globalThis.Node)
        return "ref: <Node>";
    }
    return innerSerialize(value, handleSerializer, visitorInfo);
  }
  __name(serialize, "serialize");
  function innerSerialize(value, handleSerializer, visitorInfo) {
    const result = handleSerializer(value);
    if ("fallThrough" in result)
      value = result.fallThrough;
    else
      return result;
    if (typeof value === "symbol")
      return { v: "undefined" };
    if (Object.is(value, void 0))
      return { v: "undefined" };
    if (Object.is(value, null))
      return { v: "null" };
    if (Object.is(value, NaN))
      return { v: "NaN" };
    if (Object.is(value, Infinity))
      return { v: "Infinity" };
    if (Object.is(value, -Infinity))
      return { v: "-Infinity" };
    if (Object.is(value, -0))
      return { v: "-0" };
    if (typeof value === "boolean")
      return value;
    if (typeof value === "number")
      return value;
    if (typeof value === "string")
      return value;
    if (typeof value === "bigint")
      return { bi: value.toString() };
    if (isError4(value)) {
      let stack;
      if (value.stack?.startsWith(value.name + ": " + value.message)) {
        stack = value.stack;
      } else {
        stack = `${value.name}: ${value.message}
${value.stack}`;
      }
      return { e: { n: value.name, m: value.message, s: stack } };
    }
    if (isDate4(value))
      return { d: value.toJSON() };
    if (isURL2(value))
      return { u: value.toJSON() };
    if (isRegExp7(value))
      return { r: { p: value.source, f: value.flags } };
    for (const [k, ctor] of Object.entries(typedArrayConstructors)) {
      if (isTypedArray(value, ctor))
        return { ta: { b: typedArrayToBase64(value), k } };
    }
    const id = visitorInfo.visited.get(value);
    if (id)
      return { ref: id };
    if (Array.isArray(value)) {
      const a = [];
      const id2 = ++visitorInfo.lastId;
      visitorInfo.visited.set(value, id2);
      for (let i = 0; i < value.length; ++i)
        a.push(serialize(value[i], handleSerializer, visitorInfo));
      return { a, id: id2 };
    }
    if (typeof value === "object") {
      const o = [];
      const id2 = ++visitorInfo.lastId;
      visitorInfo.visited.set(value, id2);
      for (const name of Object.keys(value)) {
        let item;
        try {
          item = value[name];
        } catch (e) {
          continue;
        }
        if (name === "toJSON" && typeof item === "function")
          o.push({ k: name, v: { o: [], id: 0 } });
        else
          o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });
      }
      let jsonWrapper;
      try {
        if (o.length === 0 && value.toJSON && typeof value.toJSON === "function")
          jsonWrapper = { value: value.toJSON() };
      } catch (e) {
      }
      if (jsonWrapper)
        return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);
      return { o, id: id2 };
    }
  }
  __name(innerSerialize, "innerSerialize");
  return { parseEvaluationResultValue: parseEvaluationResultValue2, serializeAsCallArgument: serializeAsCallArgument2 };
}
__name(source3, "source");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/javascript.js
var utilityScriptSerializers = source3(builtins());
var parseEvaluationResultValue = utilityScriptSerializers.parseEvaluationResultValue;
var serializeAsCallArgument = utilityScriptSerializers.serializeAsCallArgument;
var ExecutionContext = class extends SdkObject {
  static {
    __name(this, "ExecutionContext");
  }
  constructor(parent, delegate, worldNameForTest) {
    super(parent, "execution-context");
    this._contextDestroyedScope = new LongStandingScope();
    this.worldNameForTest = worldNameForTest;
    this.delegate = delegate;
  }
  contextDestroyed(reason) {
    this._contextDestroyedScope.close(new Error(reason));
  }
  async _raceAgainstContextDestroyed(promise) {
    return this._contextDestroyedScope.race(promise);
  }
  rawEvaluateJSON(expression) {
    return this._raceAgainstContextDestroyed(this.delegate.rawEvaluateJSON(expression));
  }
  rawEvaluateHandle(expression) {
    return this._raceAgainstContextDestroyed(this.delegate.rawEvaluateHandle(this, expression));
  }
  async evaluateWithArguments(expression, returnByValue, values, handles) {
    const utilityScript = await this._utilityScript();
    return this._raceAgainstContextDestroyed(this.delegate.evaluateWithArguments(expression, returnByValue, utilityScript, values, handles));
  }
  getProperties(object) {
    return this._raceAgainstContextDestroyed(this.delegate.getProperties(object));
  }
  releaseHandle(handle) {
    return this.delegate.releaseHandle(handle);
  }
  adoptIfNeeded(handle) {
    return null;
  }
  _utilityScript() {
    if (!this._utilityScriptPromise) {
      const source22 = `
      (() => {
        const module = {};
        ${source2}
        return new (module.exports.UtilityScript())(${isUnderTest()});
      })();`;
      this._utilityScriptPromise = this._raceAgainstContextDestroyed(this.delegate.rawEvaluateHandle(this, source22)).then((handle) => {
        handle._setPreview("UtilityScript");
        return handle;
      });
    }
    return this._utilityScriptPromise;
  }
  async doSlowMo() {
  }
};
var JSHandle = class extends SdkObject {
  static {
    __name(this, "JSHandle");
  }
  constructor(context2, type2, preview, objectId, value) {
    super(context2, "handle");
    this.__jshandle = true;
    this._disposed = false;
    this._context = context2;
    this._objectId = objectId;
    this._value = value;
    this._objectType = type2;
    this._preview = this._objectId ? preview || `JSHandle@${this._objectType}` : String(value);
    if (this._objectId && globalThis.leakedJSHandles)
      globalThis.leakedJSHandles.set(this, new Error("Leaked JSHandle"));
  }
  async evaluate(pageFunction, arg) {
    return evaluate(this._context, true, pageFunction, this, arg);
  }
  async evaluateHandle(pageFunction, arg) {
    return evaluate(this._context, false, pageFunction, this, arg);
  }
  async evaluateExpression(expression, options2, arg) {
    const value = await evaluateExpression(this._context, expression, { ...options2, returnByValue: true }, this, arg);
    await this._context.doSlowMo();
    return value;
  }
  async evaluateExpressionHandle(expression, options2, arg) {
    const value = await evaluateExpression(this._context, expression, { ...options2, returnByValue: false }, this, arg);
    await this._context.doSlowMo();
    return value;
  }
  async getProperty(propertyName) {
    const objectHandle = await this.evaluateHandle((object, propertyName2) => {
      const result2 = { __proto__: null };
      result2[propertyName2] = object[propertyName2];
      return result2;
    }, propertyName);
    const properties = await objectHandle.getProperties();
    const result = properties.get(propertyName);
    objectHandle.dispose();
    return result;
  }
  async getProperties() {
    if (!this._objectId)
      return /* @__PURE__ */ new Map();
    return this._context.getProperties(this);
  }
  rawValue() {
    return this._value;
  }
  async jsonValue() {
    if (!this._objectId)
      return this._value;
    const script = `(utilityScript, ...args) => utilityScript.jsonValue(...args)`;
    return this._context.evaluateWithArguments(script, true, [true], [this]);
  }
  asElement() {
    return null;
  }
  dispose() {
    if (this._disposed)
      return;
    this._disposed = true;
    if (this._objectId) {
      this._context.releaseHandle(this).catch((e) => {
      });
      if (globalThis.leakedJSHandles)
        globalThis.leakedJSHandles.delete(this);
    }
  }
  toString() {
    return this._preview;
  }
  _setPreviewCallback(callback) {
    this._previewCallback = callback;
  }
  preview() {
    return this._preview;
  }
  worldNameForTest() {
    return this._context.worldNameForTest;
  }
  _setPreview(preview) {
    this._preview = preview;
    if (this._previewCallback)
      this._previewCallback(preview);
  }
};
async function evaluate(context2, returnByValue, pageFunction, ...args) {
  return evaluateExpression(context2, String(pageFunction), { returnByValue, isFunction: typeof pageFunction === "function" }, ...args);
}
__name(evaluate, "evaluate");
async function evaluateExpression(context2, expression, options2, ...args) {
  expression = normalizeEvaluationExpression(expression, options2.isFunction);
  const handles = [];
  const toDispose = [];
  const pushHandle = /* @__PURE__ */ __name((handle) => {
    handles.push(handle);
    return handles.length - 1;
  }, "pushHandle");
  args = args.map((arg) => serializeAsCallArgument(arg, (handle) => {
    if (handle instanceof JSHandle) {
      if (!handle._objectId)
        return { fallThrough: handle._value };
      if (handle._disposed)
        throw new JavaScriptErrorInEvaluate("JSHandle is disposed!");
      const adopted = context2.adoptIfNeeded(handle);
      if (adopted === null)
        return { h: pushHandle(Promise.resolve(handle)) };
      toDispose.push(adopted);
      return { h: pushHandle(adopted) };
    }
    return { fallThrough: handle };
  }));
  const utilityScriptObjects = [];
  for (const handle of await Promise.all(handles)) {
    if (handle._context !== context2)
      throw new JavaScriptErrorInEvaluate("JSHandles can be evaluated only in the context they were created!");
    utilityScriptObjects.push(handle);
  }
  const utilityScriptValues = [options2.isFunction, options2.returnByValue, expression, args.length, ...args];
  const script = `(utilityScript, ...args) => utilityScript.evaluate(...args)`;
  try {
    return await context2.evaluateWithArguments(script, options2.returnByValue || false, utilityScriptValues, utilityScriptObjects);
  } finally {
    toDispose.map((handlePromise) => handlePromise.then((handle) => handle.dispose()));
  }
}
__name(evaluateExpression, "evaluateExpression");
function parseUnserializableValue(unserializableValue) {
  if (unserializableValue === "NaN")
    return NaN;
  if (unserializableValue === "Infinity")
    return Infinity;
  if (unserializableValue === "-Infinity")
    return -Infinity;
  if (unserializableValue === "-0")
    return -0;
}
__name(parseUnserializableValue, "parseUnserializableValue");
function normalizeEvaluationExpression(expression, isFunction2) {
  expression = expression.trim();
  if (isFunction2) {
    if (globalThis.navigator?.userAgent === "Cloudflare-Workers") {
      expression = `((__name => (${expression}))(t => t))`;
    } else {
      try {
        new Function("(" + expression + ")");
      } catch (e1) {
        if (expression.startsWith("async "))
          expression = "async function " + expression.substring("async ".length);
        else
          expression = "function " + expression;
        try {
          new Function("(" + expression + ")");
        } catch (e2) {
          throw new Error("Passed function is not well-serializable!");
        }
      }
    }
  }
  if (/^(async)?\s*function(\s|\()/.test(expression))
    expression = "(" + expression + ")";
  return expression;
}
__name(normalizeEvaluationExpression, "normalizeEvaluationExpression");
var JavaScriptErrorInEvaluate = class extends Error {
  static {
    __name(this, "JavaScriptErrorInEvaluate");
  }
};
function isJavaScriptErrorInEvaluate(error4) {
  return error4 instanceof JavaScriptErrorInEvaluate;
}
__name(isJavaScriptErrorInEvaluate, "isJavaScriptErrorInEvaluate");
function sparseArrayToString(entries) {
  const arrayEntries = [];
  for (const { name, value } of entries) {
    const index2 = +name;
    if (isNaN(index2) || index2 < 0)
      continue;
    arrayEntries.push({ index: index2, value });
  }
  arrayEntries.sort((a, b) => a.index - b.index);
  let lastIndex = -1;
  const tokens = [];
  for (const { index: index2, value } of arrayEntries) {
    const emptyItems = index2 - lastIndex - 1;
    if (emptyItems === 1)
      tokens.push(`empty`);
    else if (emptyItems > 1)
      tokens.push(`empty x ${emptyItems}`);
    tokens.push(String(value));
    lastIndex = index2;
  }
  return "[" + tokens.join(", ") + "]";
}
__name(sparseArrayToString, "sparseArrayToString");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/progress.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var ProgressController = class {
  static {
    __name(this, "ProgressController");
  }
  constructor(metadata, sdkObject) {
    this._forceAbortPromise = new ManualPromise();
    this._cleanups = [];
    this._logName = "api";
    this._state = "before";
    this._deadline = 0;
    this._timeout = 0;
    this.metadata = metadata;
    this.sdkObject = sdkObject;
    this.instrumentation = sdkObject.instrumentation;
    this._forceAbortPromise.catch((e) => null);
  }
  setLogName(logName) {
    this._logName = logName;
  }
  abort(error4) {
    this._forceAbortPromise.reject(error4);
  }
  async run(task, timeout) {
    if (timeout) {
      this._timeout = timeout;
      this._deadline = timeout ? monotonicTime() + timeout : 0;
    }
    assert3(this._state === "before");
    this._state = "running";
    this.sdkObject.attribution.context?._activeProgressControllers.add(this);
    const progress3 = {
      log: /* @__PURE__ */ __name((message) => {
        if (this._state === "running")
          this.metadata.log.push(message);
        this.instrumentation.onCallLog(this.sdkObject, this.metadata, this._logName, message);
      }, "log"),
      timeUntilDeadline: /* @__PURE__ */ __name(() => this._deadline ? this._deadline - monotonicTime() : 2147483647, "timeUntilDeadline"),
      // 2^31-1 safe setTimeout in Node.
      isRunning: /* @__PURE__ */ __name(() => this._state === "running", "isRunning"),
      cleanupWhenAborted: /* @__PURE__ */ __name((cleanup) => {
        if (this._state === "running")
          this._cleanups.push(cleanup);
        else
          runCleanup(cleanup);
      }, "cleanupWhenAborted"),
      throwIfAborted: /* @__PURE__ */ __name(() => {
        if (this._state === "aborted")
          throw new AbortedError();
      }, "throwIfAborted"),
      metadata: this.metadata
    };
    const timeoutError = new TimeoutError(`Timeout ${this._timeout}ms exceeded.`);
    const timer = setTimeout(() => this._forceAbortPromise.reject(timeoutError), progress3.timeUntilDeadline());
    try {
      const promise = task(progress3);
      const result = await Promise.race([promise, this._forceAbortPromise]);
      this._state = "finished";
      return result;
    } catch (e) {
      this._state = "aborted";
      await Promise.all(this._cleanups.splice(0).map(runCleanup));
      throw e;
    } finally {
      this.sdkObject.attribution.context?._activeProgressControllers.delete(this);
      clearTimeout(timer);
    }
  }
};
async function runCleanup(cleanup) {
  try {
    await cleanup();
  } catch (e) {
  }
}
__name(runCleanup, "runCleanup");
var AbortedError = class extends Error {
  static {
    __name(this, "AbortedError");
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/locatorGenerators.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function asLocator(lang, selector, isFrameLocator = false) {
  return asLocators(lang, selector, isFrameLocator, 1)[0];
}
__name(asLocator, "asLocator");
function asLocators(lang, selector, isFrameLocator = false, maxOutputSize = 20, preferredQuote) {
  try {
    return innerAsLocators(new generators[lang](preferredQuote), parseSelector(selector), isFrameLocator, maxOutputSize);
  } catch (e) {
    return [selector];
  }
}
__name(asLocators, "asLocators");
function innerAsLocators(factory, parsed, isFrameLocator = false, maxOutputSize = 20) {
  const parts = [...parsed.parts];
  const tokens = [];
  let nextBase = isFrameLocator ? "frame-locator" : "page";
  for (let index2 = 0; index2 < parts.length; index2++) {
    const part = parts[index2];
    const base = nextBase;
    nextBase = "locator";
    if (part.name === "nth") {
      if (part.body === "0")
        tokens.push([factory.generateLocator(base, "first", ""), factory.generateLocator(base, "nth", "0")]);
      else if (part.body === "-1")
        tokens.push([factory.generateLocator(base, "last", ""), factory.generateLocator(base, "nth", "-1")]);
      else
        tokens.push([factory.generateLocator(base, "nth", part.body)]);
      continue;
    }
    if (part.name === "visible") {
      tokens.push([factory.generateLocator(base, "visible", part.body), factory.generateLocator(base, "default", `visible=${part.body}`)]);
      continue;
    }
    if (part.name === "internal:text") {
      const { exact, text } = detectExact(part.body);
      tokens.push([factory.generateLocator(base, "text", text, { exact })]);
      continue;
    }
    if (part.name === "internal:has-text") {
      const { exact, text } = detectExact(part.body);
      if (!exact) {
        tokens.push([factory.generateLocator(base, "has-text", text, { exact })]);
        continue;
      }
    }
    if (part.name === "internal:has-not-text") {
      const { exact, text } = detectExact(part.body);
      if (!exact) {
        tokens.push([factory.generateLocator(base, "has-not-text", text, { exact })]);
        continue;
      }
    }
    if (part.name === "internal:has") {
      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
      tokens.push(inners.map((inner) => factory.generateLocator(base, "has", inner)));
      continue;
    }
    if (part.name === "internal:has-not") {
      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
      tokens.push(inners.map((inner) => factory.generateLocator(base, "hasNot", inner)));
      continue;
    }
    if (part.name === "internal:and") {
      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
      tokens.push(inners.map((inner) => factory.generateLocator(base, "and", inner)));
      continue;
    }
    if (part.name === "internal:or") {
      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
      tokens.push(inners.map((inner) => factory.generateLocator(base, "or", inner)));
      continue;
    }
    if (part.name === "internal:chain") {
      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
      tokens.push(inners.map((inner) => factory.generateLocator(base, "chain", inner)));
      continue;
    }
    if (part.name === "internal:label") {
      const { exact, text } = detectExact(part.body);
      tokens.push([factory.generateLocator(base, "label", text, { exact })]);
      continue;
    }
    if (part.name === "internal:role") {
      const attrSelector = parseAttributeSelector(part.body);
      const options2 = { attrs: [] };
      for (const attr of attrSelector.attributes) {
        if (attr.name === "name") {
          options2.exact = attr.caseSensitive;
          options2.name = attr.value;
        } else {
          if (attr.name === "level" && typeof attr.value === "string")
            attr.value = +attr.value;
          options2.attrs.push({ name: attr.name === "include-hidden" ? "includeHidden" : attr.name, value: attr.value });
        }
      }
      tokens.push([factory.generateLocator(base, "role", attrSelector.name, options2)]);
      continue;
    }
    if (part.name === "internal:testid") {
      const attrSelector = parseAttributeSelector(part.body);
      const { value } = attrSelector.attributes[0];
      tokens.push([factory.generateLocator(base, "test-id", value)]);
      continue;
    }
    if (part.name === "internal:attr") {
      const attrSelector = parseAttributeSelector(part.body);
      const { name, value, caseSensitive } = attrSelector.attributes[0];
      const text = value;
      const exact = !!caseSensitive;
      if (name === "placeholder") {
        tokens.push([factory.generateLocator(base, "placeholder", text, { exact })]);
        continue;
      }
      if (name === "alt") {
        tokens.push([factory.generateLocator(base, "alt", text, { exact })]);
        continue;
      }
      if (name === "title") {
        tokens.push([factory.generateLocator(base, "title", text, { exact })]);
        continue;
      }
    }
    if (part.name === "internal:control" && part.body === "enter-frame") {
      const lastTokens = tokens[tokens.length - 1];
      const lastPart = parts[index2 - 1];
      const transformed = lastTokens.map((token) => factory.chainLocators([token, factory.generateLocator(base, "frame", "")]));
      if (["xpath", "css"].includes(lastPart.name)) {
        transformed.push(
          factory.generateLocator(base, "frame-locator", stringifySelector({ parts: [lastPart] })),
          factory.generateLocator(base, "frame-locator", stringifySelector({ parts: [lastPart] }, true))
        );
      }
      lastTokens.splice(0, lastTokens.length, ...transformed);
      nextBase = "frame-locator";
      continue;
    }
    const nextPart = parts[index2 + 1];
    const selectorPart = stringifySelector({ parts: [part] });
    const locatorPart = factory.generateLocator(base, "default", selectorPart);
    if (nextPart && ["internal:has-text", "internal:has-not-text"].includes(nextPart.name)) {
      const { exact, text } = detectExact(nextPart.body);
      if (!exact) {
        const nextLocatorPart = factory.generateLocator("locator", nextPart.name === "internal:has-text" ? "has-text" : "has-not-text", text, { exact });
        const options2 = {};
        if (nextPart.name === "internal:has-text")
          options2.hasText = text;
        else
          options2.hasNotText = text;
        const combinedPart = factory.generateLocator(base, "default", selectorPart, options2);
        tokens.push([factory.chainLocators([locatorPart, nextLocatorPart]), combinedPart]);
        index2++;
        continue;
      }
    }
    let locatorPartWithEngine;
    if (["xpath", "css"].includes(part.name)) {
      const selectorPart2 = stringifySelector(
        { parts: [part] },
        /* forceEngineName */
        true
      );
      locatorPartWithEngine = factory.generateLocator(base, "default", selectorPart2);
    }
    tokens.push([locatorPart, locatorPartWithEngine].filter(Boolean));
  }
  return combineTokens(factory, tokens, maxOutputSize);
}
__name(innerAsLocators, "innerAsLocators");
function combineTokens(factory, tokens, maxOutputSize) {
  const currentTokens = tokens.map(() => "");
  const result = [];
  const visit2 = /* @__PURE__ */ __name((index2) => {
    if (index2 === tokens.length) {
      result.push(factory.chainLocators(currentTokens));
      return result.length < maxOutputSize;
    }
    for (const taken of tokens[index2]) {
      currentTokens[index2] = taken;
      if (!visit2(index2 + 1))
        return false;
    }
    return true;
  }, "visit");
  visit2(0);
  return result;
}
__name(combineTokens, "combineTokens");
function detectExact(text) {
  let exact = false;
  const match = text.match(/^\/(.*)\/([igm]*)$/);
  if (match)
    return { text: new RegExp(match[1], match[2]) };
  if (text.endsWith('"')) {
    text = JSON.parse(text);
    exact = true;
  } else if (text.endsWith('"s')) {
    text = JSON.parse(text.substring(0, text.length - 1));
    exact = true;
  } else if (text.endsWith('"i')) {
    text = JSON.parse(text.substring(0, text.length - 1));
    exact = false;
  }
  return { exact, text };
}
__name(detectExact, "detectExact");
var JavaScriptLocatorFactory = class {
  static {
    __name(this, "JavaScriptLocatorFactory");
  }
  constructor(preferredQuote) {
    this.preferredQuote = preferredQuote;
  }
  generateLocator(base, kind, body, options2 = {}) {
    switch (kind) {
      case "default":
        if (options2.hasText !== void 0)
          return `locator(${this.quote(body)}, { hasText: ${this.toHasText(options2.hasText)} })`;
        if (options2.hasNotText !== void 0)
          return `locator(${this.quote(body)}, { hasNotText: ${this.toHasText(options2.hasNotText)} })`;
        return `locator(${this.quote(body)})`;
      case "frame-locator":
        return `frameLocator(${this.quote(body)})`;
      case "frame":
        return `contentFrame()`;
      case "nth":
        return `nth(${body})`;
      case "first":
        return `first()`;
      case "last":
        return `last()`;
      case "visible":
        return `filter({ visible: ${body === "true" ? "true" : "false"} })`;
      case "role":
        const attrs = [];
        if (isRegExp5(options2.name)) {
          attrs.push(`name: ${this.regexToSourceString(options2.name)}`);
        } else if (typeof options2.name === "string") {
          attrs.push(`name: ${this.quote(options2.name)}`);
          if (options2.exact)
            attrs.push(`exact: true`);
        }
        for (const { name, value } of options2.attrs)
          attrs.push(`${name}: ${typeof value === "string" ? this.quote(value) : value}`);
        const attrString = attrs.length ? `, { ${attrs.join(", ")} }` : "";
        return `getByRole(${this.quote(body)}${attrString})`;
      case "has-text":
        return `filter({ hasText: ${this.toHasText(body)} })`;
      case "has-not-text":
        return `filter({ hasNotText: ${this.toHasText(body)} })`;
      case "has":
        return `filter({ has: ${body} })`;
      case "hasNot":
        return `filter({ hasNot: ${body} })`;
      case "and":
        return `and(${body})`;
      case "or":
        return `or(${body})`;
      case "chain":
        return `locator(${body})`;
      case "test-id":
        return `getByTestId(${this.toTestIdValue(body)})`;
      case "text":
        return this.toCallWithExact("getByText", body, !!options2.exact);
      case "alt":
        return this.toCallWithExact("getByAltText", body, !!options2.exact);
      case "placeholder":
        return this.toCallWithExact("getByPlaceholder", body, !!options2.exact);
      case "label":
        return this.toCallWithExact("getByLabel", body, !!options2.exact);
      case "title":
        return this.toCallWithExact("getByTitle", body, !!options2.exact);
      default:
        throw new Error("Unknown selector kind " + kind);
    }
  }
  chainLocators(locators) {
    return locators.join(".");
  }
  regexToSourceString(re2) {
    return normalizeEscapedRegexQuotes(String(re2));
  }
  toCallWithExact(method, body, exact) {
    if (isRegExp5(body))
      return `${method}(${this.regexToSourceString(body)})`;
    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;
  }
  toHasText(body) {
    if (isRegExp5(body))
      return this.regexToSourceString(body);
    return this.quote(body);
  }
  toTestIdValue(value) {
    if (isRegExp5(value))
      return this.regexToSourceString(value);
    return this.quote(value);
  }
  quote(text) {
    return escapeWithQuotes(text, this.preferredQuote ?? "'");
  }
};
var PythonLocatorFactory = class {
  static {
    __name(this, "PythonLocatorFactory");
  }
  generateLocator(base, kind, body, options2 = {}) {
    switch (kind) {
      case "default":
        if (options2.hasText !== void 0)
          return `locator(${this.quote(body)}, has_text=${this.toHasText(options2.hasText)})`;
        if (options2.hasNotText !== void 0)
          return `locator(${this.quote(body)}, has_not_text=${this.toHasText(options2.hasNotText)})`;
        return `locator(${this.quote(body)})`;
      case "frame-locator":
        return `frame_locator(${this.quote(body)})`;
      case "frame":
        return `content_frame`;
      case "nth":
        return `nth(${body})`;
      case "first":
        return `first`;
      case "last":
        return `last`;
      case "visible":
        return `filter(visible=${body === "true" ? "True" : "False"})`;
      case "role":
        const attrs = [];
        if (isRegExp5(options2.name)) {
          attrs.push(`name=${this.regexToString(options2.name)}`);
        } else if (typeof options2.name === "string") {
          attrs.push(`name=${this.quote(options2.name)}`);
          if (options2.exact)
            attrs.push(`exact=True`);
        }
        for (const { name, value } of options2.attrs) {
          let valueString = typeof value === "string" ? this.quote(value) : value;
          if (typeof value === "boolean")
            valueString = value ? "True" : "False";
          attrs.push(`${toSnakeCase(name)}=${valueString}`);
        }
        const attrString = attrs.length ? `, ${attrs.join(", ")}` : "";
        return `get_by_role(${this.quote(body)}${attrString})`;
      case "has-text":
        return `filter(has_text=${this.toHasText(body)})`;
      case "has-not-text":
        return `filter(has_not_text=${this.toHasText(body)})`;
      case "has":
        return `filter(has=${body})`;
      case "hasNot":
        return `filter(has_not=${body})`;
      case "and":
        return `and_(${body})`;
      case "or":
        return `or_(${body})`;
      case "chain":
        return `locator(${body})`;
      case "test-id":
        return `get_by_test_id(${this.toTestIdValue(body)})`;
      case "text":
        return this.toCallWithExact("get_by_text", body, !!options2.exact);
      case "alt":
        return this.toCallWithExact("get_by_alt_text", body, !!options2.exact);
      case "placeholder":
        return this.toCallWithExact("get_by_placeholder", body, !!options2.exact);
      case "label":
        return this.toCallWithExact("get_by_label", body, !!options2.exact);
      case "title":
        return this.toCallWithExact("get_by_title", body, !!options2.exact);
      default:
        throw new Error("Unknown selector kind " + kind);
    }
  }
  chainLocators(locators) {
    return locators.join(".");
  }
  regexToString(body) {
    const suffix = body.flags.includes("i") ? ", re.IGNORECASE" : "";
    return `re.compile(r"${normalizeEscapedRegexQuotes(body.source).replace(/\\\//, "/").replace(/"/g, '\\"')}"${suffix})`;
  }
  toCallWithExact(method, body, exact) {
    if (isRegExp5(body))
      return `${method}(${this.regexToString(body)})`;
    if (exact)
      return `${method}(${this.quote(body)}, exact=True)`;
    return `${method}(${this.quote(body)})`;
  }
  toHasText(body) {
    if (isRegExp5(body))
      return this.regexToString(body);
    return `${this.quote(body)}`;
  }
  toTestIdValue(value) {
    if (isRegExp5(value))
      return this.regexToString(value);
    return this.quote(value);
  }
  quote(text) {
    return escapeWithQuotes(text, '"');
  }
};
var JavaLocatorFactory = class {
  static {
    __name(this, "JavaLocatorFactory");
  }
  generateLocator(base, kind, body, options2 = {}) {
    let clazz;
    switch (base) {
      case "page":
        clazz = "Page";
        break;
      case "frame-locator":
        clazz = "FrameLocator";
        break;
      case "locator":
        clazz = "Locator";
        break;
    }
    switch (kind) {
      case "default":
        if (options2.hasText !== void 0)
          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasText(${this.toHasText(options2.hasText)}))`;
        if (options2.hasNotText !== void 0)
          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasNotText(${this.toHasText(options2.hasNotText)}))`;
        return `locator(${this.quote(body)})`;
      case "frame-locator":
        return `frameLocator(${this.quote(body)})`;
      case "frame":
        return `contentFrame()`;
      case "nth":
        return `nth(${body})`;
      case "first":
        return `first()`;
      case "last":
        return `last()`;
      case "visible":
        return `filter(new ${clazz}.FilterOptions().setVisible(${body === "true" ? "true" : "false"}))`;
      case "role":
        const attrs = [];
        if (isRegExp5(options2.name)) {
          attrs.push(`.setName(${this.regexToString(options2.name)})`);
        } else if (typeof options2.name === "string") {
          attrs.push(`.setName(${this.quote(options2.name)})`);
          if (options2.exact)
            attrs.push(`.setExact(true)`);
        }
        for (const { name, value } of options2.attrs)
          attrs.push(`.set${toTitleCase(name)}(${typeof value === "string" ? this.quote(value) : value})`);
        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join("")}` : "";
        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;
      case "has-text":
        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;
      case "has-not-text":
        return `filter(new ${clazz}.FilterOptions().setHasNotText(${this.toHasText(body)}))`;
      case "has":
        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;
      case "hasNot":
        return `filter(new ${clazz}.FilterOptions().setHasNot(${body}))`;
      case "and":
        return `and(${body})`;
      case "or":
        return `or(${body})`;
      case "chain":
        return `locator(${body})`;
      case "test-id":
        return `getByTestId(${this.toTestIdValue(body)})`;
      case "text":
        return this.toCallWithExact(clazz, "getByText", body, !!options2.exact);
      case "alt":
        return this.toCallWithExact(clazz, "getByAltText", body, !!options2.exact);
      case "placeholder":
        return this.toCallWithExact(clazz, "getByPlaceholder", body, !!options2.exact);
      case "label":
        return this.toCallWithExact(clazz, "getByLabel", body, !!options2.exact);
      case "title":
        return this.toCallWithExact(clazz, "getByTitle", body, !!options2.exact);
      default:
        throw new Error("Unknown selector kind " + kind);
    }
  }
  chainLocators(locators) {
    return locators.join(".");
  }
  regexToString(body) {
    const suffix = body.flags.includes("i") ? ", Pattern.CASE_INSENSITIVE" : "";
    return `Pattern.compile(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;
  }
  toCallWithExact(clazz, method, body, exact) {
    if (isRegExp5(body))
      return `${method}(${this.regexToString(body)})`;
    if (exact)
      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;
    return `${method}(${this.quote(body)})`;
  }
  toHasText(body) {
    if (isRegExp5(body))
      return this.regexToString(body);
    return this.quote(body);
  }
  toTestIdValue(value) {
    if (isRegExp5(value))
      return this.regexToString(value);
    return this.quote(value);
  }
  quote(text) {
    return escapeWithQuotes(text, '"');
  }
};
var CSharpLocatorFactory = class {
  static {
    __name(this, "CSharpLocatorFactory");
  }
  generateLocator(base, kind, body, options2 = {}) {
    switch (kind) {
      case "default":
        if (options2.hasText !== void 0)
          return `Locator(${this.quote(body)}, new() { ${this.toHasText(options2.hasText)} })`;
        if (options2.hasNotText !== void 0)
          return `Locator(${this.quote(body)}, new() { ${this.toHasNotText(options2.hasNotText)} })`;
        return `Locator(${this.quote(body)})`;
      case "frame-locator":
        return `FrameLocator(${this.quote(body)})`;
      case "frame":
        return `ContentFrame`;
      case "nth":
        return `Nth(${body})`;
      case "first":
        return `First`;
      case "last":
        return `Last`;
      case "visible":
        return `Filter(new() { Visible = ${body === "true" ? "true" : "false"} })`;
      case "role":
        const attrs = [];
        if (isRegExp5(options2.name)) {
          attrs.push(`NameRegex = ${this.regexToString(options2.name)}`);
        } else if (typeof options2.name === "string") {
          attrs.push(`Name = ${this.quote(options2.name)}`);
          if (options2.exact)
            attrs.push(`Exact = true`);
        }
        for (const { name, value } of options2.attrs)
          attrs.push(`${toTitleCase(name)} = ${typeof value === "string" ? this.quote(value) : value}`);
        const attrString = attrs.length ? `, new() { ${attrs.join(", ")} }` : "";
        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;
      case "has-text":
        return `Filter(new() { ${this.toHasText(body)} })`;
      case "has-not-text":
        return `Filter(new() { ${this.toHasNotText(body)} })`;
      case "has":
        return `Filter(new() { Has = ${body} })`;
      case "hasNot":
        return `Filter(new() { HasNot = ${body} })`;
      case "and":
        return `And(${body})`;
      case "or":
        return `Or(${body})`;
      case "chain":
        return `Locator(${body})`;
      case "test-id":
        return `GetByTestId(${this.toTestIdValue(body)})`;
      case "text":
        return this.toCallWithExact("GetByText", body, !!options2.exact);
      case "alt":
        return this.toCallWithExact("GetByAltText", body, !!options2.exact);
      case "placeholder":
        return this.toCallWithExact("GetByPlaceholder", body, !!options2.exact);
      case "label":
        return this.toCallWithExact("GetByLabel", body, !!options2.exact);
      case "title":
        return this.toCallWithExact("GetByTitle", body, !!options2.exact);
      default:
        throw new Error("Unknown selector kind " + kind);
    }
  }
  chainLocators(locators) {
    return locators.join(".");
  }
  regexToString(body) {
    const suffix = body.flags.includes("i") ? ", RegexOptions.IgnoreCase" : "";
    return `new Regex(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;
  }
  toCallWithExact(method, body, exact) {
    if (isRegExp5(body))
      return `${method}(${this.regexToString(body)})`;
    if (exact)
      return `${method}(${this.quote(body)}, new() { Exact = true })`;
    return `${method}(${this.quote(body)})`;
  }
  toHasText(body) {
    if (isRegExp5(body))
      return `HasTextRegex = ${this.regexToString(body)}`;
    return `HasText = ${this.quote(body)}`;
  }
  toTestIdValue(value) {
    if (isRegExp5(value))
      return this.regexToString(value);
    return this.quote(value);
  }
  toHasNotText(body) {
    if (isRegExp5(body))
      return `HasNotTextRegex = ${this.regexToString(body)}`;
    return `HasNotText = ${this.quote(body)}`;
  }
  quote(text) {
    return escapeWithQuotes(text, '"');
  }
};
var JsonlLocatorFactory = class {
  static {
    __name(this, "JsonlLocatorFactory");
  }
  generateLocator(base, kind, body, options2 = {}) {
    return JSON.stringify({
      kind,
      body,
      options: options2
    });
  }
  chainLocators(locators) {
    const objects = locators.map((l) => JSON.parse(l));
    for (let i = 0; i < objects.length - 1; ++i)
      objects[i].next = objects[i + 1];
    return JSON.stringify(objects[0]);
  }
};
var generators = {
  javascript: JavaScriptLocatorFactory,
  python: PythonLocatorFactory,
  java: JavaLocatorFactory,
  csharp: CSharpLocatorFactory,
  jsonl: JsonlLocatorFactory
};
function isRegExp5(obj) {
  return obj instanceof RegExp;
}
__name(isRegExp5, "isRegExp");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dom.js
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/fileUploadUtils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path10 from "node:path";
var fileUploadSizeLimit = 50 * 1024 * 1024;
async function filesExceedUploadLimit(files) {
  const sizes = await Promise.all(files.map(async (file) => (await fs.promises.stat(file)).size));
  return sizes.reduce((total, size) => total + size, 0) >= fileUploadSizeLimit;
}
__name(filesExceedUploadLimit, "filesExceedUploadLimit");
async function prepareFilesForUpload(frame, params) {
  const { payloads, streams, directoryStream } = params;
  let { localPaths, localDirectory } = params;
  if ([payloads, localPaths, localDirectory, streams, directoryStream].filter(Boolean).length !== 1)
    throw new Error("Exactly one of payloads, localPaths and streams must be provided");
  if (streams)
    localPaths = streams.map((c) => c.path());
  if (directoryStream)
    localDirectory = directoryStream.path();
  if (localPaths) {
    for (const p of localPaths)
      assert3(path10.isAbsolute(p) && path10.resolve(p) === p, "Paths provided to localPaths must be absolute and fully resolved.");
  }
  let fileBuffers = payloads;
  if (!frame._page._browserContext._browser._isCollocatedWithServer) {
    if (localPaths) {
      if (await filesExceedUploadLimit(localPaths))
        throw new Error("Cannot transfer files larger than 50Mb to a browser not co-located with the server");
      fileBuffers = await Promise.all(localPaths.map(async (item) => {
        return {
          name: path10.basename(item),
          buffer: await fs.promises.readFile(item),
          lastModifiedMs: (await fs.promises.stat(item)).mtimeMs
        };
      }));
      localPaths = void 0;
    }
  }
  const filePayloads = fileBuffers?.map((payload) => ({
    name: payload.name,
    mimeType: payload.mimeType || mime2.getType(payload.name) || "application/octet-stream",
    buffer: payload.buffer.toString("base64"),
    lastModifiedMs: payload.lastModifiedMs
  }));
  return { localPaths, localDirectory, filePayloads };
}
__name(prepareFilesForUpload, "prepareFilesForUpload");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/generated/injectedScriptSource.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source4 = '\nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, \'default\': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/injectedScript.ts\nvar injectedScript_exports = {};\n__export(injectedScript_exports, {\n  InjectedScript: () => InjectedScript\n});\nmodule.exports = __toCommonJS(injectedScript_exports);\n\n// packages/playwright-core/src/utils/isomorphic/ariaSnapshot.ts\nfunction parseAriaSnapshot(yaml, text, options = {}) {\n  var _a;\n  const lineCounter = new yaml.LineCounter();\n  const parseOptions = {\n    keepSourceTokens: true,\n    lineCounter,\n    ...options\n  };\n  const yamlDoc = yaml.parseDocument(text, parseOptions);\n  const errors = [];\n  const convertRange = (range) => {\n    return [lineCounter.linePos(range[0]), lineCounter.linePos(range[1])];\n  };\n  const addError = (error) => {\n    errors.push({\n      message: error.message,\n      range: [lineCounter.linePos(error.pos[0]), lineCounter.linePos(error.pos[1])]\n    });\n  };\n  const convertSeq = (container, seq) => {\n    for (const item of seq.items) {\n      const itemIsString = item instanceof yaml.Scalar && typeof item.value === "string";\n      if (itemIsString) {\n        const childNode = KeyParser.parse(item, parseOptions, errors);\n        if (childNode) {\n          container.children = container.children || [];\n          container.children.push(childNode);\n        }\n        continue;\n      }\n      const itemIsMap = item instanceof yaml.YAMLMap;\n      if (itemIsMap) {\n        convertMap(container, item);\n        continue;\n      }\n      errors.push({\n        message: "Sequence items should be strings or maps",\n        range: convertRange(item.range || seq.range)\n      });\n    }\n  };\n  const convertMap = (container, map) => {\n    var _a2;\n    for (const entry of map.items) {\n      container.children = container.children || [];\n      const keyIsString = entry.key instanceof yaml.Scalar && typeof entry.key.value === "string";\n      if (!keyIsString) {\n        errors.push({\n          message: "Only string keys are supported",\n          range: convertRange(entry.key.range || map.range)\n        });\n        continue;\n      }\n      const key = entry.key;\n      const value = entry.value;\n      if (key.value === "text") {\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === "string";\n        if (!valueIsString) {\n          errors.push({\n            message: "Text value should be a string",\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.children.push({\n          kind: "text",\n          text: valueOrRegex(value.value)\n        });\n        continue;\n      }\n      if (key.value === "/children") {\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === "string";\n        if (!valueIsString || value.value !== "contain" && value.value !== "equal" && value.value !== "deep-equal") {\n          errors.push({\n            message: \'Strict value should be "contain", "equal" or "deep-equal"\',\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.containerMode = value.value;\n        continue;\n      }\n      if (key.value.startsWith("/")) {\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === "string";\n        if (!valueIsString) {\n          errors.push({\n            message: "Property value should be a string",\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.props = (_a2 = container.props) != null ? _a2 : {};\n        container.props[key.value.slice(1)] = valueOrRegex(value.value);\n        continue;\n      }\n      const childNode = KeyParser.parse(key, parseOptions, errors);\n      if (!childNode)\n        continue;\n      const valueIsScalar = value instanceof yaml.Scalar;\n      if (valueIsScalar) {\n        const type = typeof value.value;\n        if (type !== "string" && type !== "number" && type !== "boolean") {\n          errors.push({\n            message: "Node value should be a string or a sequence",\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.children.push({\n          ...childNode,\n          children: [{\n            kind: "text",\n            text: valueOrRegex(String(value.value))\n          }]\n        });\n        continue;\n      }\n      const valueIsSequence = value instanceof yaml.YAMLSeq;\n      if (valueIsSequence) {\n        container.children.push(childNode);\n        convertSeq(childNode, value);\n        continue;\n      }\n      errors.push({\n        message: "Map values should be strings or sequences",\n        range: convertRange(entry.value.range || map.range)\n      });\n    }\n  };\n  const fragment = { kind: "role", role: "fragment" };\n  yamlDoc.errors.forEach(addError);\n  if (errors.length)\n    return { errors, fragment };\n  if (!(yamlDoc.contents instanceof yaml.YAMLSeq)) {\n    errors.push({\n      message: \'Aria snapshot must be a YAML sequence, elements starting with " -"\',\n      range: yamlDoc.contents ? convertRange(yamlDoc.contents.range) : [{ line: 0, col: 0 }, { line: 0, col: 0 }]\n    });\n  }\n  if (errors.length)\n    return { errors, fragment };\n  convertSeq(fragment, yamlDoc.contents);\n  if (errors.length)\n    return { errors, fragment: emptyFragment };\n  if (((_a = fragment.children) == null ? void 0 : _a.length) === 1)\n    return { fragment: fragment.children[0], errors };\n  return { fragment, errors };\n}\nvar emptyFragment = { kind: "role", role: "fragment" };\nfunction normalizeWhitespace(text) {\n  return text.replace(/[\\u200b\\u00ad]/g, "").replace(/[\\r\\n\\s\\t]+/g, " ").trim();\n}\nfunction valueOrRegex(value) {\n  return value.startsWith("/") && value.endsWith("/") && value.length > 1 ? { pattern: value.slice(1, -1) } : normalizeWhitespace(value);\n}\nvar KeyParser = class _KeyParser {\n  static parse(text, options, errors) {\n    try {\n      return new _KeyParser(text.value)._parse();\n    } catch (e) {\n      if (e instanceof ParserError) {\n        const message = options.prettyErrors === false ? e.message : e.message + ":\\n\\n" + text.value + "\\n" + " ".repeat(e.pos) + "^\\n";\n        errors.push({\n          message,\n          range: [options.lineCounter.linePos(text.range[0]), options.lineCounter.linePos(text.range[0] + e.pos)]\n        });\n        return null;\n      }\n      throw e;\n    }\n  }\n  constructor(input) {\n    this._input = input;\n    this._pos = 0;\n    this._length = input.length;\n  }\n  _peek() {\n    return this._input[this._pos] || "";\n  }\n  _next() {\n    if (this._pos < this._length)\n      return this._input[this._pos++];\n    return null;\n  }\n  _eof() {\n    return this._pos >= this._length;\n  }\n  _isWhitespace() {\n    return !this._eof() && /\\s/.test(this._peek());\n  }\n  _skipWhitespace() {\n    while (this._isWhitespace())\n      this._pos++;\n  }\n  _readIdentifier(type) {\n    if (this._eof())\n      this._throwError(`Unexpected end of input when expecting ${type}`);\n    const start = this._pos;\n    while (!this._eof() && /[a-zA-Z]/.test(this._peek()))\n      this._pos++;\n    return this._input.slice(start, this._pos);\n  }\n  _readString() {\n    let result = "";\n    let escaped = false;\n    while (!this._eof()) {\n      const ch = this._next();\n      if (escaped) {\n        result += ch;\n        escaped = false;\n      } else if (ch === "\\\\") {\n        escaped = true;\n      } else if (ch === \'"\') {\n        return result;\n      } else {\n        result += ch;\n      }\n    }\n    this._throwError("Unterminated string");\n  }\n  _throwError(message, offset = 0) {\n    throw new ParserError(message, offset || this._pos);\n  }\n  _readRegex() {\n    let result = "";\n    let escaped = false;\n    let insideClass = false;\n    while (!this._eof()) {\n      const ch = this._next();\n      if (escaped) {\n        result += ch;\n        escaped = false;\n      } else if (ch === "\\\\") {\n        escaped = true;\n        result += ch;\n      } else if (ch === "/" && !insideClass) {\n        return { pattern: result };\n      } else if (ch === "[") {\n        insideClass = true;\n        result += ch;\n      } else if (ch === "]" && insideClass) {\n        result += ch;\n        insideClass = false;\n      } else {\n        result += ch;\n      }\n    }\n    this._throwError("Unterminated regex");\n  }\n  _readStringOrRegex() {\n    const ch = this._peek();\n    if (ch === \'"\') {\n      this._next();\n      return normalizeWhitespace(this._readString());\n    }\n    if (ch === "/") {\n      this._next();\n      return this._readRegex();\n    }\n    return null;\n  }\n  _readAttributes(result) {\n    let errorPos = this._pos;\n    while (true) {\n      this._skipWhitespace();\n      if (this._peek() === "[") {\n        this._next();\n        this._skipWhitespace();\n        errorPos = this._pos;\n        const flagName = this._readIdentifier("attribute");\n        this._skipWhitespace();\n        let flagValue = "";\n        if (this._peek() === "=") {\n          this._next();\n          this._skipWhitespace();\n          errorPos = this._pos;\n          while (this._peek() !== "]" && !this._isWhitespace() && !this._eof())\n            flagValue += this._next();\n        }\n        this._skipWhitespace();\n        if (this._peek() !== "]")\n          this._throwError("Expected ]");\n        this._next();\n        this._applyAttribute(result, flagName, flagValue || "true", errorPos);\n      } else {\n        break;\n      }\n    }\n  }\n  _parse() {\n    this._skipWhitespace();\n    const role = this._readIdentifier("role");\n    this._skipWhitespace();\n    const name = this._readStringOrRegex() || "";\n    const result = { kind: "role", role, name };\n    this._readAttributes(result);\n    this._skipWhitespace();\n    if (!this._eof())\n      this._throwError("Unexpected input");\n    return result;\n  }\n  _applyAttribute(node, key, value, errorPos) {\n    if (key === "checked") {\n      this._assert(value === "true" || value === "false" || value === "mixed", \'Value of "checked" attribute must be a boolean or "mixed"\', errorPos);\n      node.checked = value === "true" ? true : value === "false" ? false : "mixed";\n      return;\n    }\n    if (key === "disabled") {\n      this._assert(value === "true" || value === "false", \'Value of "disabled" attribute must be a boolean\', errorPos);\n      node.disabled = value === "true";\n      return;\n    }\n    if (key === "expanded") {\n      this._assert(value === "true" || value === "false", \'Value of "expanded" attribute must be a boolean\', errorPos);\n      node.expanded = value === "true";\n      return;\n    }\n    if (key === "level") {\n      this._assert(!isNaN(Number(value)), \'Value of "level" attribute must be a number\', errorPos);\n      node.level = Number(value);\n      return;\n    }\n    if (key === "pressed") {\n      this._assert(value === "true" || value === "false" || value === "mixed", \'Value of "pressed" attribute must be a boolean or "mixed"\', errorPos);\n      node.pressed = value === "true" ? true : value === "false" ? false : "mixed";\n      return;\n    }\n    if (key === "selected") {\n      this._assert(value === "true" || value === "false", \'Value of "selected" attribute must be a boolean\', errorPos);\n      node.selected = value === "true";\n      return;\n    }\n    this._assert(false, `Unsupported attribute [${key}]`, errorPos);\n  }\n  _assert(value, message, valuePos) {\n    if (!value)\n      this._throwError(message || "Assertion error", valuePos);\n  }\n};\nvar ParserError = class extends Error {\n  constructor(message, pos) {\n    super(message);\n    this.pos = pos;\n  }\n};\n\n// packages/playwright-core/src/utils/isomorphic/builtins.ts\nfunction builtins(global) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  global = global != null ? global : globalThis;\n  if (!global["__playwright_builtins__"]) {\n    const builtins2 = {\n      setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),\n      clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),\n      setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\n      clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\n      requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\n      cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\n      requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\n      cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\n      performance: global.performance,\n      eval: (_i = global.eval) == null ? void 0 : _i.bind(global),\n      Intl: global.Intl,\n      Date: global.Date,\n      Map: global.Map,\n      Set: global.Set\n    };\n    Object.defineProperty(global, "__playwright_builtins__", { value: builtins2, configurable: false, enumerable: false, writable: false });\n  }\n  return global["__playwright_builtins__"];\n}\nvar instance = builtins();\nvar setTimeout = instance.setTimeout;\nvar clearTimeout = instance.clearTimeout;\nvar setInterval = instance.setInterval;\nvar clearInterval = instance.clearInterval;\nvar requestAnimationFrame = instance.requestAnimationFrame;\nvar cancelAnimationFrame = instance.cancelAnimationFrame;\nvar requestIdleCallback = instance.requestIdleCallback;\nvar cancelIdleCallback = instance.cancelIdleCallback;\nvar performance = instance.performance;\nvar Intl = instance.Intl;\nvar Date = instance.Date;\nvar Map = instance.Map;\nvar Set = instance.Set;\n\n// packages/playwright-core/src/utils/isomorphic/cssTokenizer.ts\nvar between = function(num, first, last) {\n  return num >= first && num <= last;\n};\nfunction digit(code) {\n  return between(code, 48, 57);\n}\nfunction hexdigit(code) {\n  return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n}\nfunction uppercaseletter(code) {\n  return between(code, 65, 90);\n}\nfunction lowercaseletter(code) {\n  return between(code, 97, 122);\n}\nfunction letter(code) {\n  return uppercaseletter(code) || lowercaseletter(code);\n}\nfunction nonascii(code) {\n  return code >= 128;\n}\nfunction namestartchar(code) {\n  return letter(code) || nonascii(code) || code === 95;\n}\nfunction namechar(code) {\n  return namestartchar(code) || digit(code) || code === 45;\n}\nfunction nonprintable(code) {\n  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\n}\nfunction newline(code) {\n  return code === 10;\n}\nfunction whitespace(code) {\n  return newline(code) || code === 9 || code === 32;\n}\nvar maximumallowedcodepoint = 1114111;\nvar InvalidCharacterError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = "InvalidCharacterError";\n  }\n};\nfunction preprocess(str) {\n  const codepoints = [];\n  for (let i = 0; i < str.length; i++) {\n    let code = str.charCodeAt(i);\n    if (code === 13 && str.charCodeAt(i + 1) === 10) {\n      code = 10;\n      i++;\n    }\n    if (code === 13 || code === 12)\n      code = 10;\n    if (code === 0)\n      code = 65533;\n    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n      const lead = code - 55296;\n      const trail = str.charCodeAt(i + 1) - 56320;\n      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n      i++;\n    }\n    codepoints.push(code);\n  }\n  return codepoints;\n}\nfunction stringFromCode(code) {\n  if (code <= 65535)\n    return String.fromCharCode(code);\n  code -= Math.pow(2, 16);\n  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n  const trail = code % Math.pow(2, 10) + 56320;\n  return String.fromCharCode(lead) + String.fromCharCode(trail);\n}\nfunction tokenize(str1) {\n  const str = preprocess(str1);\n  let i = -1;\n  const tokens = [];\n  let code;\n  let line = 0;\n  let column = 0;\n  let lastLineLength = 0;\n  const incrLineno = function() {\n    line += 1;\n    lastLineLength = column;\n    column = 0;\n  };\n  const locStart = { line, column };\n  const codepoint = function(i2) {\n    if (i2 >= str.length)\n      return -1;\n    return str[i2];\n  };\n  const next = function(num) {\n    if (num === void 0)\n      num = 1;\n    if (num > 3)\n      throw "Spec Error: no more than three codepoints of lookahead.";\n    return codepoint(i + num);\n  };\n  const consume = function(num) {\n    if (num === void 0)\n      num = 1;\n    i += num;\n    code = codepoint(i);\n    if (newline(code))\n      incrLineno();\n    else\n      column += num;\n    return true;\n  };\n  const reconsume = function() {\n    i -= 1;\n    if (newline(code)) {\n      line -= 1;\n      column = lastLineLength;\n    } else {\n      column -= 1;\n    }\n    locStart.line = line;\n    locStart.column = column;\n    return true;\n  };\n  const eof = function(codepoint2) {\n    if (codepoint2 === void 0)\n      codepoint2 = code;\n    return codepoint2 === -1;\n  };\n  const donothing = function() {\n  };\n  const parseerror = function() {\n  };\n  const consumeAToken = function() {\n    consumeComments();\n    consume();\n    if (whitespace(code)) {\n      while (whitespace(next()))\n        consume();\n      return new WhitespaceToken();\n    } else if (code === 34) {\n      return consumeAStringToken();\n    } else if (code === 35) {\n      if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n        const token = new HashToken("");\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n          token.type = "id";\n        token.value = consumeAName();\n        return token;\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 36) {\n      if (next() === 61) {\n        consume();\n        return new SuffixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 39) {\n      return consumeAStringToken();\n    } else if (code === 40) {\n      return new OpenParenToken();\n    } else if (code === 41) {\n      return new CloseParenToken();\n    } else if (code === 42) {\n      if (next() === 61) {\n        consume();\n        return new SubstringMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 43) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 44) {\n      return new CommaToken();\n    } else if (code === 45) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else if (next(1) === 45 && next(2) === 62) {\n        consume(2);\n        return new CDCToken();\n      } else if (startsWithAnIdentifier()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 46) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 58) {\n      return new ColonToken();\n    } else if (code === 59) {\n      return new SemicolonToken();\n    } else if (code === 60) {\n      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {\n        consume(3);\n        return new CDOToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 64) {\n      if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n        return new AtKeywordToken(consumeAName());\n      else\n        return new DelimToken(code);\n    } else if (code === 91) {\n      return new OpenSquareToken();\n    } else if (code === 92) {\n      if (startsWithAValidEscape()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        parseerror();\n        return new DelimToken(code);\n      }\n    } else if (code === 93) {\n      return new CloseSquareToken();\n    } else if (code === 94) {\n      if (next() === 61) {\n        consume();\n        return new PrefixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 123) {\n      return new OpenCurlyToken();\n    } else if (code === 124) {\n      if (next() === 61) {\n        consume();\n        return new DashMatchToken();\n      } else if (next() === 124) {\n        consume();\n        return new ColumnToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 125) {\n      return new CloseCurlyToken();\n    } else if (code === 126) {\n      if (next() === 61) {\n        consume();\n        return new IncludeMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (digit(code)) {\n      reconsume();\n      return consumeANumericToken();\n    } else if (namestartchar(code)) {\n      reconsume();\n      return consumeAnIdentlikeToken();\n    } else if (eof()) {\n      return new EOFToken();\n    } else {\n      return new DelimToken(code);\n    }\n  };\n  const consumeComments = function() {\n    while (next(1) === 47 && next(2) === 42) {\n      consume(2);\n      while (true) {\n        consume();\n        if (code === 42 && next() === 47) {\n          consume();\n          break;\n        } else if (eof()) {\n          parseerror();\n          return;\n        }\n      }\n    }\n  };\n  const consumeANumericToken = function() {\n    const num = consumeANumber();\n    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n      const token = new DimensionToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      token.unit = consumeAName();\n      return token;\n    } else if (next() === 37) {\n      consume();\n      const token = new PercentageToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      return token;\n    } else {\n      const token = new NumberToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      return token;\n    }\n  };\n  const consumeAnIdentlikeToken = function() {\n    const str2 = consumeAName();\n    if (str2.toLowerCase() === "url" && next() === 40) {\n      consume();\n      while (whitespace(next(1)) && whitespace(next(2)))\n        consume();\n      if (next() === 34 || next() === 39)\n        return new FunctionToken(str2);\n      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\n        return new FunctionToken(str2);\n      else\n        return consumeAURLToken();\n    } else if (next() === 40) {\n      consume();\n      return new FunctionToken(str2);\n    } else {\n      return new IdentToken(str2);\n    }\n  };\n  const consumeAStringToken = function(endingCodePoint) {\n    if (endingCodePoint === void 0)\n      endingCodePoint = code;\n    let string = "";\n    while (consume()) {\n      if (code === endingCodePoint || eof()) {\n        return new StringToken(string);\n      } else if (newline(code)) {\n        parseerror();\n        reconsume();\n        return new BadStringToken();\n      } else if (code === 92) {\n        if (eof(next()))\n          donothing();\n        else if (newline(next()))\n          consume();\n        else\n          string += stringFromCode(consumeEscape());\n      } else {\n        string += stringFromCode(code);\n      }\n    }\n    throw new Error("Internal error");\n  };\n  const consumeAURLToken = function() {\n    const token = new URLToken("");\n    while (whitespace(next()))\n      consume();\n    if (eof(next()))\n      return token;\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return token;\n      } else if (whitespace(code)) {\n        while (whitespace(next()))\n          consume();\n        if (next() === 41 || eof(next())) {\n          consume();\n          return token;\n        } else {\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\n        parseerror();\n        consumeTheRemnantsOfABadURL();\n        return new BadURLToken();\n      } else if (code === 92) {\n        if (startsWithAValidEscape()) {\n          token.value += stringFromCode(consumeEscape());\n        } else {\n          parseerror();\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else {\n        token.value += stringFromCode(code);\n      }\n    }\n    throw new Error("Internal error");\n  };\n  const consumeEscape = function() {\n    consume();\n    if (hexdigit(code)) {\n      const digits = [code];\n      for (let total = 0; total < 5; total++) {\n        if (hexdigit(next())) {\n          consume();\n          digits.push(code);\n        } else {\n          break;\n        }\n      }\n      if (whitespace(next()))\n        consume();\n      let value = parseInt(digits.map(function(x) {\n        return String.fromCharCode(x);\n      }).join(""), 16);\n      if (value > maximumallowedcodepoint)\n        value = 65533;\n      return value;\n    } else if (eof()) {\n      return 65533;\n    } else {\n      return code;\n    }\n  };\n  const areAValidEscape = function(c1, c2) {\n    if (c1 !== 92)\n      return false;\n    if (newline(c2))\n      return false;\n    return true;\n  };\n  const startsWithAValidEscape = function() {\n    return areAValidEscape(code, next());\n  };\n  const wouldStartAnIdentifier = function(c1, c2, c3) {\n    if (c1 === 45)\n      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\n    else if (namestartchar(c1))\n      return true;\n    else if (c1 === 92)\n      return areAValidEscape(c1, c2);\n    else\n      return false;\n  };\n  const startsWithAnIdentifier = function() {\n    return wouldStartAnIdentifier(code, next(1), next(2));\n  };\n  const wouldStartANumber = function(c1, c2, c3) {\n    if (c1 === 43 || c1 === 45) {\n      if (digit(c2))\n        return true;\n      if (c2 === 46 && digit(c3))\n        return true;\n      return false;\n    } else if (c1 === 46) {\n      if (digit(c2))\n        return true;\n      return false;\n    } else if (digit(c1)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const startsWithANumber = function() {\n    return wouldStartANumber(code, next(1), next(2));\n  };\n  const consumeAName = function() {\n    let result = "";\n    while (consume()) {\n      if (namechar(code)) {\n        result += stringFromCode(code);\n      } else if (startsWithAValidEscape()) {\n        result += stringFromCode(consumeEscape());\n      } else {\n        reconsume();\n        return result;\n      }\n    }\n    throw new Error("Internal parse error");\n  };\n  const consumeANumber = function() {\n    let repr = "";\n    let type = "integer";\n    if (next() === 43 || next() === 45) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    while (digit(next())) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    if (next(1) === 46 && digit(next(2))) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const c1 = next(1), c2 = next(2), c3 = next(3);\n    if ((c1 === 69 || c1 === 101) && digit(c2)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const value = convertAStringToANumber(repr);\n    return { type, value, repr };\n  };\n  const convertAStringToANumber = function(string) {\n    return +string;\n  };\n  const consumeTheRemnantsOfABadURL = function() {\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return;\n      } else if (startsWithAValidEscape()) {\n        consumeEscape();\n        donothing();\n      } else {\n        donothing();\n      }\n    }\n  };\n  let iterationCount = 0;\n  while (!eof(next())) {\n    tokens.push(consumeAToken());\n    iterationCount++;\n    if (iterationCount > str.length * 2)\n      throw new Error("I\'m infinite-looping!");\n  }\n  return tokens;\n}\nvar CSSParserToken = class {\n  constructor() {\n    this.tokenType = "";\n  }\n  toJSON() {\n    return { token: this.tokenType };\n  }\n  toString() {\n    return this.tokenType;\n  }\n  toSource() {\n    return "" + this;\n  }\n};\nvar BadStringToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "BADSTRING";\n  }\n};\nvar BadURLToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "BADURL";\n  }\n};\nvar WhitespaceToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "WHITESPACE";\n  }\n  toString() {\n    return "WS";\n  }\n  toSource() {\n    return " ";\n  }\n};\nvar CDOToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "CDO";\n  }\n  toSource() {\n    return "<!--";\n  }\n};\nvar CDCToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "CDC";\n  }\n  toSource() {\n    return "-->";\n  }\n};\nvar ColonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ":";\n  }\n};\nvar SemicolonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ";";\n  }\n};\nvar CommaToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ",";\n  }\n};\nvar GroupingToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = "";\n    this.mirror = "";\n  }\n};\nvar OpenCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "{";\n    this.value = "{";\n    this.mirror = "}";\n  }\n};\nvar CloseCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "}";\n    this.value = "}";\n    this.mirror = "{";\n  }\n};\nvar OpenSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "[";\n    this.value = "[";\n    this.mirror = "]";\n  }\n};\nvar CloseSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "]";\n    this.value = "]";\n    this.mirror = "[";\n  }\n};\nvar OpenParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "(";\n    this.value = "(";\n    this.mirror = ")";\n  }\n};\nvar CloseParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = ")";\n    this.value = ")";\n    this.mirror = "(";\n  }\n};\nvar IncludeMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "~=";\n  }\n};\nvar DashMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "|=";\n  }\n};\nvar PrefixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "^=";\n  }\n};\nvar SuffixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "$=";\n  }\n};\nvar SubstringMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "*=";\n  }\n};\nvar ColumnToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "||";\n  }\n};\nvar EOFToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "EOF";\n  }\n  toSource() {\n    return "";\n  }\n};\nvar DelimToken = class extends CSSParserToken {\n  constructor(code) {\n    super();\n    this.tokenType = "DELIM";\n    this.value = "";\n    this.value = stringFromCode(code);\n  }\n  toString() {\n    return "DELIM(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n  toSource() {\n    if (this.value === "\\\\")\n      return "\\\\\\n";\n    else\n      return this.value;\n  }\n};\nvar StringValuedToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = "";\n  }\n  ASCIIMatch(str) {\n    return this.value.toLowerCase() === str.toLowerCase();\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n};\nvar IdentToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "IDENT";\n    this.value = val;\n  }\n  toString() {\n    return "IDENT(" + this.value + ")";\n  }\n  toSource() {\n    return escapeIdent(this.value);\n  }\n};\nvar FunctionToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "FUNCTION";\n    this.value = val;\n    this.mirror = ")";\n  }\n  toString() {\n    return "FUNCTION(" + this.value + ")";\n  }\n  toSource() {\n    return escapeIdent(this.value) + "(";\n  }\n};\nvar AtKeywordToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "AT-KEYWORD";\n    this.value = val;\n  }\n  toString() {\n    return "AT(" + this.value + ")";\n  }\n  toSource() {\n    return "@" + escapeIdent(this.value);\n  }\n};\nvar HashToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "HASH";\n    this.value = val;\n    this.type = "unrestricted";\n  }\n  toString() {\n    return "HASH(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    return json;\n  }\n  toSource() {\n    if (this.type === "id")\n      return "#" + escapeIdent(this.value);\n    else\n      return "#" + escapeHash(this.value);\n  }\n};\nvar StringToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "STRING";\n    this.value = val;\n  }\n  toString() {\n    return \'"\' + escapeString(this.value) + \'"\';\n  }\n};\nvar URLToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "URL";\n    this.value = val;\n  }\n  toString() {\n    return "URL(" + this.value + ")";\n  }\n  toSource() {\n    return \'url("\' + escapeString(this.value) + \'")\';\n  }\n};\nvar NumberToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "NUMBER";\n    this.type = "integer";\n    this.repr = "";\n  }\n  toString() {\n    if (this.type === "integer")\n      return "INT(" + this.value + ")";\n    return "NUMBER(" + this.value + ")";\n  }\n  toJSON() {\n    const json = super.toJSON();\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr;\n  }\n};\nvar PercentageToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "PERCENTAGE";\n    this.repr = "";\n  }\n  toString() {\n    return "PERCENTAGE(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr + "%";\n  }\n};\nvar DimensionToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "DIMENSION";\n    this.type = "integer";\n    this.repr = "";\n    this.unit = "";\n  }\n  toString() {\n    return "DIM(" + this.value + "," + this.unit + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    json.unit = this.unit;\n    return json;\n  }\n  toSource() {\n    const source = this.repr;\n    let unit = escapeIdent(this.unit);\n    if (unit[0].toLowerCase() === "e" && (unit[1] === "-" || between(unit.charCodeAt(1), 48, 57))) {\n      unit = "\\\\65 " + unit.slice(1, unit.length);\n    }\n    return source + unit;\n  }\n};\nfunction escapeIdent(string) {\n  string = "" + string;\n  let result = "";\n  const firstcode = string.charCodeAt(0);\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)\n      result += "\\\\" + code.toString(16) + " ";\n    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += "\\\\" + string[i];\n  }\n  return result;\n}\nfunction escapeHash(string) {\n  string = "" + string;\n  let result = "";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += "\\\\" + code.toString(16) + " ";\n  }\n  return result;\n}\nfunction escapeString(string) {\n  string = "" + string;\n  let result = "";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (between(code, 1, 31) || code === 127)\n      result += "\\\\" + code.toString(16) + " ";\n    else if (code === 34 || code === 92)\n      result += "\\\\" + string[i];\n    else\n      result += string[i];\n  }\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/cssParser.ts\nvar InvalidSelectorError = class extends Error {\n};\nfunction parseCSS(selector, customNames) {\n  let tokens;\n  try {\n    tokens = tokenize(selector);\n    if (!(tokens[tokens.length - 1] instanceof EOFToken))\n      tokens.push(new EOFToken());\n  } catch (e) {\n    const newMessage = e.message + ` while parsing css selector "${selector}". Did you mean to CSS.escape it?`;\n    const index = (e.stack || "").indexOf(e.message);\n    if (index !== -1)\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n    e.message = newMessage;\n    throw e;\n  }\n  const unsupportedToken = tokens.find((token) => {\n    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || // TODO: Consider using these for something, e.g. to escape complex strings.\n    // For example :xpath{ (//div/bar[@attr="foo"])[2]/baz }\n    // Or this way :xpath( {complex-xpath-goes-here("hello")} )\n    token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || // TODO: Consider treating these as strings?\n    token instanceof URLToken || token instanceof PercentageToken;\n  });\n  if (unsupportedToken)\n    throw new InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing css selector "${selector}". Did you mean to CSS.escape it?`);\n  let pos = 0;\n  const names = new Set();\n  function unexpected() {\n    return new InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing css selector "${selector}". Did you mean to CSS.escape it?`);\n  }\n  function skipWhitespace() {\n    while (tokens[pos] instanceof WhitespaceToken)\n      pos++;\n  }\n  function isIdent(p = pos) {\n    return tokens[p] instanceof IdentToken;\n  }\n  function isString(p = pos) {\n    return tokens[p] instanceof StringToken;\n  }\n  function isNumber(p = pos) {\n    return tokens[p] instanceof NumberToken;\n  }\n  function isComma(p = pos) {\n    return tokens[p] instanceof CommaToken;\n  }\n  function isOpenParen(p = pos) {\n    return tokens[p] instanceof OpenParenToken;\n  }\n  function isCloseParen(p = pos) {\n    return tokens[p] instanceof CloseParenToken;\n  }\n  function isFunction(p = pos) {\n    return tokens[p] instanceof FunctionToken;\n  }\n  function isStar(p = pos) {\n    return tokens[p] instanceof DelimToken && tokens[p].value === "*";\n  }\n  function isEOF(p = pos) {\n    return tokens[p] instanceof EOFToken;\n  }\n  function isClauseCombinator(p = pos) {\n    return tokens[p] instanceof DelimToken && [">", "+", "~"].includes(tokens[p].value);\n  }\n  function isSelectorClauseEnd(p = pos) {\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;\n  }\n  function consumeFunctionArguments() {\n    const result2 = [consumeArgument()];\n    while (true) {\n      skipWhitespace();\n      if (!isComma())\n        break;\n      pos++;\n      result2.push(consumeArgument());\n    }\n    return result2;\n  }\n  function consumeArgument() {\n    skipWhitespace();\n    if (isNumber())\n      return tokens[pos++].value;\n    if (isString())\n      return tokens[pos++].value;\n    return consumeComplexSelector();\n  }\n  function consumeComplexSelector() {\n    const result2 = { simples: [] };\n    skipWhitespace();\n    if (isClauseCombinator()) {\n      result2.simples.push({ selector: { functions: [{ name: "scope", args: [] }] }, combinator: "" });\n    } else {\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: "" });\n    }\n    while (true) {\n      skipWhitespace();\n      if (isClauseCombinator()) {\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\n        skipWhitespace();\n      } else if (isSelectorClauseEnd()) {\n        break;\n      }\n      result2.simples.push({ combinator: "", selector: consumeSimpleSelector() });\n    }\n    return result2;\n  }\n  function consumeSimpleSelector() {\n    let rawCSSString = "";\n    const functions = [];\n    while (!isSelectorClauseEnd()) {\n      if (isIdent() || isStar()) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof HashToken) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === ".") {\n        pos++;\n        if (isIdent())\n          rawCSSString += "." + tokens[pos++].toSource();\n        else\n          throw unexpected();\n      } else if (tokens[pos] instanceof ColonToken) {\n        pos++;\n        if (isIdent()) {\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\n            rawCSSString += ":" + tokens[pos++].toSource();\n          } else {\n            const name = tokens[pos++].value.toLowerCase();\n            functions.push({ name, args: [] });\n            names.add(name);\n          }\n        } else if (isFunction()) {\n          const name = tokens[pos++].value.toLowerCase();\n          if (!customNames.has(name)) {\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n          } else {\n            functions.push({ name, args: consumeFunctionArguments() });\n            names.add(name);\n          }\n          skipWhitespace();\n          if (!isCloseParen())\n            throw unexpected();\n          pos++;\n        } else {\n          throw unexpected();\n        }\n      } else if (tokens[pos] instanceof OpenSquareToken) {\n        rawCSSString += "[";\n        pos++;\n        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())\n          rawCSSString += tokens[pos++].toSource();\n        if (!(tokens[pos] instanceof CloseSquareToken))\n          throw unexpected();\n        rawCSSString += "]";\n        pos++;\n      } else {\n        throw unexpected();\n      }\n    }\n    if (!rawCSSString && !functions.length)\n      throw unexpected();\n    return { css: rawCSSString || void 0, functions };\n  }\n  function consumeBuiltinFunctionArguments() {\n    let s = "";\n    let balance = 1;\n    while (!isEOF()) {\n      if (isOpenParen() || isFunction())\n        balance++;\n      if (isCloseParen())\n        balance--;\n      if (!balance)\n        break;\n      s += tokens[pos++].toSource();\n    }\n    return s;\n  }\n  const result = consumeFunctionArguments();\n  if (!isEOF())\n    throw unexpected();\n  if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))\n    throw new InvalidSelectorError(`Error while parsing css selector "${selector}". Did you mean to CSS.escape it?`);\n  return { selector: result, names: Array.from(names) };\n}\n\n// packages/playwright-core/src/utils/isomorphic/selectorParser.ts\nvar kNestedSelectorNames = new Set(["internal:has", "internal:has-not", "internal:and", "internal:or", "internal:chain", "left-of", "right-of", "above", "below", "near"]);\nvar kNestedSelectorNamesWithDistance = new Set(["left-of", "right-of", "above", "below", "near"]);\nvar customCSSNames = new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);\nfunction parseSelector(selector) {\n  const parsedStrings = parseSelectorString(selector);\n  const parts = [];\n  for (const part of parsedStrings.parts) {\n    if (part.name === "css" || part.name === "css:light") {\n      if (part.name === "css:light")\n        part.body = ":light(" + part.body + ")";\n      const parsedCSS = parseCSS(part.body, customCSSNames);\n      parts.push({\n        name: "css",\n        body: parsedCSS.selector,\n        source: part.body\n      });\n      continue;\n    }\n    if (kNestedSelectorNames.has(part.name)) {\n      let innerSelector;\n      let distance;\n      try {\n        const unescaped = JSON.parse("[" + part.body + "]");\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== "string")\n          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n        innerSelector = unescaped[0];\n        if (unescaped.length === 2) {\n          if (typeof unescaped[1] !== "number" || !kNestedSelectorNamesWithDistance.has(part.name))\n            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n          distance = unescaped[1];\n        }\n      } catch (e) {\n        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n      }\n      const nested = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\n      const lastFrame = [...nested.body.parsed.parts].reverse().find((part2) => part2.name === "internal:control" && part2.body === "enter-frame");\n      const lastFrameIndex = lastFrame ? nested.body.parsed.parts.indexOf(lastFrame) : -1;\n      if (lastFrameIndex !== -1 && selectorPartsEqual(nested.body.parsed.parts.slice(0, lastFrameIndex + 1), parts.slice(0, lastFrameIndex + 1)))\n        nested.body.parsed.parts.splice(0, lastFrameIndex + 1);\n      parts.push(nested);\n      continue;\n    }\n    parts.push({ ...part, source: part.body });\n  }\n  if (kNestedSelectorNames.has(parts[0].name))\n    throw new InvalidSelectorError(`"${parts[0].name}" selector cannot be first`);\n  return {\n    capture: parsedStrings.capture,\n    parts\n  };\n}\nfunction selectorPartsEqual(list1, list2) {\n  return stringifySelector({ parts: list1 }) === stringifySelector({ parts: list2 });\n}\nfunction stringifySelector(selector, forceEngineName) {\n  if (typeof selector === "string")\n    return selector;\n  return selector.parts.map((p, i) => {\n    let includeEngine = true;\n    if (!forceEngineName && i !== selector.capture) {\n      if (p.name === "css")\n        includeEngine = false;\n      else if (p.name === "xpath" && p.source.startsWith("//") || p.source.startsWith(".."))\n        includeEngine = false;\n    }\n    const prefix = includeEngine ? p.name + "=" : "";\n    return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;\n  }).join(" >> ");\n}\nfunction visitAllSelectorParts(selector, visitor) {\n  const visit = (selector2, nested) => {\n    for (const part of selector2.parts) {\n      visitor(part, nested);\n      if (kNestedSelectorNames.has(part.name))\n        visit(part.body.parsed, true);\n    }\n  };\n  visit(selector, false);\n}\nfunction parseSelectorString(selector) {\n  let index = 0;\n  let quote;\n  let start = 0;\n  const result = { parts: [] };\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf("=");\n    let name;\n    let body;\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === \'"\' && part[part.length - 1] === \'"\') {\n      name = "text";\n      body = part;\n    } else if (part.length > 1 && part[0] === "\'" && part[part.length - 1] === "\'") {\n      name = "text";\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith("..")) {\n      name = "xpath";\n      body = part;\n    } else {\n      name = "css";\n      body = part;\n    }\n    let capture = false;\n    if (name[0] === "*") {\n      capture = true;\n      name = name.substring(1);\n    }\n    result.parts.push({ name, body });\n    if (capture) {\n      if (result.capture !== void 0)\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n  if (!selector.includes(">>")) {\n    index = selector.length;\n    append();\n    return result;\n  }\n  const shouldIgnoreTextSelectorQuote = () => {\n    const prefix = selector.substring(start, index);\n    const match = prefix.match(/^\\s*text\\s*=(.*)$/);\n    return !!match && !!match[1];\n  };\n  while (index < selector.length) {\n    const c = selector[index];\n    if (c === "\\\\" && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = void 0;\n      index++;\n    } else if (!quote && (c === \'"\' || c === "\'" || c === "`") && !shouldIgnoreTextSelectorQuote()) {\n      quote = c;\n      index++;\n    } else if (!quote && c === ">" && selector[index + 1] === ">") {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n  append();\n  return result;\n}\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\n  let wp = 0;\n  let EOL = selector.length === 0;\n  const next = () => selector[wp] || "";\n  const eat1 = () => {\n    const result2 = next();\n    ++wp;\n    EOL = wp >= selector.length;\n    return result2;\n  };\n  const syntaxError = (stage) => {\n    if (EOL)\n      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \\`${selector}\\``);\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - unexpected symbol "${next()}" at position ${wp}` + (stage ? " during " + stage : ""));\n  };\n  function skipSpaces() {\n    while (!EOL && /\\s/.test(next()))\n      eat1();\n  }\n  function isCSSNameChar(char) {\n    return char >= "\\x80" || char >= "0" && char <= "9" || char >= "A" && char <= "Z" || char >= "a" && char <= "z" || char >= "0" && char <= "9" || char === "_" || char === "-";\n  }\n  function readIdentifier() {\n    let result2 = "";\n    skipSpaces();\n    while (!EOL && isCSSNameChar(next()))\n      result2 += eat1();\n    return result2;\n  }\n  function readQuotedString(quote) {\n    let result2 = eat1();\n    if (result2 !== quote)\n      syntaxError("parsing quoted string");\n    while (!EOL && next() !== quote) {\n      if (next() === "\\\\")\n        eat1();\n      result2 += eat1();\n    }\n    if (next() !== quote)\n      syntaxError("parsing quoted string");\n    result2 += eat1();\n    return result2;\n  }\n  function readRegularExpression() {\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let source = "";\n    let inClass = false;\n    while (!EOL) {\n      if (next() === "\\\\") {\n        source += eat1();\n        if (EOL)\n          syntaxError("parsing regular expression");\n      } else if (inClass && next() === "]") {\n        inClass = false;\n      } else if (!inClass && next() === "[") {\n        inClass = true;\n      } else if (!inClass && next() === "/") {\n        break;\n      }\n      source += eat1();\n    }\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let flags = "";\n    while (!EOL && next().match(/[dgimsuy]/))\n      flags += eat1();\n    try {\n      return new RegExp(source, flags);\n    } catch (e) {\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\`: ${e.message}`);\n    }\n  }\n  function readAttributeToken() {\n    let token = "";\n    skipSpaces();\n    if (next() === `\'` || next() === `"`)\n      token = readQuotedString(next()).slice(1, -1);\n    else\n      token = readIdentifier();\n    if (!token)\n      syntaxError("parsing property path");\n    return token;\n  }\n  function readOperator() {\n    skipSpaces();\n    let op = "";\n    if (!EOL)\n      op += eat1();\n    if (!EOL && op !== "=")\n      op += eat1();\n    if (!["=", "*=", "^=", "$=", "|=", "~="].includes(op))\n      syntaxError("parsing operator");\n    return op;\n  }\n  function readAttribute() {\n    eat1();\n    const jsonPath = [];\n    jsonPath.push(readAttributeToken());\n    skipSpaces();\n    while (next() === ".") {\n      eat1();\n      jsonPath.push(readAttributeToken());\n      skipSpaces();\n    }\n    if (next() === "]") {\n      eat1();\n      return { name: jsonPath.join("."), jsonPath, op: "<truthy>", value: null, caseSensitive: false };\n    }\n    const operator = readOperator();\n    let value = void 0;\n    let caseSensitive = true;\n    skipSpaces();\n    if (next() === "/") {\n      if (operator !== "=")\n        throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with regular expression`);\n      value = readRegularExpression();\n    } else if (next() === `\'` || next() === `"`) {\n      value = readQuotedString(next()).slice(1, -1);\n      skipSpaces();\n      if (next() === "i" || next() === "I") {\n        caseSensitive = false;\n        eat1();\n      } else if (next() === "s" || next() === "S") {\n        caseSensitive = true;\n        eat1();\n      }\n    } else {\n      value = "";\n      while (!EOL && (isCSSNameChar(next()) || next() === "+" || next() === "."))\n        value += eat1();\n      if (value === "true") {\n        value = true;\n      } else if (value === "false") {\n        value = false;\n      } else {\n        if (!allowUnquotedStrings) {\n          value = +value;\n          if (Number.isNaN(value))\n            syntaxError("parsing attribute value");\n        }\n      }\n    }\n    skipSpaces();\n    if (next() !== "]")\n      syntaxError("parsing attribute value");\n    eat1();\n    if (operator !== "=" && typeof value !== "string")\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\n    return { name: jsonPath.join("."), jsonPath, op: operator, value, caseSensitive };\n  }\n  const result = {\n    name: "",\n    attributes: []\n  };\n  result.name = readIdentifier();\n  skipSpaces();\n  while (next() === "[") {\n    result.attributes.push(readAttribute());\n    skipSpaces();\n  }\n  if (!EOL)\n    syntaxError(void 0);\n  if (!result.name && !result.attributes.length)\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - selector cannot be empty`);\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\nfunction escapeWithQuotes(text, char = "\'") {\n  const stringified = JSON.stringify(text);\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\"/g, \'"\');\n  if (char === "\'")\n    return char + escapedText.replace(/[\']/g, "\\\\\'") + char;\n  if (char === \'"\')\n    return char + escapedText.replace(/["]/g, \'\\\\"\') + char;\n  if (char === "`")\n    return char + escapedText.replace(/[`]/g, "`") + char;\n  throw new Error("Invalid escape char");\n}\nfunction toTitleCase(name) {\n  return name.charAt(0).toUpperCase() + name.substring(1);\n}\nfunction toSnakeCase(name) {\n  return name.replace(/([a-z0-9])([A-Z])/g, "$1_$2").replace(/([A-Z])([A-Z][a-z])/g, "$1_$2").toLowerCase();\n}\nfunction cssEscape(s) {\n  let result = "";\n  for (let i = 0; i < s.length; i++)\n    result += cssEscapeOne(s, i);\n  return result;\n}\nfunction quoteCSSAttributeValue(text) {\n  return `"${cssEscape(text).replace(/\\\\ /g, " ")}"`;\n}\nfunction cssEscapeOne(s, i) {\n  const c = s.charCodeAt(i);\n  if (c === 0)\n    return "\\uFFFD";\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\n    return "\\\\" + c.toString(16) + " ";\n  if (i === 0 && c === 45 && s.length === 1)\n    return "\\\\" + s.charAt(i);\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\n    return s.charAt(i);\n  return "\\\\" + s.charAt(i);\n}\nvar normalizedWhitespaceCache;\nfunction cacheNormalizedWhitespaces() {\n  normalizedWhitespaceCache = new Map();\n}\nfunction normalizeWhiteSpace(text) {\n  let result = normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.get(text);\n  if (result === void 0) {\n    result = text.replace(/[\\u200b\\u00ad]/g, "").trim().replace(/\\s+/g, " ");\n    normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.set(text, result);\n  }\n  return result;\n}\nfunction normalizeEscapedRegexQuotes(source) {\n  return source.replace(/(^|[^\\\\])(\\\\\\\\)*\\\\([\'"`])/g, "$1$2$3");\n}\nfunction escapeRegexForSelector(re) {\n  if (re.unicode || re.unicodeSets)\n    return String(re);\n  return String(re).replace(/(^|[^\\\\])(\\\\\\\\)*(["\'`])/g, "$1$2\\\\$3").replace(/>>/g, "\\\\>\\\\>");\n}\nfunction escapeForTextSelector(text, exact) {\n  if (typeof text !== "string")\n    return escapeRegexForSelector(text);\n  return `${JSON.stringify(text)}${exact ? "s" : "i"}`;\n}\nfunction escapeForAttributeSelector(value, exact) {\n  if (typeof value !== "string")\n    return escapeRegexForSelector(value);\n  return `"${value.replace(/\\\\/g, "\\\\\\\\").replace(/["]/g, \'\\\\"\')}"${exact ? "s" : "i"}`;\n}\nfunction trimString(input, cap, suffix = "") {\n  if (input.length <= cap)\n    return input;\n  const chars = [...input];\n  if (chars.length > cap)\n    return chars.slice(0, cap - suffix.length).join("") + suffix;\n  return chars.join("");\n}\nfunction trimStringWithEllipsis(input, cap) {\n  return trimString(input, cap, "\\u2026");\n}\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction longestCommonSubstring(s1, s2) {\n  const n = s1.length;\n  const m = s2.length;\n  let maxLen = 0;\n  let endingIndex = 0;\n  const dp = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= m; j++) {\n      if (s1[i - 1] === s2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n        if (dp[i][j] > maxLen) {\n          maxLen = dp[i][j];\n          endingIndex = i;\n        }\n      }\n    }\n  }\n  return s1.slice(endingIndex - maxLen, endingIndex);\n}\n\n// packages/playwright-core/src/utils/isomorphic/locatorGenerators.ts\nfunction asLocator(lang, selector, isFrameLocator = false) {\n  return asLocators(lang, selector, isFrameLocator, 1)[0];\n}\nfunction asLocators(lang, selector, isFrameLocator = false, maxOutputSize = 20, preferredQuote) {\n  try {\n    return innerAsLocators(new generators[lang](preferredQuote), parseSelector(selector), isFrameLocator, maxOutputSize);\n  } catch (e) {\n    return [selector];\n  }\n}\nfunction innerAsLocators(factory, parsed, isFrameLocator = false, maxOutputSize = 20) {\n  const parts = [...parsed.parts];\n  const tokens = [];\n  let nextBase = isFrameLocator ? "frame-locator" : "page";\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const base = nextBase;\n    nextBase = "locator";\n    if (part.name === "nth") {\n      if (part.body === "0")\n        tokens.push([factory.generateLocator(base, "first", ""), factory.generateLocator(base, "nth", "0")]);\n      else if (part.body === "-1")\n        tokens.push([factory.generateLocator(base, "last", ""), factory.generateLocator(base, "nth", "-1")]);\n      else\n        tokens.push([factory.generateLocator(base, "nth", part.body)]);\n      continue;\n    }\n    if (part.name === "visible") {\n      tokens.push([factory.generateLocator(base, "visible", part.body), factory.generateLocator(base, "default", `visible=${part.body}`)]);\n      continue;\n    }\n    if (part.name === "internal:text") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, "text", text, { exact })]);\n      continue;\n    }\n    if (part.name === "internal:has-text") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, "has-text", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:has-not-text") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, "has-not-text", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:has") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "has", inner)));\n      continue;\n    }\n    if (part.name === "internal:has-not") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "hasNot", inner)));\n      continue;\n    }\n    if (part.name === "internal:and") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "and", inner)));\n      continue;\n    }\n    if (part.name === "internal:or") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "or", inner)));\n      continue;\n    }\n    if (part.name === "internal:chain") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "chain", inner)));\n      continue;\n    }\n    if (part.name === "internal:label") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, "label", text, { exact })]);\n      continue;\n    }\n    if (part.name === "internal:role") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const options = { attrs: [] };\n      for (const attr of attrSelector.attributes) {\n        if (attr.name === "name") {\n          options.exact = attr.caseSensitive;\n          options.name = attr.value;\n        } else {\n          if (attr.name === "level" && typeof attr.value === "string")\n            attr.value = +attr.value;\n          options.attrs.push({ name: attr.name === "include-hidden" ? "includeHidden" : attr.name, value: attr.value });\n        }\n      }\n      tokens.push([factory.generateLocator(base, "role", attrSelector.name, options)]);\n      continue;\n    }\n    if (part.name === "internal:testid") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { value } = attrSelector.attributes[0];\n      tokens.push([factory.generateLocator(base, "test-id", value)]);\n      continue;\n    }\n    if (part.name === "internal:attr") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { name, value, caseSensitive } = attrSelector.attributes[0];\n      const text = value;\n      const exact = !!caseSensitive;\n      if (name === "placeholder") {\n        tokens.push([factory.generateLocator(base, "placeholder", text, { exact })]);\n        continue;\n      }\n      if (name === "alt") {\n        tokens.push([factory.generateLocator(base, "alt", text, { exact })]);\n        continue;\n      }\n      if (name === "title") {\n        tokens.push([factory.generateLocator(base, "title", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:control" && part.body === "enter-frame") {\n      const lastTokens = tokens[tokens.length - 1];\n      const lastPart = parts[index - 1];\n      const transformed = lastTokens.map((token) => factory.chainLocators([token, factory.generateLocator(base, "frame", "")]));\n      if (["xpath", "css"].includes(lastPart.name)) {\n        transformed.push(\n          factory.generateLocator(base, "frame-locator", stringifySelector({ parts: [lastPart] })),\n          factory.generateLocator(base, "frame-locator", stringifySelector({ parts: [lastPart] }, true))\n        );\n      }\n      lastTokens.splice(0, lastTokens.length, ...transformed);\n      nextBase = "frame-locator";\n      continue;\n    }\n    const nextPart = parts[index + 1];\n    const selectorPart = stringifySelector({ parts: [part] });\n    const locatorPart = factory.generateLocator(base, "default", selectorPart);\n    if (nextPart && ["internal:has-text", "internal:has-not-text"].includes(nextPart.name)) {\n      const { exact, text } = detectExact(nextPart.body);\n      if (!exact) {\n        const nextLocatorPart = factory.generateLocator("locator", nextPart.name === "internal:has-text" ? "has-text" : "has-not-text", text, { exact });\n        const options = {};\n        if (nextPart.name === "internal:has-text")\n          options.hasText = text;\n        else\n          options.hasNotText = text;\n        const combinedPart = factory.generateLocator(base, "default", selectorPart, options);\n        tokens.push([factory.chainLocators([locatorPart, nextLocatorPart]), combinedPart]);\n        index++;\n        continue;\n      }\n    }\n    let locatorPartWithEngine;\n    if (["xpath", "css"].includes(part.name)) {\n      const selectorPart2 = stringifySelector(\n        { parts: [part] },\n        /* forceEngineName */\n        true\n      );\n      locatorPartWithEngine = factory.generateLocator(base, "default", selectorPart2);\n    }\n    tokens.push([locatorPart, locatorPartWithEngine].filter(Boolean));\n  }\n  return combineTokens(factory, tokens, maxOutputSize);\n}\nfunction combineTokens(factory, tokens, maxOutputSize) {\n  const currentTokens = tokens.map(() => "");\n  const result = [];\n  const visit = (index) => {\n    if (index === tokens.length) {\n      result.push(factory.chainLocators(currentTokens));\n      return result.length < maxOutputSize;\n    }\n    for (const taken of tokens[index]) {\n      currentTokens[index] = taken;\n      if (!visit(index + 1))\n        return false;\n    }\n    return true;\n  };\n  visit(0);\n  return result;\n}\nfunction detectExact(text) {\n  let exact = false;\n  const match = text.match(/^\\/(.*)\\/([igm]*)$/);\n  if (match)\n    return { text: new RegExp(match[1], match[2]) };\n  if (text.endsWith(\'"\')) {\n    text = JSON.parse(text);\n    exact = true;\n  } else if (text.endsWith(\'"s\')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = true;\n  } else if (text.endsWith(\'"i\')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = false;\n  }\n  return { exact, text };\n}\nvar JavaScriptLocatorFactory = class {\n  constructor(preferredQuote) {\n    this.preferredQuote = preferredQuote;\n  }\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, { hasText: ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, { hasNotText: ${this.toHasText(options.hasNotText)} })`;\n        return `locator(${this.quote(body)})`;\n      case "frame-locator":\n        return `frameLocator(${this.quote(body)})`;\n      case "frame":\n        return `contentFrame()`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first()`;\n      case "last":\n        return `last()`;\n      case "visible":\n        return `filter({ visible: ${body === "true" ? "true" : "false"} })`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name: ${this.regexToSourceString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`name: ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact: true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${name}: ${typeof value === "string" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, { ${attrs.join(", ")} }` : "";\n        return `getByRole(${this.quote(body)}${attrString})`;\n      case "has-text":\n        return `filter({ hasText: ${this.toHasText(body)} })`;\n      case "has-not-text":\n        return `filter({ hasNotText: ${this.toHasText(body)} })`;\n      case "has":\n        return `filter({ has: ${body} })`;\n      case "hasNot":\n        return `filter({ hasNot: ${body} })`;\n      case "and":\n        return `and(${body})`;\n      case "or":\n        return `or(${body})`;\n      case "chain":\n        return `locator(${body})`;\n      case "test-id":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("getByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("getByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("getByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("getByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("getByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToSourceString(re) {\n    return normalizeEscapedRegexQuotes(String(re));\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToSourceString(body)})`;\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToSourceString(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToSourceString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    var _a;\n    return escapeWithQuotes(text, (_a = this.preferredQuote) != null ? _a : "\'");\n  }\n};\nvar PythonLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, has_text=${this.toHasText(options.hasText)})`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, has_not_text=${this.toHasText(options.hasNotText)})`;\n        return `locator(${this.quote(body)})`;\n      case "frame-locator":\n        return `frame_locator(${this.quote(body)})`;\n      case "frame":\n        return `content_frame`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first`;\n      case "last":\n        return `last`;\n      case "visible":\n        return `filter(visible=${body === "true" ? "True" : "False"})`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name=${this.regexToString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`name=${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact=True`);\n        }\n        for (const { name, value } of options.attrs) {\n          let valueString = typeof value === "string" ? this.quote(value) : value;\n          if (typeof value === "boolean")\n            valueString = value ? "True" : "False";\n          attrs.push(`${toSnakeCase(name)}=${valueString}`);\n        }\n        const attrString = attrs.length ? `, ${attrs.join(", ")}` : "";\n        return `get_by_role(${this.quote(body)}${attrString})`;\n      case "has-text":\n        return `filter(has_text=${this.toHasText(body)})`;\n      case "has-not-text":\n        return `filter(has_not_text=${this.toHasText(body)})`;\n      case "has":\n        return `filter(has=${body})`;\n      case "hasNot":\n        return `filter(has_not=${body})`;\n      case "and":\n        return `and_(${body})`;\n      case "or":\n        return `or_(${body})`;\n      case "chain":\n        return `locator(${body})`;\n      case "test-id":\n        return `get_by_test_id(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("get_by_text", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("get_by_alt_text", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("get_by_placeholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("get_by_label", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("get_by_title", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", re.IGNORECASE" : "";\n    return `re.compile(r"${normalizeEscapedRegexQuotes(body.source).replace(/\\\\\\//, "/").replace(/"/g, \'\\\\"\')}"${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, exact=True)`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return `${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar JavaLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    let clazz;\n    switch (base) {\n      case "page":\n        clazz = "Page";\n        break;\n      case "frame-locator":\n        clazz = "FrameLocator";\n        break;\n      case "locator":\n        clazz = "Locator";\n        break;\n    }\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasText(${this.toHasText(options.hasText)}))`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasNotText(${this.toHasText(options.hasNotText)}))`;\n        return `locator(${this.quote(body)})`;\n      case "frame-locator":\n        return `frameLocator(${this.quote(body)})`;\n      case "frame":\n        return `contentFrame()`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first()`;\n      case "last":\n        return `last()`;\n      case "visible":\n        return `filter(new ${clazz}.FilterOptions().setVisible(${body === "true" ? "true" : "false"}))`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`.setName(${this.quote(options.name)})`);\n          if (options.exact)\n            attrs.push(`.setExact(true)`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`.set${toTitleCase(name)}(${typeof value === "string" ? this.quote(value) : value})`);\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join("")}` : "";\n        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;\n      case "has-text":\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\n      case "has-not-text":\n        return `filter(new ${clazz}.FilterOptions().setHasNotText(${this.toHasText(body)}))`;\n      case "has":\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\n      case "hasNot":\n        return `filter(new ${clazz}.FilterOptions().setHasNot(${body}))`;\n      case "and":\n        return `and(${body})`;\n      case "or":\n        return `or(${body})`;\n      case "chain":\n        return `locator(${body})`;\n      case "test-id":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact(clazz, "getByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact(clazz, "getByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact(clazz, "getByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact(clazz, "getByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact(clazz, "getByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", Pattern.CASE_INSENSITIVE" : "";\n    return `Pattern.compile(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;\n  }\n  toCallWithExact(clazz, method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar CSharpLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasNotText(options.hasNotText)} })`;\n        return `Locator(${this.quote(body)})`;\n      case "frame-locator":\n        return `FrameLocator(${this.quote(body)})`;\n      case "frame":\n        return `ContentFrame`;\n      case "nth":\n        return `Nth(${body})`;\n      case "first":\n        return `First`;\n      case "last":\n        return `Last`;\n      case "visible":\n        return `Filter(new() { Visible = ${body === "true" ? "true" : "false"} })`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`Name = ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`Exact = true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${toTitleCase(name)} = ${typeof value === "string" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, new() { ${attrs.join(", ")} }` : "";\n        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;\n      case "has-text":\n        return `Filter(new() { ${this.toHasText(body)} })`;\n      case "has-not-text":\n        return `Filter(new() { ${this.toHasNotText(body)} })`;\n      case "has":\n        return `Filter(new() { Has = ${body} })`;\n      case "hasNot":\n        return `Filter(new() { HasNot = ${body} })`;\n      case "and":\n        return `And(${body})`;\n      case "or":\n        return `Or(${body})`;\n      case "chain":\n        return `Locator(${body})`;\n      case "test-id":\n        return `GetByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("GetByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("GetByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("GetByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("GetByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("GetByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", RegexOptions.IgnoreCase" : "";\n    return `new Regex(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new() { Exact = true })`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return `HasTextRegex = ${this.regexToString(body)}`;\n    return `HasText = ${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  toHasNotText(body) {\n    if (isRegExp(body))\n      return `HasNotTextRegex = ${this.regexToString(body)}`;\n    return `HasNotText = ${this.quote(body)}`;\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar JsonlLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    return JSON.stringify({\n      kind,\n      body,\n      options\n    });\n  }\n  chainLocators(locators) {\n    const objects = locators.map((l) => JSON.parse(l));\n    for (let i = 0; i < objects.length - 1; ++i)\n      objects[i].next = objects[i + 1];\n    return JSON.stringify(objects[0]);\n  }\n};\nvar generators = {\n  javascript: JavaScriptLocatorFactory,\n  python: PythonLocatorFactory,\n  java: JavaLocatorFactory,\n  csharp: CSharpLocatorFactory,\n  jsonl: JsonlLocatorFactory\n};\nfunction isRegExp(obj) {\n  return obj instanceof RegExp;\n}\n\n// packages/injected/src/domUtils.ts\nvar globalOptions = {};\nfunction setGlobalOptions(options) {\n  globalOptions = options;\n}\nfunction getGlobalOptions() {\n  return globalOptions;\n}\nfunction isInsideScope(scope, element) {\n  while (element) {\n    if (scope.contains(element))\n      return true;\n    element = enclosingShadowHost(element);\n  }\n  return false;\n}\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return;\n  if (element.parentNode.nodeType === 11 && element.parentNode.host)\n    return element.parentNode.host;\n}\nfunction enclosingShadowRootOrDocument(element) {\n  let node = element;\n  while (node.parentNode)\n    node = node.parentNode;\n  if (node.nodeType === 11 || node.nodeType === 9)\n    return node;\n}\nfunction enclosingShadowHost(element) {\n  while (element.parentElement)\n    element = element.parentElement;\n  return parentElementOrShadowHost(element);\n}\nfunction closestCrossShadow(element, css, scope) {\n  while (element) {\n    const closest = element.closest(css);\n    if (scope && closest !== scope && (closest == null ? void 0 : closest.contains(scope)))\n      return;\n    if (closest)\n      return closest;\n    element = enclosingShadowHost(element);\n  }\n}\nfunction getElementComputedStyle(element, pseudo) {\n  return element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\n}\nfunction isElementStyleVisibilityVisible(element, style) {\n  style = style != null ? style : getElementComputedStyle(element);\n  if (!style)\n    return true;\n  if (Element.prototype.checkVisibility && globalOptions.browserNameForWorkarounds !== "webkit") {\n    if (!element.checkVisibility())\n      return false;\n  } else {\n    const detailsOrSummary = element.closest("details,summary");\n    if (detailsOrSummary !== element && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === "DETAILS" && !detailsOrSummary.open)\n      return false;\n  }\n  if (style.visibility !== "visible")\n    return false;\n  return true;\n}\nfunction box(element) {\n  const style = getElementComputedStyle(element);\n  if (!style)\n    return { visible: true };\n  if (style.display === "contents") {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && isElementVisible(child))\n        return { visible: true, style };\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return { visible: true, style };\n    }\n    return { visible: false, style };\n  }\n  if (!isElementStyleVisibilityVisible(element, style))\n    return { style, visible: false };\n  const rect = element.getBoundingClientRect();\n  return { rect, style, visible: rect.width > 0 && rect.height > 0 };\n}\nfunction isElementVisible(element) {\n  return box(element).visible;\n}\nfunction isVisibleTextNode(node) {\n  const range = node.ownerDocument.createRange();\n  range.selectNode(node);\n  const rect = range.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\nfunction elementSafeTagName(element) {\n  if (element instanceof HTMLFormElement)\n    return "FORM";\n  return element.tagName.toUpperCase();\n}\n\n// packages/injected/src/roleUtils.ts\nfunction hasExplicitAccessibleName(e) {\n  return e.hasAttribute("aria-label") || e.hasAttribute("aria-labelledby");\n}\nvar kAncestorPreventingLandmark = "article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]";\nvar kGlobalAriaAttributes = [\n  ["aria-atomic", void 0],\n  ["aria-busy", void 0],\n  ["aria-controls", void 0],\n  ["aria-current", void 0],\n  ["aria-describedby", void 0],\n  ["aria-details", void 0],\n  // Global use deprecated in ARIA 1.2\n  // [\'aria-disabled\', undefined],\n  ["aria-dropeffect", void 0],\n  // Global use deprecated in ARIA 1.2\n  // [\'aria-errormessage\', undefined],\n  ["aria-flowto", void 0],\n  ["aria-grabbed", void 0],\n  // Global use deprecated in ARIA 1.2\n  // [\'aria-haspopup\', undefined],\n  ["aria-hidden", void 0],\n  // Global use deprecated in ARIA 1.2\n  // [\'aria-invalid\', undefined],\n  ["aria-keyshortcuts", void 0],\n  ["aria-label", ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]],\n  ["aria-labelledby", ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]],\n  ["aria-live", void 0],\n  ["aria-owns", void 0],\n  ["aria-relevant", void 0],\n  ["aria-roledescription", ["generic"]]\n];\nfunction hasGlobalAriaAttribute(element, forRole) {\n  return kGlobalAriaAttributes.some(([attr, prohibited]) => {\n    return !(prohibited == null ? void 0 : prohibited.includes(forRole || "")) && element.hasAttribute(attr);\n  });\n}\nfunction hasTabIndex(element) {\n  return !Number.isNaN(Number(String(element.getAttribute("tabindex"))));\n}\nfunction isFocusable(element) {\n  return !isNativelyDisabled(element) && (isNativelyFocusable(element) || hasTabIndex(element));\n}\nfunction isNativelyFocusable(element) {\n  const tagName = elementSafeTagName(element);\n  if (["BUTTON", "DETAILS", "SELECT", "TEXTAREA"].includes(tagName))\n    return true;\n  if (tagName === "A" || tagName === "AREA")\n    return element.hasAttribute("href");\n  if (tagName === "INPUT")\n    return !element.hidden;\n  return false;\n}\nvar kImplicitRoleByTagName = {\n  "A": (e) => {\n    return e.hasAttribute("href") ? "link" : null;\n  },\n  "AREA": (e) => {\n    return e.hasAttribute("href") ? "link" : null;\n  },\n  "ARTICLE": () => "article",\n  "ASIDE": () => "complementary",\n  "BLOCKQUOTE": () => "blockquote",\n  "BUTTON": () => "button",\n  "CAPTION": () => "caption",\n  "CODE": () => "code",\n  "DATALIST": () => "listbox",\n  "DD": () => "definition",\n  "DEL": () => "deletion",\n  "DETAILS": () => "group",\n  "DFN": () => "term",\n  "DIALOG": () => "dialog",\n  "DT": () => "term",\n  "EM": () => "emphasis",\n  "FIELDSET": () => "group",\n  "FIGURE": () => "figure",\n  "FOOTER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "contentinfo",\n  "FORM": (e) => hasExplicitAccessibleName(e) ? "form" : null,\n  "H1": () => "heading",\n  "H2": () => "heading",\n  "H3": () => "heading",\n  "H4": () => "heading",\n  "H5": () => "heading",\n  "H6": () => "heading",\n  "HEADER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "banner",\n  "HR": () => "separator",\n  "HTML": () => "document",\n  "IMG": (e) => e.getAttribute("alt") === "" && !e.getAttribute("title") && !hasGlobalAriaAttribute(e) && !hasTabIndex(e) ? "presentation" : "img",\n  "INPUT": (e) => {\n    const type = e.type.toLowerCase();\n    if (type === "search")\n      return e.hasAttribute("list") ? "combobox" : "searchbox";\n    if (["email", "tel", "text", "url", ""].includes(type)) {\n      const list = getIdRefs(e, e.getAttribute("list"))[0];\n      return list && elementSafeTagName(list) === "DATALIST" ? "combobox" : "textbox";\n    }\n    if (type === "hidden")\n      return null;\n    if (type === "file" && !getGlobalOptions().inputFileRoleTextbox)\n      return "button";\n    return inputTypeToRole[type] || "textbox";\n  },\n  "INS": () => "insertion",\n  "LI": () => "listitem",\n  "MAIN": () => "main",\n  "MARK": () => "mark",\n  "MATH": () => "math",\n  "MENU": () => "list",\n  "METER": () => "meter",\n  "NAV": () => "navigation",\n  "OL": () => "list",\n  "OPTGROUP": () => "group",\n  "OPTION": () => "option",\n  "OUTPUT": () => "status",\n  "P": () => "paragraph",\n  "PROGRESS": () => "progressbar",\n  "SECTION": (e) => hasExplicitAccessibleName(e) ? "region" : null,\n  "SELECT": (e) => e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox",\n  "STRONG": () => "strong",\n  "SUB": () => "subscript",\n  "SUP": () => "superscript",\n  // For <svg> we default to Chrome behavior:\n  // - Chrome reports \'img\'.\n  // - Firefox reports \'diagram\' that is not in official ARIA spec yet.\n  // - Safari reports \'no role\', but still computes accessible name.\n  "SVG": () => "img",\n  "TABLE": () => "table",\n  "TBODY": () => "rowgroup",\n  "TD": (e) => {\n    const table = closestCrossShadow(e, "table");\n    const role = table ? getExplicitAriaRole(table) : "";\n    return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n  },\n  "TEXTAREA": () => "textbox",\n  "TFOOT": () => "rowgroup",\n  "TH": (e) => {\n    if (e.getAttribute("scope") === "col")\n      return "columnheader";\n    if (e.getAttribute("scope") === "row")\n      return "rowheader";\n    const table = closestCrossShadow(e, "table");\n    const role = table ? getExplicitAriaRole(table) : "";\n    return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n  },\n  "THEAD": () => "rowgroup",\n  "TIME": () => "time",\n  "TR": () => "row",\n  "UL": () => "list"\n};\nvar kPresentationInheritanceParents = {\n  "DD": ["DL", "DIV"],\n  "DIV": ["DL"],\n  "DT": ["DL", "DIV"],\n  "LI": ["OL", "UL"],\n  "TBODY": ["TABLE"],\n  "TD": ["TR"],\n  "TFOOT": ["TABLE"],\n  "TH": ["TR"],\n  "THEAD": ["TABLE"],\n  "TR": ["THEAD", "TBODY", "TFOOT", "TABLE"]\n};\nfunction getImplicitAriaRole(element) {\n  var _a;\n  const implicitRole = ((_a = kImplicitRoleByTagName[elementSafeTagName(element)]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || "";\n  if (!implicitRole)\n    return null;\n  let ancestor = element;\n  while (ancestor) {\n    const parent = parentElementOrShadowHost(ancestor);\n    const parents = kPresentationInheritanceParents[elementSafeTagName(ancestor)];\n    if (!parents || !parent || !parents.includes(elementSafeTagName(parent)))\n      break;\n    const parentExplicitRole = getExplicitAriaRole(parent);\n    if ((parentExplicitRole === "none" || parentExplicitRole === "presentation") && !hasPresentationConflictResolution(parent, parentExplicitRole))\n      return parentExplicitRole;\n    ancestor = parent;\n  }\n  return implicitRole;\n}\nvar validRoles = [\n  "alert",\n  "alertdialog",\n  "application",\n  "article",\n  "banner",\n  "blockquote",\n  "button",\n  "caption",\n  "cell",\n  "checkbox",\n  "code",\n  "columnheader",\n  "combobox",\n  "complementary",\n  "contentinfo",\n  "definition",\n  "deletion",\n  "dialog",\n  "directory",\n  "document",\n  "emphasis",\n  "feed",\n  "figure",\n  "form",\n  "generic",\n  "grid",\n  "gridcell",\n  "group",\n  "heading",\n  "img",\n  "insertion",\n  "link",\n  "list",\n  "listbox",\n  "listitem",\n  "log",\n  "main",\n  "mark",\n  "marquee",\n  "math",\n  "meter",\n  "menu",\n  "menubar",\n  "menuitem",\n  "menuitemcheckbox",\n  "menuitemradio",\n  "navigation",\n  "none",\n  "note",\n  "option",\n  "paragraph",\n  "presentation",\n  "progressbar",\n  "radio",\n  "radiogroup",\n  "region",\n  "row",\n  "rowgroup",\n  "rowheader",\n  "scrollbar",\n  "search",\n  "searchbox",\n  "separator",\n  "slider",\n  "spinbutton",\n  "status",\n  "strong",\n  "subscript",\n  "superscript",\n  "switch",\n  "tab",\n  "table",\n  "tablist",\n  "tabpanel",\n  "term",\n  "textbox",\n  "time",\n  "timer",\n  "toolbar",\n  "tooltip",\n  "tree",\n  "treegrid",\n  "treeitem"\n];\nfunction getExplicitAriaRole(element) {\n  const roles = (element.getAttribute("role") || "").split(" ").map((role) => role.trim());\n  return roles.find((role) => validRoles.includes(role)) || null;\n}\nfunction hasPresentationConflictResolution(element, role) {\n  return hasGlobalAriaAttribute(element, role) || isFocusable(element);\n}\nfunction getAriaRole(element) {\n  const explicitRole = getExplicitAriaRole(element);\n  if (!explicitRole)\n    return getImplicitAriaRole(element);\n  if (explicitRole === "none" || explicitRole === "presentation") {\n    const implicitRole = getImplicitAriaRole(element);\n    if (hasPresentationConflictResolution(element, implicitRole))\n      return implicitRole;\n  }\n  return explicitRole;\n}\nfunction getAriaBoolean(attr) {\n  return attr === null ? void 0 : attr.toLowerCase() === "true";\n}\nfunction isElementIgnoredForAria(element) {\n  return ["STYLE", "SCRIPT", "NOSCRIPT", "TEMPLATE"].includes(elementSafeTagName(element));\n}\nfunction isElementHiddenForAria(element) {\n  if (isElementIgnoredForAria(element))\n    return true;\n  const style = getElementComputedStyle(element);\n  const isSlot = element.nodeName === "SLOT";\n  if ((style == null ? void 0 : style.display) === "contents" && !isSlot) {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && !isElementHiddenForAria(child))\n        return false;\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return false;\n    }\n    return true;\n  }\n  const isOptionInsideSelect = element.nodeName === "OPTION" && !!element.closest("select");\n  if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element, style))\n    return true;\n  return belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element);\n}\nfunction belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element) {\n  let hidden = cacheIsHidden == null ? void 0 : cacheIsHidden.get(element);\n  if (hidden === void 0) {\n    hidden = false;\n    if (element.parentElement && element.parentElement.shadowRoot && !element.assignedSlot)\n      hidden = true;\n    if (!hidden) {\n      const style = getElementComputedStyle(element);\n      hidden = !style || style.display === "none" || getAriaBoolean(element.getAttribute("aria-hidden")) === true;\n    }\n    if (!hidden) {\n      const parent = parentElementOrShadowHost(element);\n      if (parent)\n        hidden = belongsToDisplayNoneOrAriaHiddenOrNonSlotted(parent);\n    }\n    cacheIsHidden == null ? void 0 : cacheIsHidden.set(element, hidden);\n  }\n  return hidden;\n}\nfunction getIdRefs(element, ref) {\n  if (!ref)\n    return [];\n  const root = enclosingShadowRootOrDocument(element);\n  if (!root)\n    return [];\n  try {\n    const ids = ref.split(" ").filter((id) => !!id);\n    const result = [];\n    for (const id of ids) {\n      const firstElement = root.querySelector("#" + CSS.escape(id));\n      if (firstElement && !result.includes(firstElement))\n        result.push(firstElement);\n    }\n    return result;\n  } catch (e) {\n    return [];\n  }\n}\nfunction trimFlatString(s) {\n  return s.trim();\n}\nfunction asFlatString(s) {\n  return s.split("\\xA0").map((chunk) => chunk.replace(/\\r\\n/g, "\\n").replace(/[\\u200b\\u00ad]/g, "").replace(/\\s\\s*/g, " ")).join("\\xA0").trim();\n}\nfunction queryInAriaOwned(element, selector) {\n  const result = [...element.querySelectorAll(selector)];\n  for (const owned of getIdRefs(element, element.getAttribute("aria-owns"))) {\n    if (owned.matches(selector))\n      result.push(owned);\n    result.push(...owned.querySelectorAll(selector));\n  }\n  return result;\n}\nfunction getPseudoContent(element, pseudo) {\n  const cache = pseudo === "::before" ? cachePseudoContentBefore : cachePseudoContentAfter;\n  if (cache == null ? void 0 : cache.has(element))\n    return (cache == null ? void 0 : cache.get(element)) || "";\n  const pseudoStyle = getElementComputedStyle(element, pseudo);\n  const content = getPseudoContentImpl(element, pseudoStyle);\n  if (cache)\n    cache.set(element, content);\n  return content;\n}\nfunction getPseudoContentImpl(element, pseudoStyle) {\n  if (!pseudoStyle || pseudoStyle.display === "none" || pseudoStyle.visibility === "hidden")\n    return "";\n  const content = pseudoStyle.content;\n  let resolvedContent;\n  if (content[0] === "\'" && content[content.length - 1] === "\'" || content[0] === \'"\' && content[content.length - 1] === \'"\') {\n    resolvedContent = content.substring(1, content.length - 1);\n  } else if (content.startsWith("attr(") && content.endsWith(")")) {\n    const attrName = content.substring("attr(".length, content.length - 1).trim();\n    resolvedContent = element.getAttribute(attrName) || "";\n  }\n  if (resolvedContent !== void 0) {\n    const display = pseudoStyle.display || "inline";\n    if (display !== "inline")\n      return " " + resolvedContent + " ";\n    return resolvedContent;\n  }\n  return "";\n}\nfunction getAriaLabelledByElements(element) {\n  const ref = element.getAttribute("aria-labelledby");\n  if (ref === null)\n    return null;\n  const refs = getIdRefs(element, ref);\n  return refs.length ? refs : null;\n}\nfunction allowsNameFromContent(role, targetDescendant) {\n  const alwaysAllowsNameFromContent = ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"].includes(role);\n  const descendantAllowsNameFromContent = targetDescendant && ["", "caption", "code", "contentinfo", "definition", "deletion", "emphasis", "insertion", "list", "listitem", "mark", "none", "paragraph", "presentation", "region", "row", "rowgroup", "section", "strong", "subscript", "superscript", "table", "term", "time"].includes(role);\n  return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\n}\nfunction getElementAccessibleName(element, includeHidden) {\n  const cache = includeHidden ? cacheAccessibleNameHidden : cacheAccessibleName;\n  let accessibleName = cache == null ? void 0 : cache.get(element);\n  if (accessibleName === void 0) {\n    accessibleName = "";\n    const elementProhibitsNaming = ["caption", "code", "definition", "deletion", "emphasis", "generic", "insertion", "mark", "paragraph", "presentation", "strong", "subscript", "suggestion", "superscript", "term", "time"].includes(getAriaRole(element) || "");\n    if (!elementProhibitsNaming) {\n      accessibleName = asFlatString(getTextAlternativeInternal(element, {\n        includeHidden,\n        visitedElements: new Set(),\n        embeddedInTargetElement: "self"\n      }));\n    }\n    cache == null ? void 0 : cache.set(element, accessibleName);\n  }\n  return accessibleName;\n}\nfunction getElementAccessibleDescription(element, includeHidden) {\n  const cache = includeHidden ? cacheAccessibleDescriptionHidden : cacheAccessibleDescription;\n  let accessibleDescription = cache == null ? void 0 : cache.get(element);\n  if (accessibleDescription === void 0) {\n    accessibleDescription = "";\n    if (element.hasAttribute("aria-describedby")) {\n      const describedBy = getIdRefs(element, element.getAttribute("aria-describedby"));\n      accessibleDescription = asFlatString(describedBy.map((ref) => getTextAlternativeInternal(ref, {\n        includeHidden,\n        visitedElements: new Set(),\n        embeddedInDescribedBy: { element: ref, hidden: isElementHiddenForAria(ref) }\n      })).join(" "));\n    } else if (element.hasAttribute("aria-description")) {\n      accessibleDescription = asFlatString(element.getAttribute("aria-description") || "");\n    } else {\n      accessibleDescription = asFlatString(element.getAttribute("title") || "");\n    }\n    cache == null ? void 0 : cache.set(element, accessibleDescription);\n  }\n  return accessibleDescription;\n}\nvar kAriaInvalidRoles = ["application", "checkbox", "combobox", "gridcell", "listbox", "radiogroup", "slider", "spinbutton", "textbox", "tree", "columnheader", "rowheader", "searchbox", "switch", "treegrid"];\nfunction getAriaInvalid(element) {\n  const role = getAriaRole(element) || "";\n  if (!role || !kAriaInvalidRoles.includes(role))\n    return "false";\n  const ariaInvalid = element.getAttribute("aria-invalid");\n  if (!ariaInvalid || ariaInvalid.trim() === "" || ariaInvalid.toLocaleLowerCase() === "false")\n    return "false";\n  if (ariaInvalid === "true" || ariaInvalid === "grammar" || ariaInvalid === "spelling")\n    return ariaInvalid;\n  return "true";\n}\nfunction getValidityInvalid(element) {\n  if ("validity" in element) {\n    const validity = element.validity;\n    return (validity == null ? void 0 : validity.valid) === false;\n  }\n  return false;\n}\nfunction getElementAccessibleErrorMessage(element) {\n  const cache = cacheAccessibleErrorMessage;\n  let accessibleErrorMessage = cacheAccessibleErrorMessage == null ? void 0 : cacheAccessibleErrorMessage.get(element);\n  if (accessibleErrorMessage === void 0) {\n    accessibleErrorMessage = "";\n    const isAriaInvalid = getAriaInvalid(element) !== "false";\n    const isValidityInvalid = getValidityInvalid(element);\n    if (isAriaInvalid || isValidityInvalid) {\n      const errorMessageId = element.getAttribute("aria-errormessage");\n      const errorMessages = getIdRefs(element, errorMessageId);\n      const parts = errorMessages.map((errorMessage) => asFlatString(\n        getTextAlternativeInternal(errorMessage, {\n          visitedElements: new Set(),\n          embeddedInDescribedBy: { element: errorMessage, hidden: isElementHiddenForAria(errorMessage) }\n        })\n      ));\n      accessibleErrorMessage = parts.join(" ").trim();\n    }\n    cache == null ? void 0 : cache.set(element, accessibleErrorMessage);\n  }\n  return accessibleErrorMessage;\n}\nfunction getTextAlternativeInternal(element, options) {\n  var _a, _b, _c, _d;\n  if (options.visitedElements.has(element))\n    return "";\n  const childOptions = {\n    ...options,\n    embeddedInTargetElement: options.embeddedInTargetElement === "self" ? "descendant" : options.embeddedInTargetElement\n  };\n  if (!options.includeHidden) {\n    const isEmbeddedInHiddenReferenceTraversal = !!((_a = options.embeddedInLabelledBy) == null ? void 0 : _a.hidden) || !!((_b = options.embeddedInDescribedBy) == null ? void 0 : _b.hidden) || !!((_c = options.embeddedInNativeTextAlternative) == null ? void 0 : _c.hidden) || !!((_d = options.embeddedInLabel) == null ? void 0 : _d.hidden);\n    if (isElementIgnoredForAria(element) || !isEmbeddedInHiddenReferenceTraversal && isElementHiddenForAria(element)) {\n      options.visitedElements.add(element);\n      return "";\n    }\n  }\n  const labelledBy = getAriaLabelledByElements(element);\n  if (!options.embeddedInLabelledBy) {\n    const accessibleName = (labelledBy || []).map((ref) => getTextAlternativeInternal(ref, {\n      ...options,\n      embeddedInLabelledBy: { element: ref, hidden: isElementHiddenForAria(ref) },\n      embeddedInDescribedBy: void 0,\n      embeddedInTargetElement: void 0,\n      embeddedInLabel: void 0,\n      embeddedInNativeTextAlternative: void 0\n    })).join(" ");\n    if (accessibleName)\n      return accessibleName;\n  }\n  const role = getAriaRole(element) || "";\n  const tagName = elementSafeTagName(element);\n  if (!!options.embeddedInLabel || !!options.embeddedInLabelledBy || options.embeddedInTargetElement === "descendant") {\n    const isOwnLabel = [...element.labels || []].includes(element);\n    const isOwnLabelledBy = (labelledBy || []).includes(element);\n    if (!isOwnLabel && !isOwnLabelledBy) {\n      if (role === "textbox") {\n        options.visitedElements.add(element);\n        if (tagName === "INPUT" || tagName === "TEXTAREA")\n          return element.value;\n        return element.textContent || "";\n      }\n      if (["combobox", "listbox"].includes(role)) {\n        options.visitedElements.add(element);\n        let selectedOptions;\n        if (tagName === "SELECT") {\n          selectedOptions = [...element.selectedOptions];\n          if (!selectedOptions.length && element.options.length)\n            selectedOptions.push(element.options[0]);\n        } else {\n          const listbox = role === "combobox" ? queryInAriaOwned(element, "*").find((e) => getAriaRole(e) === "listbox") : element;\n          selectedOptions = listbox ? queryInAriaOwned(listbox, \'[aria-selected="true"]\').filter((e) => getAriaRole(e) === "option") : [];\n        }\n        if (!selectedOptions.length && tagName === "INPUT") {\n          return element.value;\n        }\n        return selectedOptions.map((option) => getTextAlternativeInternal(option, childOptions)).join(" ");\n      }\n      if (["progressbar", "scrollbar", "slider", "spinbutton", "meter"].includes(role)) {\n        options.visitedElements.add(element);\n        if (element.hasAttribute("aria-valuetext"))\n          return element.getAttribute("aria-valuetext") || "";\n        if (element.hasAttribute("aria-valuenow"))\n          return element.getAttribute("aria-valuenow") || "";\n        return element.getAttribute("value") || "";\n      }\n      if (["menu"].includes(role)) {\n        options.visitedElements.add(element);\n        return "";\n      }\n    }\n  }\n  const ariaLabel = element.getAttribute("aria-label") || "";\n  if (trimFlatString(ariaLabel)) {\n    options.visitedElements.add(element);\n    return ariaLabel;\n  }\n  if (!["presentation", "none"].includes(role)) {\n    if (tagName === "INPUT" && ["button", "submit", "reset"].includes(element.type)) {\n      options.visitedElements.add(element);\n      const value = element.value || "";\n      if (trimFlatString(value))\n        return value;\n      if (element.type === "submit")\n        return "Submit";\n      if (element.type === "reset")\n        return "Reset";\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (!getGlobalOptions().inputFileRoleTextbox && tagName === "INPUT" && element.type === "file") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length && !options.embeddedInLabelledBy)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      return "Choose File";\n    }\n    if (tagName === "INPUT" && element.type === "image") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length && !options.embeddedInLabelledBy)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      const alt = element.getAttribute("alt") || "";\n      if (trimFlatString(alt))\n        return alt;\n      const title = element.getAttribute("title") || "";\n      if (trimFlatString(title))\n        return title;\n      return "Submit";\n    }\n    if (!labelledBy && tagName === "BUTTON") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n    }\n    if (!labelledBy && tagName === "OUTPUT") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      return element.getAttribute("title") || "";\n    }\n    if (!labelledBy && (tagName === "TEXTAREA" || tagName === "SELECT" || tagName === "INPUT")) {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      const usePlaceholder = tagName === "INPUT" && ["text", "password", "search", "tel", "email", "url"].includes(element.type) || tagName === "TEXTAREA";\n      const placeholder = element.getAttribute("placeholder") || "";\n      const title = element.getAttribute("title") || "";\n      if (!usePlaceholder || title)\n        return title;\n      return placeholder;\n    }\n    if (!labelledBy && tagName === "FIELDSET") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === "LEGEND") {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (!labelledBy && tagName === "FIGURE") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === "FIGCAPTION") {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (tagName === "IMG") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (trimFlatString(alt))\n        return alt;\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (tagName === "TABLE") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === "CAPTION") {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n      const summary = element.getAttribute("summary") || "";\n      if (summary)\n        return summary;\n    }\n    if (tagName === "AREA") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (trimFlatString(alt))\n        return alt;\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (tagName === "SVG" || element.ownerSVGElement) {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === "TITLE" && child.ownerSVGElement) {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInLabelledBy: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n    }\n    if (element.ownerSVGElement && tagName === "A") {\n      const title = element.getAttribute("xlink:title") || "";\n      if (trimFlatString(title)) {\n        options.visitedElements.add(element);\n        return title;\n      }\n    }\n  }\n  const shouldNameFromContentForSummary = tagName === "SUMMARY" && !["presentation", "none"].includes(role);\n  if (allowsNameFromContent(role, options.embeddedInTargetElement === "descendant") || shouldNameFromContentForSummary || !!options.embeddedInLabelledBy || !!options.embeddedInDescribedBy || !!options.embeddedInLabel || !!options.embeddedInNativeTextAlternative) {\n    options.visitedElements.add(element);\n    const accessibleName = innerAccumulatedElementText(element, childOptions);\n    const maybeTrimmedAccessibleName = options.embeddedInTargetElement === "self" ? trimFlatString(accessibleName) : accessibleName;\n    if (maybeTrimmedAccessibleName)\n      return accessibleName;\n  }\n  if (!["presentation", "none"].includes(role) || tagName === "IFRAME") {\n    options.visitedElements.add(element);\n    const title = element.getAttribute("title") || "";\n    if (trimFlatString(title))\n      return title;\n  }\n  options.visitedElements.add(element);\n  return "";\n}\nfunction innerAccumulatedElementText(element, options) {\n  const tokens = [];\n  const visit = (node, skipSlotted) => {\n    var _a;\n    if (skipSlotted && node.assignedSlot)\n      return;\n    if (node.nodeType === 1) {\n      const display = ((_a = getElementComputedStyle(node)) == null ? void 0 : _a.display) || "inline";\n      let token = getTextAlternativeInternal(node, options);\n      if (display !== "inline" || node.nodeName === "BR")\n        token = " " + token + " ";\n      tokens.push(token);\n    } else if (node.nodeType === 3) {\n      tokens.push(node.textContent || "");\n    }\n  };\n  tokens.push(getPseudoContent(element, "::before"));\n  const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];\n  if (assignedNodes.length) {\n    for (const child of assignedNodes)\n      visit(child, false);\n  } else {\n    for (let child = element.firstChild; child; child = child.nextSibling)\n      visit(child, true);\n    if (element.shadowRoot) {\n      for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n        visit(child, true);\n    }\n    for (const owned of getIdRefs(element, element.getAttribute("aria-owns")))\n      visit(owned, true);\n  }\n  tokens.push(getPseudoContent(element, "::after"));\n  return tokens.join("");\n}\nvar kAriaSelectedRoles = ["gridcell", "option", "row", "tab", "rowheader", "columnheader", "treeitem"];\nfunction getAriaSelected(element) {\n  if (elementSafeTagName(element) === "OPTION")\n    return element.selected;\n  if (kAriaSelectedRoles.includes(getAriaRole(element) || ""))\n    return getAriaBoolean(element.getAttribute("aria-selected")) === true;\n  return false;\n}\nvar kAriaCheckedRoles = ["checkbox", "menuitemcheckbox", "option", "radio", "switch", "menuitemradio", "treeitem"];\nfunction getAriaChecked(element) {\n  const result = getChecked(element, true);\n  return result === "error" ? false : result;\n}\nfunction getCheckedAllowMixed(element) {\n  return getChecked(element, true);\n}\nfunction getCheckedWithoutMixed(element) {\n  const result = getChecked(element, false);\n  return result;\n}\nfunction getChecked(element, allowMixed) {\n  const tagName = elementSafeTagName(element);\n  if (allowMixed && tagName === "INPUT" && element.indeterminate)\n    return "mixed";\n  if (tagName === "INPUT" && ["checkbox", "radio"].includes(element.type))\n    return element.checked;\n  if (kAriaCheckedRoles.includes(getAriaRole(element) || "")) {\n    const checked = element.getAttribute("aria-checked");\n    if (checked === "true")\n      return true;\n    if (allowMixed && checked === "mixed")\n      return "mixed";\n    return false;\n  }\n  return "error";\n}\nvar kAriaReadonlyRoles = ["checkbox", "combobox", "grid", "gridcell", "listbox", "radiogroup", "slider", "spinbutton", "textbox", "columnheader", "rowheader", "searchbox", "switch", "treegrid"];\nfunction getReadonly(element) {\n  const tagName = elementSafeTagName(element);\n  if (["INPUT", "TEXTAREA", "SELECT"].includes(tagName))\n    return element.hasAttribute("readonly");\n  if (kAriaReadonlyRoles.includes(getAriaRole(element) || ""))\n    return element.getAttribute("aria-readonly") === "true";\n  if (element.isContentEditable)\n    return false;\n  return "error";\n}\nvar kAriaPressedRoles = ["button"];\nfunction getAriaPressed(element) {\n  if (kAriaPressedRoles.includes(getAriaRole(element) || "")) {\n    const pressed = element.getAttribute("aria-pressed");\n    if (pressed === "true")\n      return true;\n    if (pressed === "mixed")\n      return "mixed";\n  }\n  return false;\n}\nvar kAriaExpandedRoles = ["application", "button", "checkbox", "combobox", "gridcell", "link", "listbox", "menuitem", "row", "rowheader", "tab", "treeitem", "columnheader", "menuitemcheckbox", "menuitemradio", "rowheader", "switch"];\nfunction getAriaExpanded(element) {\n  if (elementSafeTagName(element) === "DETAILS")\n    return element.open;\n  if (kAriaExpandedRoles.includes(getAriaRole(element) || "")) {\n    const expanded = element.getAttribute("aria-expanded");\n    if (expanded === null)\n      return void 0;\n    if (expanded === "true")\n      return true;\n    return false;\n  }\n  return void 0;\n}\nvar kAriaLevelRoles = ["heading", "listitem", "row", "treeitem"];\nfunction getAriaLevel(element) {\n  const native = { "H1": 1, "H2": 2, "H3": 3, "H4": 4, "H5": 5, "H6": 6 }[elementSafeTagName(element)];\n  if (native)\n    return native;\n  if (kAriaLevelRoles.includes(getAriaRole(element) || "")) {\n    const attr = element.getAttribute("aria-level");\n    const value = attr === null ? Number.NaN : Number(attr);\n    if (Number.isInteger(value) && value >= 1)\n      return value;\n  }\n  return 0;\n}\nvar kAriaDisabledRoles = ["application", "button", "composite", "gridcell", "group", "input", "link", "menuitem", "scrollbar", "separator", "tab", "checkbox", "columnheader", "combobox", "grid", "listbox", "menu", "menubar", "menuitemcheckbox", "menuitemradio", "option", "radio", "radiogroup", "row", "rowheader", "searchbox", "select", "slider", "spinbutton", "switch", "tablist", "textbox", "toolbar", "tree", "treegrid", "treeitem"];\nfunction getAriaDisabled(element) {\n  return isNativelyDisabled(element) || hasExplicitAriaDisabled(element);\n}\nfunction isNativelyDisabled(element) {\n  const isNativeFormControl = ["BUTTON", "INPUT", "SELECT", "TEXTAREA", "OPTION", "OPTGROUP"].includes(element.tagName);\n  return isNativeFormControl && (element.hasAttribute("disabled") || belongsToDisabledFieldSet(element));\n}\nfunction belongsToDisabledFieldSet(element) {\n  const fieldSetElement = element == null ? void 0 : element.closest("FIELDSET[DISABLED]");\n  if (!fieldSetElement)\n    return false;\n  const legendElement = fieldSetElement.querySelector(":scope > LEGEND");\n  return !legendElement || !legendElement.contains(element);\n}\nfunction hasExplicitAriaDisabled(element, isAncestor = false) {\n  if (!element)\n    return false;\n  if (isAncestor || kAriaDisabledRoles.includes(getAriaRole(element) || "")) {\n    const attribute = (element.getAttribute("aria-disabled") || "").toLowerCase();\n    if (attribute === "true")\n      return true;\n    if (attribute === "false")\n      return false;\n    return hasExplicitAriaDisabled(parentElementOrShadowHost(element), true);\n  }\n  return false;\n}\nfunction getAccessibleNameFromAssociatedLabels(labels, options) {\n  return [...labels].map((label) => getTextAlternativeInternal(label, {\n    ...options,\n    embeddedInLabel: { element: label, hidden: isElementHiddenForAria(label) },\n    embeddedInNativeTextAlternative: void 0,\n    embeddedInLabelledBy: void 0,\n    embeddedInDescribedBy: void 0,\n    embeddedInTargetElement: void 0\n  })).filter((accessibleName) => !!accessibleName).join(" ");\n}\nvar cacheAccessibleName;\nvar cacheAccessibleNameHidden;\nvar cacheAccessibleDescription;\nvar cacheAccessibleDescriptionHidden;\nvar cacheAccessibleErrorMessage;\nvar cacheIsHidden;\nvar cachePseudoContentBefore;\nvar cachePseudoContentAfter;\nvar cachesCounter = 0;\nfunction beginAriaCaches() {\n  ++cachesCounter;\n  cacheAccessibleName != null ? cacheAccessibleName : cacheAccessibleName = new Map();\n  cacheAccessibleNameHidden != null ? cacheAccessibleNameHidden : cacheAccessibleNameHidden = new Map();\n  cacheAccessibleDescription != null ? cacheAccessibleDescription : cacheAccessibleDescription = new Map();\n  cacheAccessibleDescriptionHidden != null ? cacheAccessibleDescriptionHidden : cacheAccessibleDescriptionHidden = new Map();\n  cacheAccessibleErrorMessage != null ? cacheAccessibleErrorMessage : cacheAccessibleErrorMessage = new Map();\n  cacheIsHidden != null ? cacheIsHidden : cacheIsHidden = new Map();\n  cachePseudoContentBefore != null ? cachePseudoContentBefore : cachePseudoContentBefore = new Map();\n  cachePseudoContentAfter != null ? cachePseudoContentAfter : cachePseudoContentAfter = new Map();\n}\nfunction endAriaCaches() {\n  if (!--cachesCounter) {\n    cacheAccessibleName = void 0;\n    cacheAccessibleNameHidden = void 0;\n    cacheAccessibleDescription = void 0;\n    cacheAccessibleDescriptionHidden = void 0;\n    cacheAccessibleErrorMessage = void 0;\n    cacheIsHidden = void 0;\n    cachePseudoContentBefore = void 0;\n    cachePseudoContentAfter = void 0;\n  }\n}\nvar inputTypeToRole = {\n  "button": "button",\n  "checkbox": "checkbox",\n  "image": "button",\n  "number": "spinbutton",\n  "radio": "radio",\n  "range": "slider",\n  "reset": "button",\n  "submit": "button"\n};\n\n// packages/injected/src/yaml.ts\nfunction yamlEscapeKeyIfNeeded(str) {\n  if (!yamlStringNeedsQuotes(str))\n    return str;\n  return `\'` + str.replace(/\'/g, `\'\'`) + `\'`;\n}\nfunction yamlEscapeValueIfNeeded(str) {\n  if (!yamlStringNeedsQuotes(str))\n    return str;\n  return \'"\' + str.replace(/[\\\\"\\x00-\\x1f\\x7f-\\x9f]/g, (c) => {\n    switch (c) {\n      case "\\\\":\n        return "\\\\\\\\";\n      case \'"\':\n        return \'\\\\"\';\n      case "\\b":\n        return "\\\\b";\n      case "\\f":\n        return "\\\\f";\n      case "\\n":\n        return "\\\\n";\n      case "\\r":\n        return "\\\\r";\n      case "	":\n        return "\\\\t";\n      default:\n        const code = c.charCodeAt(0);\n        return "\\\\x" + code.toString(16).padStart(2, "0");\n    }\n  }) + \'"\';\n}\nfunction yamlStringNeedsQuotes(str) {\n  if (str.length === 0)\n    return true;\n  if (/^\\s|\\s$/.test(str))\n    return true;\n  if (/[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f-\\x9f]/.test(str))\n    return true;\n  if (/^-/.test(str))\n    return true;\n  if (/[\\n:](\\s|$)/.test(str))\n    return true;\n  if (/\\s#/.test(str))\n    return true;\n  if (/[\\n\\r]/.test(str))\n    return true;\n  if (/^[&*\\],?!>|@"\'#%]/.test(str))\n    return true;\n  if (/[{}`]/.test(str))\n    return true;\n  if (/^\\[/.test(str))\n    return true;\n  if (!isNaN(Number(str)) || ["y", "n", "yes", "no", "true", "false", "on", "off", "null"].includes(str.toLowerCase()))\n    return true;\n  return false;\n}\n\n// packages/injected/src/ariaSnapshot.ts\nfunction generateAriaTree(rootElement, generation, options) {\n  const visited = new Set();\n  const snapshot = {\n    root: { role: "fragment", name: "", children: [], element: rootElement, props: {}, box: box(rootElement) },\n    elements: new Map(),\n    generation,\n    ids: new Map()\n  };\n  const addElement = (element) => {\n    const id = snapshot.elements.size + 1;\n    snapshot.elements.set(id, element);\n    snapshot.ids.set(element, id);\n  };\n  addElement(rootElement);\n  const visit = (ariaNode, node) => {\n    if (visited.has(node))\n      return;\n    visited.add(node);\n    if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {\n      const text = node.nodeValue;\n      if (ariaNode.role !== "textbox" && text)\n        ariaNode.children.push(node.nodeValue || "");\n      return;\n    }\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return;\n    const element = node;\n    if (isElementHiddenForAria(element))\n      return;\n    const ariaChildren = [];\n    if (element.hasAttribute("aria-owns")) {\n      const ids = element.getAttribute("aria-owns").split(/\\s+/);\n      for (const id of ids) {\n        const ownedElement = rootElement.ownerDocument.getElementById(id);\n        if (ownedElement)\n          ariaChildren.push(ownedElement);\n      }\n    }\n    addElement(element);\n    const childAriaNode = toAriaNode(element, options);\n    if (childAriaNode)\n      ariaNode.children.push(childAriaNode);\n    processElement(childAriaNode || ariaNode, element, ariaChildren);\n  };\n  function processElement(ariaNode, element, ariaChildren = []) {\n    var _a;\n    const display = ((_a = getElementComputedStyle(element)) == null ? void 0 : _a.display) || "inline";\n    const treatAsBlock = display !== "inline" || element.nodeName === "BR" ? " " : "";\n    if (treatAsBlock)\n      ariaNode.children.push(treatAsBlock);\n    ariaNode.children.push(getPseudoContent(element, "::before"));\n    const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];\n    if (assignedNodes.length) {\n      for (const child of assignedNodes)\n        visit(ariaNode, child);\n    } else {\n      for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (!child.assignedSlot)\n          visit(ariaNode, child);\n      }\n      if (element.shadowRoot) {\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n          visit(ariaNode, child);\n      }\n    }\n    for (const child of ariaChildren)\n      visit(ariaNode, child);\n    ariaNode.children.push(getPseudoContent(element, "::after"));\n    if (treatAsBlock)\n      ariaNode.children.push(treatAsBlock);\n    if (ariaNode.children.length === 1 && ariaNode.name === ariaNode.children[0])\n      ariaNode.children = [];\n    if (ariaNode.role === "link" && element.hasAttribute("href")) {\n      const href = element.getAttribute("href");\n      ariaNode.props["url"] = href;\n    }\n  }\n  beginAriaCaches();\n  try {\n    visit(snapshot.root, rootElement);\n  } finally {\n    endAriaCaches();\n  }\n  normalizeStringChildren(snapshot.root);\n  normalizeGenericRoles(snapshot.root);\n  return snapshot;\n}\nfunction toAriaNode(element, options) {\n  var _a;\n  if (element.nodeName === "IFRAME")\n    return { role: "iframe", name: "", children: [], props: {}, element, box: box(element) };\n  const defaultRole = (options == null ? void 0 : options.emitGeneric) ? "generic" : null;\n  const role = (_a = getAriaRole(element)) != null ? _a : defaultRole;\n  if (!role || role === "presentation" || role === "none")\n    return null;\n  const name = normalizeWhiteSpace(getElementAccessibleName(element, false) || "");\n  const result = { role, name, children: [], props: {}, element, box: box(element) };\n  if (kAriaCheckedRoles.includes(role))\n    result.checked = getAriaChecked(element);\n  if (kAriaDisabledRoles.includes(role))\n    result.disabled = getAriaDisabled(element);\n  if (kAriaExpandedRoles.includes(role))\n    result.expanded = getAriaExpanded(element);\n  if (kAriaLevelRoles.includes(role))\n    result.level = getAriaLevel(element);\n  if (kAriaPressedRoles.includes(role))\n    result.pressed = getAriaPressed(element);\n  if (kAriaSelectedRoles.includes(role))\n    result.selected = getAriaSelected(element);\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    if (element.type !== "checkbox" && element.type !== "radio" && (element.type !== "file" || getGlobalOptions().inputFileRoleTextbox))\n      result.children = [element.value];\n  }\n  return result;\n}\nfunction normalizeGenericRoles(rootA11yNode) {\n  const visit = (ariaNode) => {\n    const newChildren = [];\n    for (const child of ariaNode.children) {\n      if (typeof child === "string") {\n        newChildren.push(child);\n        continue;\n      }\n      const isEmptyGeneric = child.role === "generic" && child.children.length === 0;\n      const isSingleGenericChild = child.role === "generic" && child.children.length === 1;\n      if (isSingleGenericChild) {\n        const newChild = child.children[0];\n        newChildren.push(newChild);\n        if (typeof newChild !== "string")\n          visit(newChild);\n      } else if (!isEmptyGeneric) {\n        newChildren.push(child);\n        visit(child);\n      }\n    }\n    ariaNode.children = newChildren;\n  };\n  visit(rootA11yNode);\n}\nfunction normalizeStringChildren(rootA11yNode) {\n  const flushChildren = (buffer, normalizedChildren) => {\n    if (!buffer.length)\n      return;\n    const text = normalizeWhiteSpace(buffer.join(""));\n    if (text)\n      normalizedChildren.push(text);\n    buffer.length = 0;\n  };\n  const visit = (ariaNode) => {\n    const normalizedChildren = [];\n    const buffer = [];\n    for (const child of ariaNode.children || []) {\n      if (typeof child === "string") {\n        buffer.push(child);\n      } else {\n        flushChildren(buffer, normalizedChildren);\n        visit(child);\n        normalizedChildren.push(child);\n      }\n    }\n    flushChildren(buffer, normalizedChildren);\n    ariaNode.children = normalizedChildren.length ? normalizedChildren : [];\n    if (ariaNode.children.length === 1 && ariaNode.children[0] === ariaNode.name)\n      ariaNode.children = [];\n  };\n  visit(rootA11yNode);\n}\nfunction matchesText(text, template) {\n  if (!template)\n    return true;\n  if (!text)\n    return false;\n  if (typeof template === "string")\n    return text === template;\n  return !!text.match(new RegExp(template.pattern));\n}\nfunction matchesTextNode(text, template) {\n  return matchesText(text, template.text);\n}\nfunction matchesName(text, template) {\n  return matchesText(text, template.name);\n}\nfunction matchesAriaTree(rootElement, template) {\n  const snapshot = generateAriaTree(rootElement, 0);\n  const matches = matchesNodeDeep(snapshot.root, template, false, false);\n  return {\n    matches,\n    received: {\n      raw: renderAriaTree(snapshot, { mode: "raw" }),\n      regex: renderAriaTree(snapshot, { mode: "regex" })\n    }\n  };\n}\nfunction getAllByAria(rootElement, template) {\n  const root = generateAriaTree(rootElement, 0).root;\n  const matches = matchesNodeDeep(root, template, true, false);\n  return matches.map((n) => n.element);\n}\nfunction matchesNode(node, template, isDeepEqual) {\n  var _a;\n  if (typeof node === "string" && template.kind === "text")\n    return matchesTextNode(node, template);\n  if (node === null || typeof node !== "object" || template.kind !== "role")\n    return false;\n  if (template.role !== "fragment" && template.role !== node.role)\n    return false;\n  if (template.checked !== void 0 && template.checked !== node.checked)\n    return false;\n  if (template.disabled !== void 0 && template.disabled !== node.disabled)\n    return false;\n  if (template.expanded !== void 0 && template.expanded !== node.expanded)\n    return false;\n  if (template.level !== void 0 && template.level !== node.level)\n    return false;\n  if (template.pressed !== void 0 && template.pressed !== node.pressed)\n    return false;\n  if (template.selected !== void 0 && template.selected !== node.selected)\n    return false;\n  if (!matchesName(node.name, template))\n    return false;\n  if (!matchesText(node.props.url, (_a = template.props) == null ? void 0 : _a.url))\n    return false;\n  if (template.containerMode === "contain")\n    return containsList(node.children || [], template.children || []);\n  if (template.containerMode === "equal")\n    return listEqual(node.children || [], template.children || [], false);\n  if (template.containerMode === "deep-equal" || isDeepEqual)\n    return listEqual(node.children || [], template.children || [], true);\n  return containsList(node.children || [], template.children || []);\n}\nfunction listEqual(children, template, isDeepEqual) {\n  if (template.length !== children.length)\n    return false;\n  for (let i = 0; i < template.length; ++i) {\n    if (!matchesNode(children[i], template[i], isDeepEqual))\n      return false;\n  }\n  return true;\n}\nfunction containsList(children, template) {\n  if (template.length > children.length)\n    return false;\n  const cc = children.slice();\n  const tt = template.slice();\n  for (const t of tt) {\n    let c = cc.shift();\n    while (c) {\n      if (matchesNode(c, t, false))\n        break;\n      c = cc.shift();\n    }\n    if (!c)\n      return false;\n  }\n  return true;\n}\nfunction matchesNodeDeep(root, template, collectAll, isDeepEqual) {\n  const results = [];\n  const visit = (node, parent) => {\n    if (matchesNode(node, template, isDeepEqual)) {\n      const result = typeof node === "string" ? parent : node;\n      if (result)\n        results.push(result);\n      return !collectAll;\n    }\n    if (typeof node === "string")\n      return false;\n    for (const child of node.children || []) {\n      if (visit(child, node))\n        return true;\n    }\n    return false;\n  };\n  visit(root, null);\n  return results;\n}\nfunction renderAriaTree(ariaSnapshot, options) {\n  const lines = [];\n  const includeText = (options == null ? void 0 : options.mode) === "regex" ? textContributesInfo : () => true;\n  const renderString = (options == null ? void 0 : options.mode) === "regex" ? convertToBestGuessRegex : (str) => str;\n  const visit = (ariaNode2, parentAriaNode, indent) => {\n    if (typeof ariaNode2 === "string") {\n      if (parentAriaNode && !includeText(parentAriaNode, ariaNode2))\n        return;\n      const text = yamlEscapeValueIfNeeded(renderString(ariaNode2));\n      if (text)\n        lines.push(indent + "- text: " + text);\n      return;\n    }\n    let key = ariaNode2.role;\n    if (ariaNode2.name && ariaNode2.name.length <= 900) {\n      const name = renderString(ariaNode2.name);\n      if (name) {\n        const stringifiedName = name.startsWith("/") && name.endsWith("/") ? name : JSON.stringify(name);\n        key += " " + stringifiedName;\n      }\n    }\n    if (ariaNode2.checked === "mixed")\n      key += ` [checked=mixed]`;\n    if (ariaNode2.checked === true)\n      key += ` [checked]`;\n    if (ariaNode2.disabled)\n      key += ` [disabled]`;\n    if (ariaNode2.expanded)\n      key += ` [expanded]`;\n    if (ariaNode2.level)\n      key += ` [level=${ariaNode2.level}]`;\n    if (ariaNode2.pressed === "mixed")\n      key += ` [pressed=mixed]`;\n    if (ariaNode2.pressed === true)\n      key += ` [pressed]`;\n    if (ariaNode2.selected === true)\n      key += ` [selected]`;\n    if ((options == null ? void 0 : options.ref) && ariaNode2.box.visible) {\n      const id = ariaSnapshot.ids.get(ariaNode2.element);\n      if (id)\n        key += ` [ref=s${ariaSnapshot.generation}e${id}]`;\n    }\n    const escapedKey = indent + "- " + yamlEscapeKeyIfNeeded(key);\n    const hasProps = !!Object.keys(ariaNode2.props).length;\n    if (!ariaNode2.children.length && !hasProps) {\n      lines.push(escapedKey);\n    } else if (ariaNode2.children.length === 1 && typeof ariaNode2.children[0] === "string" && !hasProps) {\n      const text = includeText(ariaNode2, ariaNode2.children[0]) ? renderString(ariaNode2.children[0]) : null;\n      if (text)\n        lines.push(escapedKey + ": " + yamlEscapeValueIfNeeded(text));\n      else\n        lines.push(escapedKey);\n    } else {\n      lines.push(escapedKey + ":");\n      for (const [name, value] of Object.entries(ariaNode2.props))\n        lines.push(indent + "  - /" + name + ": " + yamlEscapeValueIfNeeded(value));\n      for (const child of ariaNode2.children || [])\n        visit(child, ariaNode2, indent + "  ");\n    }\n  };\n  const ariaNode = ariaSnapshot.root;\n  if (ariaNode.role === "fragment") {\n    for (const child of ariaNode.children || [])\n      visit(child, ariaNode, "");\n  } else {\n    visit(ariaNode, null, "");\n  }\n  return lines.join("\\n");\n}\nfunction convertToBestGuessRegex(text) {\n  const dynamicContent = [\n    // 2mb\n    { regex: /\\b[\\d,.]+[bkmBKM]+\\b/, replacement: "[\\\\d,.]+[bkmBKM]+" },\n    // 2ms, 20s\n    { regex: /\\b\\d+[hmsp]+\\b/, replacement: "\\\\d+[hmsp]+" },\n    { regex: /\\b[\\d,.]+[hmsp]+\\b/, replacement: "[\\\\d,.]+[hmsp]+" },\n    // Do not replace single digits with regex by default.\n    // 2+ digits: [Issue 22, 22.3, 2.33, 2,333]\n    { regex: /\\b\\d+,\\d+\\b/, replacement: "\\\\d+,\\\\d+" },\n    { regex: /\\b\\d+\\.\\d{2,}\\b/, replacement: "\\\\d+\\\\.\\\\d+" },\n    { regex: /\\b\\d{2,}\\.\\d+\\b/, replacement: "\\\\d+\\\\.\\\\d+" },\n    { regex: /\\b\\d{2,}\\b/, replacement: "\\\\d+" }\n  ];\n  let pattern = "";\n  let lastIndex = 0;\n  const combinedRegex = new RegExp(dynamicContent.map((r) => "(" + r.regex.source + ")").join("|"), "g");\n  text.replace(combinedRegex, (match, ...args) => {\n    const offset = args[args.length - 2];\n    const groups = args.slice(0, -2);\n    pattern += escapeRegExp(text.slice(lastIndex, offset));\n    for (let i = 0; i < groups.length; i++) {\n      if (groups[i]) {\n        const { replacement } = dynamicContent[i];\n        pattern += replacement;\n        break;\n      }\n    }\n    lastIndex = offset + match.length;\n    return match;\n  });\n  if (!pattern)\n    return text;\n  pattern += escapeRegExp(text.slice(lastIndex));\n  return String(new RegExp(pattern));\n}\nfunction textContributesInfo(node, text) {\n  if (!text.length)\n    return false;\n  if (!node.name)\n    return true;\n  if (node.name.length > text.length)\n    return false;\n  const substr = text.length <= 200 && node.name.length <= 200 ? longestCommonSubstring(text, node.name) : "";\n  let filtered = text;\n  while (substr && filtered.includes(substr))\n    filtered = filtered.replace(substr, "");\n  return filtered.trim().length / text.length > 0.1;\n}\n\n// packages/injected/src/highlight.css?inline\nvar highlight_default = ":host{font-size:13px;font-family:system-ui,Ubuntu,Droid Sans,sans-serif;color:#333}svg{position:absolute;height:0}x-pw-tooltip{backdrop-filter:blur(5px);background-color:#fff;border-radius:6px;box-shadow:0 .5rem 1.2rem #0000004d;display:none;font-size:12.8px;font-weight:400;left:0;line-height:1.5;max-width:600px;position:absolute;top:0;padding:0;flex-direction:column;overflow:hidden}x-pw-tooltip-line{display:flex;max-width:600px;padding:6px;user-select:none;cursor:pointer}x-pw-tooltip-line.selectable:hover{background-color:#f2f2f2;overflow:hidden}x-pw-tooltip-footer{display:flex;max-width:600px;padding:6px;user-select:none;color:#777}x-pw-dialog{background-color:#fff;pointer-events:auto;border-radius:6px;box-shadow:0 .5rem 1.2rem #0000004d;display:flex;flex-direction:column;position:absolute;width:400px;height:150px;z-index:10;font-size:13px}x-pw-dialog-body{display:flex;flex-direction:column;flex:auto}x-pw-dialog-body label{margin:5px 8px;display:flex;flex-direction:row;align-items:center}x-pw-highlight{position:absolute;top:0;left:0;width:0;height:0}x-pw-action-point{position:absolute;width:20px;height:20px;background:red;border-radius:10px;margin:-10px 0 0 -10px;z-index:2}x-pw-separator{height:1px;margin:6px 9px;background:#949494e5}x-pw-tool-gripper{height:28px;width:24px;margin:2px 0;cursor:grab}x-pw-tool-gripper:active{cursor:grabbing}x-pw-tool-gripper>x-div{width:16px;height:16px;margin:6px 4px;clip-path:url(#icon-gripper);background-color:#555}x-pw-tools-list>label{display:flex;align-items:center;margin:0 10px;user-select:none}x-pw-tools-list{display:flex;width:100%;border-bottom:1px solid #dddddd}x-pw-tool-item{pointer-events:auto;height:28px;width:28px;border-radius:3px}x-pw-tool-item:not(.disabled){cursor:pointer}x-pw-tool-item:not(.disabled):hover{background-color:#dbdbdb}x-pw-tool-item.toggled{background-color:#8acae480}x-pw-tool-item.toggled:not(.disabled):hover{background-color:#8acae4c4}x-pw-tool-item>x-div{width:16px;height:16px;margin:6px;background-color:#3a3a3a}x-pw-tool-item.disabled>x-div{background-color:#61616180;cursor:default}x-pw-tool-item.record.toggled{background-color:transparent}x-pw-tool-item.record.toggled:not(.disabled):hover{background-color:#dbdbdb}x-pw-tool-item.record.toggled>x-div{background-color:#a1260d}x-pw-tool-item.record.disabled.toggled>x-div{opacity:.8}x-pw-tool-item.accept>x-div{background-color:#388a34}x-pw-tool-item.record>x-div{clip-path:url(#icon-circle-large-filled)}x-pw-tool-item.pick-locator>x-div{clip-path:url(#icon-inspect)}x-pw-tool-item.text>x-div{clip-path:url(#icon-whole-word)}x-pw-tool-item.visibility>x-div{clip-path:url(#icon-eye)}x-pw-tool-item.value>x-div{clip-path:url(#icon-symbol-constant)}x-pw-tool-item.snapshot>x-div{clip-path:url(#icon-gist)}x-pw-tool-item.accept>x-div{clip-path:url(#icon-check)}x-pw-tool-item.cancel>x-div{clip-path:url(#icon-close)}x-pw-tool-item.succeeded>x-div{clip-path:url(#icon-pass);background-color:#388a34!important}x-pw-overlay{position:absolute;top:0;max-width:min-content;z-index:2147483647;background:transparent;pointer-events:auto}x-pw-overlay x-pw-tools-list{background-color:#fffd;box-shadow:#0000001a 0 5px 5px;border-radius:3px;border-bottom:none}x-pw-overlay x-pw-tool-item{margin:2px}textarea.text-editor{font-family:system-ui,Ubuntu,Droid Sans,sans-serif;flex:auto;border:none;margin:6px 10px;color:#333;outline:1px solid transparent!important;resize:none;padding:0;font-size:13px}textarea.text-editor.does-not-match{outline:1px solid red!important}x-div{display:block}x-spacer{flex:auto}*{box-sizing:border-box}*[hidden]{display:none!important}x-locator-editor{flex:none;width:100%;height:60px;padding:4px;border-bottom:1px solid #dddddd;outline:1px solid transparent}x-locator-editor.does-not-match{outline:1px solid red}.CodeMirror{width:100%!important;height:100%!important}\\n";\n\n// packages/injected/src/highlight.ts\nvar Highlight = class {\n  constructor(injectedScript) {\n    this._renderedEntries = [];\n    this._language = "javascript";\n    this._injectedScript = injectedScript;\n    const document = injectedScript.document;\n    this._isUnderTest = injectedScript.isUnderTest;\n    this._glassPaneElement = document.createElement("x-pw-glass");\n    this._glassPaneElement.style.position = "fixed";\n    this._glassPaneElement.style.top = "0";\n    this._glassPaneElement.style.right = "0";\n    this._glassPaneElement.style.bottom = "0";\n    this._glassPaneElement.style.left = "0";\n    this._glassPaneElement.style.zIndex = "2147483646";\n    this._glassPaneElement.style.pointerEvents = "none";\n    this._glassPaneElement.style.display = "flex";\n    this._glassPaneElement.style.backgroundColor = "transparent";\n    for (const eventName of ["click", "auxclick", "dragstart", "input", "keydown", "keyup", "pointerdown", "pointerup", "mousedown", "mouseup", "mouseleave", "focus", "scroll"]) {\n      this._glassPaneElement.addEventListener(eventName, (e) => {\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n      });\n    }\n    this._actionPointElement = document.createElement("x-pw-action-point");\n    this._actionPointElement.setAttribute("hidden", "true");\n    this._glassPaneShadow = this._glassPaneElement.attachShadow({ mode: this._isUnderTest ? "open" : "closed" });\n    if (typeof this._glassPaneShadow.adoptedStyleSheets.push === "function") {\n      const sheet = new this._injectedScript.window.CSSStyleSheet();\n      sheet.replaceSync(highlight_default);\n      this._glassPaneShadow.adoptedStyleSheets.push(sheet);\n    } else {\n      const styleElement = this._injectedScript.document.createElement("style");\n      styleElement.textContent = highlight_default;\n      this._glassPaneShadow.appendChild(styleElement);\n    }\n    this._glassPaneShadow.appendChild(this._actionPointElement);\n  }\n  install() {\n    if (this._injectedScript.document.documentElement && !this._injectedScript.document.documentElement.contains(this._glassPaneElement))\n      this._injectedScript.document.documentElement.appendChild(this._glassPaneElement);\n  }\n  setLanguage(language) {\n    this._language = language;\n  }\n  runHighlightOnRaf(selector) {\n    if (this._rafRequest)\n      cancelAnimationFrame(this._rafRequest);\n    const elements = this._injectedScript.querySelectorAll(selector, this._injectedScript.document.documentElement);\n    const locator = asLocator(this._language, stringifySelector(selector));\n    const color = elements.length > 1 ? "#f6b26b7f" : "#6fa8dc7f";\n    this.updateHighlight(elements.map((element, index) => {\n      const suffix = elements.length > 1 ? ` [${index + 1} of ${elements.length}]` : "";\n      return { element, color, tooltipText: locator + suffix };\n    }));\n    this._rafRequest = requestAnimationFrame(() => this.runHighlightOnRaf(selector));\n  }\n  uninstall() {\n    if (this._rafRequest)\n      cancelAnimationFrame(this._rafRequest);\n    this._glassPaneElement.remove();\n  }\n  showActionPoint(x, y) {\n    this._actionPointElement.style.top = y + "px";\n    this._actionPointElement.style.left = x + "px";\n    this._actionPointElement.hidden = false;\n  }\n  hideActionPoint() {\n    this._actionPointElement.hidden = true;\n  }\n  clearHighlight() {\n    var _a, _b;\n    for (const entry of this._renderedEntries) {\n      (_a = entry.highlightElement) == null ? void 0 : _a.remove();\n      (_b = entry.tooltipElement) == null ? void 0 : _b.remove();\n    }\n    this._renderedEntries = [];\n  }\n  maskElements(elements, color) {\n    this.updateHighlight(elements.map((element) => ({ element, color })));\n  }\n  updateHighlight(entries) {\n    if (this._highlightIsUpToDate(entries))\n      return;\n    this.clearHighlight();\n    for (const entry of entries) {\n      const highlightElement = this._createHighlightElement();\n      this._glassPaneShadow.appendChild(highlightElement);\n      let tooltipElement;\n      if (entry.tooltipText) {\n        tooltipElement = this._injectedScript.document.createElement("x-pw-tooltip");\n        this._glassPaneShadow.appendChild(tooltipElement);\n        tooltipElement.style.top = "0";\n        tooltipElement.style.left = "0";\n        tooltipElement.style.display = "flex";\n        const lineElement = this._injectedScript.document.createElement("x-pw-tooltip-line");\n        lineElement.textContent = entry.tooltipText;\n        tooltipElement.appendChild(lineElement);\n      }\n      this._renderedEntries.push({ targetElement: entry.element, color: entry.color, tooltipElement, highlightElement });\n    }\n    for (const entry of this._renderedEntries) {\n      entry.box = entry.targetElement.getBoundingClientRect();\n      if (!entry.tooltipElement)\n        continue;\n      const { anchorLeft, anchorTop } = this.tooltipPosition(entry.box, entry.tooltipElement);\n      entry.tooltipTop = anchorTop;\n      entry.tooltipLeft = anchorLeft;\n    }\n    for (const entry of this._renderedEntries) {\n      if (entry.tooltipElement) {\n        entry.tooltipElement.style.top = entry.tooltipTop + "px";\n        entry.tooltipElement.style.left = entry.tooltipLeft + "px";\n      }\n      const box2 = entry.box;\n      entry.highlightElement.style.backgroundColor = entry.color;\n      entry.highlightElement.style.left = box2.x + "px";\n      entry.highlightElement.style.top = box2.y + "px";\n      entry.highlightElement.style.width = box2.width + "px";\n      entry.highlightElement.style.height = box2.height + "px";\n      entry.highlightElement.style.display = "block";\n      if (this._isUnderTest)\n        console.error("Highlight box for test: " + JSON.stringify({ x: box2.x, y: box2.y, width: box2.width, height: box2.height }));\n    }\n  }\n  firstBox() {\n    var _a;\n    return (_a = this._renderedEntries[0]) == null ? void 0 : _a.box;\n  }\n  tooltipPosition(box2, tooltipElement) {\n    const tooltipWidth = tooltipElement.offsetWidth;\n    const tooltipHeight = tooltipElement.offsetHeight;\n    const totalWidth = this._glassPaneElement.offsetWidth;\n    const totalHeight = this._glassPaneElement.offsetHeight;\n    let anchorLeft = box2.left;\n    if (anchorLeft + tooltipWidth > totalWidth - 5)\n      anchorLeft = totalWidth - tooltipWidth - 5;\n    let anchorTop = box2.bottom + 5;\n    if (anchorTop + tooltipHeight > totalHeight - 5) {\n      if (box2.top > tooltipHeight + 5) {\n        anchorTop = box2.top - tooltipHeight - 5;\n      } else {\n        anchorTop = totalHeight - 5 - tooltipHeight;\n      }\n    }\n    return { anchorLeft, anchorTop };\n  }\n  _highlightIsUpToDate(entries) {\n    if (entries.length !== this._renderedEntries.length)\n      return false;\n    for (let i = 0; i < this._renderedEntries.length; ++i) {\n      if (entries[i].element !== this._renderedEntries[i].targetElement)\n        return false;\n      if (entries[i].color !== this._renderedEntries[i].color)\n        return false;\n      const oldBox = this._renderedEntries[i].box;\n      if (!oldBox)\n        return false;\n      const box2 = entries[i].element.getBoundingClientRect();\n      if (box2.top !== oldBox.top || box2.right !== oldBox.right || box2.bottom !== oldBox.bottom || box2.left !== oldBox.left)\n        return false;\n    }\n    return true;\n  }\n  _createHighlightElement() {\n    return this._injectedScript.document.createElement("x-pw-highlight");\n  }\n  appendChild(element) {\n    this._glassPaneShadow.appendChild(element);\n  }\n};\n\n// packages/injected/src/layoutSelectorUtils.ts\nfunction boxRightOf(box1, box2, maxDistance) {\n  const distance = box1.left - box2.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxLeftOf(box1, box2, maxDistance) {\n  const distance = box2.left - box1.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxAbove(box1, box2, maxDistance) {\n  const distance = box2.top - box1.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxBelow(box1, box2, maxDistance) {\n  const distance = box1.top - box2.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxNear(box1, box2, maxDistance) {\n  const kThreshold = maxDistance === void 0 ? 50 : maxDistance;\n  let score = 0;\n  if (box1.left - box2.right >= 0)\n    score += box1.left - box2.right;\n  if (box2.left - box1.right >= 0)\n    score += box2.left - box1.right;\n  if (box2.top - box1.bottom >= 0)\n    score += box2.top - box1.bottom;\n  if (box1.top - box2.bottom >= 0)\n    score += box1.top - box2.bottom;\n  return score > kThreshold ? void 0 : score;\n}\nvar kLayoutSelectorNames = ["left-of", "right-of", "above", "below", "near"];\nfunction layoutSelectorScore(name, element, inner, maxDistance) {\n  const box2 = element.getBoundingClientRect();\n  const scorer = { "left-of": boxLeftOf, "right-of": boxRightOf, "above": boxAbove, "below": boxBelow, "near": boxNear }[name];\n  let bestScore;\n  for (const e of inner) {\n    if (e === element)\n      continue;\n    const score = scorer(box2, e.getBoundingClientRect(), maxDistance);\n    if (score === void 0)\n      continue;\n    if (bestScore === void 0 || score < bestScore)\n      bestScore = score;\n  }\n  return bestScore;\n}\n\n// packages/injected/src/selectorUtils.ts\nfunction matchesComponentAttribute(obj, attr) {\n  for (const token of attr.jsonPath) {\n    if (obj !== void 0 && obj !== null)\n      obj = obj[token];\n  }\n  return matchesAttributePart(obj, attr);\n}\nfunction matchesAttributePart(value, attr) {\n  const objValue = typeof value === "string" && !attr.caseSensitive ? value.toUpperCase() : value;\n  const attrValue = typeof attr.value === "string" && !attr.caseSensitive ? attr.value.toUpperCase() : attr.value;\n  if (attr.op === "<truthy>")\n    return !!objValue;\n  if (attr.op === "=") {\n    if (attrValue instanceof RegExp)\n      return typeof objValue === "string" && !!objValue.match(attrValue);\n    return objValue === attrValue;\n  }\n  if (typeof objValue !== "string" || typeof attrValue !== "string")\n    return false;\n  if (attr.op === "*=")\n    return objValue.includes(attrValue);\n  if (attr.op === "^=")\n    return objValue.startsWith(attrValue);\n  if (attr.op === "$=")\n    return objValue.endsWith(attrValue);\n  if (attr.op === "|=")\n    return objValue === attrValue || objValue.startsWith(attrValue + "-");\n  if (attr.op === "~=")\n    return objValue.split(" ").includes(attrValue);\n  return false;\n}\nfunction shouldSkipForTextMatching(element) {\n  const document = element.ownerDocument;\n  return element.nodeName === "SCRIPT" || element.nodeName === "NOSCRIPT" || element.nodeName === "STYLE" || document.head && document.head.contains(element);\n}\nfunction elementText(cache, root) {\n  let value = cache.get(root);\n  if (value === void 0) {\n    value = { full: "", normalized: "", immediate: [] };\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = "";\n      if (root instanceof HTMLInputElement && (root.type === "submit" || root.type === "button")) {\n        value = { full: root.value, normalized: normalizeWhiteSpace(root.value), immediate: [root.value] };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || "";\n            currentImmediate += child.nodeValue || "";\n          } else if (child.nodeType === Node.COMMENT_NODE) {\n            continue;\n          } else {\n            if (currentImmediate)\n              value.immediate.push(currentImmediate);\n            currentImmediate = "";\n            if (child.nodeType === Node.ELEMENT_NODE)\n              value.full += elementText(cache, child).full;\n          }\n        }\n        if (currentImmediate)\n          value.immediate.push(currentImmediate);\n        if (root.shadowRoot)\n          value.full += elementText(cache, root.shadowRoot).full;\n        if (value.full)\n          value.normalized = normalizeWhiteSpace(value.full);\n      }\n    }\n    cache.set(root, value);\n  }\n  return value;\n}\nfunction elementMatchesText(cache, element, matcher) {\n  if (shouldSkipForTextMatching(element))\n    return "none";\n  if (!matcher(elementText(cache, element)))\n    return "none";\n  for (let child = element.firstChild; child; child = child.nextSibling) {\n    if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(cache, child)))\n      return "selfAndChildren";\n  }\n  if (element.shadowRoot && matcher(elementText(cache, element.shadowRoot)))\n    return "selfAndChildren";\n  return "self";\n}\nfunction getElementLabels(textCache, element) {\n  const labels = getAriaLabelledByElements(element);\n  if (labels)\n    return labels.map((label) => elementText(textCache, label));\n  const ariaLabel = element.getAttribute("aria-label");\n  if (ariaLabel !== null && !!ariaLabel.trim())\n    return [{ full: ariaLabel, normalized: normalizeWhiteSpace(ariaLabel), immediate: [ariaLabel] }];\n  const isNonHiddenInput = element.nodeName === "INPUT" && element.type !== "hidden";\n  if (["BUTTON", "METER", "OUTPUT", "PROGRESS", "SELECT", "TEXTAREA"].includes(element.nodeName) || isNonHiddenInput) {\n    const labels2 = element.labels;\n    if (labels2)\n      return [...labels2].map((label) => elementText(textCache, label));\n  }\n  return [];\n}\n\n// packages/injected/src/reactSelectorEngine.ts\nfunction getFunctionComponentName(component) {\n  return component.displayName || component.name || "Anonymous";\n}\nfunction getComponentName(reactElement) {\n  if (reactElement.type) {\n    switch (typeof reactElement.type) {\n      case "function":\n        return getFunctionComponentName(reactElement.type);\n      case "string":\n        return reactElement.type;\n      case "object":\n        return reactElement.type.displayName || (reactElement.type.render ? getFunctionComponentName(reactElement.type.render) : "");\n    }\n  }\n  if (reactElement._currentElement) {\n    const elementType = reactElement._currentElement.type;\n    if (typeof elementType === "string")\n      return elementType;\n    if (typeof elementType === "function")\n      return elementType.displayName || elementType.name || "Anonymous";\n  }\n  return "";\n}\nfunction getComponentKey(reactElement) {\n  var _a, _b;\n  return (_b = reactElement.key) != null ? _b : (_a = reactElement._currentElement) == null ? void 0 : _a.key;\n}\nfunction getChildren(reactElement) {\n  if (reactElement.child) {\n    const children = [];\n    for (let child = reactElement.child; child; child = child.sibling)\n      children.push(child);\n    return children;\n  }\n  if (!reactElement._currentElement)\n    return [];\n  const isKnownElement = (reactElement2) => {\n    var _a;\n    const elementType = (_a = reactElement2._currentElement) == null ? void 0 : _a.type;\n    return typeof elementType === "function" || typeof elementType === "string";\n  };\n  if (reactElement._renderedComponent) {\n    const child = reactElement._renderedComponent;\n    return isKnownElement(child) ? [child] : [];\n  }\n  if (reactElement._renderedChildren)\n    return [...Object.values(reactElement._renderedChildren)].filter(isKnownElement);\n  return [];\n}\nfunction getProps(reactElement) {\n  var _a;\n  const props = (\n    // React 16+\n    reactElement.memoizedProps || // React 15\n    ((_a = reactElement._currentElement) == null ? void 0 : _a.props)\n  );\n  if (!props || typeof props === "string")\n    return props;\n  const result = { ...props };\n  delete result.children;\n  return result;\n}\nfunction buildComponentsTree(reactElement) {\n  var _a;\n  const treeNode = {\n    key: getComponentKey(reactElement),\n    name: getComponentName(reactElement),\n    children: getChildren(reactElement).map(buildComponentsTree),\n    rootElements: [],\n    props: getProps(reactElement)\n  };\n  const rootElement = (\n    // React 16+\n    // @see https://github.com/baruchvlz/resq/blob/5c15a5e04d3f7174087248f5a158c3d6dcc1ec72/src/utils.js#L29\n    reactElement.stateNode || // React 15\n    reactElement._hostNode || ((_a = reactElement._renderedComponent) == null ? void 0 : _a._hostNode)\n  );\n  if (rootElement instanceof Element) {\n    treeNode.rootElements.push(rootElement);\n  } else {\n    for (const child of treeNode.children)\n      treeNode.rootElements.push(...child.rootElements);\n  }\n  return treeNode;\n}\nfunction filterComponentsTree(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree(child, searchFn, result);\n  return result;\n}\nfunction findReactRoots(root, roots = []) {\n  const document = root.ownerDocument || root;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  do {\n    const node = walker.currentNode;\n    const reactNode = node;\n    const rootKey = Object.keys(reactNode).find((key) => key.startsWith("__reactContainer") && reactNode[key] !== null);\n    if (rootKey) {\n      roots.push(reactNode[rootKey].stateNode.current);\n    } else {\n      const legacyRootKey = "_reactRootContainer";\n      if (reactNode.hasOwnProperty(legacyRootKey) && reactNode[legacyRootKey] !== null) {\n        roots.push(reactNode[legacyRootKey]._internalRoot.current);\n      }\n    }\n    if (node instanceof Element && node.hasAttribute("data-reactroot")) {\n      for (const key of Object.keys(node)) {\n        if (key.startsWith("__reactInternalInstance") || key.startsWith("__reactFiber"))\n          roots.push(node[key]);\n      }\n    }\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findReactRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  return roots;\n}\nvar createReactEngine = () => ({\n  queryAll(scope, selector) {\n    const { name, attributes } = parseAttributeSelector(selector, false);\n    const reactRoots = findReactRoots(scope.ownerDocument || scope);\n    const trees = reactRoots.map((reactRoot) => buildComponentsTree(reactRoot));\n    const treeNodes = trees.map((tree) => filterComponentsTree(tree, (treeNode) => {\n      var _a;\n      const props = (_a = treeNode.props) != null ? _a : {};\n      if (treeNode.key !== void 0)\n        props.key = treeNode.key;\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((domNode) => !isInsideScope(scope, domNode)))\n        return false;\n      for (const attr of attributes) {\n        if (!matchesComponentAttribute(props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = new Set();\n    for (const treeNode of treeNodes) {\n      for (const domNode of treeNode.rootElements)\n        allRootElements.add(domNode);\n    }\n    return [...allRootElements];\n  }\n});\n\n// packages/injected/src/roleSelectorEngine.ts\nvar kSupportedAttributes = ["selected", "checked", "pressed", "expanded", "level", "disabled", "name", "include-hidden"];\nkSupportedAttributes.sort();\nfunction validateSupportedRole(attr, roles, role) {\n  if (!roles.includes(role))\n    throw new Error(`"${attr}" attribute is only supported for roles: ${roles.slice().sort().map((role2) => `"${role2}"`).join(", ")}`);\n}\nfunction validateSupportedValues(attr, values) {\n  if (attr.op !== "<truthy>" && !values.includes(attr.value))\n    throw new Error(`"${attr.name}" must be one of ${values.map((v) => JSON.stringify(v)).join(", ")}`);\n}\nfunction validateSupportedOp(attr, ops) {\n  if (!ops.includes(attr.op))\n    throw new Error(`"${attr.name}" does not support "${attr.op}" matcher`);\n}\nfunction validateAttributes(attrs, role) {\n  const options = { role };\n  for (const attr of attrs) {\n    switch (attr.name) {\n      case "checked": {\n        validateSupportedRole(attr.name, kAriaCheckedRoles, role);\n        validateSupportedValues(attr, [true, false, "mixed"]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.checked = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "pressed": {\n        validateSupportedRole(attr.name, kAriaPressedRoles, role);\n        validateSupportedValues(attr, [true, false, "mixed"]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.pressed = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "selected": {\n        validateSupportedRole(attr.name, kAriaSelectedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.selected = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "expanded": {\n        validateSupportedRole(attr.name, kAriaExpandedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.expanded = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "level": {\n        validateSupportedRole(attr.name, kAriaLevelRoles, role);\n        if (typeof attr.value === "string")\n          attr.value = +attr.value;\n        if (attr.op !== "=" || typeof attr.value !== "number" || Number.isNaN(attr.value))\n          throw new Error(`"level" attribute must be compared to a number`);\n        options.level = attr.value;\n        break;\n      }\n      case "disabled": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.disabled = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "name": {\n        if (attr.op === "<truthy>")\n          throw new Error(`"name" attribute must have a value`);\n        if (typeof attr.value !== "string" && !(attr.value instanceof RegExp))\n          throw new Error(`"name" attribute must be a string or a regular expression`);\n        options.name = attr.value;\n        options.nameOp = attr.op;\n        options.exact = attr.caseSensitive;\n        break;\n      }\n      case "include-hidden": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.includeHidden = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      default: {\n        throw new Error(`Unknown attribute "${attr.name}", must be one of ${kSupportedAttributes.map((a) => `"${a}"`).join(", ")}.`);\n      }\n    }\n  }\n  return options;\n}\nfunction queryRole(scope, options, internal) {\n  const result = [];\n  const match = (element) => {\n    if (getAriaRole(element) !== options.role)\n      return;\n    if (options.selected !== void 0 && getAriaSelected(element) !== options.selected)\n      return;\n    if (options.checked !== void 0 && getAriaChecked(element) !== options.checked)\n      return;\n    if (options.pressed !== void 0 && getAriaPressed(element) !== options.pressed)\n      return;\n    if (options.expanded !== void 0 && getAriaExpanded(element) !== options.expanded)\n      return;\n    if (options.level !== void 0 && getAriaLevel(element) !== options.level)\n      return;\n    if (options.disabled !== void 0 && getAriaDisabled(element) !== options.disabled)\n      return;\n    if (!options.includeHidden) {\n      const isHidden = isElementHiddenForAria(element);\n      if (isHidden)\n        return;\n    }\n    if (options.name !== void 0) {\n      const accessibleName = normalizeWhiteSpace(getElementAccessibleName(element, !!options.includeHidden));\n      if (typeof options.name === "string")\n        options.name = normalizeWhiteSpace(options.name);\n      if (internal && !options.exact && options.nameOp === "=")\n        options.nameOp = "*=";\n      if (!matchesAttributePart(accessibleName, { name: "", jsonPath: [], op: options.nameOp || "=", value: options.name, caseSensitive: !!options.exact }))\n        return;\n    }\n    result.push(element);\n  };\n  const query = (root) => {\n    const shadows = [];\n    if (root.shadowRoot)\n      shadows.push(root.shadowRoot);\n    for (const element of root.querySelectorAll("*")) {\n      match(element);\n      if (element.shadowRoot)\n        shadows.push(element.shadowRoot);\n    }\n    shadows.forEach(query);\n  };\n  query(scope);\n  return result;\n}\nfunction createRoleEngine(internal) {\n  return {\n    queryAll: (scope, selector) => {\n      const parsed = parseAttributeSelector(selector, true);\n      const role = parsed.name.toLowerCase();\n      if (!role)\n        throw new Error(`Role must not be empty`);\n      const options = validateAttributes(parsed.attributes, role);\n      beginAriaCaches();\n      try {\n        return queryRole(scope, options, internal);\n      } finally {\n        endAriaCaches();\n      }\n    }\n  };\n}\n\n// packages/injected/src/selectorEvaluator.ts\nvar SelectorEvaluatorImpl = class {\n  constructor() {\n    this._retainCacheCounter = 0;\n    this._cacheText = new Map();\n    this._cacheQueryCSS = new Map();\n    this._cacheMatches = new Map();\n    this._cacheQuery = new Map();\n    this._cacheMatchesSimple = new Map();\n    this._cacheMatchesParents = new Map();\n    this._cacheCallMatches = new Map();\n    this._cacheCallQuery = new Map();\n    this._cacheQuerySimple = new Map();\n    this._engines = new Map();\n    this._engines.set("not", notEngine);\n    this._engines.set("is", isEngine);\n    this._engines.set("where", isEngine);\n    this._engines.set("has", hasEngine);\n    this._engines.set("scope", scopeEngine);\n    this._engines.set("light", lightEngine);\n    this._engines.set("visible", visibleEngine);\n    this._engines.set("text", textEngine);\n    this._engines.set("text-is", textIsEngine);\n    this._engines.set("text-matches", textMatchesEngine);\n    this._engines.set("has-text", hasTextEngine);\n    this._engines.set("right-of", createLayoutEngine("right-of"));\n    this._engines.set("left-of", createLayoutEngine("left-of"));\n    this._engines.set("above", createLayoutEngine("above"));\n    this._engines.set("below", createLayoutEngine("below"));\n    this._engines.set("near", createLayoutEngine("near"));\n    this._engines.set("nth-match", nthMatchEngine);\n    const allNames = [...this._engines.keys()];\n    allNames.sort();\n    const parserNames = [...customCSSNames];\n    parserNames.sort();\n    if (allNames.join("|") !== parserNames.join("|"))\n      throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join("|")} vs ${parserNames.join("|")}`);\n  }\n  begin() {\n    ++this._retainCacheCounter;\n  }\n  end() {\n    --this._retainCacheCounter;\n    if (!this._retainCacheCounter) {\n      this._cacheQueryCSS.clear();\n      this._cacheMatches.clear();\n      this._cacheQuery.clear();\n      this._cacheMatchesSimple.clear();\n      this._cacheMatchesParents.clear();\n      this._cacheCallMatches.clear();\n      this._cacheCallQuery.clear();\n      this._cacheQuerySimple.clear();\n      this._cacheText.clear();\n    }\n  }\n  _cached(cache, main, rest, cb) {\n    if (!cache.has(main))\n      cache.set(main, []);\n    const entries = cache.get(main);\n    const entry = entries.find((e) => rest.every((value, index) => e.rest[index] === value));\n    if (entry)\n      return entry.result;\n    const result = cb();\n    entries.push({ rest, result });\n    return result;\n  }\n  _checkSelector(s) {\n    const wellFormed = typeof s === "object" && s && (Array.isArray(s) || "simples" in s && s.simples.length);\n    if (!wellFormed)\n      throw new Error(`Malformed selector "${s}"`);\n    return s;\n  }\n  matches(element, s, context) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow, context.originalScope], () => {\n        if (Array.isArray(selector))\n          return this._matchesEngine(isEngine, element, selector, context);\n        if (this._hasScopeClause(selector))\n          context = this._expandContextForScopeMatching(context);\n        if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\n          return false;\n        return this._matchesParents(element, selector, selector.simples.length - 2, context);\n      });\n    } finally {\n      this.end();\n    }\n  }\n  query(context, s) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow, context.originalScope], () => {\n        if (Array.isArray(selector))\n          return this._queryEngine(isEngine, context, selector);\n        if (this._hasScopeClause(selector))\n          context = this._expandContextForScopeMatching(context);\n        const previousScoreMap = this._scoreMap;\n        this._scoreMap = new Map();\n        let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n        elements = elements.filter((element) => this._matchesParents(element, selector, selector.simples.length - 2, context));\n        if (this._scoreMap.size) {\n          elements.sort((a, b) => {\n            const aScore = this._scoreMap.get(a);\n            const bScore = this._scoreMap.get(b);\n            if (aScore === bScore)\n              return 0;\n            if (aScore === void 0)\n              return 1;\n            if (bScore === void 0)\n              return -1;\n            return aScore - bScore;\n          });\n        }\n        this._scoreMap = previousScoreMap;\n        return elements;\n      });\n    } finally {\n      this.end();\n    }\n  }\n  _markScore(element, score) {\n    if (this._scoreMap)\n      this._scoreMap.set(element, score);\n  }\n  _hasScopeClause(selector) {\n    return selector.simples.some((simple) => simple.selector.functions.some((f) => f.name === "scope"));\n  }\n  _expandContextForScopeMatching(context) {\n    if (context.scope.nodeType !== 1)\n      return context;\n    const scope = parentElementOrShadowHost(context.scope);\n    if (!scope)\n      return context;\n    return { ...context, scope, originalScope: context.originalScope || context.scope };\n  }\n  _matchesSimple(element, simple, context) {\n    return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow, context.originalScope], () => {\n      if (element === context.scope)\n        return false;\n      if (simple.css && !this._matchesCSS(element, simple.css))\n        return false;\n      for (const func of simple.functions) {\n        if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\n          return false;\n      }\n      return true;\n    });\n  }\n  _querySimple(context, simple) {\n    if (!simple.functions.length)\n      return this._queryCSS(context, simple.css || "*");\n    return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow, context.originalScope], () => {\n      let css = simple.css;\n      const funcs = simple.functions;\n      if (css === "*" && funcs.length)\n        css = void 0;\n      let elements;\n      let firstIndex = -1;\n      if (css !== void 0) {\n        elements = this._queryCSS(context, css);\n      } else {\n        firstIndex = funcs.findIndex((func) => this._getEngine(func.name).query !== void 0);\n        if (firstIndex === -1)\n          firstIndex = 0;\n        elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches !== void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches === void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      return elements;\n    });\n  }\n  _matchesParents(element, complex, index, context) {\n    if (index < 0)\n      return true;\n    return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow, context.originalScope], () => {\n      const { selector: simple, combinator } = complex.simples[index];\n      if (combinator === ">") {\n        const parent = parentElementOrShadowHostInContext(element, context);\n        if (!parent || !this._matchesSimple(parent, simple, context))\n          return false;\n        return this._matchesParents(parent, complex, index - 1, context);\n      }\n      if (combinator === "+") {\n        const previousSibling = previousSiblingInContext(element, context);\n        if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\n          return false;\n        return this._matchesParents(previousSibling, complex, index - 1, context);\n      }\n      if (combinator === "") {\n        let parent = parentElementOrShadowHostInContext(element, context);\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      if (combinator === "~") {\n        let previousSibling = previousSiblingInContext(element, context);\n        while (previousSibling) {\n          if (this._matchesSimple(previousSibling, simple, context)) {\n            if (this._matchesParents(previousSibling, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "~")\n              break;\n          }\n          previousSibling = previousSiblingInContext(previousSibling, context);\n        }\n        return false;\n      }\n      if (combinator === ">=") {\n        let parent = element;\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      throw new Error(`Unsupported combinator "${combinator}"`);\n    });\n  }\n  _matchesEngine(engine, element, args, context) {\n    if (engine.matches)\n      return this._callMatches(engine, element, args, context);\n    if (engine.query)\n      return this._callQuery(engine, args, context).includes(element);\n    throw new Error(`Selector engine should implement "matches" or "query"`);\n  }\n  _queryEngine(engine, context, args) {\n    if (engine.query)\n      return this._callQuery(engine, args, context);\n    if (engine.matches)\n      return this._queryCSS(context, "*").filter((element) => this._callMatches(engine, element, args, context));\n    throw new Error(`Selector engine should implement "matches" or "query"`);\n  }\n  _callMatches(engine, element, args, context) {\n    return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, context.originalScope, ...args], () => {\n      return engine.matches(element, args, context, this);\n    });\n  }\n  _callQuery(engine, args, context) {\n    return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, context.originalScope, ...args], () => {\n      return engine.query(context, args, this);\n    });\n  }\n  _matchesCSS(element, css) {\n    return element.matches(css);\n  }\n  _queryCSS(context, css) {\n    return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow, context.originalScope], () => {\n      let result = [];\n      function query(root) {\n        result = result.concat([...root.querySelectorAll(css)]);\n        if (!context.pierceShadow)\n          return;\n        if (root.shadowRoot)\n          query(root.shadowRoot);\n        for (const element of root.querySelectorAll("*")) {\n          if (element.shadowRoot)\n            query(element.shadowRoot);\n        }\n      }\n      query(context.scope);\n      return result;\n    });\n  }\n  _getEngine(name) {\n    const engine = this._engines.get(name);\n    if (!engine)\n      throw new Error(`Unknown selector engine "${name}"`);\n    return engine;\n  }\n};\nvar isEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"is" engine expects non-empty selector list`);\n    return args.some((selector) => evaluator.matches(element, selector, context));\n  },\n  query(context, args, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"is" engine expects non-empty selector list`);\n    let elements = [];\n    for (const arg of args)\n      elements = elements.concat(evaluator.query(context, arg));\n    return args.length === 1 ? elements : sortInDOMOrder(elements);\n  }\n};\nvar hasEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"has" engine expects non-empty selector list`);\n    return evaluator.query({ ...context, scope: element }, args).length > 0;\n  }\n  // TODO: we can implement efficient "query" by matching "args" and returning\n  // all parents/descendants, just have to be careful with the ":scope" matching.\n};\nvar scopeEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`"scope" engine expects no arguments`);\n    const actualScope = context.originalScope || context.scope;\n    if (actualScope.nodeType === 9)\n      return element === actualScope.documentElement;\n    return element === actualScope;\n  },\n  query(context, args, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`"scope" engine expects no arguments`);\n    const actualScope = context.originalScope || context.scope;\n    if (actualScope.nodeType === 9) {\n      const root = actualScope.documentElement;\n      return root ? [root] : [];\n    }\n    if (actualScope.nodeType === 1)\n      return [actualScope];\n    return [];\n  }\n};\nvar notEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"not" engine expects non-empty selector list`);\n    return !evaluator.matches(element, args, context);\n  }\n};\nvar lightEngine = {\n  query(context, args, evaluator) {\n    return evaluator.query({ ...context, pierceShadow: false }, args);\n  },\n  matches(element, args, context, evaluator) {\n    return evaluator.matches(element, args, { ...context, pierceShadow: false });\n  }\n};\nvar visibleEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length)\n      throw new Error(`"visible" engine expects no arguments`);\n    return isElementVisible(element);\n  }\n};\nvar textEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"text" engine expects a single string`);\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\n    const matcher = (elementText2) => elementText2.normalized.toLowerCase().includes(text);\n    return elementMatchesText(evaluator._cacheText, element, matcher) === "self";\n  }\n};\nvar textIsEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"text-is" engine expects a single string`);\n    const text = normalizeWhiteSpace(args[0]);\n    const matcher = (elementText2) => {\n      if (!text && !elementText2.immediate.length)\n        return true;\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === text);\n    };\n    return elementMatchesText(evaluator._cacheText, element, matcher) !== "none";\n  }\n};\nvar textMatchesEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0 || typeof args[0] !== "string" || args.length > 2 || args.length === 2 && typeof args[1] !== "string")\n      throw new Error(`"text-matches" engine expects a regexp body and optional regexp flags`);\n    const re = new RegExp(args[0], args.length === 2 ? args[1] : void 0);\n    const matcher = (elementText2) => re.test(elementText2.full);\n    return elementMatchesText(evaluator._cacheText, element, matcher) === "self";\n  }\n};\nvar hasTextEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"has-text" engine expects a single string`);\n    if (shouldSkipForTextMatching(element))\n      return false;\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\n    const matcher = (elementText2) => elementText2.normalized.toLowerCase().includes(text);\n    return matcher(elementText(evaluator._cacheText, element));\n  }\n};\nfunction createLayoutEngine(name) {\n  return {\n    matches(element, args, context, evaluator) {\n      const maxDistance = args.length && typeof args[args.length - 1] === "number" ? args[args.length - 1] : void 0;\n      const queryArgs = maxDistance === void 0 ? args : args.slice(0, args.length - 1);\n      if (args.length < 1 + (maxDistance === void 0 ? 0 : 1))\n        throw new Error(`"${name}" engine expects a selector list and optional maximum distance in pixels`);\n      const inner = evaluator.query(context, queryArgs);\n      const score = layoutSelectorScore(name, element, inner, maxDistance);\n      if (score === void 0)\n        return false;\n      evaluator._markScore(element, score);\n      return true;\n    }\n  };\n}\nvar nthMatchEngine = {\n  query(context, args, evaluator) {\n    let index = args[args.length - 1];\n    if (args.length < 2)\n      throw new Error(`"nth-match" engine expects non-empty selector list and an index argument`);\n    if (typeof index !== "number" || index < 1)\n      throw new Error(`"nth-match" engine expects a one-based index as the last argument`);\n    const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n    index--;\n    return index < elements.length ? [elements[index]] : [];\n  }\n};\nfunction parentElementOrShadowHostInContext(element, context) {\n  if (element === context.scope)\n    return;\n  if (!context.pierceShadow)\n    return element.parentElement || void 0;\n  return parentElementOrShadowHost(element);\n}\nfunction previousSiblingInContext(element, context) {\n  if (element === context.scope)\n    return;\n  return element.previousElementSibling || void 0;\n}\nfunction sortInDOMOrder(elements) {\n  const elementToEntry = new Map();\n  const roots = [];\n  const result = [];\n  function append(element) {\n    let entry = elementToEntry.get(element);\n    if (entry)\n      return entry;\n    const parent = parentElementOrShadowHost(element);\n    if (parent) {\n      const parentEntry = append(parent);\n      parentEntry.children.push(element);\n    } else {\n      roots.push(element);\n    }\n    entry = { children: [], taken: false };\n    elementToEntry.set(element, entry);\n    return entry;\n  }\n  for (const e of elements)\n    append(e).taken = true;\n  function visit(element) {\n    const entry = elementToEntry.get(element);\n    if (entry.taken)\n      result.push(element);\n    if (entry.children.length > 1) {\n      const set = new Set(entry.children);\n      entry.children = [];\n      let child = element.firstElementChild;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n      child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n    }\n    entry.children.forEach(visit);\n  }\n  roots.forEach(visit);\n  return result;\n}\n\n// packages/injected/src/selectorGenerator.ts\nvar kTextScoreRange = 10;\nvar kExactPenalty = kTextScoreRange / 2;\nvar kTestIdScore = 1;\nvar kOtherTestIdScore = 2;\nvar kIframeByAttributeScore = 10;\nvar kBeginPenalizedScore = 50;\nvar kRoleWithNameScore = 100;\nvar kPlaceholderScore = 120;\nvar kLabelScore = 140;\nvar kAltTextScore = 160;\nvar kTextScore = 180;\nvar kTitleScore = 200;\nvar kTextScoreRegex = 250;\nvar kPlaceholderScoreExact = kPlaceholderScore + kExactPenalty;\nvar kLabelScoreExact = kLabelScore + kExactPenalty;\nvar kRoleWithNameScoreExact = kRoleWithNameScore + kExactPenalty;\nvar kAltTextScoreExact = kAltTextScore + kExactPenalty;\nvar kTextScoreExact = kTextScore + kExactPenalty;\nvar kTitleScoreExact = kTitleScore + kExactPenalty;\nvar kEndPenalizedScore = 300;\nvar kCSSIdScore = 500;\nvar kRoleWithoutNameScore = 510;\nvar kCSSInputTypeNameScore = 520;\nvar kCSSTagNameScore = 530;\nvar kNthScore = 1e4;\nvar kCSSFallbackScore = 1e7;\nvar kScoreThresholdForTextExpect = 1e3;\nfunction generateSelector(injectedScript, targetElement, options) {\n  var _a;\n  injectedScript._evaluator.begin();\n  const cache = { allowText: new Map(), disallowText: new Map() };\n  beginAriaCaches();\n  try {\n    let selectors = [];\n    if (options.forTextExpect) {\n      let targetTokens = cssFallback(injectedScript, targetElement.ownerDocument.documentElement, options);\n      for (let element = targetElement; element; element = parentElementOrShadowHost(element)) {\n        const tokens = generateSelectorFor(cache, injectedScript, element, { ...options, noText: true });\n        if (!tokens)\n          continue;\n        const score = combineScores(tokens);\n        if (score <= kScoreThresholdForTextExpect) {\n          targetTokens = tokens;\n          break;\n        }\n      }\n      selectors = [joinTokens(targetTokens)];\n    } else {\n      if (!targetElement.matches("input,textarea,select") && !targetElement.isContentEditable) {\n        const interactiveParent = closestCrossShadow(targetElement, "button,select,input,[role=button],[role=checkbox],[role=radio],a,[role=link]", options.root);\n        if (interactiveParent && isElementVisible(interactiveParent))\n          targetElement = interactiveParent;\n      }\n      if (options.multiple) {\n        const withText = generateSelectorFor(cache, injectedScript, targetElement, options);\n        const withoutText = generateSelectorFor(cache, injectedScript, targetElement, { ...options, noText: true });\n        let tokens = [withText, withoutText];\n        cache.allowText.clear();\n        cache.disallowText.clear();\n        if (withText && hasCSSIdToken(withText))\n          tokens.push(generateSelectorFor(cache, injectedScript, targetElement, { ...options, noCSSId: true }));\n        if (withoutText && hasCSSIdToken(withoutText))\n          tokens.push(generateSelectorFor(cache, injectedScript, targetElement, { ...options, noText: true, noCSSId: true }));\n        tokens = tokens.filter(Boolean);\n        if (!tokens.length) {\n          const css = cssFallback(injectedScript, targetElement, options);\n          tokens.push(css);\n          if (hasCSSIdToken(css))\n            tokens.push(cssFallback(injectedScript, targetElement, { ...options, noCSSId: true }));\n        }\n        selectors = [...new Set(tokens.map((t) => joinTokens(t)))];\n      } else {\n        const targetTokens = generateSelectorFor(cache, injectedScript, targetElement, options) || cssFallback(injectedScript, targetElement, options);\n        selectors = [joinTokens(targetTokens)];\n      }\n    }\n    const selector = selectors[0];\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      selectors,\n      elements: injectedScript.querySelectorAll(parsedSelector, (_a = options.root) != null ? _a : targetElement.ownerDocument)\n    };\n  } finally {\n    endAriaCaches();\n    injectedScript._evaluator.end();\n  }\n}\nfunction filterRegexTokens(textCandidates) {\n  return textCandidates.filter((c) => c[0].selector[0] !== "/");\n}\nfunction generateSelectorFor(cache, injectedScript, targetElement, options) {\n  if (options.root && !isInsideScope(options.root, targetElement))\n    throw new Error(`Target element must belong to the root\'s subtree`);\n  if (targetElement === options.root)\n    return [{ engine: "css", selector: ":scope", score: 1 }];\n  if (targetElement.ownerDocument.documentElement === targetElement)\n    return [{ engine: "css", selector: "html", score: 1 }];\n  const calculate = (element, allowText) => {\n    var _a;\n    const allowNthMatch = element === targetElement;\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement) : [];\n    if (element !== targetElement) {\n      textCandidates = filterRegexTokens(textCandidates);\n    }\n    const noTextCandidates = buildNoTextCandidates(injectedScript, element, options).filter((token) => !options.omitInternalEngines || !token.engine.startsWith("internal:")).map((token) => [token]);\n    let result = chooseFirstSelector(injectedScript, (_a = options.root) != null ? _a : targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);\n    textCandidates = filterRegexTokens(textCandidates);\n    const checkWithText = (textCandidatesToUse) => {\n      const allowParentText = allowText && !textCandidatesToUse.length;\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\n        if (!result)\n          return true;\n        return combineScores(c) < combineScores(result);\n      });\n      let bestPossibleInParent = candidates[0];\n      if (!bestPossibleInParent)\n        return;\n      for (let parent = parentElementOrShadowHost(element); parent && parent !== options.root; parent = parentElementOrShadowHost(parent)) {\n        const parentTokens = calculateCached(parent, allowParentText);\n        if (!parentTokens)\n          continue;\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n          continue;\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);\n        if (!bestPossibleInParent)\n          return;\n        const combined = [...parentTokens, ...bestPossibleInParent];\n        if (!result || combineScores(combined) < combineScores(result))\n          result = combined;\n      }\n    };\n    checkWithText(textCandidates);\n    if (element === targetElement && textCandidates.length)\n      checkWithText([]);\n    return result;\n  };\n  const calculateCached = (element, allowText) => {\n    const map = allowText ? cache.allowText : cache.disallowText;\n    let value = map.get(element);\n    if (value === void 0) {\n      value = calculate(element, allowText);\n      map.set(element, value);\n    }\n    return value;\n  };\n  return calculate(targetElement, !options.noText);\n}\nfunction buildNoTextCandidates(injectedScript, element, options) {\n  const candidates = [];\n  {\n    for (const attr of ["data-testid", "data-test-id", "data-test"]) {\n      if (attr !== options.testIdAttributeName && element.getAttribute(attr))\n        candidates.push({ engine: "css", selector: `[${attr}=${quoteCSSAttributeValue(element.getAttribute(attr))}]`, score: kOtherTestIdScore });\n    }\n    if (!options.noCSSId) {\n      const idAttr = element.getAttribute("id");\n      if (idAttr && !isGuidLike(idAttr))\n        candidates.push({ engine: "css", selector: makeSelectorForId(idAttr), score: kCSSIdScore });\n    }\n    candidates.push({ engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSTagNameScore });\n  }\n  if (element.nodeName === "IFRAME") {\n    for (const attribute of ["name", "title"]) {\n      if (element.getAttribute(attribute))\n        candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[${attribute}=${quoteCSSAttributeValue(element.getAttribute(attribute))}]`, score: kIframeByAttributeScore });\n    }\n    if (element.getAttribute(options.testIdAttributeName))\n      candidates.push({ engine: "css", selector: `[${options.testIdAttributeName}=${quoteCSSAttributeValue(element.getAttribute(options.testIdAttributeName))}]`, score: kTestIdScore });\n    penalizeScoreForLength([candidates]);\n    return candidates;\n  }\n  if (element.getAttribute(options.testIdAttributeName))\n    candidates.push({ engine: "internal:testid", selector: `[${options.testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(options.testIdAttributeName), true)}]`, score: kTestIdScore });\n  if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {\n    const input = element;\n    if (input.placeholder) {\n      candidates.push({ engine: "internal:attr", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, true)}]`, score: kPlaceholderScoreExact });\n      for (const alternative of suitableTextAlternatives(input.placeholder))\n        candidates.push({ engine: "internal:attr", selector: `[placeholder=${escapeForAttributeSelector(alternative.text, false)}]`, score: kPlaceholderScore - alternative.scoreBonus });\n    }\n  }\n  const labels = getElementLabels(injectedScript._evaluator._cacheText, element);\n  for (const label of labels) {\n    const labelText = label.normalized;\n    candidates.push({ engine: "internal:label", selector: escapeForTextSelector(labelText, true), score: kLabelScoreExact });\n    for (const alternative of suitableTextAlternatives(labelText))\n      candidates.push({ engine: "internal:label", selector: escapeForTextSelector(alternative.text, false), score: kLabelScore - alternative.scoreBonus });\n  }\n  const ariaRole = getAriaRole(element);\n  if (ariaRole && !["none", "presentation"].includes(ariaRole))\n    candidates.push({ engine: "internal:role", selector: ariaRole, score: kRoleWithoutNameScore });\n  if (element.getAttribute("name") && ["BUTTON", "FORM", "FIELDSET", "FRAME", "IFRAME", "INPUT", "KEYGEN", "OBJECT", "OUTPUT", "SELECT", "TEXTAREA", "MAP", "META", "PARAM"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteCSSAttributeValue(element.getAttribute("name"))}]`, score: kCSSInputTypeNameScore });\n  if (["INPUT", "TEXTAREA"].includes(element.nodeName) && element.getAttribute("type") !== "hidden") {\n    if (element.getAttribute("type"))\n      candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteCSSAttributeValue(element.getAttribute("type"))}]`, score: kCSSInputTypeNameScore });\n  }\n  if (["INPUT", "TEXTAREA", "SELECT"].includes(element.nodeName) && element.getAttribute("type") !== "hidden")\n    candidates.push({ engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSInputTypeNameScore + 1 });\n  penalizeScoreForLength([candidates]);\n  return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, isTargetNode) {\n  if (element.nodeName === "SELECT")\n    return [];\n  const candidates = [];\n  const title = element.getAttribute("title");\n  if (title) {\n    candidates.push([{ engine: "internal:attr", selector: `[title=${escapeForAttributeSelector(title, true)}]`, score: kTitleScoreExact }]);\n    for (const alternative of suitableTextAlternatives(title))\n      candidates.push([{ engine: "internal:attr", selector: `[title=${escapeForAttributeSelector(alternative.text, false)}]`, score: kTitleScore - alternative.scoreBonus }]);\n  }\n  const alt = element.getAttribute("alt");\n  if (alt && ["APPLET", "AREA", "IMG", "INPUT"].includes(element.nodeName)) {\n    candidates.push([{ engine: "internal:attr", selector: `[alt=${escapeForAttributeSelector(alt, true)}]`, score: kAltTextScoreExact }]);\n    for (const alternative of suitableTextAlternatives(alt))\n      candidates.push([{ engine: "internal:attr", selector: `[alt=${escapeForAttributeSelector(alternative.text, false)}]`, score: kAltTextScore - alternative.scoreBonus }]);\n  }\n  const text = elementText(injectedScript._evaluator._cacheText, element).normalized;\n  const textAlternatives = text ? suitableTextAlternatives(text) : [];\n  if (text) {\n    if (isTargetNode) {\n      if (text.length <= 80)\n        candidates.push([{ engine: "internal:text", selector: escapeForTextSelector(text, true), score: kTextScoreExact }]);\n      for (const alternative of textAlternatives)\n        candidates.push([{ engine: "internal:text", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\n    }\n    const cssToken = { engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSTagNameScore };\n    for (const alternative of textAlternatives)\n      candidates.push([cssToken, { engine: "internal:has-text", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\n    if (text.length <= 80) {\n      const re = new RegExp("^" + escapeRegExp(text) + "$");\n      candidates.push([cssToken, { engine: "internal:has-text", selector: escapeForTextSelector(re, false), score: kTextScoreRegex }]);\n    }\n  }\n  const ariaRole = getAriaRole(element);\n  if (ariaRole && !["none", "presentation"].includes(ariaRole)) {\n    const ariaName = getElementAccessibleName(element, false);\n    if (ariaName) {\n      const roleToken = { engine: "internal:role", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact };\n      candidates.push([roleToken]);\n      for (const alternative of suitableTextAlternatives(ariaName))\n        candidates.push([{ engine: "internal:role", selector: `${ariaRole}[name=${escapeForAttributeSelector(alternative.text, false)}]`, score: kRoleWithNameScore - alternative.scoreBonus }]);\n    } else {\n      const roleToken = { engine: "internal:role", selector: `${ariaRole}`, score: kRoleWithoutNameScore };\n      for (const alternative of textAlternatives)\n        candidates.push([roleToken, { engine: "internal:has-text", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\n      if (text.length <= 80) {\n        const re = new RegExp("^" + escapeRegExp(text) + "$");\n        candidates.push([roleToken, { engine: "internal:has-text", selector: escapeForTextSelector(re, false), score: kTextScoreRegex }]);\n      }\n    }\n  }\n  penalizeScoreForLength(candidates);\n  return candidates;\n}\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? "#" + id : `[id="${cssEscape(id)}"]`;\n}\nfunction hasCSSIdToken(tokens) {\n  return tokens.some((token) => token.engine === "css" && (token.selector.startsWith("#") || token.selector.startsWith(\'[id="\')));\n}\nfunction cssFallback(injectedScript, targetElement, options) {\n  var _a;\n  const root = (_a = options.root) != null ? _a : targetElement.ownerDocument;\n  const tokens = [];\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix)\n      path.unshift(prefix);\n    const selector = path.join(" > ");\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, root, false);\n    return node === targetElement ? selector : void 0;\n  }\n  function makeStrict(selector) {\n    const token = { engine: "css", selector, score: kCSSFallbackScore };\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, root);\n    if (elements.length === 1)\n      return [token];\n    const nth = { engine: "nth", selector: String(elements.indexOf(targetElement)), score: kNthScore };\n    return [token, nth];\n  }\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n    const nodeName = element.nodeName.toLowerCase();\n    let bestTokenForLevel = "";\n    if (element.id && !options.noCSSId) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      bestTokenForLevel = token;\n    }\n    const parent = element.parentNode;\n    const classes = [...element.classList];\n    for (let i = 0; i < classes.length; ++i) {\n      const token = "." + cssEscape(classes.slice(0, i + 1).join("."));\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1)\n          bestTokenForLevel = token;\n      }\n    }\n    if (parent) {\n      const siblings = [...parent.children];\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel)\n        bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = cssEscape(nodeName);\n    }\n    tokens.unshift(bestTokenForLevel);\n  }\n  return makeStrict(uniqueCSSSelector());\n}\nfunction penalizeScoreForLength(groups) {\n  for (const group of groups) {\n    for (const token of group) {\n      if (token.score > kBeginPenalizedScore && token.score < kEndPenalizedScore)\n        token.score += Math.min(kTextScoreRange, token.selector.length / 10 | 0);\n    }\n  }\n}\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = "";\n  for (const { engine, selector } of tokens) {\n    if (parts.length && (lastEngine !== "css" || engine !== "css" || selector.startsWith(":nth-match(")))\n      parts.push(">>");\n    lastEngine = engine;\n    if (engine === "css")\n      parts.push(selector);\n    else\n      parts.push(`${engine}=${selector}`);\n  }\n  return parts.join(" ");\n}\nfunction combineScores(tokens) {\n  let score = 0;\n  for (let i = 0; i < tokens.length; i++)\n    score += tokens[i].score * (tokens.length - i);\n  return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\n  joined.sort((a, b) => a.score - b.score);\n  let bestWithIndex = null;\n  for (const { tokens } of joined) {\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\n    if (result[0] === targetElement && result.length === 1) {\n      return tokens;\n    }\n    const index = result.indexOf(targetElement);\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n      continue;\n    const nth = { engine: "nth", selector: String(index), score: kNthScore };\n    bestWithIndex = [...tokens, nth];\n  }\n  return bestWithIndex;\n}\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === "-" || c === "_")\n      continue;\n    if (c >= "a" && c <= "z")\n      characterType = "lower";\n    else if (c >= "A" && c <= "Z")\n      characterType = "upper";\n    else if (c >= "0" && c <= "9")\n      characterType = "digit";\n    else\n      characterType = "other";\n    if (characterType === "lower" && lastCharacterType === "upper") {\n      lastCharacterType = characterType;\n      continue;\n    }\n    if (lastCharacterType && lastCharacterType !== characterType)\n      ++transitionCount;\n    lastCharacterType = characterType;\n  }\n  return transitionCount >= id.length / 4;\n}\nfunction trimWordBoundary(text, maxLength) {\n  if (text.length <= maxLength)\n    return text;\n  text = text.substring(0, maxLength);\n  const match = text.match(/^(.*)\\b(.+?)$/);\n  if (!match)\n    return "";\n  return match[1].trimEnd();\n}\nfunction suitableTextAlternatives(text) {\n  let result = [];\n  {\n    const match = text.match(/^([\\d.,]+)[^.,\\w]/);\n    const leadingNumberLength = match ? match[1].length : 0;\n    if (leadingNumberLength) {\n      const alt = trimWordBoundary(text.substring(leadingNumberLength).trimStart(), 80);\n      result.push({ text: alt, scoreBonus: alt.length <= 30 ? 2 : 1 });\n    }\n  }\n  {\n    const match = text.match(/[^.,\\w]([\\d.,]+)$/);\n    const trailingNumberLength = match ? match[1].length : 0;\n    if (trailingNumberLength) {\n      const alt = trimWordBoundary(text.substring(0, text.length - trailingNumberLength).trimEnd(), 80);\n      result.push({ text: alt, scoreBonus: alt.length <= 30 ? 2 : 1 });\n    }\n  }\n  if (text.length <= 30) {\n    result.push({ text, scoreBonus: 0 });\n  } else {\n    result.push({ text: trimWordBoundary(text, 80), scoreBonus: 0 });\n    result.push({ text: trimWordBoundary(text, 30), scoreBonus: 1 });\n  }\n  result = result.filter((r) => r.text);\n  if (!result.length)\n    result.push({ text: text.substring(0, 80), scoreBonus: 0 });\n  return result;\n}\n\n// packages/injected/src/vueSelectorEngine.ts\nfunction basename(filename, ext) {\n  const normalized = filename.replace(/^[a-zA-Z]:/, "").replace(/\\\\/g, "/");\n  let result = normalized.substring(normalized.lastIndexOf("/") + 1);\n  if (ext && result.endsWith(ext))\n    result = result.substring(0, result.length - ext.length);\n  return result;\n}\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : "";\n}\nvar classifyRE = /(?:^|[-_/])(\\w)/g;\nvar classify = (str) => {\n  return str && str.replace(classifyRE, toUpper);\n};\nfunction buildComponentsTreeVue3(instance2) {\n  function getComponentTypeName(options) {\n    const name = options.name || options._componentTag || options.__playwright_guessedName;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, ".vue"));\n  }\n  function saveComponentName(instance3, key) {\n    instance3.type.__playwright_guessedName = key;\n    return key;\n  }\n  function getInstanceName(instance3) {\n    var _a, _b, _c, _d;\n    const name = getComponentTypeName(instance3.type || {});\n    if (name)\n      return name;\n    if (instance3.root === instance3)\n      return "Root";\n    for (const key in (_b = (_a = instance3.parent) == null ? void 0 : _a.type) == null ? void 0 : _b.components) {\n      if (((_c = instance3.parent) == null ? void 0 : _c.type.components[key]) === instance3.type)\n        return saveComponentName(instance3, key);\n    }\n    for (const key in (_d = instance3.appContext) == null ? void 0 : _d.components) {\n      if (instance3.appContext.components[key] === instance3.type)\n        return saveComponentName(instance3, key);\n    }\n    return "Anonymous Component";\n  }\n  function isBeingDestroyed(instance3) {\n    return instance3._isBeingDestroyed || instance3.isUnmounted;\n  }\n  function isFragment(instance3) {\n    return instance3.subTree.type.toString() === "Symbol(Fragment)";\n  }\n  function getInternalInstanceChildren(subTree) {\n    const list = [];\n    if (subTree.component)\n      list.push(subTree.component);\n    if (subTree.suspense)\n      list.push(...getInternalInstanceChildren(subTree.suspense.activeBranch));\n    if (Array.isArray(subTree.children)) {\n      subTree.children.forEach((childSubTree) => {\n        if (childSubTree.component)\n          list.push(childSubTree.component);\n        else\n          list.push(...getInternalInstanceChildren(childSubTree));\n      });\n    }\n    return list.filter((child) => {\n      var _a;\n      return !isBeingDestroyed(child) && !((_a = child.type.devtools) == null ? void 0 : _a.hide);\n    });\n  }\n  function getRootElementsFromComponentInstance(instance3) {\n    if (isFragment(instance3))\n      return getFragmentRootElements(instance3.subTree);\n    return [instance3.subTree.el];\n  }\n  function getFragmentRootElements(vnode) {\n    if (!vnode.children)\n      return [];\n    const list = [];\n    for (let i = 0, l = vnode.children.length; i < l; i++) {\n      const childVnode = vnode.children[i];\n      if (childVnode.component)\n        list.push(...getRootElementsFromComponentInstance(childVnode.component));\n      else if (childVnode.el)\n        list.push(childVnode.el);\n    }\n    return list;\n  }\n  function buildComponentsTree2(instance3) {\n    return {\n      name: getInstanceName(instance3),\n      children: getInternalInstanceChildren(instance3.subTree).map(buildComponentsTree2),\n      rootElements: getRootElementsFromComponentInstance(instance3),\n      props: instance3.props\n    };\n  }\n  return buildComponentsTree2(instance2);\n}\nfunction buildComponentsTreeVue2(instance2) {\n  function getComponentName2(options) {\n    const name = options.displayName || options.name || options._componentTag;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, ".vue"));\n  }\n  function getInstanceName(instance3) {\n    const name = getComponentName2(instance3.$options || instance3.fnOptions || {});\n    if (name)\n      return name;\n    return instance3.$root === instance3 ? "Root" : "Anonymous Component";\n  }\n  function getInternalInstanceChildren(instance3) {\n    if (instance3.$children)\n      return instance3.$children;\n    if (Array.isArray(instance3.subTree.children))\n      return instance3.subTree.children.filter((vnode) => !!vnode.component).map((vnode) => vnode.component);\n    return [];\n  }\n  function buildComponentsTree2(instance3) {\n    return {\n      name: getInstanceName(instance3),\n      children: getInternalInstanceChildren(instance3).map(buildComponentsTree2),\n      rootElements: [instance3.$el],\n      props: instance3._props\n    };\n  }\n  return buildComponentsTree2(instance2);\n}\nfunction filterComponentsTree2(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree2(child, searchFn, result);\n  return result;\n}\nfunction findVueRoots(root, roots = []) {\n  const document = root.ownerDocument || root;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  const vue2Roots = new Set();\n  do {\n    const node = walker.currentNode;\n    if (node.__vue__)\n      vue2Roots.add(node.__vue__.$root);\n    if (node.__vue_app__ && node._vnode && node._vnode.component)\n      roots.push({ root: node._vnode.component, version: 3 });\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findVueRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  for (const vue2root of vue2Roots) {\n    roots.push({\n      version: 2,\n      root: vue2root\n    });\n  }\n  return roots;\n}\nvar createVueEngine = () => ({\n  queryAll(scope, selector) {\n    const document = scope.ownerDocument || scope;\n    const { name, attributes } = parseAttributeSelector(selector, false);\n    const vueRoots = findVueRoots(document);\n    const trees = vueRoots.map((vueRoot) => vueRoot.version === 3 ? buildComponentsTreeVue3(vueRoot.root) : buildComponentsTreeVue2(vueRoot.root));\n    const treeNodes = trees.map((tree) => filterComponentsTree2(tree, (treeNode) => {\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((rootElement) => !isInsideScope(scope, rootElement)))\n        return false;\n      for (const attr of attributes) {\n        if (!matchesComponentAttribute(treeNode.props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = new Set();\n    for (const treeNode of treeNodes) {\n      for (const rootElement of treeNode.rootElements)\n        allRootElements.add(rootElement);\n    }\n    return [...allRootElements];\n  }\n});\n\n// packages/injected/src/xpathSelectorEngine.ts\nvar XPathEngine = {\n  queryAll(root, selector) {\n    if (selector.startsWith("/") && root.nodeType !== Node.DOCUMENT_NODE)\n      selector = "." + selector;\n    const result = [];\n    const document = root.ownerDocument || root;\n    if (!document)\n      return result;\n    const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n    for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n      if (node.nodeType === Node.ELEMENT_NODE)\n        result.push(node);\n    }\n    return result;\n  }\n};\n\n// packages/playwright-core/src/utils/isomorphic/locatorUtils.ts\nfunction getByAttributeTextSelector(attrName, text, options) {\n  return `internal:attr=[${attrName}=${escapeForAttributeSelector(text, (options == null ? void 0 : options.exact) || false)}]`;\n}\nfunction getByTestIdSelector(testIdAttributeName, testId) {\n  return `internal:testid=[${testIdAttributeName}=${escapeForAttributeSelector(testId, true)}]`;\n}\nfunction getByLabelSelector(text, options) {\n  return "internal:label=" + escapeForTextSelector(text, !!(options == null ? void 0 : options.exact));\n}\nfunction getByAltTextSelector(text, options) {\n  return getByAttributeTextSelector("alt", text, options);\n}\nfunction getByTitleSelector(text, options) {\n  return getByAttributeTextSelector("title", text, options);\n}\nfunction getByPlaceholderSelector(text, options) {\n  return getByAttributeTextSelector("placeholder", text, options);\n}\nfunction getByTextSelector(text, options) {\n  return "internal:text=" + escapeForTextSelector(text, !!(options == null ? void 0 : options.exact));\n}\nfunction getByRoleSelector(role, options = {}) {\n  const props = [];\n  if (options.checked !== void 0)\n    props.push(["checked", String(options.checked)]);\n  if (options.disabled !== void 0)\n    props.push(["disabled", String(options.disabled)]);\n  if (options.selected !== void 0)\n    props.push(["selected", String(options.selected)]);\n  if (options.expanded !== void 0)\n    props.push(["expanded", String(options.expanded)]);\n  if (options.includeHidden !== void 0)\n    props.push(["include-hidden", String(options.includeHidden)]);\n  if (options.level !== void 0)\n    props.push(["level", String(options.level)]);\n  if (options.name !== void 0)\n    props.push(["name", escapeForAttributeSelector(options.name, !!options.exact)]);\n  if (options.pressed !== void 0)\n    props.push(["pressed", String(options.pressed)]);\n  return `internal:role=${role}${props.map(([n, v]) => `[${n}=${v}]`).join("")}`;\n}\n\n// packages/injected/src/consoleApi.ts\nvar selectorSymbol = Symbol("selector");\nselectorSymbol;\nvar _Locator = class _Locator {\n  constructor(injectedScript, selector, options) {\n    if (options == null ? void 0 : options.hasText)\n      selector += ` >> internal:has-text=${escapeForTextSelector(options.hasText, false)}`;\n    if (options == null ? void 0 : options.hasNotText)\n      selector += ` >> internal:has-not-text=${escapeForTextSelector(options.hasNotText, false)}`;\n    if (options == null ? void 0 : options.has)\n      selector += ` >> internal:has=` + JSON.stringify(options.has[selectorSymbol]);\n    if (options == null ? void 0 : options.hasNot)\n      selector += ` >> internal:has-not=` + JSON.stringify(options.hasNot[selectorSymbol]);\n    if ((options == null ? void 0 : options.visible) !== void 0)\n      selector += ` >> visible=${options.visible ? "true" : "false"}`;\n    this[selectorSymbol] = selector;\n    if (selector) {\n      const parsed = injectedScript.parseSelector(selector);\n      this.element = injectedScript.querySelector(parsed, injectedScript.document, false);\n      this.elements = injectedScript.querySelectorAll(parsed, injectedScript.document);\n    }\n    const selectorBase = selector;\n    const self = this;\n    self.locator = (selector2, options2) => {\n      return new _Locator(injectedScript, selectorBase ? selectorBase + " >> " + selector2 : selector2, options2);\n    };\n    self.getByTestId = (testId) => self.locator(getByTestIdSelector(injectedScript.testIdAttributeNameForStrictErrorAndConsoleCodegen(), testId));\n    self.getByAltText = (text, options2) => self.locator(getByAltTextSelector(text, options2));\n    self.getByLabel = (text, options2) => self.locator(getByLabelSelector(text, options2));\n    self.getByPlaceholder = (text, options2) => self.locator(getByPlaceholderSelector(text, options2));\n    self.getByText = (text, options2) => self.locator(getByTextSelector(text, options2));\n    self.getByTitle = (text, options2) => self.locator(getByTitleSelector(text, options2));\n    self.getByRole = (role, options2 = {}) => self.locator(getByRoleSelector(role, options2));\n    self.filter = (options2) => new _Locator(injectedScript, selector, options2);\n    self.first = () => self.locator("nth=0");\n    self.last = () => self.locator("nth=-1");\n    self.nth = (index) => self.locator(`nth=${index}`);\n    self.and = (locator) => new _Locator(injectedScript, selectorBase + ` >> internal:and=` + JSON.stringify(locator[selectorSymbol]));\n    self.or = (locator) => new _Locator(injectedScript, selectorBase + ` >> internal:or=` + JSON.stringify(locator[selectorSymbol]));\n  }\n};\nvar Locator = _Locator;\nvar ConsoleAPI = class {\n  constructor(injectedScript) {\n    this._injectedScript = injectedScript;\n  }\n  install() {\n    if (this._injectedScript.window.playwright)\n      return;\n    this._injectedScript.window.playwright = {\n      $: (selector, strict) => this._querySelector(selector, !!strict),\n      $$: (selector) => this._querySelectorAll(selector),\n      inspect: (selector) => this._inspect(selector),\n      selector: (element) => this._selector(element),\n      generateLocator: (element, language) => this._generateLocator(element, language),\n      ariaSnapshot: (element, options) => {\n        return this._injectedScript.ariaSnapshot(element || this._injectedScript.document.body, options);\n      },\n      resume: () => this._resume(),\n      ...new Locator(this._injectedScript, "")\n    };\n    delete this._injectedScript.window.playwright.filter;\n    delete this._injectedScript.window.playwright.first;\n    delete this._injectedScript.window.playwright.last;\n    delete this._injectedScript.window.playwright.nth;\n    delete this._injectedScript.window.playwright.and;\n    delete this._injectedScript.window.playwright.or;\n  }\n  _querySelector(selector, strict) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.query(\'Playwright >> selector\').`);\n    const parsed = this._injectedScript.parseSelector(selector);\n    return this._injectedScript.querySelector(parsed, this._injectedScript.document, strict);\n  }\n  _querySelectorAll(selector) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.$$(\'Playwright >> selector\').`);\n    const parsed = this._injectedScript.parseSelector(selector);\n    return this._injectedScript.querySelectorAll(parsed, this._injectedScript.document);\n  }\n  _inspect(selector) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.inspect(\'Playwright >> selector\').`);\n    this._injectedScript.window.inspect(this._querySelector(selector, false));\n  }\n  _selector(element) {\n    if (!(element instanceof Element))\n      throw new Error(`Usage: playwright.selector(element).`);\n    return this._injectedScript.generateSelectorSimple(element);\n  }\n  _generateLocator(element, language) {\n    if (!(element instanceof Element))\n      throw new Error(`Usage: playwright.locator(element).`);\n    const selector = this._injectedScript.generateSelectorSimple(element);\n    return asLocator(language || "javascript", selector);\n  }\n  _resume() {\n    this._injectedScript.window.__pw_resume().catch(() => {\n    });\n  }\n};\n\n// packages/injected/src/injectedScript.ts\nvar InjectedScript = class {\n  // eslint-disable-next-line no-restricted-globals\n  constructor(window, isUnderTest, sdkLanguage, testIdAttributeNameForStrictErrorAndConsoleCodegen, stableRafCount, browserName, inputFileRoleTextbox, customEngines) {\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = "data-testid";\n    // Recorder must use any external dependencies through InjectedScript.\n    // Otherwise it will end up with a copy of all modules it uses, and any\n    // module-level globals will be duplicated, which leads to subtle bugs.\n    this.utils = {\n      asLocator,\n      cacheNormalizedWhitespaces,\n      elementText,\n      getAriaRole,\n      getElementAccessibleDescription,\n      getElementAccessibleName,\n      isElementVisible,\n      isInsideScope,\n      normalizeWhiteSpace,\n      parseAriaSnapshot,\n      builtins: builtins()\n    };\n    this.window = window;\n    this.document = window.document;\n    this.isUnderTest = isUnderTest;\n    this.utils.builtins = builtins(window);\n    this._sdkLanguage = sdkLanguage;\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = testIdAttributeNameForStrictErrorAndConsoleCodegen;\n    this._evaluator = new SelectorEvaluatorImpl();\n    this.consoleApi = new ConsoleAPI(this);\n    this.onGlobalListenersRemoved = new Set();\n    this._autoClosingTags = new Set(["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "MENUITEM", "META", "PARAM", "SOURCE", "TRACK", "WBR"]);\n    this._booleanAttributes = new Set(["checked", "selected", "disabled", "readonly", "multiple"]);\n    this._eventTypes = new Map([\n      ["auxclick", "mouse"],\n      ["click", "mouse"],\n      ["dblclick", "mouse"],\n      ["mousedown", "mouse"],\n      ["mouseeenter", "mouse"],\n      ["mouseleave", "mouse"],\n      ["mousemove", "mouse"],\n      ["mouseout", "mouse"],\n      ["mouseover", "mouse"],\n      ["mouseup", "mouse"],\n      ["mouseleave", "mouse"],\n      ["mousewheel", "mouse"],\n      ["keydown", "keyboard"],\n      ["keyup", "keyboard"],\n      ["keypress", "keyboard"],\n      ["textInput", "keyboard"],\n      ["touchstart", "touch"],\n      ["touchmove", "touch"],\n      ["touchend", "touch"],\n      ["touchcancel", "touch"],\n      ["pointerover", "pointer"],\n      ["pointerout", "pointer"],\n      ["pointerenter", "pointer"],\n      ["pointerleave", "pointer"],\n      ["pointerdown", "pointer"],\n      ["pointerup", "pointer"],\n      ["pointermove", "pointer"],\n      ["pointercancel", "pointer"],\n      ["gotpointercapture", "pointer"],\n      ["lostpointercapture", "pointer"],\n      ["focus", "focus"],\n      ["blur", "focus"],\n      ["drag", "drag"],\n      ["dragstart", "drag"],\n      ["dragend", "drag"],\n      ["dragover", "drag"],\n      ["dragenter", "drag"],\n      ["dragleave", "drag"],\n      ["dragexit", "drag"],\n      ["drop", "drag"],\n      ["wheel", "wheel"],\n      ["deviceorientation", "deviceorientation"],\n      ["deviceorientationabsolute", "deviceorientation"],\n      ["devicemotion", "devicemotion"]\n    ]);\n    this._hoverHitTargetInterceptorEvents = new Set(["mousemove"]);\n    this._tapHitTargetInterceptorEvents = new Set(["pointerdown", "pointerup", "touchstart", "touchend", "touchcancel"]);\n    this._mouseHitTargetInterceptorEvents = new Set(["mousedown", "mouseup", "pointerdown", "pointerup", "click", "auxclick", "dblclick", "contextmenu"]);\n    this._allHitTargetInterceptorEvents = new Set([...this._hoverHitTargetInterceptorEvents, ...this._tapHitTargetInterceptorEvents, ...this._mouseHitTargetInterceptorEvents]);\n    this._engines = new Map();\n    this._engines.set("xpath", XPathEngine);\n    this._engines.set("xpath:light", XPathEngine);\n    this._engines.set("_react", createReactEngine());\n    this._engines.set("_vue", createVueEngine());\n    this._engines.set("role", createRoleEngine(false));\n    this._engines.set("text", this._createTextEngine(true, false));\n    this._engines.set("text:light", this._createTextEngine(false, false));\n    this._engines.set("id", this._createAttributeEngine("id", true));\n    this._engines.set("id:light", this._createAttributeEngine("id", false));\n    this._engines.set("data-testid", this._createAttributeEngine("data-testid", true));\n    this._engines.set("data-testid:light", this._createAttributeEngine("data-testid", false));\n    this._engines.set("data-test-id", this._createAttributeEngine("data-test-id", true));\n    this._engines.set("data-test-id:light", this._createAttributeEngine("data-test-id", false));\n    this._engines.set("data-test", this._createAttributeEngine("data-test", true));\n    this._engines.set("data-test:light", this._createAttributeEngine("data-test", false));\n    this._engines.set("css", this._createCSSEngine());\n    this._engines.set("nth", { queryAll: () => [] });\n    this._engines.set("visible", this._createVisibleEngine());\n    this._engines.set("internal:control", this._createControlEngine());\n    this._engines.set("internal:has", this._createHasEngine());\n    this._engines.set("internal:has-not", this._createHasNotEngine());\n    this._engines.set("internal:and", { queryAll: () => [] });\n    this._engines.set("internal:or", { queryAll: () => [] });\n    this._engines.set("internal:chain", this._createInternalChainEngine());\n    this._engines.set("internal:label", this._createInternalLabelEngine());\n    this._engines.set("internal:text", this._createTextEngine(true, true));\n    this._engines.set("internal:has-text", this._createInternalHasTextEngine());\n    this._engines.set("internal:has-not-text", this._createInternalHasNotTextEngine());\n    this._engines.set("internal:attr", this._createNamedAttributeEngine());\n    this._engines.set("internal:testid", this._createNamedAttributeEngine());\n    this._engines.set("internal:role", createRoleEngine(true));\n    this._engines.set("aria-ref", this._createAriaIdEngine());\n    for (const { name, engine } of customEngines)\n      this._engines.set(name, engine);\n    this._stableRafCount = stableRafCount;\n    this._browserName = browserName;\n    setGlobalOptions({ browserNameForWorkarounds: browserName, inputFileRoleTextbox });\n    this._setupGlobalListenersRemovalDetection();\n    this._setupHitTargetInterceptors();\n    if (isUnderTest)\n      this.window.__injectedScript = this;\n  }\n  eval(expression) {\n    return this.window.eval(expression);\n  }\n  testIdAttributeNameForStrictErrorAndConsoleCodegen() {\n    return this._testIdAttributeNameForStrictErrorAndConsoleCodegen;\n  }\n  parseSelector(selector) {\n    const result = parseSelector(selector);\n    visitAllSelectorParts(result, (part) => {\n      if (!this._engines.has(part.name))\n        throw this.createStacklessError(`Unknown engine "${part.name}" while parsing selector ${selector}`);\n    });\n    return result;\n  }\n  generateSelector(targetElement, options) {\n    return generateSelector(this, targetElement, options);\n  }\n  generateSelectorSimple(targetElement, options) {\n    return generateSelector(this, targetElement, { ...options, testIdAttributeName: this._testIdAttributeNameForStrictErrorAndConsoleCodegen }).selector;\n  }\n  querySelector(selector, root, strict) {\n    const result = this.querySelectorAll(selector, root);\n    if (strict && result.length > 1)\n      throw this.strictModeViolationError(selector, result);\n    return result[0];\n  }\n  _queryNth(elements, part) {\n    const list = [...elements];\n    let nth = +part.body;\n    if (nth === -1)\n      nth = list.length - 1;\n    return new Set(list.slice(nth, nth + 1));\n  }\n  _queryLayoutSelector(elements, part, originalRoot) {\n    const name = part.name;\n    const body = part.body;\n    const result = [];\n    const inner = this.querySelectorAll(body.parsed, originalRoot);\n    for (const element of elements) {\n      const score = layoutSelectorScore(name, element, inner, body.distance);\n      if (score !== void 0)\n        result.push({ element, score });\n    }\n    result.sort((a, b) => a.score - b.score);\n    return new Set(result.map((r) => r.element));\n  }\n  ariaSnapshot(node, options) {\n    var _a;\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError("Can only capture aria snapshot of Element nodes.");\n    const generation = (((_a = this._lastAriaSnapshot) == null ? void 0 : _a.generation) || 0) + 1;\n    this._lastAriaSnapshot = generateAriaTree(node, generation, options);\n    return renderAriaTree(this._lastAriaSnapshot, options);\n  }\n  ariaSnapshotElement(snapshot, elementId) {\n    return snapshot.elements.get(elementId) || null;\n  }\n  getAllByAria(document, template) {\n    return getAllByAria(document.documentElement, template);\n  }\n  querySelectorAll(selector, root) {\n    if (selector.capture !== void 0) {\n      if (selector.parts.some((part) => part.name === "nth"))\n        throw this.createStacklessError(`Can\'t query n-th element in a request with the capture.`);\n      const withHas = { parts: selector.parts.slice(0, selector.capture + 1) };\n      if (selector.capture < selector.parts.length - 1) {\n        const parsed = { parts: selector.parts.slice(selector.capture + 1) };\n        const has = { name: "internal:has", body: { parsed }, source: stringifySelector(parsed) };\n        withHas.parts.push(has);\n      }\n      return this.querySelectorAll(withHas, root);\n    }\n    if (!root["querySelectorAll"])\n      throw this.createStacklessError("Node is not queryable.");\n    if (selector.capture !== void 0) {\n      throw this.createStacklessError("Internal error: there should not be a capture in the selector.");\n    }\n    if (root.nodeType === 11 && selector.parts.length === 1 && selector.parts[0].name === "css" && selector.parts[0].source === ":scope")\n      return [root];\n    this._evaluator.begin();\n    try {\n      let roots = new Set([root]);\n      for (const part of selector.parts) {\n        if (part.name === "nth") {\n          roots = this._queryNth(roots, part);\n        } else if (part.name === "internal:and") {\n          const andElements = this.querySelectorAll(part.body.parsed, root);\n          roots = new Set(andElements.filter((e) => roots.has(e)));\n        } else if (part.name === "internal:or") {\n          const orElements = this.querySelectorAll(part.body.parsed, root);\n          roots = new Set(sortInDOMOrder(new Set([...roots, ...orElements])));\n        } else if (kLayoutSelectorNames.includes(part.name)) {\n          roots = this._queryLayoutSelector(roots, part, root);\n        } else {\n          const next = new Set();\n          for (const root2 of roots) {\n            const all = this._queryEngineAll(part, root2);\n            for (const one of all)\n              next.add(one);\n          }\n          roots = next;\n        }\n      }\n      return [...roots];\n    } finally {\n      this._evaluator.end();\n    }\n  }\n  _queryEngineAll(part, root) {\n    const result = this._engines.get(part.name).queryAll(root, part.body);\n    for (const element of result) {\n      if (!("nodeName" in element))\n        throw this.createStacklessError(`Expected a Node but got ${Object.prototype.toString.call(element)}`);\n    }\n    return result;\n  }\n  _createAttributeEngine(attribute, shadow) {\n    const toCSS = (selector) => {\n      const css = `[${attribute}=${JSON.stringify(selector)}]`;\n      return [{ simples: [{ selector: { css, functions: [] }, combinator: "" }] }];\n    };\n    return {\n      queryAll: (root, selector) => {\n        return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector));\n      }\n    };\n  }\n  _createCSSEngine() {\n    return {\n      queryAll: (root, body) => {\n        return this._evaluator.query({ scope: root, pierceShadow: true }, body);\n      }\n    };\n  }\n  _createTextEngine(shadow, internal) {\n    const queryAll = (root, selector) => {\n      const { matcher, kind } = createTextMatcher(selector, internal);\n      const result = [];\n      let lastDidNotMatchSelf = null;\n      const appendElement = (element) => {\n        if (kind === "lax" && lastDidNotMatchSelf && lastDidNotMatchSelf.contains(element))\n          return false;\n        const matches = elementMatchesText(this._evaluator._cacheText, element, matcher);\n        if (matches === "none")\n          lastDidNotMatchSelf = element;\n        if (matches === "self" || matches === "selfAndChildren" && kind === "strict" && !internal)\n          result.push(element);\n      };\n      if (root.nodeType === Node.ELEMENT_NODE)\n        appendElement(root);\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: shadow }, "*");\n      for (const element of elements)\n        appendElement(element);\n      return result;\n    };\n    return { queryAll };\n  }\n  _createInternalHasTextEngine() {\n    return {\n      queryAll: (root, selector) => {\n        if (root.nodeType !== 1)\n          return [];\n        const element = root;\n        const text = elementText(this._evaluator._cacheText, element);\n        const { matcher } = createTextMatcher(selector, true);\n        return matcher(text) ? [element] : [];\n      }\n    };\n  }\n  _createInternalHasNotTextEngine() {\n    return {\n      queryAll: (root, selector) => {\n        if (root.nodeType !== 1)\n          return [];\n        const element = root;\n        const text = elementText(this._evaluator._cacheText, element);\n        const { matcher } = createTextMatcher(selector, true);\n        return matcher(text) ? [] : [element];\n      }\n    };\n  }\n  _createInternalLabelEngine() {\n    return {\n      queryAll: (root, selector) => {\n        const { matcher } = createTextMatcher(selector, true);\n        const allElements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, "*");\n        return allElements.filter((element) => {\n          return getElementLabels(this._evaluator._cacheText, element).some((label) => matcher(label));\n        });\n      }\n    };\n  }\n  _createNamedAttributeEngine() {\n    const queryAll = (root, selector) => {\n      const parsed = parseAttributeSelector(selector, true);\n      if (parsed.name || parsed.attributes.length !== 1)\n        throw new Error("Malformed attribute selector: " + selector);\n      const { name, value, caseSensitive } = parsed.attributes[0];\n      const lowerCaseValue = caseSensitive ? null : value.toLowerCase();\n      let matcher;\n      if (value instanceof RegExp)\n        matcher = (s) => !!s.match(value);\n      else if (caseSensitive)\n        matcher = (s) => s === value;\n      else\n        matcher = (s) => s.toLowerCase().includes(lowerCaseValue);\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, `[${name}]`);\n      return elements.filter((e) => matcher(e.getAttribute(name)));\n    };\n    return { queryAll };\n  }\n  _createControlEngine() {\n    return {\n      queryAll(root, body) {\n        if (body === "enter-frame")\n          return [];\n        if (body === "return-empty")\n          return [];\n        if (body === "component") {\n          if (root.nodeType !== 1)\n            return [];\n          return [root.childElementCount === 1 ? root.firstElementChild : root];\n        }\n        throw new Error(`Internal error, unknown internal:control selector ${body}`);\n      }\n    };\n  }\n  _createHasEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body.parsed, root, false);\n      return has ? [root] : [];\n    };\n    return { queryAll };\n  }\n  _createHasNotEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body.parsed, root, false);\n      return has ? [] : [root];\n    };\n    return { queryAll };\n  }\n  _createVisibleEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const visible = body === "true";\n      return isElementVisible(root) === visible ? [root] : [];\n    };\n    return { queryAll };\n  }\n  _createInternalChainEngine() {\n    const queryAll = (root, body) => {\n      return this.querySelectorAll(body.parsed, root);\n    };\n    return { queryAll };\n  }\n  extend(source, params) {\n    const constrFunction = this.window.eval(`\n    (() => {\n      const module = {};\n      ${source}\n      return module.exports.default();\n    })()`);\n    return new constrFunction(this, params);\n  }\n  async viewportRatio(element) {\n    return await new Promise((resolve) => {\n      const observer = new IntersectionObserver((entries) => {\n        resolve(entries[0].intersectionRatio);\n        observer.disconnect();\n      });\n      observer.observe(element);\n      requestAnimationFrame(() => {\n      });\n    });\n  }\n  getElementBorderWidth(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)\n      return { left: 0, top: 0 };\n    const style = node.ownerDocument.defaultView.getComputedStyle(node);\n    return { left: parseInt(style.borderLeftWidth || "", 10), top: parseInt(style.borderTopWidth || "", 10) };\n  }\n  describeIFrameStyle(iframe) {\n    if (!iframe.ownerDocument || !iframe.ownerDocument.defaultView)\n      return "error:notconnected";\n    const defaultView = iframe.ownerDocument.defaultView;\n    for (let e = iframe; e; e = parentElementOrShadowHost(e)) {\n      if (defaultView.getComputedStyle(e).transform !== "none")\n        return "transformed";\n    }\n    const iframeStyle = defaultView.getComputedStyle(iframe);\n    return {\n      left: parseInt(iframeStyle.borderLeftWidth || "", 10) + parseInt(iframeStyle.paddingLeft || "", 10),\n      top: parseInt(iframeStyle.borderTopWidth || "", 10) + parseInt(iframeStyle.paddingTop || "", 10)\n    };\n  }\n  retarget(node, behavior) {\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (!element)\n      return null;\n    if (behavior === "none")\n      return element;\n    if (!element.matches("input, textarea, select") && !element.isContentEditable) {\n      if (behavior === "button-link")\n        element = element.closest("button, [role=button], a, [role=link]") || element;\n      else\n        element = element.closest("button, [role=button], [role=checkbox], [role=radio]") || element;\n    }\n    if (behavior === "follow-label") {\n      if (!element.matches("a, input, textarea, button, select, [role=link], [role=button], [role=checkbox], [role=radio]") && !element.isContentEditable) {\n        const enclosingLabel = element.closest("label");\n        if (enclosingLabel && enclosingLabel.control)\n          element = enclosingLabel.control;\n      }\n    }\n    return element;\n  }\n  async checkElementStates(node, states) {\n    if (states.includes("stable")) {\n      const stableResult = await this._checkElementIsStable(node);\n      if (stableResult === false)\n        return { missingState: "stable" };\n      if (stableResult === "error:notconnected")\n        return "error:notconnected";\n    }\n    for (const state of states) {\n      if (state !== "stable") {\n        const result = this.elementState(node, state);\n        if (result.received === "error:notconnected")\n          return "error:notconnected";\n        if (!result.matches)\n          return { missingState: state };\n      }\n    }\n  }\n  async _checkElementIsStable(node) {\n    const continuePolling = Symbol("continuePolling");\n    let lastRect;\n    let stableRafCounter = 0;\n    let lastTime = 0;\n    const check = () => {\n      const element = this.retarget(node, "no-follow-label");\n      if (!element)\n        return "error:notconnected";\n      const time = performance.now();\n      if (this._stableRafCount > 1 && time - lastTime < 15)\n        return continuePolling;\n      lastTime = time;\n      const clientRect = element.getBoundingClientRect();\n      const rect = { x: clientRect.top, y: clientRect.left, width: clientRect.width, height: clientRect.height };\n      if (lastRect) {\n        const samePosition = rect.x === lastRect.x && rect.y === lastRect.y && rect.width === lastRect.width && rect.height === lastRect.height;\n        if (!samePosition)\n          return false;\n        if (++stableRafCounter >= this._stableRafCount)\n          return true;\n      }\n      lastRect = rect;\n      return continuePolling;\n    };\n    let fulfill;\n    let reject;\n    const result = new Promise((f, r) => {\n      fulfill = f;\n      reject = r;\n    });\n    const raf = () => {\n      try {\n        const success = check();\n        if (success !== continuePolling)\n          fulfill(success);\n        else\n          requestAnimationFrame(raf);\n      } catch (e) {\n        reject(e);\n      }\n    };\n    requestAnimationFrame(raf);\n    return result;\n  }\n  _createAriaIdEngine() {\n    const queryAll = (root, selector) => {\n      var _a, _b, _c, _d;\n      const match = selector.match(/^s(\\d+)e(\\d+)$/);\n      if (!match)\n        throw this.createStacklessError("Invalid aria-ref selector, should be of form s<number>e<number>");\n      const [, generation, elementId] = match;\n      if (((_a = this._lastAriaSnapshot) == null ? void 0 : _a.generation) !== +generation)\n        throw this.createStacklessError(`Stale aria-ref, expected s${(_b = this._lastAriaSnapshot) == null ? void 0 : _b.generation}e{number}, got ${selector}`);\n      const result = (_d = (_c = this._lastAriaSnapshot) == null ? void 0 : _c.elements) == null ? void 0 : _d.get(+elementId);\n      return result && result.isConnected ? [result] : [];\n    };\n    return { queryAll };\n  }\n  elementState(node, state) {\n    const element = this.retarget(node, ["visible", "hidden"].includes(state) ? "none" : "follow-label");\n    if (!element || !element.isConnected) {\n      if (state === "hidden")\n        return { matches: true, received: "hidden" };\n      return { matches: false, received: "error:notconnected" };\n    }\n    if (state === "visible" || state === "hidden") {\n      const visible = isElementVisible(element);\n      return {\n        matches: state === "visible" ? visible : !visible,\n        received: visible ? "visible" : "hidden"\n      };\n    }\n    if (state === "disabled" || state === "enabled") {\n      const disabled = getAriaDisabled(element);\n      return {\n        matches: state === "disabled" ? disabled : !disabled,\n        received: disabled ? "disabled" : "enabled"\n      };\n    }\n    if (state === "editable") {\n      const disabled = getAriaDisabled(element);\n      const readonly = getReadonly(element);\n      if (readonly === "error")\n        throw this.createStacklessError("Element is not an <input>, <textarea>, <select> or [contenteditable] and does not have a role allowing [aria-readonly]");\n      return {\n        matches: !disabled && !readonly,\n        received: disabled ? "disabled" : readonly ? "readOnly" : "editable"\n      };\n    }\n    if (state === "checked" || state === "unchecked") {\n      const need = state === "checked";\n      const checked = getCheckedWithoutMixed(element);\n      if (checked === "error")\n        throw this.createStacklessError("Not a checkbox or radio button");\n      return {\n        matches: need === checked,\n        received: checked ? "checked" : "unchecked"\n      };\n    }\n    if (state === "indeterminate") {\n      const checked = getCheckedAllowMixed(element);\n      if (checked === "error")\n        throw this.createStacklessError("Not a checkbox or radio button");\n      return {\n        matches: checked === "mixed",\n        received: checked === true ? "checked" : checked === false ? "unchecked" : "mixed"\n      };\n    }\n    throw this.createStacklessError(`Unexpected element state "${state}"`);\n  }\n  selectOptions(node, optionsToSelect) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() !== "select")\n      throw this.createStacklessError("Element is not a <select> element");\n    const select = element;\n    const options = [...select.options];\n    const selectedOptions = [];\n    let remainingOptionsToSelect = optionsToSelect.slice();\n    for (let index = 0; index < options.length; index++) {\n      const option = options[index];\n      const filter = (optionToSelect) => {\n        if (optionToSelect instanceof Node)\n          return option === optionToSelect;\n        let matches = true;\n        if (optionToSelect.valueOrLabel !== void 0)\n          matches = matches && (optionToSelect.valueOrLabel === option.value || optionToSelect.valueOrLabel === option.label);\n        if (optionToSelect.value !== void 0)\n          matches = matches && optionToSelect.value === option.value;\n        if (optionToSelect.label !== void 0)\n          matches = matches && optionToSelect.label === option.label;\n        if (optionToSelect.index !== void 0)\n          matches = matches && optionToSelect.index === index;\n        return matches;\n      };\n      if (!remainingOptionsToSelect.some(filter))\n        continue;\n      selectedOptions.push(option);\n      if (select.multiple) {\n        remainingOptionsToSelect = remainingOptionsToSelect.filter((o) => !filter(o));\n      } else {\n        remainingOptionsToSelect = [];\n        break;\n      }\n    }\n    if (remainingOptionsToSelect.length)\n      return "error:optionsnotfound";\n    select.value = void 0;\n    selectedOptions.forEach((option) => option.selected = true);\n    select.dispatchEvent(new Event("input", { bubbles: true, composed: true }));\n    select.dispatchEvent(new Event("change", { bubbles: true }));\n    return selectedOptions.map((option) => option.value);\n  }\n  fill(node, value) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() === "input") {\n      const input = element;\n      const type = input.type.toLowerCase();\n      const kInputTypesToSetValue = new Set(["color", "date", "time", "datetime-local", "month", "range", "week"]);\n      const kInputTypesToTypeInto = new Set(["", "email", "number", "password", "search", "tel", "text", "url"]);\n      if (!kInputTypesToTypeInto.has(type) && !kInputTypesToSetValue.has(type))\n        throw this.createStacklessError(`Input of type "${type}" cannot be filled`);\n      if (type === "number") {\n        value = value.trim();\n        if (isNaN(Number(value)))\n          throw this.createStacklessError("Cannot type text into input[type=number]");\n      }\n      if (kInputTypesToSetValue.has(type)) {\n        value = value.trim();\n        input.focus();\n        input.value = value;\n        if (input.value !== value)\n          throw this.createStacklessError("Malformed value");\n        element.dispatchEvent(new Event("input", { bubbles: true, composed: true }));\n        element.dispatchEvent(new Event("change", { bubbles: true }));\n        return "done";\n      }\n    } else if (element.nodeName.toLowerCase() === "textarea") {\n    } else if (!element.isContentEditable) {\n      throw this.createStacklessError("Element is not an <input>, <textarea> or [contenteditable] element");\n    }\n    this.selectText(element);\n    return "needsinput";\n  }\n  selectText(node) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() === "input") {\n      const input = element;\n      input.select();\n      input.focus();\n      return "done";\n    }\n    if (element.nodeName.toLowerCase() === "textarea") {\n      const textarea = element;\n      textarea.selectionStart = 0;\n      textarea.selectionEnd = textarea.value.length;\n      textarea.focus();\n      return "done";\n    }\n    const range = element.ownerDocument.createRange();\n    range.selectNodeContents(element);\n    const selection = element.ownerDocument.defaultView.getSelection();\n    if (selection) {\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n    element.focus();\n    return "done";\n  }\n  _activelyFocused(node) {\n    const activeElement = node.getRootNode().activeElement;\n    const isFocused = activeElement === node && !!node.ownerDocument && node.ownerDocument.hasFocus();\n    return { activeElement, isFocused };\n  }\n  focusNode(node, resetSelectionIfNotFocused) {\n    if (!node.isConnected)\n      return "error:notconnected";\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError("Node is not an element");\n    const { activeElement, isFocused: wasFocused } = this._activelyFocused(node);\n    if (node.isContentEditable && !wasFocused && activeElement && activeElement.blur) {\n      activeElement.blur();\n    }\n    node.focus();\n    node.focus();\n    if (resetSelectionIfNotFocused && !wasFocused && node.nodeName.toLowerCase() === "input") {\n      try {\n        const input = node;\n        input.setSelectionRange(0, 0);\n      } catch (e) {\n      }\n    }\n    return "done";\n  }\n  blurNode(node) {\n    if (!node.isConnected)\n      return "error:notconnected";\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError("Node is not an element");\n    node.blur();\n    return "done";\n  }\n  setInputFiles(node, payloads) {\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return "Node is not of type HTMLElement";\n    const element = node;\n    if (element.nodeName !== "INPUT")\n      return "Not an <input> element";\n    const input = element;\n    const type = (input.getAttribute("type") || "").toLowerCase();\n    if (type !== "file")\n      return "Not an input[type=file] element";\n    const files = payloads.map((file) => {\n      const bytes = Uint8Array.from(atob(file.buffer), (c) => c.charCodeAt(0));\n      return new File([bytes], file.name, { type: file.mimeType, lastModified: file.lastModifiedMs });\n    });\n    const dt = new DataTransfer();\n    for (const file of files)\n      dt.items.add(file);\n    input.files = dt.files;\n    input.dispatchEvent(new Event("input", { bubbles: true, composed: true }));\n    input.dispatchEvent(new Event("change", { bubbles: true }));\n  }\n  expectHitTarget(hitPoint, targetElement) {\n    const roots = [];\n    let parentElement = targetElement;\n    while (parentElement) {\n      const root = enclosingShadowRootOrDocument(parentElement);\n      if (!root)\n        break;\n      roots.push(root);\n      if (root.nodeType === 9)\n        break;\n      parentElement = root.host;\n    }\n    let hitElement;\n    for (let index = roots.length - 1; index >= 0; index--) {\n      const root = roots[index];\n      const elements = root.elementsFromPoint(hitPoint.x, hitPoint.y);\n      const singleElement = root.elementFromPoint(hitPoint.x, hitPoint.y);\n      if (singleElement && elements[0] && parentElementOrShadowHost(singleElement) === elements[0]) {\n        const style = this.window.getComputedStyle(singleElement);\n        if ((style == null ? void 0 : style.display) === "contents") {\n          elements.unshift(singleElement);\n        }\n      }\n      if (elements[0] && elements[0].shadowRoot === root && elements[1] === singleElement) {\n        elements.shift();\n      }\n      const innerElement = elements[0];\n      if (!innerElement)\n        break;\n      hitElement = innerElement;\n      if (index && innerElement !== roots[index - 1].host)\n        break;\n    }\n    const hitParents = [];\n    while (hitElement && hitElement !== targetElement) {\n      hitParents.push(hitElement);\n      hitElement = parentElementOrShadowHost(hitElement);\n    }\n    if (hitElement === targetElement)\n      return "done";\n    const hitTargetDescription = this.previewNode(hitParents[0] || this.document.documentElement);\n    let rootHitTargetDescription;\n    let element = targetElement;\n    while (element) {\n      const index = hitParents.indexOf(element);\n      if (index !== -1) {\n        if (index > 1)\n          rootHitTargetDescription = this.previewNode(hitParents[index - 1]);\n        break;\n      }\n      element = parentElementOrShadowHost(element);\n    }\n    if (rootHitTargetDescription)\n      return { hitTargetDescription: `${hitTargetDescription} from ${rootHitTargetDescription} subtree` };\n    return { hitTargetDescription };\n  }\n  // Life of a pointer action, for example click.\n  //\n  // 0. Retry items 1 and 2 while action fails due to navigation or element being detached.\n  //   1. Resolve selector to an element.\n  //   2. Retry the following steps until the element is detached or frame navigates away.\n  //     2a. Wait for the element to be stable (not moving), visible and enabled.\n  //     2b. Scroll element into view. Scrolling alternates between:\n  //         - Built-in protocol scrolling.\n  //         - Anchoring to the top/left, bottom/right and center/center.\n  //         This is to scroll elements from under sticky headers/footers.\n  //     2c. Click point is calculated, either based on explicitly specified position,\n  //         or some visible point of the element based on protocol content quads.\n  //     2d. Click point relative to page viewport is converted relative to the target iframe\n  //         for the next hit-point check.\n  //     2e. (injected) Hit target at the click point must be a descendant of the target element.\n  //         This prevents mis-clicking in edge cases like <iframe> overlaying the target.\n  //     2f. (injected) Events specific for click (or some other action type) are intercepted on\n  //         the Window with capture:true. See 2i for details.\n  //         Note: this step is skipped for drag&drop (see inline comments for the reason).\n  //     2g. Necessary keyboard modifiers are pressed.\n  //     2h. Click event is issued (mousemove + mousedown + mouseup).\n  //     2i. (injected) For each event, we check that hit target at the event point\n  //         is a descendant of the target element.\n  //         This guarantees no race between issuing the event and handling it in the page,\n  //         for example due to layout shift.\n  //         When hit target check fails, we block all future events in the page.\n  //     2j. Keyboard modifiers are restored.\n  //     2k. (injected) Event interceptor is removed.\n  //     2l. All navigations triggered between 2g-2k are awaited to be either committed or canceled.\n  //     2m. If failed, wait for increasing amount of time before the next retry.\n  setupHitTargetInterceptor(node, action, hitPoint, blockAllEvents) {\n    const element = this.retarget(node, "button-link");\n    if (!element || !element.isConnected)\n      return "error:notconnected";\n    if (hitPoint) {\n      const preliminaryResult = this.expectHitTarget(hitPoint, element);\n      if (preliminaryResult !== "done")\n        return preliminaryResult.hitTargetDescription;\n    }\n    if (action === "drag")\n      return { stop: () => "done" };\n    const events = {\n      "hover": this._hoverHitTargetInterceptorEvents,\n      "tap": this._tapHitTargetInterceptorEvents,\n      "mouse": this._mouseHitTargetInterceptorEvents\n    }[action];\n    let result;\n    const listener = (event) => {\n      if (!events.has(event.type))\n        return;\n      if (!event.isTrusted)\n        return;\n      const point = !!this.window.TouchEvent && event instanceof this.window.TouchEvent ? event.touches[0] : event;\n      if (result === void 0 && point)\n        result = this.expectHitTarget({ x: point.clientX, y: point.clientY }, element);\n      if (blockAllEvents || result !== "done" && result !== void 0) {\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n      }\n    };\n    const stop = () => {\n      if (this._hitTargetInterceptor === listener)\n        this._hitTargetInterceptor = void 0;\n      return result || "done";\n    };\n    this._hitTargetInterceptor = listener;\n    return { stop };\n  }\n  dispatchEvent(node, type, eventInitObj) {\n    var _a, _b, _c, _d, _e;\n    let event;\n    const eventInit = { bubbles: true, cancelable: true, composed: true, ...eventInitObj };\n    switch (this._eventTypes.get(type)) {\n      case "mouse":\n        event = new MouseEvent(type, eventInit);\n        break;\n      case "keyboard":\n        event = new KeyboardEvent(type, eventInit);\n        break;\n      case "touch": {\n        if (this._browserName === "webkit") {\n          const createTouch = (t) => {\n            var _a2, _b2, _c2;\n            if (t instanceof Touch)\n              return t;\n            let pageX = t.pageX;\n            if (pageX === void 0 && t.clientX !== void 0)\n              pageX = t.clientX + (((_a2 = this.document.scrollingElement) == null ? void 0 : _a2.scrollLeft) || 0);\n            let pageY = t.pageY;\n            if (pageY === void 0 && t.clientY !== void 0)\n              pageY = t.clientY + (((_b2 = this.document.scrollingElement) == null ? void 0 : _b2.scrollTop) || 0);\n            return this.document.createTouch(this.window, (_c2 = t.target) != null ? _c2 : node, t.identifier, pageX, pageY, t.screenX, t.screenY, t.radiusX, t.radiusY, t.rotationAngle, t.force);\n          };\n          const createTouchList = (touches) => {\n            if (touches instanceof TouchList || !touches)\n              return touches;\n            return this.document.createTouchList(...touches.map(createTouch));\n          };\n          (_a = eventInit.target) != null ? _a : eventInit.target = node;\n          eventInit.touches = createTouchList(eventInit.touches);\n          eventInit.targetTouches = createTouchList(eventInit.targetTouches);\n          eventInit.changedTouches = createTouchList(eventInit.changedTouches);\n          event = new TouchEvent(type, eventInit);\n        } else {\n          (_b = eventInit.target) != null ? _b : eventInit.target = node;\n          eventInit.touches = (_c = eventInit.touches) == null ? void 0 : _c.map((t) => {\n            var _a2;\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\n          });\n          eventInit.targetTouches = (_d = eventInit.targetTouches) == null ? void 0 : _d.map((t) => {\n            var _a2;\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\n          });\n          eventInit.changedTouches = (_e = eventInit.changedTouches) == null ? void 0 : _e.map((t) => {\n            var _a2;\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\n          });\n          event = new TouchEvent(type, eventInit);\n        }\n        break;\n      }\n      case "pointer":\n        event = new PointerEvent(type, eventInit);\n        break;\n      case "focus":\n        event = new FocusEvent(type, eventInit);\n        break;\n      case "drag":\n        event = new DragEvent(type, eventInit);\n        break;\n      case "wheel":\n        event = new WheelEvent(type, eventInit);\n        break;\n      case "deviceorientation":\n        try {\n          event = new DeviceOrientationEvent(type, eventInit);\n        } catch {\n          const { bubbles, cancelable, alpha, beta, gamma, absolute } = eventInit;\n          event = this.document.createEvent("DeviceOrientationEvent");\n          event.initDeviceOrientationEvent(type, bubbles, cancelable, alpha, beta, gamma, absolute);\n        }\n        break;\n      case "devicemotion":\n        try {\n          event = new DeviceMotionEvent(type, eventInit);\n        } catch {\n          const { bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval } = eventInit;\n          event = this.document.createEvent("DeviceMotionEvent");\n          event.initDeviceMotionEvent(type, bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval);\n        }\n        break;\n      default:\n        event = new Event(type, eventInit);\n        break;\n    }\n    node.dispatchEvent(event);\n  }\n  previewNode(node) {\n    if (node.nodeType === Node.TEXT_NODE)\n      return oneLine(`#text=${node.nodeValue || ""}`);\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return oneLine(`<${node.nodeName.toLowerCase()} />`);\n    const element = node;\n    const attrs = [];\n    for (let i = 0; i < element.attributes.length; i++) {\n      const { name, value } = element.attributes[i];\n      if (name === "style")\n        continue;\n      if (!value && this._booleanAttributes.has(name))\n        attrs.push(` ${name}`);\n      else\n        attrs.push(` ${name}="${value}"`);\n    }\n    attrs.sort((a, b) => a.length - b.length);\n    const attrText = trimStringWithEllipsis(attrs.join(""), 500);\n    if (this._autoClosingTags.has(element.nodeName))\n      return oneLine(`<${element.nodeName.toLowerCase()}${attrText}/>`);\n    const children = element.childNodes;\n    let onlyText = false;\n    if (children.length <= 5) {\n      onlyText = true;\n      for (let i = 0; i < children.length; i++)\n        onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;\n    }\n    const text = onlyText ? element.textContent || "" : children.length ? "\\u2026" : "";\n    return oneLine(`<${element.nodeName.toLowerCase()}${attrText}>${trimStringWithEllipsis(text, 50)}</${element.nodeName.toLowerCase()}>`);\n  }\n  strictModeViolationError(selector, matches) {\n    const infos = matches.slice(0, 10).map((m) => ({\n      preview: this.previewNode(m),\n      selector: this.generateSelectorSimple(m)\n    }));\n    const lines = infos.map((info, i) => `\n    ${i + 1}) ${info.preview} aka ${asLocator(this._sdkLanguage, info.selector)}`);\n    if (infos.length < matches.length)\n      lines.push("\\n    ...");\n    return this.createStacklessError(`strict mode violation: ${asLocator(this._sdkLanguage, stringifySelector(selector))} resolved to ${matches.length} elements:${lines.join("")}\n`);\n  }\n  createStacklessError(message) {\n    if (this._browserName === "firefox") {\n      const error2 = new Error("Error: " + message);\n      error2.stack = "";\n      return error2;\n    }\n    const error = new Error(message);\n    delete error.stack;\n    return error;\n  }\n  createHighlight() {\n    return new Highlight(this);\n  }\n  maskSelectors(selectors, color) {\n    if (this._highlight)\n      this.hideHighlight();\n    this._highlight = new Highlight(this);\n    this._highlight.install();\n    const elements = [];\n    for (const selector of selectors)\n      elements.push(this.querySelectorAll(selector, this.document.documentElement));\n    this._highlight.maskElements(elements.flat(), color);\n  }\n  highlight(selector) {\n    if (!this._highlight) {\n      this._highlight = new Highlight(this);\n      this._highlight.install();\n    }\n    this._highlight.runHighlightOnRaf(selector);\n  }\n  hideHighlight() {\n    if (this._highlight) {\n      this._highlight.uninstall();\n      delete this._highlight;\n    }\n  }\n  markTargetElements(markedElements, callId) {\n    var _a, _b;\n    if (((_a = this._markedElements) == null ? void 0 : _a.callId) !== callId)\n      this._markedElements = void 0;\n    const previous = ((_b = this._markedElements) == null ? void 0 : _b.elements) || new Set();\n    const unmarkEvent = new CustomEvent("__playwright_unmark_target__", {\n      bubbles: true,\n      cancelable: true,\n      detail: callId,\n      composed: true\n    });\n    for (const element of previous) {\n      if (!markedElements.has(element))\n        element.dispatchEvent(unmarkEvent);\n    }\n    const markEvent = new CustomEvent("__playwright_mark_target__", {\n      bubbles: true,\n      cancelable: true,\n      detail: callId,\n      composed: true\n    });\n    for (const element of markedElements) {\n      if (!previous.has(element))\n        element.dispatchEvent(markEvent);\n    }\n    this._markedElements = { callId, elements: markedElements };\n  }\n  _setupGlobalListenersRemovalDetection() {\n    const customEventName = "__playwright_global_listeners_check__";\n    let seenEvent = false;\n    const handleCustomEvent = () => seenEvent = true;\n    this.window.addEventListener(customEventName, handleCustomEvent);\n    new MutationObserver((entries) => {\n      const newDocumentElement = entries.some((entry) => Array.from(entry.addedNodes).includes(this.document.documentElement));\n      if (!newDocumentElement)\n        return;\n      seenEvent = false;\n      this.window.dispatchEvent(new CustomEvent(customEventName));\n      if (seenEvent)\n        return;\n      this.window.addEventListener(customEventName, handleCustomEvent);\n      for (const callback of this.onGlobalListenersRemoved)\n        callback();\n    }).observe(this.document, { childList: true });\n  }\n  _setupHitTargetInterceptors() {\n    const listener = (event) => {\n      var _a;\n      return (_a = this._hitTargetInterceptor) == null ? void 0 : _a.call(this, event);\n    };\n    const addHitTargetInterceptorListeners = () => {\n      for (const event of this._allHitTargetInterceptorEvents)\n        this.window.addEventListener(event, listener, { capture: true, passive: false });\n    };\n    addHitTargetInterceptorListeners();\n    this.onGlobalListenersRemoved.add(addHitTargetInterceptorListeners);\n  }\n  async expect(element, options, elements) {\n    const isArray = options.expression === "to.have.count" || options.expression.endsWith(".array");\n    if (isArray)\n      return this.expectArray(elements, options);\n    if (!element) {\n      if (!options.isNot && options.expression === "to.be.hidden")\n        return { matches: true };\n      if (options.isNot && options.expression === "to.be.visible")\n        return { matches: false };\n      if (!options.isNot && options.expression === "to.be.detached")\n        return { matches: true };\n      if (options.isNot && options.expression === "to.be.attached")\n        return { matches: false };\n      if (options.isNot && options.expression === "to.be.in.viewport")\n        return { matches: false };\n      return { matches: options.isNot, missingReceived: true };\n    }\n    return await this.expectSingleElement(element, options);\n  }\n  async expectSingleElement(element, options) {\n    var _a, _b;\n    const expression = options.expression;\n    {\n      let result;\n      if (expression === "to.have.attribute") {\n        const hasAttribute = element.hasAttribute(options.expressionArg);\n        result = {\n          matches: hasAttribute,\n          received: hasAttribute ? "attribute present" : "attribute not present"\n        };\n      } else if (expression === "to.be.checked") {\n        const { checked, indeterminate } = options.expectedValue;\n        if (indeterminate) {\n          if (checked !== void 0)\n            throw this.createStacklessError("Can\'t assert indeterminate and checked at the same time");\n          result = this.elementState(element, "indeterminate");\n        } else {\n          result = this.elementState(element, checked === false ? "unchecked" : "checked");\n        }\n      } else if (expression === "to.be.disabled") {\n        result = this.elementState(element, "disabled");\n      } else if (expression === "to.be.editable") {\n        result = this.elementState(element, "editable");\n      } else if (expression === "to.be.readonly") {\n        result = this.elementState(element, "editable");\n        result.matches = !result.matches;\n      } else if (expression === "to.be.empty") {\n        if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {\n          const value = element.value;\n          result = { matches: !value, received: value ? "notEmpty" : "empty" };\n        } else {\n          const text = (_a = element.textContent) == null ? void 0 : _a.trim();\n          result = { matches: !text, received: text ? "notEmpty" : "empty" };\n        }\n      } else if (expression === "to.be.enabled") {\n        result = this.elementState(element, "enabled");\n      } else if (expression === "to.be.focused") {\n        const focused = this._activelyFocused(element).isFocused;\n        result = {\n          matches: focused,\n          received: focused ? "focused" : "inactive"\n        };\n      } else if (expression === "to.be.hidden") {\n        result = this.elementState(element, "hidden");\n      } else if (expression === "to.be.visible") {\n        result = this.elementState(element, "visible");\n      } else if (expression === "to.be.attached") {\n        result = {\n          matches: true,\n          received: "attached"\n        };\n      } else if (expression === "to.be.detached") {\n        result = {\n          matches: false,\n          received: "attached"\n        };\n      }\n      if (result) {\n        if (result.received === "error:notconnected")\n          throw this.createStacklessError("Element is not connected");\n        return result;\n      }\n    }\n    {\n      if (expression === "to.have.property") {\n        let target = element;\n        const properties = options.expressionArg.split(".");\n        for (let i = 0; i < properties.length - 1; i++) {\n          if (typeof target !== "object" || !(properties[i] in target))\n            return { received: void 0, matches: false };\n          target = target[properties[i]];\n        }\n        const received = target[properties[properties.length - 1]];\n        const matches = deepEquals(received, options.expectedValue);\n        return { received, matches };\n      }\n    }\n    {\n      if (expression === "to.be.in.viewport") {\n        const ratio = await this.viewportRatio(element);\n        return { received: `viewport ratio ${ratio}`, matches: ratio > 0 && ratio > ((_b = options.expectedNumber) != null ? _b : 0) - 1e-9 };\n      }\n    }\n    {\n      if (expression === "to.have.values") {\n        element = this.retarget(element, "follow-label");\n        if (element.nodeName !== "SELECT" || !element.multiple)\n          throw this.createStacklessError("Not a select element with a multiple attribute");\n        const received = [...element.selectedOptions].map((o) => o.value);\n        if (received.length !== options.expectedText.length)\n          return { received, matches: false };\n        return { received, matches: received.map((r, i) => new ExpectedTextMatcher(options.expectedText[i]).matches(r)).every(Boolean) };\n      }\n    }\n    {\n      if (expression === "to.match.aria") {\n        const result = matchesAriaTree(element, options.expectedValue);\n        return {\n          received: result.received,\n          matches: !!result.matches.length\n        };\n      }\n    }\n    {\n      let received;\n      if (expression === "to.have.attribute.value") {\n        const value = element.getAttribute(options.expressionArg);\n        if (value === null)\n          return { received: null, matches: false };\n        received = value;\n      } else if (["to.have.class", "to.contain.class"].includes(expression)) {\n        if (!options.expectedText)\n          throw this.createStacklessError("Expected text is not provided for " + expression);\n        return {\n          received: element.classList.toString(),\n          matches: new ExpectedTextMatcher(options.expectedText[0]).matchesClassList(\n            this,\n            element.classList,\n            /* partial */\n            expression === "to.contain.class"\n          )\n        };\n      } else if (expression === "to.have.css") {\n        received = this.window.getComputedStyle(element).getPropertyValue(options.expressionArg);\n      } else if (expression === "to.have.id") {\n        received = element.id;\n      } else if (expression === "to.have.text") {\n        received = options.useInnerText ? element.innerText : elementText(new Map(), element).full;\n      } else if (expression === "to.have.accessible.name") {\n        received = getElementAccessibleName(\n          element,\n          false\n          /* includeHidden */\n        );\n      } else if (expression === "to.have.accessible.description") {\n        received = getElementAccessibleDescription(\n          element,\n          false\n          /* includeHidden */\n        );\n      } else if (expression === "to.have.accessible.error.message") {\n        received = getElementAccessibleErrorMessage(element);\n      } else if (expression === "to.have.role") {\n        received = getAriaRole(element) || "";\n      } else if (expression === "to.have.title") {\n        received = this.document.title;\n      } else if (expression === "to.have.url") {\n        received = this.document.location.href;\n      } else if (expression === "to.have.value") {\n        element = this.retarget(element, "follow-label");\n        if (element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")\n          throw this.createStacklessError("Not an input element");\n        received = element.value;\n      }\n      if (received !== void 0 && options.expectedText) {\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\n        return { received, matches: matcher.matches(received) };\n      }\n    }\n    throw this.createStacklessError("Unknown expect matcher: " + expression);\n  }\n  expectArray(elements, options) {\n    const expression = options.expression;\n    if (expression === "to.have.count") {\n      const received2 = elements.length;\n      const matches2 = received2 === options.expectedNumber;\n      return { received: received2, matches: matches2 };\n    }\n    if (!options.expectedText)\n      throw this.createStacklessError("Expected text is not provided for " + expression);\n    if (["to.have.class.array", "to.contain.class.array"].includes(expression)) {\n      const receivedClassLists = elements.map((e) => e.classList);\n      const received2 = receivedClassLists.map(String);\n      if (receivedClassLists.length !== options.expectedText.length)\n        return { received: received2, matches: false };\n      const matches2 = this._matchSequentially(\n        options.expectedText,\n        receivedClassLists,\n        (matcher, r) => matcher.matchesClassList(\n          this,\n          r,\n          /* partial */\n          expression === "to.contain.class.array"\n        )\n      );\n      return {\n        received: received2,\n        matches: matches2\n      };\n    }\n    if (!["to.contain.text.array", "to.have.text.array"].includes(expression))\n      throw this.createStacklessError("Unknown expect matcher: " + expression);\n    const received = elements.map((e) => options.useInnerText ? e.innerText : elementText(new Map(), e).full);\n    const lengthShouldMatch = expression !== "to.contain.text.array";\n    const matchesLength = received.length === options.expectedText.length || !lengthShouldMatch;\n    if (!matchesLength)\n      return { received, matches: false };\n    const matches = this._matchSequentially(options.expectedText, received, (matcher, r) => matcher.matches(r));\n    return { received, matches };\n  }\n  _matchSequentially(expectedText, received, matchFn) {\n    const matchers = expectedText.map((e) => new ExpectedTextMatcher(e));\n    let mIndex = 0;\n    let rIndex = 0;\n    while (mIndex < matchers.length && rIndex < received.length) {\n      if (matchFn(matchers[mIndex], received[rIndex]))\n        ++mIndex;\n      ++rIndex;\n    }\n    return mIndex === matchers.length;\n  }\n};\nfunction oneLine(s) {\n  return s.replace(/\\n/g, "\\u21B5").replace(/\\t/g, "\\u21C6");\n}\nfunction cssUnquote(s) {\n  s = s.substring(1, s.length - 1);\n  if (!s.includes("\\\\"))\n    return s;\n  const r = [];\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === "\\\\" && i + 1 < s.length)\n      i++;\n    r.push(s[i++]);\n  }\n  return r.join("");\n}\nfunction createTextMatcher(selector, internal) {\n  if (selector[0] === "/" && selector.lastIndexOf("/") > 0) {\n    const lastSlash = selector.lastIndexOf("/");\n    const re = new RegExp(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\n    return { matcher: (elementText2) => re.test(elementText2.full), kind: "regex" };\n  }\n  const unquote = internal ? JSON.parse.bind(JSON) : cssUnquote;\n  let strict = false;\n  if (selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 1] === \'"\') {\n    selector = unquote(selector);\n    strict = true;\n  } else if (internal && selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 2] === \'"\' && selector[selector.length - 1] === "i") {\n    selector = unquote(selector.substring(0, selector.length - 1));\n    strict = false;\n  } else if (internal && selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 2] === \'"\' && selector[selector.length - 1] === "s") {\n    selector = unquote(selector.substring(0, selector.length - 1));\n    strict = true;\n  } else if (selector.length > 1 && selector[0] === "\'" && selector[selector.length - 1] === "\'") {\n    selector = unquote(selector);\n    strict = true;\n  }\n  selector = normalizeWhiteSpace(selector);\n  if (strict) {\n    if (internal)\n      return { kind: "strict", matcher: (elementText2) => elementText2.normalized === selector };\n    const strictTextNodeMatcher = (elementText2) => {\n      if (!selector && !elementText2.immediate.length)\n        return true;\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === selector);\n    };\n    return { matcher: strictTextNodeMatcher, kind: "strict" };\n  }\n  selector = selector.toLowerCase();\n  return { kind: "lax", matcher: (elementText2) => elementText2.normalized.toLowerCase().includes(selector) };\n}\nvar ExpectedTextMatcher = class {\n  constructor(expected) {\n    this._normalizeWhiteSpace = expected.normalizeWhiteSpace;\n    this._ignoreCase = expected.ignoreCase;\n    this._string = expected.matchSubstring ? void 0 : this.normalize(expected.string);\n    this._substring = expected.matchSubstring ? this.normalize(expected.string) : void 0;\n    if (expected.regexSource) {\n      const flags = new Set((expected.regexFlags || "").split(""));\n      if (expected.ignoreCase === false)\n        flags.delete("i");\n      if (expected.ignoreCase === true)\n        flags.add("i");\n      this._regex = new RegExp(expected.regexSource, [...flags].join(""));\n    }\n  }\n  matches(text) {\n    if (!this._regex)\n      text = this.normalize(text);\n    if (this._string !== void 0)\n      return text === this._string;\n    if (this._substring !== void 0)\n      return text.includes(this._substring);\n    if (this._regex)\n      return !!this._regex.test(text);\n    return false;\n  }\n  matchesClassList(injectedScript, classList, partial) {\n    if (partial) {\n      if (this._regex)\n        throw injectedScript.createStacklessError("Partial matching does not support regular expressions. Please provide a string value.");\n      return this._string.split(/\\s+/g).filter(Boolean).every((className) => classList.contains(className));\n    }\n    return this.matches(classList.toString());\n  }\n  normalize(s) {\n    if (!s)\n      return s;\n    if (this._normalizeWhiteSpace)\n      s = normalizeWhiteSpace(s);\n    if (this._ignoreCase)\n      s = s.toLocaleLowerCase();\n    return s;\n  }\n};\nfunction deepEquals(a, b) {\n  if (a === b)\n    return true;\n  if (a && b && typeof a === "object" && typeof b === "object") {\n    if (a.constructor !== b.constructor)\n      return false;\n    if (Array.isArray(a)) {\n      if (a.length !== b.length)\n        return false;\n      for (let i = 0; i < a.length; ++i) {\n        if (!deepEquals(a[i], b[i]))\n          return false;\n      }\n      return true;\n    }\n    if (a instanceof RegExp)\n      return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString)\n      return a.toString() === b.toString();\n    const keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length)\n      return false;\n    for (let i = 0; i < keys.length; ++i) {\n      if (!b.hasOwnProperty(keys[i]))\n        return false;\n    }\n    for (const key of keys) {\n      if (!deepEquals(a[key], b[key]))\n        return false;\n    }\n    return true;\n  }\n  if (typeof a === "number" && typeof b === "number")\n    return isNaN(a) && isNaN(b);\n  return false;\n}\n';

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dom.js
var NonRecoverableDOMError = class extends Error {
  static {
    __name(this, "NonRecoverableDOMError");
  }
};
function isNonRecoverableDOMError(error4) {
  return error4 instanceof NonRecoverableDOMError;
}
__name(isNonRecoverableDOMError, "isNonRecoverableDOMError");
var FrameExecutionContext = class extends ExecutionContext {
  static {
    __name(this, "FrameExecutionContext");
  }
  constructor(delegate, frame, world) {
    super(frame, delegate, world || "content-script");
    this.frame = frame;
    this.world = world;
  }
  adoptIfNeeded(handle) {
    if (handle instanceof ElementHandle && handle._context !== this)
      return this.frame._page._delegate.adoptElementHandle(handle, this);
    return null;
  }
  async evaluate(pageFunction, arg) {
    return evaluate(this, true, pageFunction, arg);
  }
  async evaluateHandle(pageFunction, arg) {
    return evaluate(this, false, pageFunction, arg);
  }
  async evaluateExpression(expression, options2, arg) {
    return evaluateExpression(this, expression, { ...options2, returnByValue: true }, arg);
  }
  async evaluateExpressionHandle(expression, options2, arg) {
    return evaluateExpression(this, expression, { ...options2, returnByValue: false }, arg);
  }
  injectedScript() {
    if (!this._injectedScriptPromise) {
      const custom = [];
      const selectorsRegistry = this.frame._page.context().selectors();
      for (const [name, { source: source22 }] of selectorsRegistry._engines)
        custom.push(`{ name: '${name}', engine: (${source22}) }`);
      const sdkLanguage = this.frame.attribution.playwright.options.sdkLanguage;
      const source$1 = `
        (() => {
        const module = {};
        ${source4}
        return new (module.exports.InjectedScript())(
          globalThis,
          ${isUnderTest()},
          "${sdkLanguage}",
          ${JSON.stringify(selectorsRegistry.testIdAttributeName())},
          ${this.frame._page._delegate.rafCountForStablePosition()},
          "${this.frame._page._browserContext._browser.options.name}",
          ${process.env.PLAYWRIGHT_INPUT_FILE_TEXTBOX ? "true" : "false"},
          [${custom.join(",\n")}]
        );
        })();
      `;
      this._injectedScriptPromise = this.rawEvaluateHandle(source$1).then((handle) => {
        handle._setPreview("InjectedScript");
        return handle;
      });
    }
    return this._injectedScriptPromise;
  }
};
var ElementHandle = class extends JSHandle {
  static {
    __name(this, "ElementHandle");
  }
  constructor(context2, objectId) {
    super(context2, "node", void 0, objectId);
    this.__elementhandle = true;
    this._page = context2.frame._page;
    this._frame = context2.frame;
    this._initializePreview().catch((e) => {
    });
  }
  async _initializePreview() {
    const utility = await this._context.injectedScript();
    this._setPreview(await utility.evaluate((injected, e) => "JSHandle@" + injected.previewNode(e), this));
  }
  asElement() {
    return this;
  }
  async evaluateInUtility(pageFunction, arg) {
    try {
      const utility = await this._frame._utilityContext();
      return await utility.evaluate(pageFunction, [await utility.injectedScript(), this, arg]);
    } catch (e) {
      if (isJavaScriptErrorInEvaluate(e) || isSessionClosedError(e))
        throw e;
      return "error:notconnected";
    }
  }
  async evaluateHandleInUtility(pageFunction, arg) {
    try {
      const utility = await this._frame._utilityContext();
      return await utility.evaluateHandle(pageFunction, [await utility.injectedScript(), this, arg]);
    } catch (e) {
      if (isJavaScriptErrorInEvaluate(e) || isSessionClosedError(e))
        throw e;
      return "error:notconnected";
    }
  }
  async ownerFrame() {
    const frameId = await this._page._delegate.getOwnerFrame(this);
    if (!frameId)
      return null;
    const frame = this._page._frameManager.frame(frameId);
    if (frame)
      return frame;
    for (const page of this._page._browserContext.pages()) {
      const frame2 = page._frameManager.frame(frameId);
      if (frame2)
        return frame2;
    }
    return null;
  }
  async isIframeElement() {
    return this.evaluateInUtility(([injected, node2]) => node2 && (node2.nodeName === "IFRAME" || node2.nodeName === "FRAME"), {});
  }
  async contentFrame() {
    const isFrameElement = throwRetargetableDOMError(await this.isIframeElement());
    if (!isFrameElement)
      return null;
    return this._page._delegate.getContentFrame(this);
  }
  async generateLocatorString() {
    const selector = await this.evaluateInUtility(async ([injected, node2]) => {
      return injected.generateSelectorSimple(node2);
    }, {});
    if (selector === "error:notconnected")
      return;
    return asLocator("javascript", selector);
  }
  async getAttribute(metadata, name) {
    return this._frame.getAttribute(metadata, ":scope", name, {}, this);
  }
  async inputValue(metadata) {
    return this._frame.inputValue(metadata, ":scope", {}, this);
  }
  async textContent(metadata) {
    return this._frame.textContent(metadata, ":scope", {}, this);
  }
  async innerText(metadata) {
    return this._frame.innerText(metadata, ":scope", {}, this);
  }
  async innerHTML(metadata) {
    return this._frame.innerHTML(metadata, ":scope", {}, this);
  }
  async dispatchEvent(metadata, type2, eventInit = {}) {
    return this._frame.dispatchEvent(metadata, ":scope", type2, eventInit, {}, this);
  }
  async _scrollRectIntoViewIfNeeded(rect) {
    return await this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);
  }
  async _waitAndScrollIntoViewIfNeeded(progress3, waitForVisible) {
    const result = await this._retryAction(progress3, "scroll into view", async () => {
      progress3.log(`  waiting for element to be stable`);
      const waitResult = await this.evaluateInUtility(async ([injected, node2, { waitForVisible: waitForVisible2 }]) => {
        return await injected.checkElementStates(node2, waitForVisible2 ? ["visible", "stable"] : ["stable"]);
      }, { waitForVisible });
      if (waitResult)
        return waitResult;
      return await this._scrollRectIntoViewIfNeeded();
    }, {});
    assertDone(throwRetargetableDOMError(result));
  }
  async scrollIntoViewIfNeeded(metadata, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(
      (progress3) => this._waitAndScrollIntoViewIfNeeded(
        progress3,
        false
        /* waitForVisible */
      ),
      this._page._timeoutSettings.timeout(options2)
    );
  }
  async _clickablePoint() {
    const intersectQuadWithViewport = /* @__PURE__ */ __name((quad) => {
      return quad.map((point) => ({
        x: Math.min(Math.max(point.x, 0), metrics.width),
        y: Math.min(Math.max(point.y, 0), metrics.height)
      }));
    }, "intersectQuadWithViewport");
    const computeQuadArea = /* @__PURE__ */ __name((quad) => {
      let area = 0;
      for (let i = 0; i < quad.length; ++i) {
        const p1 = quad[i];
        const p2 = quad[(i + 1) % quad.length];
        area += (p1.x * p2.y - p2.x * p1.y) / 2;
      }
      return Math.abs(area);
    }, "computeQuadArea");
    const [quads, metrics] = await Promise.all([
      this._page._delegate.getContentQuads(this),
      this._page.mainFrame()._utilityContext().then((utility) => utility.evaluate(() => ({ width: innerWidth, height: innerHeight })))
    ]);
    if (quads === "error:notconnected")
      return quads;
    if (!quads || !quads.length)
      return "error:notvisible";
    const filtered = quads.map((quad) => intersectQuadWithViewport(quad)).filter((quad) => computeQuadArea(quad) > 0.99);
    if (!filtered.length)
      return "error:notinviewport";
    if (this._page._browserContext._browser.options.name === "firefox") {
      for (const quad of filtered) {
        const integerPoint = findIntegerPointInsideQuad(quad);
        if (integerPoint)
          return integerPoint;
      }
    }
    return quadMiddlePoint(filtered[0]);
  }
  async _offsetPoint(offset) {
    const [box, border] = await Promise.all([
      this.boundingBox(),
      this.evaluateInUtility(([injected, node2]) => injected.getElementBorderWidth(node2), {}).catch((e) => {
      })
    ]);
    if (!box || !border)
      return "error:notvisible";
    if (border === "error:notconnected")
      return border;
    return {
      x: box.x + border.left + offset.x,
      y: box.y + border.top + offset.y
    };
  }
  async _retryAction(progress3, actionName, action, options2) {
    let retry2 = 0;
    const waitTime = [0, 20, 100, 100, 500];
    while (progress3.isRunning()) {
      if (retry2) {
        progress3.log(`retrying ${actionName} action${options2.trial ? " (trial run)" : ""}`);
        const timeout = waitTime[Math.min(retry2 - 1, waitTime.length - 1)];
        if (timeout) {
          progress3.log(`  waiting ${timeout}ms`);
          const result2 = await this.evaluateInUtility(([injected, node2, timeout2]) => new Promise((f) => setTimeout(f, timeout2)), timeout);
          if (result2 === "error:notconnected")
            return result2;
        }
      } else {
        progress3.log(`attempting ${actionName} action${options2.trial ? " (trial run)" : ""}`);
      }
      if (!options2.skipActionPreChecks && !options2.force)
        await this._frame._page.performActionPreChecks(progress3);
      const result = await action(retry2);
      ++retry2;
      if (result === "error:notvisible") {
        if (options2.force)
          throw new NonRecoverableDOMError("Element is not visible");
        progress3.log("  element is not visible");
        continue;
      }
      if (result === "error:notinviewport") {
        if (options2.force)
          throw new NonRecoverableDOMError("Element is outside of the viewport");
        progress3.log("  element is outside of the viewport");
        continue;
      }
      if (result === "error:optionsnotfound") {
        progress3.log("  did not find some options");
        continue;
      }
      if (typeof result === "object" && "hitTargetDescription" in result) {
        progress3.log(`  ${result.hitTargetDescription} intercepts pointer events`);
        continue;
      }
      if (typeof result === "object" && "missingState" in result) {
        progress3.log(`  element is not ${result.missingState}`);
        continue;
      }
      return result;
    }
    return "done";
  }
  async _retryPointerAction(progress3, actionName, waitForEnabled, action, options2) {
    const skipActionPreChecks = actionName === "move and up";
    return await this._retryAction(progress3, actionName, async (retry2) => {
      const scrollOptions = [
        void 0,
        { block: "end", inline: "end" },
        { block: "center", inline: "center" },
        { block: "start", inline: "start" }
      ];
      const forceScrollOptions = scrollOptions[retry2 % scrollOptions.length];
      return await this._performPointerAction(progress3, actionName, waitForEnabled, action, forceScrollOptions, options2);
    }, { ...options2, skipActionPreChecks });
  }
  async _performPointerAction(progress3, actionName, waitForEnabled, action, forceScrollOptions, options2) {
    const { force = false, position } = options2;
    const doScrollIntoView = /* @__PURE__ */ __name(async () => {
      if (forceScrollOptions) {
        return await this.evaluateInUtility(([injected, node2, options22]) => {
          if (node2.nodeType === 1)
            node2.scrollIntoView(options22);
          return "done";
        }, forceScrollOptions);
      }
      return await this._scrollRectIntoViewIfNeeded(position ? { x: position.x, y: position.y, width: 0, height: 0 } : void 0);
    }, "doScrollIntoView");
    if (this._frame.parentFrame()) {
      progress3.throwIfAborted();
      await doScrollIntoView().catch(() => {
      });
    }
    if (options2.__testHookBeforeStable)
      await options2.__testHookBeforeStable();
    if (!force) {
      const elementStates = waitForEnabled ? ["visible", "enabled", "stable"] : ["visible", "stable"];
      progress3.log(`  waiting for element to be ${waitForEnabled ? "visible, enabled and stable" : "visible and stable"}`);
      const result = await this.evaluateInUtility(async ([injected, node2, { elementStates: elementStates2 }]) => {
        return await injected.checkElementStates(node2, elementStates2);
      }, { elementStates });
      if (result)
        return result;
      progress3.log(`  element is ${waitForEnabled ? "visible, enabled and stable" : "visible and stable"}`);
    }
    if (options2.__testHookAfterStable)
      await options2.__testHookAfterStable();
    progress3.log("  scrolling into view if needed");
    progress3.throwIfAborted();
    const scrolled = await doScrollIntoView();
    if (scrolled !== "done")
      return scrolled;
    progress3.log("  done scrolling");
    const maybePoint = position ? await this._offsetPoint(position) : await this._clickablePoint();
    if (typeof maybePoint === "string")
      return maybePoint;
    const point = roundPoint(maybePoint);
    progress3.metadata.point = point;
    await this.instrumentation.onBeforeInputAction(this, progress3.metadata);
    let hitTargetInterceptionHandle;
    if (force) {
      progress3.log(`  forcing action`);
    } else {
      if (options2.__testHookBeforeHitTarget)
        await options2.__testHookBeforeHitTarget();
      const frameCheckResult = await this._checkFrameIsHitTarget(point);
      if (frameCheckResult === "error:notconnected" || "hitTargetDescription" in frameCheckResult)
        return frameCheckResult;
      const hitPoint = frameCheckResult.framePoint;
      const actionType = actionName === "move and up" ? "drag" : actionName === "hover" || actionName === "tap" ? actionName : "mouse";
      const handle = await this.evaluateHandleInUtility(([injected, node2, { actionType: actionType2, hitPoint: hitPoint2, trial }]) => injected.setupHitTargetInterceptor(node2, actionType2, hitPoint2, trial), { actionType, hitPoint, trial: !!options2.trial });
      if (handle === "error:notconnected")
        return handle;
      if (!handle._objectId) {
        const error4 = handle.rawValue();
        if (error4 === "error:notconnected")
          return error4;
        return { hitTargetDescription: error4 };
      }
      hitTargetInterceptionHandle = handle;
      progress3.cleanupWhenAborted(() => {
        hitTargetInterceptionHandle.evaluate((h) => h.stop()).catch((e) => {
        });
        hitTargetInterceptionHandle.dispose();
      });
    }
    const actionResult = await this._page._frameManager.waitForSignalsCreatedBy(progress3, options2.waitAfter === true, async () => {
      if (options2.__testHookBeforePointerAction)
        await options2.__testHookBeforePointerAction();
      progress3.throwIfAborted();
      let restoreModifiers;
      if (options2 && options2.modifiers)
        restoreModifiers = await this._page.keyboard.ensureModifiers(options2.modifiers);
      progress3.log(`  performing ${actionName} action`);
      await action(point);
      if (restoreModifiers)
        await this._page.keyboard.ensureModifiers(restoreModifiers);
      if (hitTargetInterceptionHandle) {
        const stopHitTargetInterception = this._frame.raceAgainstEvaluationStallingEvents(() => {
          return hitTargetInterceptionHandle.evaluate((h) => h.stop());
        }).catch((e) => "done").finally(() => {
          hitTargetInterceptionHandle?.dispose();
        });
        if (options2.waitAfter !== false) {
          const hitTargetResult = await stopHitTargetInterception;
          if (hitTargetResult !== "done")
            return hitTargetResult;
        }
      }
      progress3.log(`  ${options2.trial ? "trial " : ""}${actionName} action done`);
      progress3.log("  waiting for scheduled navigations to finish");
      if (options2.__testHookAfterPointerAction)
        await options2.__testHookAfterPointerAction();
      return "done";
    });
    if (actionResult !== "done")
      return actionResult;
    progress3.log("  navigations have finished");
    return "done";
  }
  async _markAsTargetElement(metadata) {
    if (!metadata.id)
      return;
    await this.evaluateInUtility(([injected, node2, callId]) => {
      if (node2.nodeType === 1)
        injected.markTargetElements(/* @__PURE__ */ new Set([node2]), callId);
    }, metadata.id);
  }
  async hover(metadata, options2) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      await this._markAsTargetElement(metadata);
      const result = await this._hover(progress3, options2);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options2));
  }
  _hover(progress3, options2) {
    return this._retryPointerAction(progress3, "hover", false, (point) => this._page.mouse.move(point.x, point.y), { ...options2, waitAfter: "disabled" });
  }
  async click(metadata, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      await this._markAsTargetElement(metadata);
      const result = await this._click(progress3, { ...options2, waitAfter: !options2.noWaitAfter });
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options2));
  }
  _click(progress3, options2) {
    return this._retryPointerAction(progress3, "click", true, (point) => this._page.mouse.click(point.x, point.y, options2), options2);
  }
  async dblclick(metadata, options2) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      await this._markAsTargetElement(metadata);
      const result = await this._dblclick(progress3, options2);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options2));
  }
  _dblclick(progress3, options2) {
    return this._retryPointerAction(progress3, "dblclick", true, (point) => this._page.mouse.dblclick(point.x, point.y, options2), { ...options2, waitAfter: "disabled" });
  }
  async tap(metadata, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      await this._markAsTargetElement(metadata);
      const result = await this._tap(progress3, options2);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options2));
  }
  _tap(progress3, options2) {
    return this._retryPointerAction(progress3, "tap", true, (point) => this._page.touchscreen.tap(point.x, point.y), { ...options2, waitAfter: "disabled" });
  }
  async selectOption(metadata, elements, values, options2) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      await this._markAsTargetElement(metadata);
      const result = await this._selectOption(progress3, elements, values, options2);
      return throwRetargetableDOMError(result);
    }, this._page._timeoutSettings.timeout(options2));
  }
  async _selectOption(progress3, elements, values, options2) {
    let resultingOptions = [];
    const result = await this._retryAction(progress3, "select option", async () => {
      await this.instrumentation.onBeforeInputAction(this, progress3.metadata);
      if (!options2.force)
        progress3.log(`  waiting for element to be visible and enabled`);
      const optionsToSelect = [...elements, ...values];
      const result2 = await this.evaluateInUtility(async ([injected, node2, { optionsToSelect: optionsToSelect2, force }]) => {
        if (!force) {
          const checkResult = await injected.checkElementStates(node2, ["visible", "enabled"]);
          if (checkResult)
            return checkResult;
        }
        return injected.selectOptions(node2, optionsToSelect2);
      }, { optionsToSelect, force: options2.force });
      if (Array.isArray(result2)) {
        progress3.log("  selected specified option(s)");
        resultingOptions = result2;
        return "done";
      }
      return result2;
    }, options2);
    if (result === "error:notconnected")
      return result;
    return resultingOptions;
  }
  async fill(metadata, value, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      await this._markAsTargetElement(metadata);
      const result = await this._fill(progress3, value, options2);
      assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async _fill(progress3, value, options2) {
    progress3.log(`  fill("${value}")`);
    return await this._retryAction(progress3, "fill", async () => {
      await this.instrumentation.onBeforeInputAction(this, progress3.metadata);
      if (!options2.force)
        progress3.log("  waiting for element to be visible, enabled and editable");
      const result = await this.evaluateInUtility(async ([injected, node2, { value: value2, force }]) => {
        if (!force) {
          const checkResult = await injected.checkElementStates(node2, ["visible", "enabled", "editable"]);
          if (checkResult)
            return checkResult;
        }
        return injected.fill(node2, value2);
      }, { value, force: options2.force });
      progress3.throwIfAborted();
      if (result === "needsinput") {
        if (value)
          await this._page.keyboard.insertText(value);
        else
          await this._page.keyboard.press("Delete");
        return "done";
      } else {
        return result;
      }
    }, options2);
  }
  async selectText(metadata, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      const result = await this._retryAction(progress3, "selectText", async () => {
        if (!options2.force)
          progress3.log("  waiting for element to be visible");
        return await this.evaluateInUtility(async ([injected, node2, { force }]) => {
          if (!force) {
            const checkResult = await injected.checkElementStates(node2, ["visible"]);
            if (checkResult)
              return checkResult;
          }
          return injected.selectText(node2);
        }, { force: options2.force });
      }, options2);
      assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async setInputFiles(metadata, params) {
    const inputFileItems = await prepareFilesForUpload(this._frame, params);
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      await this._markAsTargetElement(metadata);
      const result = await this._setInputFiles(progress3, inputFileItems);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(params));
  }
  async _setInputFiles(progress3, items) {
    const { filePayloads, localPaths, localDirectory } = items;
    const multiple = filePayloads && filePayloads.length > 1 || localPaths && localPaths.length > 1;
    const result = await this.evaluateHandleInUtility(([injected, node2, { multiple: multiple2, directoryUpload }]) => {
      const element = injected.retarget(node2, "follow-label");
      if (!element)
        return;
      if (element.tagName !== "INPUT")
        throw injected.createStacklessError("Node is not an HTMLInputElement");
      const inputElement = element;
      if (multiple2 && !inputElement.multiple && !inputElement.webkitdirectory)
        throw injected.createStacklessError("Non-multiple file input can only accept single file");
      if (directoryUpload && !inputElement.webkitdirectory)
        throw injected.createStacklessError("File input does not support directories, pass individual files instead");
      if (!directoryUpload && inputElement.webkitdirectory)
        throw injected.createStacklessError("[webkitdirectory] input requires passing a path to a directory");
      return inputElement;
    }, { multiple, directoryUpload: !!localDirectory });
    if (result === "error:notconnected" || !result.asElement())
      return "error:notconnected";
    const retargeted = result.asElement();
    await this.instrumentation.onBeforeInputAction(this, progress3.metadata);
    progress3.throwIfAborted();
    if (localPaths || localDirectory) {
      const localPathsOrDirectory = localDirectory ? [localDirectory] : localPaths;
      await Promise.all(localPathsOrDirectory.map((localPath) => fs.promises.access(localPath, fs.constants.F_OK)));
      const waitForInputEvent = localDirectory ? this.evaluate((node2) => new Promise((fulfill) => {
        node2.addEventListener("input", fulfill, { once: true });
      })).catch(() => {
      }) : Promise.resolve();
      await this._page._delegate.setInputFilePaths(retargeted, localPathsOrDirectory);
      await waitForInputEvent;
    } else {
      await retargeted.evaluateInUtility(([injected, node2, files]) => injected.setInputFiles(node2, files), filePayloads);
    }
    return "done";
  }
  async focus(metadata) {
    const controller = new ProgressController(metadata, this);
    await controller.run(async (progress3) => {
      await this._markAsTargetElement(metadata);
      const result = await this._focus(progress3);
      return assertDone(throwRetargetableDOMError(result));
    }, 0);
  }
  async _focus(progress3, resetSelectionIfNotFocused) {
    progress3.throwIfAborted();
    return await this.evaluateInUtility(([injected, node2, resetSelectionIfNotFocused2]) => injected.focusNode(node2, resetSelectionIfNotFocused2), resetSelectionIfNotFocused);
  }
  async _blur(progress3) {
    progress3.throwIfAborted();
    return await this.evaluateInUtility(([injected, node2]) => injected.blurNode(node2), {});
  }
  async type(metadata, text, options2) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      await this._markAsTargetElement(metadata);
      const result = await this._type(progress3, text, options2);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async _type(progress3, text, options2) {
    progress3.log(`elementHandle.type("${text}")`);
    await this.instrumentation.onBeforeInputAction(this, progress3.metadata);
    const result = await this._focus(
      progress3,
      true
      /* resetSelectionIfNotFocused */
    );
    if (result !== "done")
      return result;
    progress3.throwIfAborted();
    await this._page.keyboard.type(text, options2);
    return "done";
  }
  async press(metadata, key, options2) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      await this._markAsTargetElement(metadata);
      const result = await this._press(progress3, key, options2);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async _press(progress3, key, options2) {
    progress3.log(`elementHandle.press("${key}")`);
    await this.instrumentation.onBeforeInputAction(this, progress3.metadata);
    return this._page._frameManager.waitForSignalsCreatedBy(progress3, !options2.noWaitAfter, async () => {
      const result = await this._focus(
        progress3,
        true
        /* resetSelectionIfNotFocused */
      );
      if (result !== "done")
        return result;
      progress3.throwIfAborted();
      await this._page.keyboard.press(key, options2);
      return "done";
    });
  }
  async check(metadata, options2) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      const result = await this._setChecked(progress3, true, options2);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async uncheck(metadata, options2) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      const result = await this._setChecked(progress3, false, options2);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async _setChecked(progress3, state, options2) {
    const isChecked = /* @__PURE__ */ __name(async () => {
      const result2 = await this.evaluateInUtility(([injected, node2]) => injected.elementState(node2, "checked"), {});
      if (result2 === "error:notconnected" || result2.received === "error:notconnected")
        throwElementIsNotAttached();
      return result2.matches;
    }, "isChecked");
    await this._markAsTargetElement(progress3.metadata);
    if (await isChecked() === state)
      return "done";
    const result = await this._click(progress3, { ...options2, waitAfter: "disabled" });
    if (result !== "done")
      return result;
    if (options2.trial)
      return "done";
    if (await isChecked() !== state)
      throw new NonRecoverableDOMError("Clicking the checkbox did not change its state");
    return "done";
  }
  async boundingBox() {
    return this._page._delegate.getBoundingBox(this);
  }
  async ariaSnapshot(options2) {
    return await this.evaluateInUtility(([injected, element, options22]) => injected.ariaSnapshot(element, options22), options2);
  }
  async screenshot(metadata, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(
      (progress3) => this._page._screenshotter.screenshotElement(progress3, this, options2),
      this._page._timeoutSettings.timeout(options2)
    );
  }
  async querySelector(selector, options2) {
    return this._frame.selectors.query(selector, options2, this);
  }
  async querySelectorAll(selector) {
    return this._frame.selectors.queryAll(selector, this);
  }
  async evalOnSelector(selector, strict, expression, isFunction2, arg) {
    return this._frame.evalOnSelector(selector, strict, expression, isFunction2, arg, this);
  }
  async evalOnSelectorAll(selector, expression, isFunction2, arg) {
    return this._frame.evalOnSelectorAll(selector, expression, isFunction2, arg, this);
  }
  async isVisible(metadata) {
    return this._frame.isVisible(metadata, ":scope", {}, this);
  }
  async isHidden(metadata) {
    return this._frame.isHidden(metadata, ":scope", {}, this);
  }
  async isEnabled(metadata) {
    return this._frame.isEnabled(metadata, ":scope", {}, this);
  }
  async isDisabled(metadata) {
    return this._frame.isDisabled(metadata, ":scope", {}, this);
  }
  async isEditable(metadata) {
    return this._frame.isEditable(metadata, ":scope", {}, this);
  }
  async isChecked(metadata) {
    return this._frame.isChecked(metadata, ":scope", {}, this);
  }
  async waitForElementState(metadata, state, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      const actionName = `wait for ${state}`;
      const result = await this._retryAction(progress3, actionName, async () => {
        return await this.evaluateInUtility(async ([injected, node2, state2]) => {
          return await injected.checkElementStates(node2, [state2]) || "done";
        }, state);
      }, {});
      assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async waitForSelector(metadata, selector, options2 = {}) {
    return this._frame.waitForSelector(metadata, selector, options2, this);
  }
  async _adoptTo(context2) {
    if (this._context !== context2) {
      const adopted = await this._page._delegate.adoptElementHandle(this, context2);
      this.dispose();
      return adopted;
    }
    return this;
  }
  async _checkFrameIsHitTarget(point) {
    let frame = this._frame;
    const data = [];
    while (frame.parentFrame()) {
      const frameElement = await frame.frameElement();
      const box = await frameElement.boundingBox();
      const style = await frameElement.evaluateInUtility(([injected, iframe]) => injected.describeIFrameStyle(iframe), {}).catch((e) => "error:notconnected");
      if (!box || style === "error:notconnected")
        return "error:notconnected";
      if (style === "transformed") {
        return { framePoint: void 0 };
      }
      const pointInFrame = { x: point.x - box.x - style.left, y: point.y - box.y - style.top };
      data.push({ frame, frameElement, pointInFrame });
      frame = frame.parentFrame();
    }
    data.push({ frame, frameElement: null, pointInFrame: point });
    for (let i = data.length - 1; i > 0; i--) {
      const element = data[i - 1].frameElement;
      const point2 = data[i].pointInFrame;
      const hitTargetResult = await element.evaluateInUtility(([injected, element2, hitPoint]) => {
        return injected.expectHitTarget(hitPoint, element2);
      }, point2);
      if (hitTargetResult !== "done")
        return hitTargetResult;
    }
    return { framePoint: data[0].pointInFrame };
  }
};
function throwRetargetableDOMError(result) {
  if (result === "error:notconnected")
    throwElementIsNotAttached();
  return result;
}
__name(throwRetargetableDOMError, "throwRetargetableDOMError");
function throwElementIsNotAttached() {
  throw new Error("Element is not attached to the DOM");
}
__name(throwElementIsNotAttached, "throwElementIsNotAttached");
function assertDone(result) {
}
__name(assertDone, "assertDone");
function roundPoint(point) {
  return {
    x: (point.x * 100 | 0) / 100,
    y: (point.y * 100 | 0) / 100
  };
}
__name(roundPoint, "roundPoint");
function quadMiddlePoint(quad) {
  const result = { x: 0, y: 0 };
  for (const point of quad) {
    result.x += point.x / 4;
    result.y += point.y / 4;
  }
  return result;
}
__name(quadMiddlePoint, "quadMiddlePoint");
function triangleArea(p1, p2, p3) {
  return Math.abs(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2;
}
__name(triangleArea, "triangleArea");
function isPointInsideQuad(point, quad) {
  const area1 = triangleArea(point, quad[0], quad[1]) + triangleArea(point, quad[1], quad[2]) + triangleArea(point, quad[2], quad[3]) + triangleArea(point, quad[3], quad[0]);
  const area2 = triangleArea(quad[0], quad[1], quad[2]) + triangleArea(quad[1], quad[2], quad[3]);
  if (Math.abs(area1 - area2) > 0.1)
    return false;
  return point.x < Math.max(quad[0].x, quad[1].x, quad[2].x, quad[3].x) && point.y < Math.max(quad[0].y, quad[1].y, quad[2].y, quad[3].y);
}
__name(isPointInsideQuad, "isPointInsideQuad");
function findIntegerPointInsideQuad(quad) {
  const point = quadMiddlePoint(quad);
  point.x = Math.floor(point.x);
  point.y = Math.floor(point.y);
  if (isPointInsideQuad(point, quad))
    return point;
  point.x += 1;
  if (isPointInsideQuad(point, quad))
    return point;
  point.y += 1;
  if (isPointInsideQuad(point, quad))
    return point;
  point.x -= 1;
  if (isPointInsideQuad(point, quad))
    return point;
}
__name(findIntegerPointInsideQuad, "findIntegerPointInsideQuad");
var kUnableToAdoptErrorMessage = "Unable to adopt element handle from a different document";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/frameSelectors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var FrameSelectors = class {
  static {
    __name(this, "FrameSelectors");
  }
  constructor(frame) {
    this.frame = frame;
  }
  _parseSelector(selector, options2) {
    const strict = typeof options2?.strict === "boolean" ? options2.strict : !!this.frame._page.context()._options.strictSelectors;
    return this.frame._page.context().selectors().parseSelector(selector, strict);
  }
  async query(selector, options2, scope) {
    const resolved = await this.resolveInjectedForSelector(selector, options2, scope);
    if (!resolved)
      return null;
    const handle = await resolved.injected.evaluateHandle((injected, { info: info3, scope: scope2 }) => {
      return injected.querySelector(info3.parsed, scope2 || document, info3.strict);
    }, { info: resolved.info, scope: resolved.scope });
    const elementHandle = handle.asElement();
    if (!elementHandle) {
      handle.dispose();
      return null;
    }
    return adoptIfNeeded(elementHandle, await resolved.frame._mainContext());
  }
  async queryArrayInMainWorld(selector, scope) {
    const resolved = await this.resolveInjectedForSelector(selector, { mainWorld: true }, scope);
    if (!resolved)
      throw new Error(`Failed to find frame for selector "${selector}"`);
    return await resolved.injected.evaluateHandle((injected, { info: info3, scope: scope2 }) => {
      return injected.querySelectorAll(info3.parsed, scope2 || document);
    }, { info: resolved.info, scope: resolved.scope });
  }
  async queryCount(selector) {
    const resolved = await this.resolveInjectedForSelector(selector);
    if (!resolved)
      throw new Error(`Failed to find frame for selector "${selector}"`);
    return await resolved.injected.evaluate((injected, { info: info3 }) => {
      return injected.querySelectorAll(info3.parsed, document).length;
    }, { info: resolved.info });
  }
  async queryAll(selector, scope) {
    const resolved = await this.resolveInjectedForSelector(selector, {}, scope);
    if (!resolved)
      return [];
    const arrayHandle = await resolved.injected.evaluateHandle((injected, { info: info3, scope: scope2 }) => {
      return injected.querySelectorAll(info3.parsed, scope2 || document);
    }, { info: resolved.info, scope: resolved.scope });
    const properties = await arrayHandle.getProperties();
    arrayHandle.dispose();
    const targetContext = await resolved.frame._mainContext();
    const result = [];
    for (const property of properties.values()) {
      const elementHandle = property.asElement();
      if (elementHandle)
        result.push(adoptIfNeeded(elementHandle, targetContext));
      else
        property.dispose();
    }
    return Promise.all(result);
  }
  async resolveFrameForSelector(selector, options2 = {}, scope) {
    let frame = this.frame;
    const frameChunks = splitSelectorByFrame(selector);
    for (const chunk of frameChunks) {
      visitAllSelectorParts(chunk, (part, nested) => {
        if (nested && part.name === "internal:control" && part.body === "enter-frame") {
          const locator = asLocator(this.frame._page.attribution.playwright.options.sdkLanguage, selector);
          throw new InvalidSelectorError(`Frame locators are not allowed inside composite locators, while querying "${locator}"`);
        }
      });
    }
    for (let i = 0; i < frameChunks.length - 1; ++i) {
      const info3 = this._parseSelector(frameChunks[i], options2);
      const context2 = await frame._context(info3.world);
      const injectedScript = await context2.injectedScript();
      const handle = await injectedScript.evaluateHandle((injected, { info: info22, scope: scope2, selectorString }) => {
        const element2 = injected.querySelector(info22.parsed, scope2 || document, info22.strict);
        if (element2 && element2.nodeName !== "IFRAME" && element2.nodeName !== "FRAME")
          throw injected.createStacklessError(`Selector "${selectorString}" resolved to ${injected.previewNode(element2)}, <iframe> was expected`);
        return element2;
      }, { info: info3, scope: i === 0 ? scope : void 0, selectorString: stringifySelector(info3.parsed) });
      const element = handle.asElement();
      if (!element)
        return null;
      const maybeFrame = await frame._page._delegate.getContentFrame(element);
      element.dispose();
      if (!maybeFrame)
        return null;
      frame = maybeFrame;
    }
    if (frame !== this.frame)
      scope = void 0;
    return { frame, info: frame.selectors._parseSelector(frameChunks[frameChunks.length - 1], options2), scope };
  }
  async resolveInjectedForSelector(selector, options2, scope) {
    const resolved = await this.resolveFrameForSelector(selector, options2, scope);
    if (!resolved)
      return;
    const context2 = await resolved.frame._context(options2?.mainWorld ? "main" : resolved.info.world);
    const injected = await context2.injectedScript();
    return { injected, info: resolved.info, frame: resolved.frame, scope: resolved.scope };
  }
};
async function adoptIfNeeded(handle, context2) {
  if (handle._context === context2)
    return handle;
  const adopted = await handle._page._delegate.adoptElementHandle(handle, context2);
  handle.dispose();
  return adopted;
}
__name(adoptIfNeeded, "adoptIfNeeded");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/helper.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MAX_LOG_LENGTH = process.env.MAX_LOG_LENGTH ? +process.env.MAX_LOG_LENGTH : Infinity;
var Helper = class {
  static {
    __name(this, "Helper");
  }
  static completeUserURL(urlString) {
    if (urlString.startsWith("localhost") || urlString.startsWith("127.0.0.1"))
      urlString = "http://" + urlString;
    return urlString;
  }
  static enclosingIntRect(rect) {
    const x = Math.floor(rect.x + 1e-3);
    const y = Math.floor(rect.y + 1e-3);
    const x2 = Math.ceil(rect.x + rect.width - 1e-3);
    const y2 = Math.ceil(rect.y + rect.height - 1e-3);
    return { x, y, width: x2 - x, height: y2 - y };
  }
  static enclosingIntSize(size) {
    return { width: Math.floor(size.width + 1e-3), height: Math.floor(size.height + 1e-3) };
  }
  static getViewportSizeFromWindowFeatures(features2) {
    const widthString = features2.find((f) => f.startsWith("width="));
    const heightString = features2.find((f) => f.startsWith("height="));
    const width = widthString ? parseInt(widthString.substring(6), 10) : NaN;
    const height = heightString ? parseInt(heightString.substring(7), 10) : NaN;
    if (!Number.isNaN(width) && !Number.isNaN(height))
      return { width, height };
    return null;
  }
  static waitForEvent(progress3, emitter, event, predicate) {
    const listeners2 = [];
    const promise = new Promise((resolve, reject) => {
      listeners2.push(eventsHelper.addEventListener(emitter, event, (eventArg) => {
        try {
          if (predicate && !predicate(eventArg))
            return;
          eventsHelper.removeEventListeners(listeners2);
          resolve(eventArg);
        } catch (e) {
          eventsHelper.removeEventListeners(listeners2);
          reject(e);
        }
      }));
    });
    const dispose = /* @__PURE__ */ __name(() => eventsHelper.removeEventListeners(listeners2), "dispose");
    if (progress3)
      progress3.cleanupWhenAborted(dispose);
    return { promise, dispose };
  }
  static secondsToRoundishMillis(value) {
    return (value * 1e6 | 0) / 1e3;
  }
  static millisToRoundishMillis(value) {
    return (value * 1e3 | 0) / 1e3;
  }
  static debugProtocolLogger(protocolLogger) {
    return (direction, message) => {
      if (protocolLogger)
        protocolLogger(direction, message);
      if (debugLogger.isEnabled("protocol")) {
        let text = JSON.stringify(message);
        if (text.length > MAX_LOG_LENGTH)
          text = text.substring(0, MAX_LOG_LENGTH / 2) + " <<<<<( LOG TRUNCATED )>>>>> " + text.substring(text.length - MAX_LOG_LENGTH / 2);
        debugLogger.log("protocol", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + text);
      }
    };
  }
  static formatBrowserLogs(logs, disconnectReason) {
    if (!disconnectReason && !logs.length)
      return "";
    return "\n" + (disconnectReason ? disconnectReason + "\n" : "") + logs.join("\n");
  }
};
var helper = Helper;

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/network.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
function filterCookies(cookies, urls) {
  const parsedURLs = urls.map((s) => new URL(s));
  return cookies.filter((c) => {
    if (!parsedURLs.length)
      return true;
    for (const parsedURL of parsedURLs) {
      let domain2 = c.domain;
      if (!domain2.startsWith("."))
        domain2 = "." + domain2;
      if (!("." + parsedURL.hostname).endsWith(domain2))
        continue;
      if (!parsedURL.pathname.startsWith(c.path))
        continue;
      if (parsedURL.protocol !== "https:" && parsedURL.hostname !== "localhost" && c.secure)
        continue;
      return true;
    }
    return false;
  });
}
__name(filterCookies, "filterCookies");
var kMaxCookieExpiresDateInSeconds = 253402300799;
function rewriteCookies(cookies) {
  return cookies.map((c) => {
    assert3(c.url || c.domain && c.path, "Cookie should have a url or a domain/path pair");
    assert3(!(c.url && c.domain), "Cookie should have either url or domain");
    assert3(!(c.url && c.path), "Cookie should have either url or path");
    assert3(!(c.expires && c.expires < 0 && c.expires !== -1), "Cookie should have a valid expires, only -1 or a positive number for the unix timestamp in seconds is allowed");
    assert3(!(c.expires && c.expires > 0 && c.expires > kMaxCookieExpiresDateInSeconds), "Cookie should have a valid expires, only -1 or a positive number for the unix timestamp in seconds is allowed");
    const copy = { ...c };
    if (copy.url) {
      assert3(copy.url !== "about:blank", `Blank page can not have cookie "${c.name}"`);
      assert3(!copy.url.startsWith("data:"), `Data URL page can not have cookie "${c.name}"`);
      const url4 = new URL(copy.url);
      copy.domain = url4.hostname;
      copy.path = url4.pathname.substring(0, url4.pathname.lastIndexOf("/") + 1);
      copy.secure = url4.protocol === "https:";
    }
    return copy;
  });
}
__name(rewriteCookies, "rewriteCookies");
function parseURL2(url4) {
  try {
    return new URL(url4);
  } catch (e) {
    return null;
  }
}
__name(parseURL2, "parseURL");
function stripFragmentFromUrl(url4) {
  if (!url4.includes("#"))
    return url4;
  return url4.substring(0, url4.indexOf("#"));
}
__name(stripFragmentFromUrl, "stripFragmentFromUrl");
var Request = class extends SdkObject {
  static {
    __name(this, "Request");
  }
  constructor(context2, frame, serviceWorker, redirectedFrom, documentId, url4, resourceType, method, postData, headers) {
    super(frame || context2, "request");
    this._response = null;
    this._redirectedTo = null;
    this._failureText = null;
    this._headersMap = /* @__PURE__ */ new Map();
    this._frame = null;
    this._serviceWorker = null;
    this._rawRequestHeadersPromise = new ManualPromise();
    this._waitForResponsePromise = new ManualPromise();
    this._responseEndTiming = -1;
    assert3(!url4.startsWith("data:"), "Data urls should not fire requests");
    this._context = context2;
    this._frame = frame;
    this._serviceWorker = serviceWorker;
    this._redirectedFrom = redirectedFrom;
    if (redirectedFrom)
      redirectedFrom._redirectedTo = this;
    this._documentId = documentId;
    this._url = stripFragmentFromUrl(url4);
    this._resourceType = resourceType;
    this._method = method;
    this._postData = postData;
    this._headers = headers;
    this._updateHeadersMap();
    this._isFavicon = url4.endsWith("/favicon.ico") || !!redirectedFrom?._isFavicon;
  }
  _setFailureText(failureText) {
    this._failureText = failureText;
    this._waitForResponsePromise.resolve(null);
  }
  _setOverrides(overrides) {
    this._overrides = overrides;
    this._updateHeadersMap();
  }
  _updateHeadersMap() {
    for (const { name, value } of this.headers())
      this._headersMap.set(name.toLowerCase(), value);
  }
  _hasOverrides() {
    return !!this._overrides;
  }
  url() {
    return this._overrides?.url || this._url;
  }
  resourceType() {
    return this._resourceType;
  }
  method() {
    return this._overrides?.method || this._method;
  }
  postDataBuffer() {
    return this._overrides?.postData || this._postData;
  }
  headers() {
    return this._overrides?.headers || this._headers;
  }
  headerValue(name) {
    return this._headersMap.get(name);
  }
  // "null" means no raw headers available - we'll use provisional headers as raw headers.
  setRawRequestHeaders(headers) {
    if (!this._rawRequestHeadersPromise.isDone())
      this._rawRequestHeadersPromise.resolve(headers || this._headers);
  }
  async rawRequestHeaders() {
    return this._overrides?.headers || this._rawRequestHeadersPromise;
  }
  response() {
    return this._waitForResponsePromise;
  }
  _existingResponse() {
    return this._response;
  }
  _setResponse(response) {
    this._response = response;
    this._waitForResponsePromise.resolve(response);
  }
  _finalRequest() {
    return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
  }
  frame() {
    return this._frame;
  }
  serviceWorker() {
    return this._serviceWorker;
  }
  isNavigationRequest() {
    return !!this._documentId;
  }
  redirectedFrom() {
    return this._redirectedFrom;
  }
  failure() {
    if (this._failureText === null)
      return null;
    return {
      errorText: this._failureText
    };
  }
  // TODO(bidi): remove once post body is available.
  _setBodySize(size) {
    this._bodySize = size;
  }
  bodySize() {
    return this._bodySize || this.postDataBuffer()?.length || 0;
  }
  async requestHeadersSize() {
    let headersSize = 4;
    headersSize += this.method().length;
    headersSize += new URL(this.url()).pathname.length;
    headersSize += 8;
    const headers = await this.rawRequestHeaders();
    for (const header of headers)
      headersSize += header.name.length + header.value.length + 4;
    return headersSize;
  }
};
var Route = class extends SdkObject {
  static {
    __name(this, "Route");
  }
  constructor(request4, delegate) {
    super(request4._frame || request4._context, "route");
    this._handled = false;
    this._request = request4;
    this._delegate = delegate;
    this._request._context.addRouteInFlight(this);
  }
  request() {
    return this._request;
  }
  async abort(errorCode = "failed") {
    this._startHandling();
    this._request._context.emit(BrowserContext.Events.RequestAborted, this._request);
    await this._delegate.abort(errorCode);
    this._endHandling();
  }
  async redirectNavigationRequest(url4) {
    this._startHandling();
    assert3(this._request.isNavigationRequest());
    this._request.frame().redirectNavigation(url4, this._request._documentId, this._request.headerValue("referer"));
  }
  async fulfill(overrides) {
    this._startHandling();
    let body = overrides.body;
    let isBase64 = overrides.isBase64 || false;
    if (body === void 0) {
      if (overrides.fetchResponseUid) {
        const buffer2 = this._request._context.fetchRequest.fetchResponses.get(overrides.fetchResponseUid) || APIRequestContext.findResponseBody(overrides.fetchResponseUid);
        assert3(buffer2, "Fetch response has been disposed");
        body = buffer2.toString("base64");
        isBase64 = true;
      } else {
        body = "";
        isBase64 = false;
      }
    }
    const headers = [...overrides.headers || []];
    this._maybeAddCorsHeaders(headers);
    this._request._context.emit(BrowserContext.Events.RequestFulfilled, this._request);
    await this._delegate.fulfill({
      status: overrides.status || 200,
      headers,
      body,
      isBase64
    });
    this._endHandling();
  }
  // See https://github.com/microsoft/playwright/issues/12929
  _maybeAddCorsHeaders(headers) {
    const origin = this._request.headerValue("origin");
    if (!origin)
      return;
    const requestUrl = new URL(this._request.url());
    if (!requestUrl.protocol.startsWith("http"))
      return;
    if (requestUrl.origin === origin.trim())
      return;
    const corsHeader = headers.find(({ name }) => name === "access-control-allow-origin");
    if (corsHeader)
      return;
    headers.push({ name: "access-control-allow-origin", value: origin });
    headers.push({ name: "access-control-allow-credentials", value: "true" });
    headers.push({ name: "vary", value: "Origin" });
  }
  async continue(overrides) {
    this._startHandling();
    if (overrides.url) {
      const newUrl = new URL(overrides.url);
      const oldUrl = new URL(this._request.url());
      if (oldUrl.protocol !== newUrl.protocol)
        throw new Error("New URL must have same protocol as overridden URL");
    }
    if (overrides.headers)
      overrides.headers = overrides.headers?.filter((header) => header.name.toLowerCase() !== "cookie");
    this._request._setOverrides(overrides);
    if (!overrides.isFallback)
      this._request._context.emit(BrowserContext.Events.RequestContinued, this._request);
    await this._delegate.continue(overrides);
    this._endHandling();
  }
  _startHandling() {
    assert3(!this._handled, "Route is already handled!");
    this._handled = true;
  }
  _endHandling() {
    this._request._context.removeRouteInFlight(this);
  }
};
var Response2 = class extends SdkObject {
  static {
    __name(this, "Response");
  }
  constructor(request4, status, statusText2, headers, timing, getResponseBodyCallback, fromServiceWorker, httpVersion) {
    super(request4.frame() || request4._context, "response");
    this._contentPromise = null;
    this._finishedPromise = new ManualPromise();
    this._headersMap = /* @__PURE__ */ new Map();
    this._serverAddrPromise = new ManualPromise();
    this._securityDetailsPromise = new ManualPromise();
    this._rawResponseHeadersPromise = new ManualPromise();
    this._encodedBodySizePromise = new ManualPromise();
    this._transferSizePromise = new ManualPromise();
    this._responseHeadersSizePromise = new ManualPromise();
    this._request = request4;
    this._timing = timing;
    this._status = status;
    this._statusText = statusText2;
    this._url = request4.url();
    this._headers = headers;
    for (const { name, value } of this._headers)
      this._headersMap.set(name.toLowerCase(), value);
    this._getResponseBodyCallback = getResponseBodyCallback;
    this._request._setResponse(this);
    this._httpVersion = httpVersion;
    this._fromServiceWorker = fromServiceWorker;
  }
  _serverAddrFinished(addr) {
    this._serverAddrPromise.resolve(addr);
  }
  _securityDetailsFinished(securityDetails) {
    this._securityDetailsPromise.resolve(securityDetails);
  }
  _requestFinished(responseEndTiming) {
    this._request._responseEndTiming = Math.max(responseEndTiming, this._timing.responseStart);
    if (this._timing.requestStart === -1)
      this._timing.requestStart = this._request._responseEndTiming;
    this._finishedPromise.resolve();
  }
  _setHttpVersion(httpVersion) {
    this._httpVersion = httpVersion;
  }
  url() {
    return this._url;
  }
  status() {
    return this._status;
  }
  statusText() {
    return this._statusText;
  }
  headers() {
    return this._headers;
  }
  headerValue(name) {
    return this._headersMap.get(name);
  }
  async rawResponseHeaders() {
    return this._rawResponseHeadersPromise;
  }
  // "null" means no raw headers available - we'll use provisional headers as raw headers.
  setRawResponseHeaders(headers) {
    if (!this._rawResponseHeadersPromise.isDone())
      this._rawResponseHeadersPromise.resolve(headers || this._headers);
  }
  setTransferSize(size) {
    this._transferSizePromise.resolve(size);
  }
  setEncodedBodySize(size) {
    this._encodedBodySizePromise.resolve(size);
  }
  setResponseHeadersSize(size) {
    this._responseHeadersSizePromise.resolve(size);
  }
  timing() {
    return this._timing;
  }
  async serverAddr() {
    return await this._serverAddrPromise || null;
  }
  async securityDetails() {
    return await this._securityDetailsPromise || null;
  }
  body() {
    if (!this._contentPromise) {
      this._contentPromise = this._finishedPromise.then(async () => {
        if (this._status >= 300 && this._status <= 399)
          throw new Error("Response body is unavailable for redirect responses");
        return this._getResponseBodyCallback();
      });
    }
    return this._contentPromise;
  }
  request() {
    return this._request;
  }
  frame() {
    return this._request.frame();
  }
  httpVersion() {
    if (!this._httpVersion)
      return "HTTP/1.1";
    if (this._httpVersion === "http/1.1")
      return "HTTP/1.1";
    if (this._httpVersion === "h2")
      return "HTTP/2.0";
    return this._httpVersion;
  }
  fromServiceWorker() {
    return this._fromServiceWorker;
  }
  async responseHeadersSize() {
    const availableSize = await this._responseHeadersSizePromise;
    if (availableSize !== null)
      return availableSize;
    let headersSize = 4;
    headersSize += 8;
    headersSize += 3;
    headersSize += this.statusText().length;
    const headers = await this._rawResponseHeadersPromise;
    for (const header of headers)
      headersSize += header.name.length + header.value.length + 4;
    headersSize += 2;
    return headersSize;
  }
  async sizes() {
    const requestHeadersSize = await this._request.requestHeadersSize();
    const responseHeadersSize = await this.responseHeadersSize();
    let encodedBodySize = await this._encodedBodySizePromise;
    if (encodedBodySize === null) {
      const headers = await this._rawResponseHeadersPromise;
      const contentLength = headers.find((h) => h.name.toLowerCase() === "content-length")?.value;
      encodedBodySize = contentLength ? +contentLength : 0;
    }
    let transferSize = await this._transferSizePromise;
    if (transferSize === null) {
      transferSize = responseHeadersSize + encodedBodySize;
    }
    return {
      requestBodySize: this._request.bodySize(),
      requestHeadersSize,
      responseBodySize: encodedBodySize,
      responseHeadersSize,
      transferSize
    };
  }
};
var WebSocket3 = class _WebSocket extends SdkObject {
  static {
    __name(this, "WebSocket");
  }
  constructor(parent, url4) {
    super(parent, "ws");
    this._notified = false;
    this._url = url4;
  }
  static {
    this.Events = {
      Close: "close",
      SocketError: "socketerror",
      FrameReceived: "framereceived",
      FrameSent: "framesent"
    };
  }
  markAsNotified() {
    if (this._notified)
      return false;
    this._notified = true;
    return true;
  }
  url() {
    return this._url;
  }
  frameSent(opcode, data) {
    this.emit(_WebSocket.Events.FrameSent, { opcode, data });
  }
  frameReceived(opcode, data) {
    this.emit(_WebSocket.Events.FrameReceived, { opcode, data });
  }
  error(errorMessage) {
    this.emit(_WebSocket.Events.SocketError, errorMessage);
  }
  closed() {
    this.emit(_WebSocket.Events.Close);
  }
};
var STATUS_TEXTS = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "306": "Switch Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
function statusText(status) {
  return STATUS_TEXTS[String(status)] || "Unknown";
}
__name(statusText, "statusText");
function singleHeader(name, value) {
  return [{ name, value }];
}
__name(singleHeader, "singleHeader");
function mergeHeaders(headers) {
  const lowerCaseToValue = /* @__PURE__ */ new Map();
  const lowerCaseToOriginalCase = /* @__PURE__ */ new Map();
  for (const h of headers) {
    if (!h)
      continue;
    for (const { name, value } of h) {
      const lower = name.toLowerCase();
      lowerCaseToOriginalCase.set(lower, name);
      lowerCaseToValue.set(lower, value);
    }
  }
  const result = [];
  for (const [lower, value] of lowerCaseToValue)
    result.push({ name: lowerCaseToOriginalCase.get(lower), value });
  return result;
}
__name(mergeHeaders, "mergeHeaders");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/page.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/accessibility.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Accessibility = class {
  static {
    __name(this, "Accessibility");
  }
  constructor(getAXTree) {
    this._getAXTree = getAXTree;
  }
  async snapshot(options2 = {}) {
    const {
      interestingOnly = true,
      root = null
    } = options2;
    const { tree, needle } = await this._getAXTree(root || void 0);
    if (!interestingOnly) {
      if (root)
        return needle && serializeTree(needle)[0];
      return serializeTree(tree)[0];
    }
    const interestingNodes = /* @__PURE__ */ new Set();
    collectInterestingNodes(interestingNodes, tree, false);
    if (root && (!needle || !interestingNodes.has(needle)))
      return null;
    return serializeTree(needle || tree, interestingNodes)[0];
  }
};
function collectInterestingNodes(collection, node2, insideControl) {
  if (node2.isInteresting(insideControl))
    collection.add(node2);
  if (node2.isLeafNode())
    return;
  insideControl = insideControl || node2.isControl();
  for (const child of node2.children())
    collectInterestingNodes(collection, child, insideControl);
}
__name(collectInterestingNodes, "collectInterestingNodes");
function serializeTree(node2, whitelistedNodes) {
  const children = [];
  for (const child of node2.children())
    children.push(...serializeTree(child, whitelistedNodes));
  if (whitelistedNodes && !whitelistedNodes.has(node2))
    return children;
  const serializedNode = node2.serialize();
  if (children.length)
    serializedNode.children = children;
  return [serializedNode];
}
__name(serializeTree, "serializeTree");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/console.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ConsoleMessage = class {
  static {
    __name(this, "ConsoleMessage");
  }
  constructor(page, type2, text, args, location2) {
    this._page = page;
    this._type = type2;
    this._text = text;
    this._args = args;
    this._location = location2 || { url: "", lineNumber: 0, columnNumber: 0 };
  }
  page() {
    return this._page;
  }
  type() {
    return this._type;
  }
  text() {
    if (this._text === void 0)
      this._text = this._args.map((arg) => arg.preview()).join(" ");
    return this._text;
  }
  args() {
    return this._args;
  }
  location() {
    return this._location;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/fileChooser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FileChooser = class {
  static {
    __name(this, "FileChooser");
  }
  constructor(page, elementHandle, isMultiple) {
    this._page = page;
    this._elementHandle = elementHandle;
    this._isMultiple = isMultiple;
  }
  element() {
    return this._elementHandle;
  }
  isMultiple() {
    return this._isMultiple;
  }
  page() {
    return this._page;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/input.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/usKeyboardLayout.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keypadLocation = 3;
var USKeyboardLayout = {
  // Functions row
  "Escape": { "keyCode": 27, "key": "Escape" },
  "F1": { "keyCode": 112, "key": "F1" },
  "F2": { "keyCode": 113, "key": "F2" },
  "F3": { "keyCode": 114, "key": "F3" },
  "F4": { "keyCode": 115, "key": "F4" },
  "F5": { "keyCode": 116, "key": "F5" },
  "F6": { "keyCode": 117, "key": "F6" },
  "F7": { "keyCode": 118, "key": "F7" },
  "F8": { "keyCode": 119, "key": "F8" },
  "F9": { "keyCode": 120, "key": "F9" },
  "F10": { "keyCode": 121, "key": "F10" },
  "F11": { "keyCode": 122, "key": "F11" },
  "F12": { "keyCode": 123, "key": "F12" },
  // Numbers row
  "Backquote": { "keyCode": 192, "shiftKey": "~", "key": "`" },
  "Digit1": { "keyCode": 49, "shiftKey": "!", "key": "1" },
  "Digit2": { "keyCode": 50, "shiftKey": "@", "key": "2" },
  "Digit3": { "keyCode": 51, "shiftKey": "#", "key": "3" },
  "Digit4": { "keyCode": 52, "shiftKey": "$", "key": "4" },
  "Digit5": { "keyCode": 53, "shiftKey": "%", "key": "5" },
  "Digit6": { "keyCode": 54, "shiftKey": "^", "key": "6" },
  "Digit7": { "keyCode": 55, "shiftKey": "&", "key": "7" },
  "Digit8": { "keyCode": 56, "shiftKey": "*", "key": "8" },
  "Digit9": { "keyCode": 57, "shiftKey": "(", "key": "9" },
  "Digit0": { "keyCode": 48, "shiftKey": ")", "key": "0" },
  "Minus": { "keyCode": 189, "shiftKey": "_", "key": "-" },
  "Equal": { "keyCode": 187, "shiftKey": "+", "key": "=" },
  "Backslash": { "keyCode": 220, "shiftKey": "|", "key": "\\" },
  "Backspace": { "keyCode": 8, "key": "Backspace" },
  // First row
  "Tab": { "keyCode": 9, "key": "Tab" },
  "KeyQ": { "keyCode": 81, "shiftKey": "Q", "key": "q" },
  "KeyW": { "keyCode": 87, "shiftKey": "W", "key": "w" },
  "KeyE": { "keyCode": 69, "shiftKey": "E", "key": "e" },
  "KeyR": { "keyCode": 82, "shiftKey": "R", "key": "r" },
  "KeyT": { "keyCode": 84, "shiftKey": "T", "key": "t" },
  "KeyY": { "keyCode": 89, "shiftKey": "Y", "key": "y" },
  "KeyU": { "keyCode": 85, "shiftKey": "U", "key": "u" },
  "KeyI": { "keyCode": 73, "shiftKey": "I", "key": "i" },
  "KeyO": { "keyCode": 79, "shiftKey": "O", "key": "o" },
  "KeyP": { "keyCode": 80, "shiftKey": "P", "key": "p" },
  "BracketLeft": { "keyCode": 219, "shiftKey": "{", "key": "[" },
  "BracketRight": { "keyCode": 221, "shiftKey": "}", "key": "]" },
  // Second row
  "CapsLock": { "keyCode": 20, "key": "CapsLock" },
  "KeyA": { "keyCode": 65, "shiftKey": "A", "key": "a" },
  "KeyS": { "keyCode": 83, "shiftKey": "S", "key": "s" },
  "KeyD": { "keyCode": 68, "shiftKey": "D", "key": "d" },
  "KeyF": { "keyCode": 70, "shiftKey": "F", "key": "f" },
  "KeyG": { "keyCode": 71, "shiftKey": "G", "key": "g" },
  "KeyH": { "keyCode": 72, "shiftKey": "H", "key": "h" },
  "KeyJ": { "keyCode": 74, "shiftKey": "J", "key": "j" },
  "KeyK": { "keyCode": 75, "shiftKey": "K", "key": "k" },
  "KeyL": { "keyCode": 76, "shiftKey": "L", "key": "l" },
  "Semicolon": { "keyCode": 186, "shiftKey": ":", "key": ";" },
  "Quote": { "keyCode": 222, "shiftKey": '"', "key": "'" },
  "Enter": { "keyCode": 13, "key": "Enter", "text": "\r" },
  // Third row
  "ShiftLeft": { "keyCode": 160, "keyCodeWithoutLocation": 16, "key": "Shift", "location": 1 },
  "KeyZ": { "keyCode": 90, "shiftKey": "Z", "key": "z" },
  "KeyX": { "keyCode": 88, "shiftKey": "X", "key": "x" },
  "KeyC": { "keyCode": 67, "shiftKey": "C", "key": "c" },
  "KeyV": { "keyCode": 86, "shiftKey": "V", "key": "v" },
  "KeyB": { "keyCode": 66, "shiftKey": "B", "key": "b" },
  "KeyN": { "keyCode": 78, "shiftKey": "N", "key": "n" },
  "KeyM": { "keyCode": 77, "shiftKey": "M", "key": "m" },
  "Comma": { "keyCode": 188, "shiftKey": "<", "key": "," },
  "Period": { "keyCode": 190, "shiftKey": ">", "key": "." },
  "Slash": { "keyCode": 191, "shiftKey": "?", "key": "/" },
  "ShiftRight": { "keyCode": 161, "keyCodeWithoutLocation": 16, "key": "Shift", "location": 2 },
  // Last row
  "ControlLeft": { "keyCode": 162, "keyCodeWithoutLocation": 17, "key": "Control", "location": 1 },
  "MetaLeft": { "keyCode": 91, "key": "Meta", "location": 1 },
  "AltLeft": { "keyCode": 164, "keyCodeWithoutLocation": 18, "key": "Alt", "location": 1 },
  "Space": { "keyCode": 32, "key": " " },
  "AltRight": { "keyCode": 165, "keyCodeWithoutLocation": 18, "key": "Alt", "location": 2 },
  "AltGraph": { "keyCode": 225, "key": "AltGraph" },
  "MetaRight": { "keyCode": 92, "key": "Meta", "location": 2 },
  "ContextMenu": { "keyCode": 93, "key": "ContextMenu" },
  "ControlRight": { "keyCode": 163, "keyCodeWithoutLocation": 17, "key": "Control", "location": 2 },
  // Center block
  "PrintScreen": { "keyCode": 44, "key": "PrintScreen" },
  "ScrollLock": { "keyCode": 145, "key": "ScrollLock" },
  "Pause": { "keyCode": 19, "key": "Pause" },
  "PageUp": { "keyCode": 33, "key": "PageUp" },
  "PageDown": { "keyCode": 34, "key": "PageDown" },
  "Insert": { "keyCode": 45, "key": "Insert" },
  "Delete": { "keyCode": 46, "key": "Delete" },
  "Home": { "keyCode": 36, "key": "Home" },
  "End": { "keyCode": 35, "key": "End" },
  "ArrowLeft": { "keyCode": 37, "key": "ArrowLeft" },
  "ArrowUp": { "keyCode": 38, "key": "ArrowUp" },
  "ArrowRight": { "keyCode": 39, "key": "ArrowRight" },
  "ArrowDown": { "keyCode": 40, "key": "ArrowDown" },
  // Numpad
  "NumLock": { "keyCode": 144, "key": "NumLock" },
  "NumpadDivide": { "keyCode": 111, "key": "/", "location": 3 },
  "NumpadMultiply": { "keyCode": 106, "key": "*", "location": 3 },
  "NumpadSubtract": { "keyCode": 109, "key": "-", "location": 3 },
  "Numpad7": { "keyCode": 36, "shiftKeyCode": 103, "key": "Home", "shiftKey": "7", "location": 3 },
  "Numpad8": { "keyCode": 38, "shiftKeyCode": 104, "key": "ArrowUp", "shiftKey": "8", "location": 3 },
  "Numpad9": { "keyCode": 33, "shiftKeyCode": 105, "key": "PageUp", "shiftKey": "9", "location": 3 },
  "Numpad4": { "keyCode": 37, "shiftKeyCode": 100, "key": "ArrowLeft", "shiftKey": "4", "location": 3 },
  "Numpad5": { "keyCode": 12, "shiftKeyCode": 101, "key": "Clear", "shiftKey": "5", "location": 3 },
  "Numpad6": { "keyCode": 39, "shiftKeyCode": 102, "key": "ArrowRight", "shiftKey": "6", "location": 3 },
  "NumpadAdd": { "keyCode": 107, "key": "+", "location": 3 },
  "Numpad1": { "keyCode": 35, "shiftKeyCode": 97, "key": "End", "shiftKey": "1", "location": 3 },
  "Numpad2": { "keyCode": 40, "shiftKeyCode": 98, "key": "ArrowDown", "shiftKey": "2", "location": 3 },
  "Numpad3": { "keyCode": 34, "shiftKeyCode": 99, "key": "PageDown", "shiftKey": "3", "location": 3 },
  "Numpad0": { "keyCode": 45, "shiftKeyCode": 96, "key": "Insert", "shiftKey": "0", "location": 3 },
  "NumpadDecimal": { "keyCode": 46, "shiftKeyCode": 110, "key": "\0", "shiftKey": ".", "location": 3 },
  "NumpadEnter": { "keyCode": 13, "key": "Enter", "text": "\r", "location": 3 }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/input.js
var keypadLocation2 = keypadLocation;
var kModifiers = ["Alt", "Control", "Meta", "Shift"];
var Keyboard = class {
  static {
    __name(this, "Keyboard");
  }
  constructor(raw) {
    this._pressedModifiers = /* @__PURE__ */ new Set();
    this._pressedKeys = /* @__PURE__ */ new Set();
    this._raw = raw;
  }
  async down(key) {
    const description = this._keyDescriptionForString(key);
    const autoRepeat = this._pressedKeys.has(description.code);
    this._pressedKeys.add(description.code);
    if (kModifiers.includes(description.key))
      this._pressedModifiers.add(description.key);
    await this._raw.keydown(this._pressedModifiers, key, description, autoRepeat);
  }
  _keyDescriptionForString(str) {
    const keyString = resolveSmartModifierString(str);
    let description = usKeyboardLayout.get(keyString);
    assert3(description, `Unknown key: "${keyString}"`);
    const shift = this._pressedModifiers.has("Shift");
    description = shift && description.shifted ? description.shifted : description;
    if (this._pressedModifiers.size > 1 || !this._pressedModifiers.has("Shift") && this._pressedModifiers.size === 1)
      return { ...description, text: "" };
    return description;
  }
  async up(key) {
    const description = this._keyDescriptionForString(key);
    if (kModifiers.includes(description.key))
      this._pressedModifiers.delete(description.key);
    this._pressedKeys.delete(description.code);
    await this._raw.keyup(this._pressedModifiers, key, description);
  }
  async insertText(text) {
    await this._raw.sendText(text);
  }
  async type(text, options2) {
    const delay = options2 && options2.delay || void 0;
    for (const char of text) {
      if (usKeyboardLayout.has(char)) {
        await this.press(char, { delay });
      } else {
        if (delay)
          await new Promise((f) => setTimeout(f, delay));
        await this.insertText(char);
      }
    }
  }
  async press(key, options2 = {}) {
    function split(keyString) {
      const keys = [];
      let building = "";
      for (const char of keyString) {
        if (char === "+" && building) {
          keys.push(building);
          building = "";
        } else {
          building += char;
        }
      }
      keys.push(building);
      return keys;
    }
    __name(split, "split");
    const tokens = split(key);
    key = tokens[tokens.length - 1];
    for (let i = 0; i < tokens.length - 1; ++i)
      await this.down(tokens[i]);
    await this.down(key);
    if (options2.delay)
      await new Promise((f) => setTimeout(f, options2.delay));
    await this.up(key);
    for (let i = tokens.length - 2; i >= 0; --i)
      await this.up(tokens[i]);
  }
  async ensureModifiers(mm) {
    const modifiers = mm.map(resolveSmartModifier);
    for (const modifier of modifiers) {
      if (!kModifiers.includes(modifier))
        throw new Error("Unknown modifier " + modifier);
    }
    const restore2 = Array.from(this._pressedModifiers);
    for (const key of kModifiers) {
      const needDown = modifiers.includes(key);
      const isDown = this._pressedModifiers.has(key);
      if (needDown && !isDown)
        await this.down(key);
      else if (!needDown && isDown)
        await this.up(key);
    }
    return restore2;
  }
  _modifiers() {
    return this._pressedModifiers;
  }
};
function resolveSmartModifierString(key) {
  if (key === "ControlOrMeta")
    return process.platform === "darwin" ? "Meta" : "Control";
  return key;
}
__name(resolveSmartModifierString, "resolveSmartModifierString");
function resolveSmartModifier(m) {
  return resolveSmartModifierString(m);
}
__name(resolveSmartModifier, "resolveSmartModifier");
var Mouse = class {
  static {
    __name(this, "Mouse");
  }
  constructor(raw, page) {
    this._x = 0;
    this._y = 0;
    this._lastButton = "none";
    this._buttons = /* @__PURE__ */ new Set();
    this._raw = raw;
    this._page = page;
    this._keyboard = this._page.keyboard;
  }
  async move(x, y, options2 = {}, metadata) {
    if (metadata)
      metadata.point = { x, y };
    const { steps = 1 } = options2;
    const fromX = this._x;
    const fromY = this._y;
    this._x = x;
    this._y = y;
    for (let i = 1; i <= steps; i++) {
      const middleX = fromX + (x - fromX) * (i / steps);
      const middleY = fromY + (y - fromY) * (i / steps);
      await this._raw.move(middleX, middleY, this._lastButton, this._buttons, this._keyboard._modifiers(), !!options2.forClick);
    }
  }
  async down(options2 = {}, metadata) {
    if (metadata)
      metadata.point = { x: this._x, y: this._y };
    const { button = "left", clickCount = 1 } = options2;
    this._lastButton = button;
    this._buttons.add(button);
    await this._raw.down(this._x, this._y, this._lastButton, this._buttons, this._keyboard._modifiers(), clickCount);
  }
  async up(options2 = {}, metadata) {
    if (metadata)
      metadata.point = { x: this._x, y: this._y };
    const { button = "left", clickCount = 1 } = options2;
    this._lastButton = "none";
    this._buttons.delete(button);
    await this._raw.up(this._x, this._y, button, this._buttons, this._keyboard._modifiers(), clickCount);
  }
  async click(x, y, options2 = {}, metadata) {
    if (metadata)
      metadata.point = { x, y };
    const { delay = null, clickCount = 1 } = options2;
    if (delay) {
      this.move(x, y, { forClick: true });
      for (let cc = 1; cc <= clickCount; ++cc) {
        await this.down({ ...options2, clickCount: cc });
        await new Promise((f) => setTimeout(f, delay));
        await this.up({ ...options2, clickCount: cc });
        if (cc < clickCount)
          await new Promise((f) => setTimeout(f, delay));
      }
    } else {
      const promises2 = [];
      promises2.push(this.move(x, y, { forClick: true }));
      for (let cc = 1; cc <= clickCount; ++cc) {
        promises2.push(this.down({ ...options2, clickCount: cc }));
        promises2.push(this.up({ ...options2, clickCount: cc }));
      }
      await Promise.all(promises2);
    }
  }
  async dblclick(x, y, options2 = {}) {
    await this.click(x, y, { ...options2, clickCount: 2 });
  }
  async wheel(deltaX, deltaY) {
    await this._raw.wheel(this._x, this._y, this._buttons, this._keyboard._modifiers(), deltaX, deltaY);
  }
};
var aliases = /* @__PURE__ */ new Map([
  ["ShiftLeft", ["Shift"]],
  ["ControlLeft", ["Control"]],
  ["AltLeft", ["Alt"]],
  ["MetaLeft", ["Meta"]],
  ["Enter", ["\n", "\r"]]
]);
var usKeyboardLayout = buildLayoutClosure(USKeyboardLayout);
function buildLayoutClosure(layout) {
  const result = /* @__PURE__ */ new Map();
  for (const code in layout) {
    const definition = layout[code];
    const description = {
      key: definition.key || "",
      keyCode: definition.keyCode || 0,
      keyCodeWithoutLocation: definition.keyCodeWithoutLocation || definition.keyCode || 0,
      code,
      text: definition.text || "",
      location: definition.location || 0
    };
    if (definition.key.length === 1)
      description.text = description.key;
    let shiftedDescription;
    if (definition.shiftKey) {
      assert3(definition.shiftKey.length === 1);
      shiftedDescription = { ...description };
      shiftedDescription.key = definition.shiftKey;
      shiftedDescription.text = definition.shiftKey;
      if (definition.shiftKeyCode)
        shiftedDescription.keyCode = definition.shiftKeyCode;
    }
    result.set(code, { ...description, shifted: shiftedDescription });
    if (aliases.has(code)) {
      for (const alias of aliases.get(code))
        result.set(alias, description);
    }
    if (definition.location)
      continue;
    if (description.key.length === 1)
      result.set(description.key, description);
    if (shiftedDescription)
      result.set(shiftedDescription.key, { ...shiftedDescription, shifted: void 0 });
  }
  return result;
}
__name(buildLayoutClosure, "buildLayoutClosure");
var Touchscreen = class {
  static {
    __name(this, "Touchscreen");
  }
  constructor(raw, page) {
    this._raw = raw;
    this._page = page;
  }
  async tap(x, y, metadata) {
    if (metadata)
      metadata.point = { x, y };
    if (!this._page._browserContext._options.hasTouch)
      throw new Error("hasTouch must be enabled on the browser context before using the touchscreen.");
    await this._raw.tap(x, y, this._page.keyboard._modifiers());
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/pageBinding.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function addPageBinding(playwrightBinding, bindingName, needsHandle, utilityScriptSerializersFactory, builtins2) {
  const { serializeAsCallArgument: serializeAsCallArgument2 } = utilityScriptSerializersFactory(builtins2);
  const binding3 = globalThis[playwrightBinding];
  globalThis[bindingName] = (...args) => {
    const me = globalThis[bindingName];
    if (needsHandle && args.slice(1).some((arg) => arg !== void 0))
      throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);
    let callbacks = me["callbacks"];
    if (!callbacks) {
      callbacks = new builtins2.Map();
      me["callbacks"] = callbacks;
    }
    const seq2 = (me["lastSeq"] || 0) + 1;
    me["lastSeq"] = seq2;
    let handles = me["handles"];
    if (!handles) {
      handles = new builtins2.Map();
      me["handles"] = handles;
    }
    const promise = new Promise((resolve, reject) => callbacks.set(seq2, { resolve, reject }));
    let payload;
    if (needsHandle) {
      handles.set(seq2, args[0]);
      payload = { name: bindingName, seq: seq2 };
    } else {
      const serializedArgs = [];
      for (let i = 0; i < args.length; i++) {
        serializedArgs[i] = serializeAsCallArgument2(args[i], (v) => {
          return { fallThrough: v };
        });
      }
      payload = { name: bindingName, seq: seq2, serializedArgs };
    }
    binding3(JSON.stringify(payload));
    return promise;
  };
  globalThis[bindingName].__installed = true;
}
__name(addPageBinding, "addPageBinding");
function takeBindingHandle(arg) {
  const handles = globalThis[arg.name]["handles"];
  const handle = handles.get(arg.seq);
  handles.delete(arg.seq);
  return handle;
}
__name(takeBindingHandle, "takeBindingHandle");
function deliverBindingResult(arg) {
  const callbacks = globalThis[arg.name]["callbacks"];
  if ("error" in arg)
    callbacks.get(arg.seq).reject(arg.error);
  else
    callbacks.get(arg.seq).resolve(arg.result);
  callbacks.delete(arg.seq);
}
__name(deliverBindingResult, "deliverBindingResult");
function createPageBindingScript(playwrightBinding, name, needsHandle) {
  const script = `(${addPageBinding.toString()})(${JSON.stringify(playwrightBinding)}, ${JSON.stringify(name)}, ${needsHandle}, (${source3}), (${builtins})())`;
  return `((__name => (${script}))(t => t))`;
}
__name(createPageBindingScript, "createPageBindingScript");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/screenshotter.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/multimap.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MultiMap = class {
  static {
    __name(this, "MultiMap");
  }
  constructor() {
    this._map = new Map2();
  }
  set(key, value) {
    let values = this._map.get(key);
    if (!values) {
      values = [];
      this._map.set(key, values);
    }
    values.push(value);
  }
  get(key) {
    return this._map.get(key) || [];
  }
  has(key) {
    return this._map.has(key);
  }
  delete(key, value) {
    const values = this._map.get(key);
    if (!values)
      return;
    if (values.includes(value))
      this._map.set(key, values.filter((v) => value !== v));
  }
  deleteAll(key) {
    this._map.delete(key);
  }
  hasValue(key, value) {
    const values = this._map.get(key);
    if (!values)
      return false;
    return values.includes(value);
  }
  get size() {
    return this._map.size;
  }
  [Symbol.iterator]() {
    return this._map[Symbol.iterator]();
  }
  keys() {
    return this._map.keys();
  }
  values() {
    const result = [];
    for (const key of this.keys())
      result.push(...this.get(key));
    return result;
  }
  clear() {
    this._map.clear();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/screenshotter.js
import "node:path";
import "node:url";
function inPagePrepareForScreenshots(screenshotStyle, hideCaret, disableAnimations, syncAnimations) {
  if (syncAnimations) {
    const style = document.createElement("style");
    style.textContent = "body {}";
    document.head.appendChild(style);
    document.documentElement.getBoundingClientRect();
    style.remove();
  }
  if (!screenshotStyle && !hideCaret && !disableAnimations)
    return;
  const collectRoots = /* @__PURE__ */ __name((root, roots2 = []) => {
    roots2.push(root);
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
    do {
      const node2 = walker.currentNode;
      const shadowRoot = node2 instanceof Element ? node2.shadowRoot : null;
      if (shadowRoot)
        collectRoots(shadowRoot, roots2);
    } while (walker.nextNode());
    return roots2;
  }, "collectRoots");
  const roots = collectRoots(document);
  const cleanupCallbacks = [];
  if (screenshotStyle) {
    for (const root of roots) {
      const styleTag = document.createElement("style");
      styleTag.textContent = screenshotStyle;
      if (root === document)
        document.documentElement.append(styleTag);
      else
        root.append(styleTag);
      cleanupCallbacks.push(() => {
        styleTag.remove();
      });
    }
  }
  if (hideCaret) {
    const elements = /* @__PURE__ */ new Map();
    for (const root of roots) {
      root.querySelectorAll("input,textarea,[contenteditable]").forEach((element) => {
        elements.set(element, {
          value: element.style.getPropertyValue("caret-color"),
          priority: element.style.getPropertyPriority("caret-color")
        });
        element.style.setProperty("caret-color", "transparent", "important");
      });
    }
    cleanupCallbacks.push(() => {
      for (const [element, value] of elements)
        element.style.setProperty("caret-color", value.value, value.priority);
    });
  }
  if (disableAnimations) {
    const infiniteAnimationsToResume = /* @__PURE__ */ new Set();
    const handleAnimations = /* @__PURE__ */ __name((root) => {
      for (const animation of root.getAnimations()) {
        if (!animation.effect || animation.playbackRate === 0 || infiniteAnimationsToResume.has(animation))
          continue;
        const endTime = animation.effect.getComputedTiming().endTime;
        if (Number.isFinite(endTime)) {
          try {
            animation.finish();
          } catch (e) {
          }
        } else {
          try {
            animation.cancel();
            infiniteAnimationsToResume.add(animation);
          } catch (e) {
          }
        }
      }
    }, "handleAnimations");
    for (const root of roots) {
      const handleRootAnimations = handleAnimations.bind(null, root);
      handleRootAnimations();
      root.addEventListener("transitionrun", handleRootAnimations);
      root.addEventListener("animationstart", handleRootAnimations);
      cleanupCallbacks.push(() => {
        root.removeEventListener("transitionrun", handleRootAnimations);
        root.removeEventListener("animationstart", handleRootAnimations);
      });
    }
    cleanupCallbacks.push(() => {
      for (const animation of infiniteAnimationsToResume) {
        try {
          animation.play();
        } catch (e) {
        }
      }
    });
  }
  window.__pwCleanupScreenshot = () => {
    for (const cleanupCallback of cleanupCallbacks)
      cleanupCallback();
    delete window.__pwCleanupScreenshot;
  };
}
__name(inPagePrepareForScreenshots, "inPagePrepareForScreenshots");
var Screenshotter = class {
  static {
    __name(this, "Screenshotter");
  }
  constructor(page) {
    this._queue = new TaskQueue();
    this._page = page;
    this._queue = new TaskQueue();
  }
  async _originalViewportSize(progress3) {
    const originalViewportSize = this._page.viewportSize();
    let viewportSize = originalViewportSize;
    if (!viewportSize)
      viewportSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress3, () => ({ width: window.innerWidth, height: window.innerHeight }));
    return { viewportSize, originalViewportSize };
  }
  async _fullPageSize(progress3) {
    const fullPageSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress3, () => {
      if (!document.body || !document.documentElement)
        return null;
      return {
        width: Math.max(
          document.body.scrollWidth,
          document.documentElement.scrollWidth,
          document.body.offsetWidth,
          document.documentElement.offsetWidth,
          document.body.clientWidth,
          document.documentElement.clientWidth
        ),
        height: Math.max(
          document.body.scrollHeight,
          document.documentElement.scrollHeight,
          document.body.offsetHeight,
          document.documentElement.offsetHeight,
          document.body.clientHeight,
          document.documentElement.clientHeight
        )
      };
    });
    return fullPageSize;
  }
  async screenshotPage(progress3, options2) {
    const format2 = validateScreenshotOptions(options2);
    return this._queue.postTask(async () => {
      progress3.log("taking page screenshot");
      const { viewportSize } = await this._originalViewportSize(progress3);
      await this._preparePageForScreenshot(progress3, this._page.mainFrame(), options2.style, options2.caret !== "initial", options2.animations === "disabled");
      progress3.throwIfAborted();
      if (options2.fullPage) {
        const fullPageSize = await this._fullPageSize(progress3);
        let documentRect = { x: 0, y: 0, width: fullPageSize.width, height: fullPageSize.height };
        const fitsViewport = fullPageSize.width <= viewportSize.width && fullPageSize.height <= viewportSize.height;
        if (options2.clip)
          documentRect = trimClipToSize(options2.clip, documentRect);
        const buffer22 = await this._screenshot(progress3, format2, documentRect, void 0, fitsViewport, options2);
        progress3.throwIfAborted();
        await this._restorePageAfterScreenshot();
        return buffer22;
      }
      const viewportRect = options2.clip ? trimClipToSize(options2.clip, viewportSize) : { x: 0, y: 0, ...viewportSize };
      const buffer2 = await this._screenshot(progress3, format2, void 0, viewportRect, true, options2);
      progress3.throwIfAborted();
      await this._restorePageAfterScreenshot();
      return buffer2;
    });
  }
  async screenshotElement(progress3, handle, options2) {
    const format2 = validateScreenshotOptions(options2);
    return this._queue.postTask(async () => {
      progress3.log("taking element screenshot");
      const { viewportSize } = await this._originalViewportSize(progress3);
      await this._preparePageForScreenshot(progress3, handle._frame, options2.style, options2.caret !== "initial", options2.animations === "disabled");
      progress3.throwIfAborted();
      await handle._waitAndScrollIntoViewIfNeeded(
        progress3,
        true
        /* waitForVisible */
      );
      progress3.throwIfAborted();
      const boundingBox = await handle.boundingBox();
      assert3(boundingBox, "Node is either not visible or not an HTMLElement");
      assert3(boundingBox.width !== 0, "Node has 0 width.");
      assert3(boundingBox.height !== 0, "Node has 0 height.");
      const fitsViewport = boundingBox.width <= viewportSize.width && boundingBox.height <= viewportSize.height;
      progress3.throwIfAborted();
      const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress3, () => ({ x: window.scrollX, y: window.scrollY }));
      const documentRect = { ...boundingBox };
      documentRect.x += scrollOffset.x;
      documentRect.y += scrollOffset.y;
      const buffer2 = await this._screenshot(progress3, format2, helper.enclosingIntRect(documentRect), void 0, fitsViewport, options2);
      progress3.throwIfAborted();
      await this._restorePageAfterScreenshot();
      return buffer2;
    });
  }
  async _preparePageForScreenshot(progress3, frame, screenshotStyle, hideCaret, disableAnimations) {
    if (disableAnimations)
      progress3.log("  disabled all CSS animations");
    const syncAnimations = this._page._delegate.shouldToggleStyleSheetToSyncAnimations();
    const script = `((__name => (${inPagePrepareForScreenshots.toString()}))(t => t))`;
    await this._page.safeNonStallingEvaluateInAllFrames("(" + script + `)(${JSON.stringify(screenshotStyle)}, ${hideCaret}, ${disableAnimations}, ${syncAnimations})`, "utility");
    if (!process.env.PW_TEST_SCREENSHOT_NO_FONTS_READY) {
      progress3.log("waiting for fonts to load...");
      await frame.nonStallingEvaluateInExistingContext("document.fonts.ready", "utility").catch(() => {
      });
      progress3.log("fonts loaded");
    }
    progress3.cleanupWhenAborted(() => this._restorePageAfterScreenshot());
  }
  async _restorePageAfterScreenshot() {
    await this._page.safeNonStallingEvaluateInAllFrames("window.__pwCleanupScreenshot && window.__pwCleanupScreenshot()", "utility");
  }
  async _maskElements(progress3, options2) {
    const framesToParsedSelectors = new MultiMap();
    const cleanup = /* @__PURE__ */ __name(async () => {
      await Promise.all([...framesToParsedSelectors.keys()].map(async (frame) => {
        await frame.hideHighlight();
      }));
    }, "cleanup");
    if (!options2.mask || !options2.mask.length)
      return cleanup;
    await Promise.all((options2.mask || []).map(async ({ frame, selector }) => {
      const pair = await frame.selectors.resolveFrameForSelector(selector);
      if (pair)
        framesToParsedSelectors.set(pair.frame, pair.info.parsed);
    }));
    progress3.throwIfAborted();
    await Promise.all([...framesToParsedSelectors.keys()].map(async (frame) => {
      await frame.maskSelectors(framesToParsedSelectors.get(frame), options2.maskColor || "#F0F");
    }));
    progress3.cleanupWhenAborted(cleanup);
    return cleanup;
  }
  async _screenshot(progress3, format2, documentRect, viewportRect, fitsViewport, options2) {
    if (options2.__testHookBeforeScreenshot)
      await options2.__testHookBeforeScreenshot();
    progress3.throwIfAborted();
    const shouldSetDefaultBackground = options2.omitBackground && format2 === "png";
    if (shouldSetDefaultBackground) {
      await this._page._delegate.setBackgroundColor({ r: 0, g: 0, b: 0, a: 0 });
      progress3.cleanupWhenAborted(() => this._page._delegate.setBackgroundColor());
    }
    progress3.throwIfAborted();
    const cleanupHighlight = await this._maskElements(progress3, options2);
    progress3.throwIfAborted();
    const quality = format2 === "jpeg" ? options2.quality ?? 80 : void 0;
    const buffer2 = await this._page._delegate.takeScreenshot(progress3, format2, documentRect, viewportRect, quality, fitsViewport, options2.scale || "device");
    progress3.throwIfAborted();
    await cleanupHighlight();
    progress3.throwIfAborted();
    if (shouldSetDefaultBackground)
      await this._page._delegate.setBackgroundColor();
    progress3.throwIfAborted();
    if (options2.__testHookAfterScreenshot)
      await options2.__testHookAfterScreenshot();
    return buffer2;
  }
};
var TaskQueue = class {
  static {
    __name(this, "TaskQueue");
  }
  constructor() {
    this._chain = Promise.resolve();
  }
  postTask(task) {
    const result = this._chain.then(task);
    this._chain = result.catch(() => {
    });
    return result;
  }
};
function trimClipToSize(clip, size) {
  const p1 = {
    x: Math.max(0, Math.min(clip.x, size.width)),
    y: Math.max(0, Math.min(clip.y, size.height))
  };
  const p2 = {
    x: Math.max(0, Math.min(clip.x + clip.width, size.width)),
    y: Math.max(0, Math.min(clip.y + clip.height, size.height))
  };
  const result = { x: p1.x, y: p1.y, width: p2.x - p1.x, height: p2.y - p1.y };
  assert3(result.width && result.height, "Clipped area is either empty or outside the resulting image");
  return result;
}
__name(trimClipToSize, "trimClipToSize");
function validateScreenshotOptions(options2) {
  let format2 = null;
  if (options2.type) {
    assert3(options2.type === "png" || options2.type === "jpeg", "Unknown options.type value: " + options2.type);
    format2 = options2.type;
  }
  if (!format2)
    format2 = "png";
  if (options2.quality !== void 0) {
    assert3(format2 === "jpeg", "options.quality is unsupported for the " + format2 + " screenshots");
    assert3(typeof options2.quality === "number", "Expected options.quality to be a number but found " + typeof options2.quality);
    assert3(Number.isInteger(options2.quality), "Expected options.quality to be an integer");
    assert3(options2.quality >= 0 && options2.quality <= 100, "Expected options.quality to be between 0 and 100 (inclusive), got " + options2.quality);
  }
  if (options2.clip) {
    assert3(typeof options2.clip.x === "number", "Expected options.clip.x to be a number but found " + typeof options2.clip.x);
    assert3(typeof options2.clip.y === "number", "Expected options.clip.y to be a number but found " + typeof options2.clip.y);
    assert3(typeof options2.clip.width === "number", "Expected options.clip.width to be a number but found " + typeof options2.clip.width);
    assert3(typeof options2.clip.height === "number", "Expected options.clip.height to be a number but found " + typeof options2.clip.height);
    assert3(options2.clip.width !== 0, "Expected options.clip.width not to be 0.");
    assert3(options2.clip.height !== 0, "Expected options.clip.height not to be 0.");
  }
  return format2;
}
__name(validateScreenshotOptions, "validateScreenshotOptions");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/comparators.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/image_tools/compare.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/image_tools/colorUtils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function blendWithWhite(c, a) {
  return 255 + (c - 255) * a;
}
__name(blendWithWhite, "blendWithWhite");
function rgb2gray(r, g, b) {
  return 77 * r + 150 * g + 29 * b + 128 >> 8;
}
__name(rgb2gray, "rgb2gray");
function colorDeltaE94(rgb1, rgb2) {
  const [l1, a1, b1] = xyz2lab(srgb2xyz(rgb1));
  const [l2, a2, b2] = xyz2lab(srgb2xyz(rgb2));
  const deltaL = l1 - l2;
  const deltaA = a1 - a2;
  const deltaB = b1 - b2;
  const c1 = Math.sqrt(a1 ** 2 + b1 ** 2);
  const c2 = Math.sqrt(a2 ** 2 + b2 ** 2);
  const deltaC = c1 - c2;
  let deltaH = deltaA ** 2 + deltaB ** 2 - deltaC ** 2;
  deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
  const k1 = 0.045;
  const k2 = 0.015;
  const kL = 1;
  const kC = 1;
  const kH = 1;
  const sC = 1 + k1 * c1;
  const sH = 1 + k2 * c1;
  const sL = 1;
  return Math.sqrt((deltaL / sL / kL) ** 2 + (deltaC / sC / kC) ** 2 + (deltaH / sH / kH) ** 2);
}
__name(colorDeltaE94, "colorDeltaE94");
function srgb2xyz(rgb) {
  let r = rgb[0] / 255;
  let g = rgb[1] / 255;
  let b = rgb[2] / 255;
  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  return [
    r * 0.4124 + g * 0.3576 + b * 0.1805,
    r * 0.2126 + g * 0.7152 + b * 0.0722,
    r * 0.0193 + g * 0.1192 + b * 0.9505
  ];
}
__name(srgb2xyz, "srgb2xyz");
var sigma_pow2 = 6 * 6 / 29 / 29;
var sigma_pow3 = 6 * 6 * 6 / 29 / 29 / 29;
function xyz2lab(xyz) {
  const x = xyz[0] / 0.950489;
  const y = xyz[1];
  const z = xyz[2] / 1.08884;
  const fx = x > sigma_pow3 ? x ** (1 / 3) : x / 3 / sigma_pow2 + 4 / 29;
  const fy = y > sigma_pow3 ? y ** (1 / 3) : y / 3 / sigma_pow2 + 4 / 29;
  const fz = z > sigma_pow3 ? z ** (1 / 3) : z / 3 / sigma_pow2 + 4 / 29;
  const l = 116 * fy - 16;
  const a = 500 * (fx - fy);
  const b = 200 * (fy - fz);
  return [l, a, b];
}
__name(xyz2lab, "xyz2lab");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/image_tools/imageChannel.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ImageChannel = class _ImageChannel {
  static {
    __name(this, "ImageChannel");
  }
  static intoRGB(width, height, data, options2 = {}) {
    const {
      paddingSize = 0,
      paddingColorOdd = [255, 0, 255],
      paddingColorEven = [0, 255, 0]
    } = options2;
    const newWidth = width + 2 * paddingSize;
    const newHeight = height + 2 * paddingSize;
    const r = new Uint8Array(newWidth * newHeight);
    const g = new Uint8Array(newWidth * newHeight);
    const b = new Uint8Array(newWidth * newHeight);
    for (let y = 0; y < newHeight; ++y) {
      for (let x = 0; x < newWidth; ++x) {
        const index2 = y * newWidth + x;
        if (y >= paddingSize && y < newHeight - paddingSize && x >= paddingSize && x < newWidth - paddingSize) {
          const offset = ((y - paddingSize) * width + (x - paddingSize)) * 4;
          const alpha = data[offset + 3] === 255 ? 1 : data[offset + 3] / 255;
          r[index2] = blendWithWhite(data[offset], alpha);
          g[index2] = blendWithWhite(data[offset + 1], alpha);
          b[index2] = blendWithWhite(data[offset + 2], alpha);
        } else {
          const color = (y + x) % 2 === 0 ? paddingColorEven : paddingColorOdd;
          r[index2] = color[0];
          g[index2] = color[1];
          b[index2] = color[2];
        }
      }
    }
    return [
      new _ImageChannel(newWidth, newHeight, r),
      new _ImageChannel(newWidth, newHeight, g),
      new _ImageChannel(newWidth, newHeight, b)
    ];
  }
  constructor(width, height, data) {
    this.data = data;
    this.width = width;
    this.height = height;
  }
  get(x, y) {
    return this.data[y * this.width + x];
  }
  boundXY(x, y) {
    return [
      Math.min(Math.max(x, 0), this.width - 1),
      Math.min(Math.max(y, 0), this.height - 1)
    ];
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/image_tools/stats.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DYNAMIC_RANGE = 2 ** 8 - 1;
function ssim(stats, x1, y1, x2, y2) {
  const mean1 = stats.meanC1(x1, y1, x2, y2);
  const mean2 = stats.meanC2(x1, y1, x2, y2);
  const var1 = stats.varianceC1(x1, y1, x2, y2);
  const var2 = stats.varianceC2(x1, y1, x2, y2);
  const cov = stats.covariance(x1, y1, x2, y2);
  const c1 = (0.01 * DYNAMIC_RANGE) ** 2;
  const c2 = (0.03 * DYNAMIC_RANGE) ** 2;
  return (2 * mean1 * mean2 + c1) * (2 * cov + c2) / (mean1 ** 2 + mean2 ** 2 + c1) / (var1 + var2 + c2);
}
__name(ssim, "ssim");
var FastStats = class {
  static {
    __name(this, "FastStats");
  }
  constructor(c1, c2) {
    this.c1 = c1;
    this.c2 = c2;
    const { width, height } = c1;
    this._partialSumC1 = new Array(width * height);
    this._partialSumC2 = new Array(width * height);
    this._partialSumSq1 = new Array(width * height);
    this._partialSumSq2 = new Array(width * height);
    this._partialSumMult = new Array(width * height);
    const recalc = /* @__PURE__ */ __name((mx, idx, initial, x, y) => {
      mx[idx] = initial;
      if (y > 0)
        mx[idx] += mx[(y - 1) * width + x];
      if (x > 0)
        mx[idx] += mx[y * width + x - 1];
      if (x > 0 && y > 0)
        mx[idx] -= mx[(y - 1) * width + x - 1];
    }, "recalc");
    for (let y = 0; y < height; ++y) {
      for (let x = 0; x < width; ++x) {
        const idx = y * width + x;
        recalc(this._partialSumC1, idx, this.c1.data[idx], x, y);
        recalc(this._partialSumC2, idx, this.c2.data[idx], x, y);
        recalc(this._partialSumSq1, idx, this.c1.data[idx] * this.c1.data[idx], x, y);
        recalc(this._partialSumSq2, idx, this.c2.data[idx] * this.c2.data[idx], x, y);
        recalc(this._partialSumMult, idx, this.c1.data[idx] * this.c2.data[idx], x, y);
      }
    }
  }
  _sum(partialSum, x1, y1, x2, y2) {
    const width = this.c1.width;
    let result = partialSum[y2 * width + x2];
    if (y1 > 0)
      result -= partialSum[(y1 - 1) * width + x2];
    if (x1 > 0)
      result -= partialSum[y2 * width + x1 - 1];
    if (x1 > 0 && y1 > 0)
      result += partialSum[(y1 - 1) * width + x1 - 1];
    return result;
  }
  meanC1(x1, y1, x2, y2) {
    const N = (y2 - y1 + 1) * (x2 - x1 + 1);
    return this._sum(this._partialSumC1, x1, y1, x2, y2) / N;
  }
  meanC2(x1, y1, x2, y2) {
    const N = (y2 - y1 + 1) * (x2 - x1 + 1);
    return this._sum(this._partialSumC2, x1, y1, x2, y2) / N;
  }
  varianceC1(x1, y1, x2, y2) {
    const N = (y2 - y1 + 1) * (x2 - x1 + 1);
    return (this._sum(this._partialSumSq1, x1, y1, x2, y2) - this._sum(this._partialSumC1, x1, y1, x2, y2) ** 2 / N) / N;
  }
  varianceC2(x1, y1, x2, y2) {
    const N = (y2 - y1 + 1) * (x2 - x1 + 1);
    return (this._sum(this._partialSumSq2, x1, y1, x2, y2) - this._sum(this._partialSumC2, x1, y1, x2, y2) ** 2 / N) / N;
  }
  covariance(x1, y1, x2, y2) {
    const N = (y2 - y1 + 1) * (x2 - x1 + 1);
    return (this._sum(this._partialSumMult, x1, y1, x2, y2) - this._sum(this._partialSumC1, x1, y1, x2, y2) * this._sum(this._partialSumC2, x1, y1, x2, y2) / N) / N;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/image_tools/compare.js
var SSIM_WINDOW_RADIUS = 15;
var VARIANCE_WINDOW_RADIUS = 1;
function drawPixel(width, data, x, y, r, g, b) {
  const idx = (y * width + x) * 4;
  data[idx + 0] = r;
  data[idx + 1] = g;
  data[idx + 2] = b;
  data[idx + 3] = 255;
}
__name(drawPixel, "drawPixel");
function compare(actual, expected, diff4, width, height, options2 = {}) {
  const {
    maxColorDeltaE94 = 1
  } = options2;
  const paddingSize = Math.max(VARIANCE_WINDOW_RADIUS, SSIM_WINDOW_RADIUS);
  const paddingColorEven = [255, 0, 255];
  const paddingColorOdd = [0, 255, 0];
  const [r1, g1, b1] = ImageChannel.intoRGB(width, height, expected, {
    paddingSize,
    paddingColorEven,
    paddingColorOdd
  });
  const [r2, g2, b2] = ImageChannel.intoRGB(width, height, actual, {
    paddingSize,
    paddingColorEven,
    paddingColorOdd
  });
  const noop = /* @__PURE__ */ __name((x, y) => {
  }, "noop");
  const drawRedPixel = diff4 ? (x, y) => drawPixel(width, diff4, x - paddingSize, y - paddingSize, 255, 0, 0) : noop;
  const drawYellowPixel = diff4 ? (x, y) => drawPixel(width, diff4, x - paddingSize, y - paddingSize, 255, 255, 0) : noop;
  const drawGrayPixel = diff4 ? (x, y) => {
    const gray = rgb2gray(r1.get(x, y), g1.get(x, y), b1.get(x, y));
    const value = blendWithWhite(gray, 0.1);
    drawPixel(width, diff4, x - paddingSize, y - paddingSize, value, value, value);
  } : noop;
  let fastR, fastG, fastB;
  let diffCount = 0;
  for (let y = paddingSize; y < r1.height - paddingSize; ++y) {
    for (let x = paddingSize; x < r1.width - paddingSize; ++x) {
      if (r1.get(x, y) === r2.get(x, y) && g1.get(x, y) === g2.get(x, y) && b1.get(x, y) === b2.get(x, y)) {
        drawGrayPixel(x, y);
        continue;
      }
      const delta = colorDeltaE94(
        [r1.get(x, y), g1.get(x, y), b1.get(x, y)],
        [r2.get(x, y), g2.get(x, y), b2.get(x, y)]
      );
      if (delta <= maxColorDeltaE94) {
        drawGrayPixel(x, y);
        continue;
      }
      if (!fastR || !fastG || !fastB) {
        fastR = new FastStats(r1, r2);
        fastG = new FastStats(g1, g2);
        fastB = new FastStats(b1, b2);
      }
      const [varX1, varY1] = r1.boundXY(x - VARIANCE_WINDOW_RADIUS, y - VARIANCE_WINDOW_RADIUS);
      const [varX2, varY2] = r1.boundXY(x + VARIANCE_WINDOW_RADIUS, y + VARIANCE_WINDOW_RADIUS);
      const var1 = fastR.varianceC1(varX1, varY1, varX2, varY2) + fastG.varianceC1(varX1, varY1, varX2, varY2) + fastB.varianceC1(varX1, varY1, varX2, varY2);
      const var2 = fastR.varianceC2(varX1, varY1, varX2, varY2) + fastG.varianceC2(varX1, varY1, varX2, varY2) + fastB.varianceC2(varX1, varY1, varX2, varY2);
      if (var1 === 0 || var2 === 0) {
        drawRedPixel(x, y);
        ++diffCount;
        continue;
      }
      const [ssimX1, ssimY1] = r1.boundXY(x - SSIM_WINDOW_RADIUS, y - SSIM_WINDOW_RADIUS);
      const [ssimX2, ssimY2] = r1.boundXY(x + SSIM_WINDOW_RADIUS, y + SSIM_WINDOW_RADIUS);
      const ssimRGB = (ssim(fastR, ssimX1, ssimY1, ssimX2, ssimY2) + ssim(fastG, ssimX1, ssimY1, ssimX2, ssimY2) + ssim(fastB, ssimX1, ssimY1, ssimX2, ssimY2)) / 3;
      const isAntialiased = ssimRGB >= 0.99;
      if (isAntialiased) {
        drawYellowPixel(x, y);
      } else {
        drawRedPixel(x, y);
        ++diffCount;
      }
    }
  }
  return diffCount;
}
__name(compare, "compare");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/comparators.js
function getComparator(mimeType) {
  if (mimeType === "image/png")
    return compareImages.bind(null, "image/png");
  if (mimeType === "image/jpeg")
    return compareImages.bind(null, "image/jpeg");
  if (mimeType === "text/plain")
    return compareText;
  return compareBuffersOrStrings;
}
__name(getComparator, "getComparator");
var JPEG_JS_MAX_BUFFER_SIZE_IN_MB = 5 * 1024;
function compareBuffersOrStrings(actualBuffer, expectedBuffer) {
  if (typeof actualBuffer === "string")
    return compareText(actualBuffer, expectedBuffer);
  if (!actualBuffer || !(actualBuffer instanceof Buffer))
    return { errorMessage: "Actual result should be a Buffer or a string." };
  if (Buffer.compare(actualBuffer, expectedBuffer))
    return { errorMessage: "Buffers differ" };
  return null;
}
__name(compareBuffersOrStrings, "compareBuffersOrStrings");
function compareImages(mimeType, actualBuffer, expectedBuffer, options2 = {}) {
  if (!actualBuffer || !(actualBuffer instanceof Buffer))
    return { errorMessage: "Actual result should be a Buffer." };
  validateBuffer(expectedBuffer, mimeType);
  let actual = mimeType === "image/png" ? PNG2.sync.read(actualBuffer) : jpegjs2.decode(actualBuffer, { maxMemoryUsageInMB: JPEG_JS_MAX_BUFFER_SIZE_IN_MB });
  let expected = mimeType === "image/png" ? PNG2.sync.read(expectedBuffer) : jpegjs2.decode(expectedBuffer, { maxMemoryUsageInMB: JPEG_JS_MAX_BUFFER_SIZE_IN_MB });
  const size = { width: Math.max(expected.width, actual.width), height: Math.max(expected.height, actual.height) };
  let sizesMismatchError = "";
  if (expected.width !== actual.width || expected.height !== actual.height) {
    sizesMismatchError = `Expected an image ${expected.width}px by ${expected.height}px, received ${actual.width}px by ${actual.height}px. `;
    actual = resizeImage(actual, size);
    expected = resizeImage(expected, size);
  }
  const diff22 = new PNG2({ width: size.width, height: size.height });
  let count3;
  if (options2.comparator === "ssim-cie94") {
    count3 = compare(expected.data, actual.data, diff22.data, size.width, size.height, {
      // All E* formulae are originally designed to have the difference of 1.0 stand for a "just noticeable difference" (JND).
      // See https://en.wikipedia.org/wiki/Color_difference#CIELAB_%CE%94E*
      maxColorDeltaE94: 1
    });
  } else if ((options2.comparator ?? "pixelmatch") === "pixelmatch") {
    count3 = pixelmatch(expected.data, actual.data, diff22.data, size.width, size.height, {
      threshold: options2.threshold ?? 0.2
    });
  } else {
    throw new Error(`Configuration specifies unknown comparator "${options2.comparator}"`);
  }
  const maxDiffPixels1 = options2.maxDiffPixels;
  const maxDiffPixels2 = options2.maxDiffPixelRatio !== void 0 ? expected.width * expected.height * options2.maxDiffPixelRatio : void 0;
  let maxDiffPixels;
  if (maxDiffPixels1 !== void 0 && maxDiffPixels2 !== void 0)
    maxDiffPixels = Math.min(maxDiffPixels1, maxDiffPixels2);
  else
    maxDiffPixels = maxDiffPixels1 ?? maxDiffPixels2 ?? 0;
  const ratio = Math.ceil(count3 / (expected.width * expected.height) * 100) / 100;
  const pixelsMismatchError = count3 > maxDiffPixels ? `${count3} pixels (ratio ${ratio.toFixed(2)} of all image pixels) are different.` : "";
  if (pixelsMismatchError || sizesMismatchError)
    return { errorMessage: sizesMismatchError + pixelsMismatchError, diff: PNG2.sync.write(diff22) };
  return null;
}
__name(compareImages, "compareImages");
function validateBuffer(buffer2, mimeType) {
  if (mimeType === "image/png") {
    const pngMagicNumber = [137, 80, 78, 71, 13, 10, 26, 10];
    if (buffer2.length < pngMagicNumber.length || !pngMagicNumber.every((byte, index2) => buffer2[index2] === byte))
      throw new Error("could not decode image as PNG.");
  } else if (mimeType === "image/jpeg") {
    const jpegMagicNumber = [255, 216];
    if (buffer2.length < jpegMagicNumber.length || !jpegMagicNumber.every((byte, index2) => buffer2[index2] === byte))
      throw new Error("could not decode image as JPEG.");
  }
}
__name(validateBuffer, "validateBuffer");
function compareText(actual, expectedBuffer) {
  if (typeof actual !== "string")
    return { errorMessage: "Actual result should be a string" };
  let expected = expectedBuffer.toString("utf-8");
  if (expected === actual)
    return null;
  if (!actual.endsWith("\n"))
    actual += "\n";
  if (!expected.endsWith("\n"))
    expected += "\n";
  const lines = diff3.createPatch("file", expected, actual, void 0, void 0, { context: 5 }).split("\n");
  const coloredLines = lines.slice(4).map((line) => {
    if (line.startsWith("-"))
      return colors2.red(line);
    if (line.startsWith("+"))
      return colors2.green(line);
    if (line.startsWith("@@"))
      return colors2.dim(line);
    return line;
  });
  const errorMessage = coloredLines.join("\n");
  return { errorMessage };
}
__name(compareText, "compareText");
function resizeImage(image, size) {
  if (image.width === size.width && image.height === size.height)
    return image;
  const buffer2 = new Uint8Array(size.width * size.height * 4);
  for (let y = 0; y < size.height; y++) {
    for (let x = 0; x < size.width; x++) {
      const to = (y * size.width + x) * 4;
      if (y < image.height && x < image.width) {
        const from = (y * image.width + x) * 4;
        buffer2[to] = image.data[from];
        buffer2[to + 1] = image.data[from + 1];
        buffer2[to + 2] = image.data[from + 2];
        buffer2[to + 3] = image.data[from + 3];
      } else {
        buffer2[to] = 0;
        buffer2[to + 1] = 0;
        buffer2[to + 2] = 0;
        buffer2[to + 3] = 0;
      }
    }
  }
  return { data: Buffer.from(buffer2), width: size.width, height: size.height };
}
__name(resizeImage, "resizeImage");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/page.js
import "node:path";
import "node:url";
var Page = class _Page extends SdkObject {
  static {
    __name(this, "Page");
  }
  constructor(delegate, browserContext) {
    super(browserContext, "page");
    this._closedState = "open";
    this._closedPromise = new ManualPromise();
    this._initializedPromise = new ManualPromise();
    this._eventsToEmitAfterInitialized = [];
    this._crashed = false;
    this.openScope = new LongStandingScope();
    this._emulatedMedia = {};
    this._interceptFileChooser = false;
    this._pageBindings = /* @__PURE__ */ new Map();
    this.initScripts = [];
    this._workers = /* @__PURE__ */ new Map();
    this._video = null;
    this._isServerSideOnly = false;
    this._locatorHandlers = /* @__PURE__ */ new Map();
    this._lastLocatorHandlerUid = 0;
    this._locatorHandlerRunningCounter = 0;
    this._frameThrottler = new FrameThrottler(10, 35, 200);
    this.attribution.page = this;
    this._delegate = delegate;
    this._browserContext = browserContext;
    this.accessibility = new Accessibility(delegate.getAccessibilityTree.bind(delegate));
    this.keyboard = new Keyboard(delegate.rawKeyboard);
    this.mouse = new Mouse(delegate.rawMouse, this);
    this.touchscreen = new Touchscreen(delegate.rawTouchscreen, this);
    this._timeoutSettings = new TimeoutSettings(browserContext._timeoutSettings);
    this._screenshotter = new Screenshotter(this);
    this._frameManager = new FrameManager(this);
    if (delegate.pdf)
      this.pdf = delegate.pdf.bind(delegate);
    this.coverage = delegate.coverage ? delegate.coverage() : null;
  }
  static {
    this.Events = {
      Close: "close",
      Crash: "crash",
      Download: "download",
      FileChooser: "filechooser",
      FrameAttached: "frameattached",
      FrameDetached: "framedetached",
      InternalFrameNavigatedToNewDocument: "internalframenavigatedtonewdocument",
      LocatorHandlerTriggered: "locatorhandlertriggered",
      ScreencastFrame: "screencastframe",
      Video: "video",
      WebSocket: "websocket",
      Worker: "worker"
    };
  }
  async reportAsNew(opener, error4 = void 0, contextEvent = BrowserContext.Events.Page) {
    if (opener) {
      const openerPageOrError = await opener.waitForInitializedOrError();
      if (openerPageOrError instanceof _Page && !openerPageOrError.isClosed())
        this._opener = openerPageOrError;
    }
    this._markInitialized(error4, contextEvent);
  }
  _markInitialized(error4 = void 0, contextEvent = BrowserContext.Events.Page) {
    if (error4) {
      if (this._browserContext.isClosingOrClosed())
        return;
      this._frameManager.createDummyMainFrameIfNeeded();
    }
    this._initialized = error4 || this;
    this.emitOnContext(contextEvent, this);
    for (const { event, args } of this._eventsToEmitAfterInitialized)
      this._browserContext.emit(event, ...args);
    this._eventsToEmitAfterInitialized = [];
    if (this.isClosed())
      this.emit(_Page.Events.Close);
    else
      this.instrumentation.onPageOpen(this);
    this._initializedPromise.resolve(this._initialized);
  }
  initializedOrUndefined() {
    return this._initialized ? this : void 0;
  }
  waitForInitializedOrError() {
    return this._initializedPromise;
  }
  emitOnContext(event, ...args) {
    if (this._isServerSideOnly)
      return;
    this._browserContext.emit(event, ...args);
  }
  emitOnContextOnceInitialized(event, ...args) {
    if (this._isServerSideOnly)
      return;
    if (this._initialized)
      this._browserContext.emit(event, ...args);
    else
      this._eventsToEmitAfterInitialized.push({ event, args });
  }
  async resetForReuse(metadata) {
    this.setDefaultNavigationTimeout(void 0);
    this.setDefaultTimeout(void 0);
    this._locatorHandlers.clear();
    await this._removeExposedBindings();
    await this._removeInitScripts();
    await this.setClientRequestInterceptor(void 0);
    await this._setServerRequestInterceptor(void 0);
    await this.setFileChooserIntercepted(false);
    await this.mainFrame().goto(metadata, "about:blank");
    this._emulatedSize = void 0;
    this._emulatedMedia = {};
    this._extraHTTPHeaders = void 0;
    this._interceptFileChooser = false;
    await Promise.all([
      this._delegate.updateEmulatedViewportSize(),
      this._delegate.updateEmulateMedia(),
      this._delegate.updateFileChooserInterception()
    ]);
    await this._delegate.resetForReuse();
  }
  _didClose() {
    this._frameManager.dispose();
    this._frameThrottler.dispose();
    assert3(this._closedState !== "closed", "Page closed twice");
    this._closedState = "closed";
    this.emit(_Page.Events.Close);
    this._closedPromise.resolve();
    this.instrumentation.onPageClose(this);
    this.openScope.close(new TargetClosedError());
  }
  _didCrash() {
    this._frameManager.dispose();
    this._frameThrottler.dispose();
    this.emit(_Page.Events.Crash);
    this._crashed = true;
    this.instrumentation.onPageClose(this);
    this.openScope.close(new Error("Page crashed"));
  }
  async _onFileChooserOpened(handle) {
    let multiple;
    try {
      multiple = await handle.evaluate((element) => !!element.multiple);
    } catch (e) {
      return;
    }
    if (!this.listenerCount(_Page.Events.FileChooser)) {
      handle.dispose();
      return;
    }
    const fileChooser = new FileChooser(this, handle, multiple);
    this.emit(_Page.Events.FileChooser, fileChooser);
  }
  context() {
    return this._browserContext;
  }
  opener() {
    return this._opener;
  }
  mainFrame() {
    return this._frameManager.mainFrame();
  }
  frames() {
    return this._frameManager.frames();
  }
  setDefaultNavigationTimeout(timeout) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout);
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }
  async exposeBinding(name, needsHandle, playwrightBinding) {
    if (this._pageBindings.has(name))
      throw new Error(`Function "${name}" has been already registered`);
    if (this._browserContext._pageBindings.has(name))
      throw new Error(`Function "${name}" has been already registered in the browser context`);
    const binding3 = new PageBinding(name, playwrightBinding, needsHandle);
    this._pageBindings.set(name, binding3);
    await this._delegate.addInitScript(binding3.initScript);
    await Promise.all(this.frames().map((frame) => frame.evaluateExpression(binding3.initScript.source).catch((e) => {
    })));
  }
  async _removeExposedBindings() {
    for (const [key, binding3] of this._pageBindings) {
      if (!binding3.internal)
        this._pageBindings.delete(key);
    }
  }
  setExtraHTTPHeaders(headers) {
    this._extraHTTPHeaders = headers;
    return this._delegate.updateExtraHTTPHeaders();
  }
  extraHTTPHeaders() {
    return this._extraHTTPHeaders;
  }
  async _onBindingCalled(payload, context2) {
    if (this._closedState === "closed")
      return;
    await PageBinding.dispatch(this, payload, context2);
  }
  _addConsoleMessage(type2, args, location2, text) {
    const message = new ConsoleMessage(this, type2, text, args, location2);
    const intercepted = this._frameManager.interceptConsoleMessage(message);
    if (intercepted) {
      args.forEach((arg) => arg.dispose());
      return;
    }
    this.emitOnContextOnceInitialized(BrowserContext.Events.Console, message);
  }
  async reload(metadata, options2) {
    const controller = new ProgressController(metadata, this);
    return controller.run((progress3) => this.mainFrame().raceNavigationAction(progress3, options2, async () => {
      const [response] = await Promise.all([
        // Reload must be a new document, and should not be confused with a stray pushState.
        this.mainFrame()._waitForNavigation(progress3, true, options2),
        this._delegate.reload()
      ]);
      return response;
    }), this._timeoutSettings.navigationTimeout(options2));
  }
  async goBack(metadata, options2) {
    const controller = new ProgressController(metadata, this);
    return controller.run((progress3) => this.mainFrame().raceNavigationAction(progress3, options2, async () => {
      let error4;
      const waitPromise = this.mainFrame()._waitForNavigation(progress3, false, options2).catch((e) => {
        error4 = e;
        return null;
      });
      const result = await this._delegate.goBack();
      if (!result)
        return null;
      const response = await waitPromise;
      if (error4)
        throw error4;
      return response;
    }), this._timeoutSettings.navigationTimeout(options2));
  }
  async goForward(metadata, options2) {
    const controller = new ProgressController(metadata, this);
    return controller.run((progress3) => this.mainFrame().raceNavigationAction(progress3, options2, async () => {
      let error4;
      const waitPromise = this.mainFrame()._waitForNavigation(progress3, false, options2).catch((e) => {
        error4 = e;
        return null;
      });
      const result = await this._delegate.goForward();
      if (!result)
        return null;
      const response = await waitPromise;
      if (error4)
        throw error4;
      return response;
    }), this._timeoutSettings.navigationTimeout(options2));
  }
  requestGC() {
    return this._delegate.requestGC();
  }
  registerLocatorHandler(selector, noWaitAfter) {
    const uid = ++this._lastLocatorHandlerUid;
    this._locatorHandlers.set(uid, { selector, noWaitAfter });
    return uid;
  }
  resolveLocatorHandler(uid, remove) {
    const handler = this._locatorHandlers.get(uid);
    if (remove)
      this._locatorHandlers.delete(uid);
    if (handler) {
      handler.resolved?.resolve();
      handler.resolved = void 0;
    }
  }
  unregisterLocatorHandler(uid) {
    this._locatorHandlers.delete(uid);
  }
  async performActionPreChecks(progress3) {
    await this._performWaitForNavigationCheck(progress3);
    progress3.throwIfAborted();
    await this._performLocatorHandlersCheckpoint(progress3);
    progress3.throwIfAborted();
    await this._performWaitForNavigationCheck(progress3);
  }
  async _performWaitForNavigationCheck(progress3) {
    if (process.env.PLAYWRIGHT_SKIP_NAVIGATION_CHECK)
      return;
    const mainFrame = this._frameManager.mainFrame();
    if (!mainFrame || !mainFrame.pendingDocument())
      return;
    const url4 = mainFrame.pendingDocument()?.request?.url();
    const toUrl = url4 ? `" ${trimStringWithEllipsis(url4, 200)}"` : "";
    progress3.log(`  waiting for${toUrl} navigation to finish...`);
    await helper.waitForEvent(progress3, mainFrame, Frame.Events.InternalNavigation, (e) => {
      if (!e.isPublic)
        return false;
      if (!e.error)
        progress3.log(`  navigated to "${trimStringWithEllipsis(mainFrame.url(), 200)}"`);
      return true;
    }).promise;
  }
  async _performLocatorHandlersCheckpoint(progress3) {
    if (this._locatorHandlerRunningCounter)
      return;
    for (const [uid, handler] of this._locatorHandlers) {
      if (!handler.resolved) {
        if (await this.mainFrame().isVisibleInternal(handler.selector, { strict: true })) {
          handler.resolved = new ManualPromise();
          this.emit(_Page.Events.LocatorHandlerTriggered, uid);
        }
      }
      if (handler.resolved) {
        ++this._locatorHandlerRunningCounter;
        progress3.log(`  found ${asLocator(this.attribution.playwright.options.sdkLanguage, handler.selector)}, intercepting action to run the handler`);
        const promise = handler.resolved.then(async () => {
          progress3.throwIfAborted();
          if (!handler.noWaitAfter) {
            progress3.log(`  locator handler has finished, waiting for ${asLocator(this.attribution.playwright.options.sdkLanguage, handler.selector)} to be hidden`);
            await this.mainFrame().waitForSelectorInternal(progress3, handler.selector, false, { state: "hidden" });
          } else {
            progress3.log(`  locator handler has finished`);
          }
        });
        await this.openScope.race(promise).finally(() => --this._locatorHandlerRunningCounter);
        progress3.throwIfAborted();
        progress3.log(`  interception handler has finished, continuing`);
      }
    }
  }
  async emulateMedia(options2) {
    if (options2.media !== void 0)
      this._emulatedMedia.media = options2.media;
    if (options2.colorScheme !== void 0)
      this._emulatedMedia.colorScheme = options2.colorScheme;
    if (options2.reducedMotion !== void 0)
      this._emulatedMedia.reducedMotion = options2.reducedMotion;
    if (options2.forcedColors !== void 0)
      this._emulatedMedia.forcedColors = options2.forcedColors;
    if (options2.contrast !== void 0)
      this._emulatedMedia.contrast = options2.contrast;
    await this._delegate.updateEmulateMedia();
  }
  emulatedMedia() {
    const contextOptions = this._browserContext._options;
    return {
      media: this._emulatedMedia.media || "no-override",
      colorScheme: this._emulatedMedia.colorScheme !== void 0 ? this._emulatedMedia.colorScheme : contextOptions.colorScheme ?? "light",
      reducedMotion: this._emulatedMedia.reducedMotion !== void 0 ? this._emulatedMedia.reducedMotion : contextOptions.reducedMotion ?? "no-preference",
      forcedColors: this._emulatedMedia.forcedColors !== void 0 ? this._emulatedMedia.forcedColors : contextOptions.forcedColors ?? "none",
      contrast: this._emulatedMedia.contrast !== void 0 ? this._emulatedMedia.contrast : contextOptions.contrast ?? "no-preference"
    };
  }
  async setViewportSize(viewportSize) {
    this._emulatedSize = { viewport: { ...viewportSize }, screen: { ...viewportSize } };
    await this._delegate.updateEmulatedViewportSize();
  }
  viewportSize() {
    return this.emulatedSize()?.viewport || null;
  }
  emulatedSize() {
    if (this._emulatedSize)
      return this._emulatedSize;
    const contextOptions = this._browserContext._options;
    return contextOptions.viewport ? { viewport: contextOptions.viewport, screen: contextOptions.screen || contextOptions.viewport } : null;
  }
  async bringToFront() {
    await this._delegate.bringToFront();
  }
  async addInitScript(source7, name) {
    const initScript = new InitScript(source7, false, name);
    this.initScripts.push(initScript);
    await this._delegate.addInitScript(initScript);
  }
  async _removeInitScripts() {
    this.initScripts = this.initScripts.filter((script) => script.internal);
    await this._delegate.removeNonInternalInitScripts();
  }
  needsRequestInterception() {
    return !!this._clientRequestInterceptor || !!this._serverRequestInterceptor || !!this._browserContext._requestInterceptor;
  }
  async setClientRequestInterceptor(handler) {
    this._clientRequestInterceptor = handler;
    await this._delegate.updateRequestInterception();
  }
  async _setServerRequestInterceptor(handler) {
    this._serverRequestInterceptor = handler;
    await this._delegate.updateRequestInterception();
  }
  async expectScreenshot(metadata, options2 = {}) {
    const locator = options2.locator;
    const rafrafScreenshot = locator ? async (progress3, timeout) => {
      return await locator.frame.rafrafTimeoutScreenshotElementWithProgress(progress3, locator.selector, timeout, options2 || {});
    } : async (progress3, timeout) => {
      await this.performActionPreChecks(progress3);
      await this.mainFrame().rafrafTimeout(timeout);
      return await this._screenshotter.screenshotPage(progress3, options2 || {});
    };
    const comparator = getComparator("image/png");
    const controller = new ProgressController(metadata, this);
    if (!options2.expected && options2.isNot)
      return { errorMessage: '"not" matcher requires expected result' };
    try {
      const format2 = validateScreenshotOptions(options2 || {});
      if (format2 !== "png")
        throw new Error("Only PNG screenshots are supported");
    } catch (error4) {
      return { errorMessage: error4.message };
    }
    let intermediateResult = void 0;
    const areEqualScreenshots = /* @__PURE__ */ __name((actual, expected, previous) => {
      const comparatorResult = actual && expected ? comparator(actual, expected, options2) : void 0;
      if (comparatorResult !== void 0 && !!comparatorResult === !!options2.isNot)
        return true;
      if (comparatorResult)
        intermediateResult = { errorMessage: comparatorResult.errorMessage, diff: comparatorResult.diff, actual, previous };
      return false;
    }, "areEqualScreenshots");
    const callTimeout = this._timeoutSettings.timeout(options2);
    return controller.run(async (progress3) => {
      let actual;
      let previous;
      const pollIntervals = [0, 100, 250, 500];
      progress3.log(`${metadata.apiName}${callTimeout ? ` with timeout ${callTimeout}ms` : ""}`);
      if (options2.expected)
        progress3.log(`  verifying given screenshot expectation`);
      else
        progress3.log(`  generating new stable screenshot expectation`);
      let isFirstIteration = true;
      while (true) {
        progress3.throwIfAborted();
        if (this.isClosed())
          throw new Error("The page has closed");
        const screenshotTimeout = pollIntervals.shift() ?? 1e3;
        if (screenshotTimeout)
          progress3.log(`waiting ${screenshotTimeout}ms before taking screenshot`);
        previous = actual;
        actual = await rafrafScreenshot(progress3, screenshotTimeout).catch((e) => {
          progress3.log(`failed to take screenshot - ` + e.message);
          return void 0;
        });
        if (!actual)
          continue;
        const expectation = options2.expected && isFirstIteration ? options2.expected : previous;
        if (areEqualScreenshots(actual, expectation, previous))
          break;
        if (intermediateResult)
          progress3.log(intermediateResult.errorMessage);
        isFirstIteration = false;
      }
      if (!isFirstIteration)
        progress3.log(`captured a stable screenshot`);
      if (!options2.expected)
        return { actual };
      if (isFirstIteration) {
        progress3.log(`screenshot matched expectation`);
        return {};
      }
      if (areEqualScreenshots(actual, options2.expected, void 0)) {
        progress3.log(`screenshot matched expectation`);
        return {};
      }
      throw new Error(intermediateResult.errorMessage);
    }, callTimeout).catch((e) => {
      if (isJavaScriptErrorInEvaluate(e) || isInvalidSelectorError(e))
        throw e;
      let errorMessage = e.message;
      if (e instanceof TimeoutError && intermediateResult?.previous)
        errorMessage = `Failed to take two consecutive stable screenshots.`;
      return {
        log: compressCallLog(e.message ? [...metadata.log, e.message] : metadata.log),
        ...intermediateResult,
        errorMessage,
        timedOut: e instanceof TimeoutError
      };
    });
  }
  async screenshot(metadata, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(
      (progress3) => this._screenshotter.screenshotPage(progress3, options2),
      this._timeoutSettings.timeout(options2)
    );
  }
  async close(metadata, options2 = {}) {
    if (this._closedState === "closed")
      return;
    if (options2.reason)
      this._closeReason = options2.reason;
    const runBeforeUnload = !!options2.runBeforeUnload;
    if (this._closedState !== "closing") {
      this._closedState = "closing";
      await this._delegate.closePage(runBeforeUnload).catch((e) => debugLogger.log("error", e));
    }
    if (!runBeforeUnload)
      await this._closedPromise;
    if (this._ownedContext)
      await this._ownedContext.close(options2);
  }
  isClosed() {
    return this._closedState === "closed";
  }
  hasCrashed() {
    return this._crashed;
  }
  isClosedOrClosingOrCrashed() {
    return this._closedState !== "open" || this._crashed;
  }
  _addWorker(workerId, worker) {
    this._workers.set(workerId, worker);
    this.emit(_Page.Events.Worker, worker);
  }
  _removeWorker(workerId) {
    const worker = this._workers.get(workerId);
    if (!worker)
      return;
    worker.didClose();
    this._workers.delete(workerId);
  }
  _clearWorkers() {
    for (const [workerId, worker] of this._workers) {
      worker.didClose();
      this._workers.delete(workerId);
    }
  }
  async setFileChooserIntercepted(enabled) {
    this._interceptFileChooser = enabled;
    await this._delegate.updateFileChooserInterception();
  }
  fileChooserIntercepted() {
    return this._interceptFileChooser;
  }
  frameNavigatedToNewDocument(frame) {
    this.emit(_Page.Events.InternalFrameNavigatedToNewDocument, frame);
    const origin = frame.origin();
    if (origin)
      this._browserContext.addVisitedOrigin(origin);
  }
  allInitScripts() {
    const bindings = [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];
    return [kBuiltinsScript, ...bindings.map((binding3) => binding3.initScript), ...this._browserContext.initScripts, ...this.initScripts];
  }
  getBinding(name) {
    return this._pageBindings.get(name) || this._browserContext._pageBindings.get(name);
  }
  setScreencastOptions(options2) {
    this._delegate.setScreencastOptions(options2).catch((e) => debugLogger.log("error", e));
    this._frameThrottler.setThrottlingEnabled(!!options2);
  }
  throttleScreencastFrameAck(ack) {
    this._frameThrottler.ack(ack);
  }
  temporarilyDisableTracingScreencastThrottling() {
    this._frameThrottler.recharge();
  }
  async safeNonStallingEvaluateInAllFrames(expression, world, options2 = {}) {
    await Promise.all(this.frames().map(async (frame) => {
      try {
        await frame.nonStallingEvaluateInExistingContext(expression, world);
      } catch (e) {
        if (options2.throwOnJSErrors && isJavaScriptErrorInEvaluate(e))
          throw e;
      }
    }));
  }
  async hideHighlight() {
    await Promise.all(this.frames().map((frame) => frame.hideHighlight().catch(() => {
    })));
  }
  markAsServerSideOnly() {
    this._isServerSideOnly = true;
  }
};
var Worker = class _Worker extends SdkObject {
  static {
    __name(this, "Worker");
  }
  constructor(parent, url4) {
    super(parent, "worker");
    this._existingExecutionContext = null;
    this.openScope = new LongStandingScope();
    this._url = url4;
    this._executionContextCallback = () => {
    };
    this._executionContextPromise = new Promise((x) => this._executionContextCallback = x);
  }
  static {
    this.Events = {
      Close: "close"
    };
  }
  _createExecutionContext(delegate) {
    this._existingExecutionContext = new ExecutionContext(this, delegate, "worker");
    this._executionContextCallback(this._existingExecutionContext);
    return this._existingExecutionContext;
  }
  url() {
    return this._url;
  }
  didClose() {
    if (this._existingExecutionContext)
      this._existingExecutionContext.contextDestroyed("Worker was closed");
    this.emit(_Worker.Events.Close, this);
    this.openScope.close(new Error("Worker closed"));
  }
  async evaluateExpression(expression, isFunction2, arg) {
    return evaluateExpression(await this._executionContextPromise, expression, { returnByValue: true, isFunction: isFunction2 }, arg);
  }
  async evaluateExpressionHandle(expression, isFunction2, arg) {
    return evaluateExpression(await this._executionContextPromise, expression, { returnByValue: false, isFunction: isFunction2 }, arg);
  }
};
var PageBinding = class _PageBinding {
  static {
    __name(this, "PageBinding");
  }
  static {
    this.kPlaywrightBinding = "__playwright__binding__";
  }
  constructor(name, playwrightFunction, needsHandle) {
    this.name = name;
    this.playwrightFunction = playwrightFunction;
    this.initScript = new InitScript(
      createPageBindingScript(_PageBinding.kPlaywrightBinding, name, needsHandle),
      true
      /* internal */
    );
    this.needsHandle = needsHandle;
    this.internal = name.startsWith("__pw");
  }
  static async dispatch(page, payload, context2) {
    const { name, seq: seq2, serializedArgs } = JSON.parse(payload);
    try {
      assert3(context2.world);
      const binding3 = page.getBinding(name);
      if (!binding3)
        throw new Error(`Function "${name}" is not exposed`);
      let result;
      if (binding3.needsHandle) {
        const handle = await context2.evaluateHandle(takeBindingHandle, { name, seq: seq2 }).catch((e) => null);
        result = await binding3.playwrightFunction({ frame: context2.frame, page, context: page._browserContext }, handle);
      } else {
        if (!Array.isArray(serializedArgs))
          throw new Error(`serializedArgs is not an array. This can happen when Array.prototype.toJSON is defined incorrectly`);
        const args = serializedArgs.map((a) => parseEvaluationResultValue(a));
        result = await binding3.playwrightFunction({ frame: context2.frame, page, context: page._browserContext }, ...args);
      }
      context2.evaluate(deliverBindingResult, { name, seq: seq2, result }).catch((e) => debugLogger.log("error", e));
    } catch (error4) {
      context2.evaluate(deliverBindingResult, { name, seq: seq2, error: error4 }).catch((e) => debugLogger.log("error", e));
    }
  }
};
var InitScript = class {
  static {
    __name(this, "InitScript");
  }
  constructor(source7, internal, name) {
    const guid = createGuid();
    this.source = `(() => {
      globalThis.__pwInitScripts = globalThis.__pwInitScripts || {};
      const hasInitScript = globalThis.__pwInitScripts[${JSON.stringify(guid)}];
      if (hasInitScript)
        return;
      globalThis.__pwInitScripts[${JSON.stringify(guid)}] = true;
      ${source7}
    })();`;
    this.internal = !!internal;
    this.name = name;
  }
};
var kBuiltinsScript = new InitScript(
  `(${builtins})()`,
  true
  /* internal */
);
var FrameThrottler = class {
  static {
    __name(this, "FrameThrottler");
  }
  constructor(nonThrottledFrames, defaultInterval, throttlingInterval) {
    this._acks = [];
    this._throttlingEnabled = false;
    this._nonThrottledFrames = nonThrottledFrames;
    this._budget = nonThrottledFrames;
    this._defaultInterval = defaultInterval;
    this._throttlingInterval = throttlingInterval;
    this._tick();
  }
  dispose() {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
      this._timeoutId = void 0;
    }
  }
  setThrottlingEnabled(enabled) {
    this._throttlingEnabled = enabled;
  }
  recharge() {
    for (const ack of this._acks)
      ack();
    this._acks = [];
    this._budget = this._nonThrottledFrames;
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
      this._tick();
    }
  }
  ack(ack) {
    if (!this._timeoutId) {
      ack();
      return;
    }
    this._acks.push(ack);
  }
  _tick() {
    const ack = this._acks.shift();
    if (ack) {
      --this._budget;
      ack();
    }
    if (this._throttlingEnabled && this._budget <= 0) {
      this._timeoutId = setTimeout(() => this._tick(), this._throttlingInterval);
    } else {
      this._timeoutId = setTimeout(() => this._tick(), this._defaultInterval);
    }
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/types.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var kLifecycleEvents = /* @__PURE__ */ new Set(["load", "domcontentloaded", "networkidle", "commit"]);

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/frames.js
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/task.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function makeWaitForNextTask() {
  if (process.versions.electron)
    return (callback) => setTimeout(callback, 0);
  if (parseInt(process.versions.node, 10) >= 11)
    return setImmediate;
  let spinning = false;
  const callbacks = [];
  const loop = /* @__PURE__ */ __name(() => {
    const callback = callbacks.shift();
    if (!callback) {
      spinning = false;
      return;
    }
    setImmediate(loop);
    callback();
  }, "loop");
  return (callback) => {
    callbacks.push(callback);
    if (!spinning) {
      spinning = true;
      setImmediate(loop);
    }
  };
}
__name(makeWaitForNextTask, "makeWaitForNextTask");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/frames.js
var NavigationAbortedError = class extends Error {
  static {
    __name(this, "NavigationAbortedError");
  }
  constructor(documentId, message) {
    super(message);
    this.documentId = documentId;
  }
};
var kDummyFrameId = "<dummy>";
var FrameManager = class {
  static {
    __name(this, "FrameManager");
  }
  constructor(page) {
    this._frames = /* @__PURE__ */ new Map();
    this._consoleMessageTags = /* @__PURE__ */ new Map();
    this._signalBarriers = /* @__PURE__ */ new Set();
    this._webSockets = /* @__PURE__ */ new Map();
    this._openedDialogs = /* @__PURE__ */ new Set();
    this._closeAllOpeningDialogs = false;
    this._page = page;
    this._mainFrame = void 0;
  }
  createDummyMainFrameIfNeeded() {
    if (!this._mainFrame)
      this.frameAttached(kDummyFrameId, null);
  }
  dispose() {
    for (const frame of this._frames.values()) {
      frame._stopNetworkIdleTimer();
      frame._invalidateNonStallingEvaluations("Target crashed");
    }
  }
  mainFrame() {
    return this._mainFrame;
  }
  frames() {
    const frames = [];
    collect2(this._mainFrame);
    return frames;
    function collect2(frame) {
      frames.push(frame);
      for (const subframe of frame.childFrames())
        collect2(subframe);
    }
    __name(collect2, "collect");
  }
  frame(frameId) {
    return this._frames.get(frameId) || null;
  }
  frameAttached(frameId, parentFrameId) {
    const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;
    if (!parentFrame) {
      if (this._mainFrame) {
        this._frames.delete(this._mainFrame._id);
        this._mainFrame._id = frameId;
      } else {
        assert3(!this._frames.has(frameId));
        this._mainFrame = new Frame(this._page, frameId, parentFrame);
      }
      this._frames.set(frameId, this._mainFrame);
      return this._mainFrame;
    } else {
      assert3(!this._frames.has(frameId));
      const frame = new Frame(this._page, frameId, parentFrame);
      this._frames.set(frameId, frame);
      this._page.emit(Page.Events.FrameAttached, frame);
      return frame;
    }
  }
  async waitForSignalsCreatedBy(progress3, waitAfter, action) {
    if (!waitAfter)
      return action();
    const barrier = new SignalBarrier(progress3);
    this._signalBarriers.add(barrier);
    if (progress3)
      progress3.cleanupWhenAborted(() => this._signalBarriers.delete(barrier));
    const result = await action();
    await this._page._delegate.inputActionEpilogue();
    await barrier.waitFor();
    this._signalBarriers.delete(barrier);
    await new Promise(makeWaitForNextTask());
    return result;
  }
  frameWillPotentiallyRequestNavigation() {
    for (const barrier of this._signalBarriers)
      barrier.retain();
  }
  frameDidPotentiallyRequestNavigation() {
    for (const barrier of this._signalBarriers)
      barrier.release();
  }
  frameRequestedNavigation(frameId, documentId) {
    const frame = this._frames.get(frameId);
    if (!frame)
      return;
    for (const barrier of this._signalBarriers)
      barrier.addFrameNavigation(frame);
    if (frame.pendingDocument() && frame.pendingDocument().documentId === documentId) {
      return;
    }
    const request4 = documentId ? Array.from(frame._inflightRequests).find((request22) => request22._documentId === documentId) : void 0;
    frame.setPendingDocument({ documentId, request: request4 });
  }
  frameCommittedNewDocumentNavigation(frameId, url4, name, documentId, initial) {
    const frame = this._frames.get(frameId);
    this.removeChildFramesRecursively(frame);
    this.clearWebSockets(frame);
    frame._url = url4;
    frame._name = name;
    let keepPending;
    const pendingDocument = frame.pendingDocument();
    if (pendingDocument) {
      if (pendingDocument.documentId === void 0) {
        pendingDocument.documentId = documentId;
      }
      if (pendingDocument.documentId === documentId) {
        frame._currentDocument = pendingDocument;
      } else {
        keepPending = pendingDocument;
        frame._currentDocument = { documentId, request: void 0 };
      }
      frame.setPendingDocument(void 0);
    } else {
      frame._currentDocument = { documentId, request: void 0 };
    }
    frame._onClearLifecycle();
    const navigationEvent = { url: url4, name, newDocument: frame._currentDocument, isPublic: true };
    this._fireInternalFrameNavigation(frame, navigationEvent);
    if (!initial) {
      debugLogger.log("api", `  navigated to "${url4}"`);
      this._page.frameNavigatedToNewDocument(frame);
    }
    frame.setPendingDocument(keepPending);
  }
  frameCommittedSameDocumentNavigation(frameId, url4) {
    const frame = this._frames.get(frameId);
    if (!frame)
      return;
    const pending = frame.pendingDocument();
    if (pending && pending.documentId === void 0 && pending.request === void 0) {
      frame.setPendingDocument(void 0);
    }
    frame._url = url4;
    const navigationEvent = { url: url4, name: frame._name, isPublic: true };
    this._fireInternalFrameNavigation(frame, navigationEvent);
    debugLogger.log("api", `  navigated to "${url4}"`);
  }
  frameAbortedNavigation(frameId, errorText, documentId) {
    const frame = this._frames.get(frameId);
    if (!frame || !frame.pendingDocument())
      return;
    if (documentId !== void 0 && frame.pendingDocument().documentId !== documentId)
      return;
    const navigationEvent = {
      url: frame._url,
      name: frame._name,
      newDocument: frame.pendingDocument(),
      error: new NavigationAbortedError(documentId, errorText),
      isPublic: !(documentId && frame._redirectedNavigations.has(documentId))
    };
    frame.setPendingDocument(void 0);
    this._fireInternalFrameNavigation(frame, navigationEvent);
  }
  frameDetached(frameId) {
    const frame = this._frames.get(frameId);
    if (frame) {
      this._removeFramesRecursively(frame);
      this._page.mainFrame()._recalculateNetworkIdle();
    }
  }
  frameLifecycleEvent(frameId, event) {
    const frame = this._frames.get(frameId);
    if (frame)
      frame._onLifecycleEvent(event);
  }
  requestStarted(request4, route) {
    const frame = request4.frame();
    this._inflightRequestStarted(request4);
    if (request4._documentId)
      frame.setPendingDocument({ documentId: request4._documentId, request: request4 });
    if (request4._isFavicon) {
      route?.abort("aborted").catch(() => {
      });
      return;
    }
    this._page.emitOnContext(BrowserContext.Events.Request, request4);
    if (route) {
      const r = new Route(request4, route);
      if (this._page._serverRequestInterceptor?.(r, request4))
        return;
      if (this._page._clientRequestInterceptor?.(r, request4))
        return;
      if (this._page._browserContext._requestInterceptor?.(r, request4))
        return;
      r.continue({ isFallback: true }).catch(() => {
      });
    }
  }
  requestReceivedResponse(response) {
    if (response.request()._isFavicon)
      return;
    this._page.emitOnContext(BrowserContext.Events.Response, response);
  }
  reportRequestFinished(request4, response) {
    this._inflightRequestFinished(request4);
    if (request4._isFavicon)
      return;
    this._page.emitOnContext(BrowserContext.Events.RequestFinished, { request: request4, response });
  }
  requestFailed(request4, canceled) {
    const frame = request4.frame();
    this._inflightRequestFinished(request4);
    if (frame.pendingDocument() && frame.pendingDocument().request === request4) {
      let errorText = request4.failure().errorText;
      if (canceled)
        errorText += "; maybe frame was detached?";
      this.frameAbortedNavigation(frame._id, errorText, frame.pendingDocument().documentId);
    }
    if (request4._isFavicon)
      return;
    this._page.emitOnContext(BrowserContext.Events.RequestFailed, request4);
  }
  dialogDidOpen(dialog) {
    for (const frame of this._frames.values())
      frame._invalidateNonStallingEvaluations("JavaScript dialog interrupted evaluation");
    if (this._closeAllOpeningDialogs)
      dialog.close().then(() => {
      });
    else
      this._openedDialogs.add(dialog);
  }
  dialogWillClose(dialog) {
    this._openedDialogs.delete(dialog);
  }
  async closeOpenDialogs() {
    await Promise.all([...this._openedDialogs].map((dialog) => dialog.close())).catch(() => {
    });
    this._openedDialogs.clear();
  }
  setCloseAllOpeningDialogs(closeDialogs) {
    this._closeAllOpeningDialogs = closeDialogs;
  }
  removeChildFramesRecursively(frame) {
    for (const child of frame.childFrames())
      this._removeFramesRecursively(child);
  }
  _removeFramesRecursively(frame) {
    this.removeChildFramesRecursively(frame);
    frame._onDetached();
    this._frames.delete(frame._id);
    if (!this._page.isClosed())
      this._page.emit(Page.Events.FrameDetached, frame);
  }
  _inflightRequestFinished(request4) {
    const frame = request4.frame();
    if (request4._isFavicon)
      return;
    if (!frame._inflightRequests.has(request4))
      return;
    frame._inflightRequests.delete(request4);
    if (frame._inflightRequests.size === 0)
      frame._startNetworkIdleTimer();
  }
  _inflightRequestStarted(request4) {
    const frame = request4.frame();
    if (request4._isFavicon)
      return;
    frame._inflightRequests.add(request4);
    if (frame._inflightRequests.size === 1)
      frame._stopNetworkIdleTimer();
  }
  interceptConsoleMessage(message) {
    if (message.type() !== "debug")
      return false;
    const tag = message.text();
    const handler = this._consoleMessageTags.get(tag);
    if (!handler)
      return false;
    this._consoleMessageTags.delete(tag);
    handler();
    return true;
  }
  clearWebSockets(frame) {
    if (frame.parentFrame())
      return;
    this._webSockets.clear();
  }
  onWebSocketCreated(requestId, url4) {
    const ws3 = new WebSocket3(this._page, url4);
    this._webSockets.set(requestId, ws3);
  }
  onWebSocketRequest(requestId) {
    const ws3 = this._webSockets.get(requestId);
    if (ws3 && ws3.markAsNotified())
      this._page.emit(Page.Events.WebSocket, ws3);
  }
  onWebSocketResponse(requestId, status, statusText2) {
    const ws3 = this._webSockets.get(requestId);
    if (status < 400)
      return;
    if (ws3)
      ws3.error(`${statusText2}: ${status}`);
  }
  onWebSocketFrameSent(requestId, opcode, data) {
    const ws3 = this._webSockets.get(requestId);
    if (ws3)
      ws3.frameSent(opcode, data);
  }
  webSocketFrameReceived(requestId, opcode, data) {
    const ws3 = this._webSockets.get(requestId);
    if (ws3)
      ws3.frameReceived(opcode, data);
  }
  webSocketClosed(requestId) {
    const ws3 = this._webSockets.get(requestId);
    if (ws3)
      ws3.closed();
    this._webSockets.delete(requestId);
  }
  webSocketError(requestId, errorMessage) {
    const ws3 = this._webSockets.get(requestId);
    if (ws3)
      ws3.error(errorMessage);
  }
  _fireInternalFrameNavigation(frame, event) {
    frame.emit(Frame.Events.InternalNavigation, event);
  }
};
var Frame = class _Frame extends SdkObject {
  static {
    __name(this, "Frame");
  }
  constructor(page, id, parentFrame) {
    super(page, "frame");
    this._firedLifecycleEvents = /* @__PURE__ */ new Set();
    this._firedNetworkIdleSelf = false;
    this._url = "";
    this._contextData = /* @__PURE__ */ new Map();
    this._childFrames = /* @__PURE__ */ new Set();
    this._name = "";
    this._inflightRequests = /* @__PURE__ */ new Set();
    this._setContentCounter = 0;
    this._detachedScope = new LongStandingScope();
    this._raceAgainstEvaluationStallingEventsPromises = /* @__PURE__ */ new Set();
    this._redirectedNavigations = /* @__PURE__ */ new Map();
    this.attribution.frame = this;
    this._id = id;
    this._page = page;
    this._parentFrame = parentFrame;
    this._currentDocument = { documentId: void 0, request: void 0 };
    this.selectors = new FrameSelectors(this);
    this._contextData.set("main", { contextPromise: new ManualPromise(), context: null });
    this._contextData.set("utility", { contextPromise: new ManualPromise(), context: null });
    this._setContext("main", null);
    this._setContext("utility", null);
    if (this._parentFrame)
      this._parentFrame._childFrames.add(this);
    this._firedLifecycleEvents.add("commit");
    if (id !== kDummyFrameId)
      this._startNetworkIdleTimer();
  }
  static {
    this.Events = {
      InternalNavigation: "internalnavigation",
      AddLifecycle: "addlifecycle",
      RemoveLifecycle: "removelifecycle"
    };
  }
  isDetached() {
    return this._detachedScope.isClosed();
  }
  _onLifecycleEvent(event) {
    if (this._firedLifecycleEvents.has(event))
      return;
    this._firedLifecycleEvents.add(event);
    this.emit(_Frame.Events.AddLifecycle, event);
    if (this === this._page.mainFrame() && this._url !== "about:blank")
      debugLogger.log("api", `  "${event}" event fired`);
    this._page.mainFrame()._recalculateNetworkIdle();
  }
  _onClearLifecycle() {
    for (const event of this._firedLifecycleEvents)
      this.emit(_Frame.Events.RemoveLifecycle, event);
    this._firedLifecycleEvents.clear();
    this._inflightRequests = new Set(Array.from(this._inflightRequests).filter((request4) => request4 === this._currentDocument.request));
    this._stopNetworkIdleTimer();
    if (this._inflightRequests.size === 0)
      this._startNetworkIdleTimer();
    this._page.mainFrame()._recalculateNetworkIdle(this);
    this._onLifecycleEvent("commit");
  }
  setPendingDocument(documentInfo) {
    this._pendingDocument = documentInfo;
    if (documentInfo)
      this._invalidateNonStallingEvaluations("Navigation interrupted the evaluation");
  }
  pendingDocument() {
    return this._pendingDocument;
  }
  _invalidateNonStallingEvaluations(message) {
    if (!this._raceAgainstEvaluationStallingEventsPromises.size)
      return;
    const error4 = new Error(message);
    for (const promise of this._raceAgainstEvaluationStallingEventsPromises)
      promise.reject(error4);
  }
  async raceAgainstEvaluationStallingEvents(cb) {
    if (this._pendingDocument)
      throw new Error("Frame is currently attempting a navigation");
    if (this._page._frameManager._openedDialogs.size)
      throw new Error("Open JavaScript dialog prevents evaluation");
    const promise = new ManualPromise();
    this._raceAgainstEvaluationStallingEventsPromises.add(promise);
    try {
      return await Promise.race([
        cb(),
        promise
      ]);
    } finally {
      this._raceAgainstEvaluationStallingEventsPromises.delete(promise);
    }
  }
  nonStallingRawEvaluateInExistingMainContext(expression) {
    return this.raceAgainstEvaluationStallingEvents(() => {
      const context2 = this._existingMainContext();
      if (!context2)
        throw new Error("Frame does not yet have a main execution context");
      return context2.rawEvaluateJSON(expression);
    });
  }
  nonStallingEvaluateInExistingContext(expression, world) {
    return this.raceAgainstEvaluationStallingEvents(() => {
      const context2 = this._contextData.get(world)?.context;
      if (!context2)
        throw new Error("Frame does not yet have the execution context");
      return context2.evaluateExpression(expression, { isFunction: false });
    });
  }
  _recalculateNetworkIdle(frameThatAllowsRemovingNetworkIdle) {
    let isNetworkIdle = this._firedNetworkIdleSelf;
    for (const child of this._childFrames) {
      child._recalculateNetworkIdle(frameThatAllowsRemovingNetworkIdle);
      if (!child._firedLifecycleEvents.has("networkidle"))
        isNetworkIdle = false;
    }
    if (isNetworkIdle && !this._firedLifecycleEvents.has("networkidle")) {
      this._firedLifecycleEvents.add("networkidle");
      this.emit(_Frame.Events.AddLifecycle, "networkidle");
      if (this === this._page.mainFrame() && this._url !== "about:blank")
        debugLogger.log("api", `  "networkidle" event fired`);
    }
    if (frameThatAllowsRemovingNetworkIdle !== this && this._firedLifecycleEvents.has("networkidle") && !isNetworkIdle) {
      this._firedLifecycleEvents.delete("networkidle");
      this.emit(_Frame.Events.RemoveLifecycle, "networkidle");
    }
  }
  async raceNavigationAction(progress3, options2, action) {
    return LongStandingScope.raceMultiple([
      this._detachedScope,
      this._page.openScope
    ], action().catch((e) => {
      if (e instanceof NavigationAbortedError && e.documentId) {
        const data = this._redirectedNavigations.get(e.documentId);
        if (data) {
          progress3.log(`waiting for redirected navigation to "${data.url}"`);
          return data.gotoPromise;
        }
      }
      throw e;
    }));
  }
  redirectNavigation(url4, documentId, referer) {
    const controller = new ProgressController(serverSideCallMetadata(), this);
    const data = {
      url: url4,
      gotoPromise: controller.run((progress3) => this._gotoAction(progress3, url4, { referer }), 0)
    };
    this._redirectedNavigations.set(documentId, data);
    data.gotoPromise.finally(() => this._redirectedNavigations.delete(documentId));
  }
  async goto(metadata, url4, options2 = {}) {
    const constructedNavigationURL = constructURLBasedOnBaseURL(this._page._browserContext._options.baseURL, url4);
    const controller = new ProgressController(metadata, this);
    return controller.run((progress3) => this._goto(progress3, constructedNavigationURL, options2), this._page._timeoutSettings.navigationTimeout(options2));
  }
  async _goto(progress3, url4, options2) {
    return this.raceNavigationAction(progress3, options2, async () => this._gotoAction(progress3, url4, options2));
  }
  async _gotoAction(progress3, url4, options2) {
    const waitUntil = verifyLifecycle("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    progress3.log(`navigating to "${url4}", waiting until "${waitUntil}"`);
    const headers = this._page.extraHTTPHeaders() || [];
    const refererHeader = headers.find((h) => h.name.toLowerCase() === "referer");
    let referer = refererHeader ? refererHeader.value : void 0;
    if (options2.referer !== void 0) {
      if (referer !== void 0 && referer !== options2.referer)
        throw new Error('"referer" is already specified as extra HTTP header');
      referer = options2.referer;
    }
    url4 = helper.completeUserURL(url4);
    const navigationEvents = [];
    const collectNavigations = /* @__PURE__ */ __name((arg) => navigationEvents.push(arg), "collectNavigations");
    this.on(_Frame.Events.InternalNavigation, collectNavigations);
    const navigateResult = await this._page._delegate.navigateFrame(this, url4, referer).finally(
      () => this.off(_Frame.Events.InternalNavigation, collectNavigations)
    );
    let event;
    if (navigateResult.newDocumentId) {
      const predicate = /* @__PURE__ */ __name((event2) => {
        return event2.newDocument && (event2.newDocument.documentId === navigateResult.newDocumentId || !event2.error);
      }, "predicate");
      const events = navigationEvents.filter(predicate);
      if (events.length)
        event = events[0];
      else
        event = await helper.waitForEvent(progress3, this, _Frame.Events.InternalNavigation, predicate).promise;
      if (event.newDocument.documentId !== navigateResult.newDocumentId) {
        throw new NavigationAbortedError(navigateResult.newDocumentId, `Navigation to "${url4}" is interrupted by another navigation to "${event.url}"`);
      }
      if (event.error)
        throw event.error;
    } else {
      const predicate = /* @__PURE__ */ __name((e) => !e.newDocument, "predicate");
      const events = navigationEvents.filter(predicate);
      if (events.length)
        event = events[0];
      else
        event = await helper.waitForEvent(progress3, this, _Frame.Events.InternalNavigation, predicate).promise;
    }
    if (!this._firedLifecycleEvents.has(waitUntil))
      await helper.waitForEvent(progress3, this, _Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
    const request4 = event.newDocument ? event.newDocument.request : void 0;
    const response = request4 ? request4._finalRequest().response() : null;
    return response;
  }
  async _waitForNavigation(progress3, requiresNewDocument, options2) {
    const waitUntil = verifyLifecycle("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    progress3.log(`waiting for navigation until "${waitUntil}"`);
    const navigationEvent = await helper.waitForEvent(progress3, this, _Frame.Events.InternalNavigation, (event) => {
      if (event.error)
        return true;
      if (requiresNewDocument && !event.newDocument)
        return false;
      progress3.log(`  navigated to "${this._url}"`);
      return true;
    }).promise;
    if (navigationEvent.error)
      throw navigationEvent.error;
    if (!this._firedLifecycleEvents.has(waitUntil))
      await helper.waitForEvent(progress3, this, _Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
    const request4 = navigationEvent.newDocument ? navigationEvent.newDocument.request : void 0;
    return request4 ? request4._finalRequest().response() : null;
  }
  async _waitForLoadState(progress3, state) {
    const waitUntil = verifyLifecycle("state", state);
    if (!this._firedLifecycleEvents.has(waitUntil))
      await helper.waitForEvent(progress3, this, _Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
  }
  async frameElement() {
    return this._page._delegate.getFrameElement(this);
  }
  _context(world) {
    return this._contextData.get(world).contextPromise.then((contextOrDestroyedReason) => {
      if (contextOrDestroyedReason instanceof ExecutionContext)
        return contextOrDestroyedReason;
      throw new Error(contextOrDestroyedReason.destroyedReason);
    });
  }
  _mainContext() {
    return this._context("main");
  }
  _existingMainContext() {
    return this._contextData.get("main")?.context || null;
  }
  _utilityContext() {
    return this._context("utility");
  }
  async evaluateExpression(expression, options2 = {}, arg) {
    const context2 = await this._context(options2.world ?? "main");
    const value = await context2.evaluateExpression(expression, options2, arg);
    return value;
  }
  async evaluateExpressionHandle(expression, options2 = {}, arg) {
    const context2 = await this._context(options2.world ?? "main");
    const value = await context2.evaluateExpressionHandle(expression, options2, arg);
    return value;
  }
  async querySelector(selector, options2) {
    debugLogger.log("api", `    finding element using the selector "${selector}"`);
    return this.selectors.query(selector, options2);
  }
  async waitForSelector(metadata, selector, options2, scope) {
    const controller = new ProgressController(metadata, this);
    if (options2.visibility)
      throw new Error("options.visibility is not supported, did you mean options.state?");
    if (options2.waitFor && options2.waitFor !== "visible")
      throw new Error("options.waitFor is not supported, did you mean options.state?");
    const { state = "visible" } = options2;
    if (!["attached", "detached", "visible", "hidden"].includes(state))
      throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
    return controller.run(async (progress3) => {
      progress3.log(`waiting for ${this._asLocator(selector)}${state === "attached" ? "" : " to be " + state}`);
      return await this.waitForSelectorInternal(progress3, selector, true, options2, scope);
    }, this._page._timeoutSettings.timeout(options2));
  }
  async waitForSelectorInternal(progress3, selector, performActionPreChecks, options2, scope) {
    const { state = "visible" } = options2;
    const promise = this.retryWithProgressAndTimeouts(progress3, [0, 20, 50, 100, 100, 500], async (continuePolling) => {
      if (performActionPreChecks)
        await this._page.performActionPreChecks(progress3);
      const resolved = await this.selectors.resolveInjectedForSelector(selector, options2, scope);
      progress3.throwIfAborted();
      if (!resolved) {
        if (state === "hidden" || state === "detached")
          return null;
        return continuePolling;
      }
      const result = await resolved.injected.evaluateHandle((injected, { info: info3, root }) => {
        if (root && !root.isConnected)
          throw injected.createStacklessError("Element is not attached to the DOM");
        const elements = injected.querySelectorAll(info3.parsed, root || document);
        const element2 = elements[0];
        const visible2 = element2 ? injected.utils.isElementVisible(element2) : false;
        let log22 = "";
        if (elements.length > 1) {
          if (info3.strict)
            throw injected.strictModeViolationError(info3.parsed, elements);
          log22 = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
        } else if (element2) {
          log22 = `  locator resolved to ${visible2 ? "visible" : "hidden"} ${injected.previewNode(element2)}`;
        }
        return { log: log22, element: element2, visible: visible2, attached: !!element2 };
      }, { info: resolved.info, root: resolved.frame === this ? scope : void 0 });
      const { log: log4, visible, attached } = await result.evaluate((r) => ({ log: r.log, visible: r.visible, attached: r.attached }));
      if (log4)
        progress3.log(log4);
      const success = { attached, detached: !attached, visible, hidden: !visible }[state];
      if (!success) {
        result.dispose();
        return continuePolling;
      }
      if (options2.omitReturnValue) {
        result.dispose();
        return null;
      }
      const element = state === "attached" || state === "visible" ? await result.evaluateHandle((r) => r.element) : null;
      result.dispose();
      if (!element)
        return null;
      if (options2.__testHookBeforeAdoptNode)
        await options2.__testHookBeforeAdoptNode();
      try {
        return await element._adoptTo(await resolved.frame._mainContext());
      } catch (e) {
        return continuePolling;
      }
    });
    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
  }
  async dispatchEvent(metadata, selector, type2, eventInit = {}, options2 = {}, scope) {
    await this._callOnElementOnceMatches(metadata, selector, (injectedScript, element, data) => {
      injectedScript.dispatchEvent(element, data.type, data.eventInit);
    }, { type: type2, eventInit }, { mainWorld: true, ...options2 }, scope);
  }
  async evalOnSelector(selector, strict, expression, isFunction2, arg, scope) {
    const handle = await this.selectors.query(selector, { strict }, scope);
    if (!handle)
      throw new Error(`Failed to find element matching selector "${selector}"`);
    const result = await handle.evaluateExpression(expression, { isFunction: isFunction2 }, arg);
    handle.dispose();
    return result;
  }
  async evalOnSelectorAll(selector, expression, isFunction2, arg, scope) {
    const arrayHandle = await this.selectors.queryArrayInMainWorld(selector, scope);
    const result = await arrayHandle.evaluateExpression(expression, { isFunction: isFunction2 }, arg);
    arrayHandle.dispose();
    return result;
  }
  async maskSelectors(selectors2, color) {
    const context2 = await this._utilityContext();
    const injectedScript = await context2.injectedScript();
    await injectedScript.evaluate((injected, { parsed, color: color2 }) => {
      injected.maskSelectors(parsed, color2);
    }, { parsed: selectors2, color });
  }
  async querySelectorAll(selector) {
    return this.selectors.queryAll(selector);
  }
  async queryCount(selector) {
    return await this.selectors.queryCount(selector);
  }
  async content() {
    try {
      const context2 = await this._utilityContext();
      return await context2.evaluate(() => {
        let retVal = "";
        if (document.doctype)
          retVal = new XMLSerializer().serializeToString(document.doctype);
        if (document.documentElement)
          retVal += document.documentElement.outerHTML;
        return retVal;
      });
    } catch (e) {
      if (isJavaScriptErrorInEvaluate(e) || isSessionClosedError(e))
        throw e;
      throw new Error(`Unable to retrieve content because the page is navigating and changing the content.`);
    }
  }
  async setContent(metadata, html, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      await this.raceNavigationAction(progress3, options2, async () => {
        const waitUntil = options2.waitUntil === void 0 ? "load" : options2.waitUntil;
        progress3.log(`setting frame content, waiting until "${waitUntil}"`);
        const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
        const context2 = await this._utilityContext();
        const lifecyclePromise = new Promise((resolve, reject) => {
          this._page._frameManager._consoleMessageTags.set(tag, () => {
            this._onClearLifecycle();
            this._waitForLoadState(progress3, waitUntil).then(resolve).catch(reject);
          });
        });
        const contentPromise = context2.evaluate(({ html: html2, tag: tag2 }) => {
          document.open();
          console.debug(tag2);
          document.write(html2);
          document.close();
        }, { html, tag });
        await Promise.all([contentPromise, lifecyclePromise]);
        return null;
      });
    }, this._page._timeoutSettings.navigationTimeout(options2));
  }
  name() {
    return this._name || "";
  }
  url() {
    return this._url;
  }
  origin() {
    if (!this._url.startsWith("http"))
      return;
    return parseURL2(this._url)?.origin;
  }
  parentFrame() {
    return this._parentFrame;
  }
  childFrames() {
    return Array.from(this._childFrames);
  }
  async addScriptTag(params) {
    const {
      url: url4 = null,
      content = null,
      type: type2 = ""
    } = params;
    if (!url4 && !content)
      throw new Error("Provide an object with a `url`, `path` or `content` property");
    const context2 = await this._mainContext();
    return this._raceWithCSPError(async () => {
      if (url4 !== null)
        return (await context2.evaluateHandle(addScriptUrl, { url: url4, type: type2 })).asElement();
      const result = (await context2.evaluateHandle(addScriptContent, { content, type: type2 })).asElement();
      if (this._page._delegate.cspErrorsAsynchronousForInlineScripts)
        await context2.evaluate(() => true);
      return result;
    });
    async function addScriptUrl(params2) {
      const script = document.createElement("script");
      script.src = params2.url;
      if (params2.type)
        script.type = params2.type;
      const promise = new Promise((res, rej) => {
        script.onload = res;
        script.onerror = (e) => rej(typeof e === "string" ? new Error(e) : new Error(`Failed to load script at ${script.src}`));
      });
      document.head.appendChild(script);
      await promise;
      return script;
    }
    __name(addScriptUrl, "addScriptUrl");
    function addScriptContent(params2) {
      const script = document.createElement("script");
      script.type = params2.type || "text/javascript";
      script.text = params2.content;
      let error4 = null;
      script.onerror = (e) => error4 = e;
      document.head.appendChild(script);
      if (error4)
        throw error4;
      return script;
    }
    __name(addScriptContent, "addScriptContent");
  }
  async addStyleTag(params) {
    const {
      url: url4 = null,
      content = null
    } = params;
    if (!url4 && !content)
      throw new Error("Provide an object with a `url`, `path` or `content` property");
    const context2 = await this._mainContext();
    return this._raceWithCSPError(async () => {
      if (url4 !== null)
        return (await context2.evaluateHandle(addStyleUrl, url4)).asElement();
      return (await context2.evaluateHandle(addStyleContent, content)).asElement();
    });
    async function addStyleUrl(url22) {
      const link2 = document.createElement("link");
      link2.rel = "stylesheet";
      link2.href = url22;
      const promise = new Promise((res, rej) => {
        link2.onload = res;
        link2.onerror = rej;
      });
      document.head.appendChild(link2);
      await promise;
      return link2;
    }
    __name(addStyleUrl, "addStyleUrl");
    async function addStyleContent(content2) {
      const style = document.createElement("style");
      style.type = "text/css";
      style.appendChild(document.createTextNode(content2));
      const promise = new Promise((res, rej) => {
        style.onload = res;
        style.onerror = rej;
      });
      document.head.appendChild(style);
      await promise;
      return style;
    }
    __name(addStyleContent, "addStyleContent");
  }
  async _raceWithCSPError(func) {
    const listeners2 = [];
    let result;
    let error4;
    let cspMessage;
    const actionPromise = func().then((r) => result = r).catch((e) => error4 = e);
    const errorPromise = new Promise((resolve) => {
      listeners2.push(eventsHelper.addEventListener(this._page._browserContext, BrowserContext.Events.Console, (message) => {
        if (message.page() !== this._page || message.type() !== "error")
          return;
        if (message.text().includes("Content-Security-Policy") || message.text().includes("Content Security Policy")) {
          cspMessage = message;
          resolve();
        }
      }));
    });
    await Promise.race([actionPromise, errorPromise]);
    eventsHelper.removeEventListeners(listeners2);
    if (cspMessage)
      throw new Error(cspMessage.text());
    if (error4)
      throw error4;
    return result;
  }
  async retryWithProgressAndTimeouts(progress3, timeouts, action) {
    const continuePolling = Symbol("continuePolling");
    timeouts = [0, ...timeouts];
    let timeoutIndex = 0;
    while (progress3.isRunning()) {
      const timeout = timeouts[Math.min(timeoutIndex++, timeouts.length - 1)];
      if (timeout) {
        const actionPromise = new Promise((f) => setTimeout(f, timeout));
        await LongStandingScope.raceMultiple([
          this._page.openScope,
          this._detachedScope
        ], actionPromise);
      }
      progress3.throwIfAborted();
      try {
        const result = await action(continuePolling);
        if (result === continuePolling)
          continue;
        return result;
      } catch (e) {
        if (this._isErrorThatCannotBeRetried(e))
          throw e;
        continue;
      }
    }
    progress3.throwIfAborted();
    return void 0;
  }
  _isErrorThatCannotBeRetried(e) {
    if (isJavaScriptErrorInEvaluate(e) || isSessionClosedError(e))
      return true;
    if (isNonRecoverableDOMError(e) || isInvalidSelectorError(e))
      return true;
    if (this.isDetached())
      return true;
    return false;
  }
  async _retryWithProgressIfNotConnected(progress3, selector, strict, performActionPreChecks, action) {
    progress3.log(`waiting for ${this._asLocator(selector)}`);
    return this.retryWithProgressAndTimeouts(progress3, [0, 20, 50, 100, 100, 500], async (continuePolling) => {
      if (performActionPreChecks)
        await this._page.performActionPreChecks(progress3);
      const resolved = await this.selectors.resolveInjectedForSelector(selector, { strict });
      progress3.throwIfAborted();
      if (!resolved)
        return continuePolling;
      const result = await resolved.injected.evaluateHandle((injected, { info: info3, callId }) => {
        const elements = injected.querySelectorAll(info3.parsed, document);
        if (callId)
          injected.markTargetElements(new Set(elements), callId);
        const element2 = elements[0];
        let log22 = "";
        if (elements.length > 1) {
          if (info3.strict)
            throw injected.strictModeViolationError(info3.parsed, elements);
          log22 = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
        } else if (element2) {
          log22 = `  locator resolved to ${injected.previewNode(element2)}`;
        }
        return { log: log22, success: !!element2, element: element2 };
      }, { info: resolved.info, callId: progress3.metadata.id });
      const { log: log4, success } = await result.evaluate((r) => ({ log: r.log, success: r.success }));
      if (log4)
        progress3.log(log4);
      if (!success) {
        result.dispose();
        return continuePolling;
      }
      const element = await result.evaluateHandle((r) => r.element);
      result.dispose();
      try {
        const result2 = await action(element);
        if (result2 === "error:notconnected") {
          progress3.log("element was detached from the DOM, retrying");
          return continuePolling;
        }
        return result2;
      } finally {
        element?.dispose();
      }
    });
  }
  async rafrafTimeoutScreenshotElementWithProgress(progress3, selector, timeout, options2) {
    return await this._retryWithProgressIfNotConnected(progress3, selector, true, true, async (handle) => {
      await handle._frame.rafrafTimeout(timeout);
      return await this._page._screenshotter.screenshotElement(progress3, handle, options2);
    });
  }
  async click(metadata, selector, options2) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._click(progress3, { ...options2, waitAfter: !options2.noWaitAfter })));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async dblclick(metadata, selector, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._dblclick(progress3, options2)));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async dragAndDrop(metadata, source7, target, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    await controller.run(async (progress3) => {
      assertDone(await this._retryWithProgressIfNotConnected(progress3, source7, options2.strict, !options2.force, async (handle) => {
        return handle._retryPointerAction(progress3, "move and down", false, async (point) => {
          await this._page.mouse.move(point.x, point.y);
          await this._page.mouse.down();
        }, {
          ...options2,
          waitAfter: "disabled",
          position: options2.sourcePosition,
          timeout: progress3.timeUntilDeadline()
        });
      }));
      assertDone(await this._retryWithProgressIfNotConnected(progress3, target, options2.strict, false, async (handle) => {
        return handle._retryPointerAction(progress3, "move and up", false, async (point) => {
          await this._page.mouse.move(point.x, point.y);
          await this._page.mouse.up();
        }, {
          ...options2,
          waitAfter: "disabled",
          position: options2.targetPosition,
          timeout: progress3.timeUntilDeadline()
        });
      }));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async tap(metadata, selector, options2) {
    if (!this._page._browserContext._options.hasTouch)
      throw new Error("The page does not support tap. Use hasTouch context option to enable touch support.");
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._tap(progress3, options2)));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async fill(metadata, selector, value, options2) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._fill(progress3, value, options2)));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async focus(metadata, selector, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    await controller.run(async (progress3) => {
      assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, true, (handle) => handle._focus(progress3)));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async blur(metadata, selector, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    await controller.run(async (progress3) => {
      assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, true, (handle) => handle._blur(progress3)));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async textContent(metadata, selector, options2 = {}, scope) {
    return this._callOnElementOnceMatches(metadata, selector, (injected, element) => element.textContent, void 0, options2, scope);
  }
  async innerText(metadata, selector, options2 = {}, scope) {
    return this._callOnElementOnceMatches(metadata, selector, (injectedScript, element) => {
      if (element.namespaceURI !== "http://www.w3.org/1999/xhtml")
        throw injectedScript.createStacklessError("Node is not an HTMLElement");
      return element.innerText;
    }, void 0, options2, scope);
  }
  async innerHTML(metadata, selector, options2 = {}, scope) {
    return this._callOnElementOnceMatches(metadata, selector, (injected, element) => element.innerHTML, void 0, options2, scope);
  }
  async getAttribute(metadata, selector, name, options2 = {}, scope) {
    return this._callOnElementOnceMatches(metadata, selector, (injected, element, data) => element.getAttribute(data.name), { name }, options2, scope);
  }
  async inputValue(metadata, selector, options2 = {}, scope) {
    return this._callOnElementOnceMatches(metadata, selector, (injectedScript, node2) => {
      const element = injectedScript.retarget(node2, "follow-label");
      if (!element || element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")
        throw injectedScript.createStacklessError("Node is not an <input>, <textarea> or <select> element");
      return element.value;
    }, void 0, options2, scope);
  }
  async highlight(selector) {
    const resolved = await this.selectors.resolveInjectedForSelector(selector);
    if (!resolved)
      return;
    return await resolved.injected.evaluate((injected, { info: info3 }) => {
      return injected.highlight(info3.parsed);
    }, { info: resolved.info });
  }
  async hideHighlight() {
    return this.raceAgainstEvaluationStallingEvents(async () => {
      const context2 = await this._utilityContext();
      const injectedScript = await context2.injectedScript();
      return await injectedScript.evaluate((injected) => {
        return injected.hideHighlight();
      });
    });
  }
  async _elementState(metadata, selector, state, options2 = {}, scope) {
    const result = await this._callOnElementOnceMatches(metadata, selector, (injected, element, data) => {
      return injected.elementState(element, data.state);
    }, { state }, options2, scope);
    if (result.received === "error:notconnected")
      throwElementIsNotAttached();
    return result.matches;
  }
  async isVisible(metadata, selector, options2 = {}, scope) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      progress3.log(`  checking visibility of ${this._asLocator(selector)}`);
      return await this.isVisibleInternal(selector, options2, scope);
    }, this._page._timeoutSettings.timeout({}));
  }
  async isVisibleInternal(selector, options2 = {}, scope) {
    try {
      const resolved = await this.selectors.resolveInjectedForSelector(selector, options2, scope);
      if (!resolved)
        return false;
      return await resolved.injected.evaluate((injected, { info: info3, root }) => {
        const element = injected.querySelector(info3.parsed, root || document, info3.strict);
        const state = element ? injected.elementState(element, "visible") : { matches: false, received: "error:notconnected" };
        return state.matches;
      }, { info: resolved.info, root: resolved.frame === this ? scope : void 0 });
    } catch (e) {
      if (isJavaScriptErrorInEvaluate(e) || isInvalidSelectorError(e) || isSessionClosedError(e))
        throw e;
      return false;
    }
  }
  async isHidden(metadata, selector, options2 = {}, scope) {
    return !await this.isVisible(metadata, selector, options2, scope);
  }
  async isDisabled(metadata, selector, options2 = {}, scope) {
    return this._elementState(metadata, selector, "disabled", options2, scope);
  }
  async isEnabled(metadata, selector, options2 = {}, scope) {
    return this._elementState(metadata, selector, "enabled", options2, scope);
  }
  async isEditable(metadata, selector, options2 = {}, scope) {
    return this._elementState(metadata, selector, "editable", options2, scope);
  }
  async isChecked(metadata, selector, options2 = {}, scope) {
    return this._elementState(metadata, selector, "checked", options2, scope);
  }
  async hover(metadata, selector, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._hover(progress3, options2)));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async selectOption(metadata, selector, elements, values, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      return await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._selectOption(progress3, elements, values, options2));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async setInputFiles(metadata, selector, params) {
    const inputFileItems = await prepareFilesForUpload(this, params);
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, params.strict, true, (handle) => handle._setInputFiles(progress3, inputFileItems)));
    }, this._page._timeoutSettings.timeout(params));
  }
  async type(metadata, selector, text, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, true, (handle) => handle._type(progress3, text, options2)));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async press(metadata, selector, key, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, true, (handle) => handle._press(progress3, key, options2)));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async check(metadata, selector, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._setChecked(progress3, true, options2)));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async uncheck(metadata, selector, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._setChecked(progress3, false, options2)));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async waitForTimeout(metadata, timeout) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async () => {
      await new Promise((resolve) => setTimeout(resolve, timeout));
    });
  }
  async ariaSnapshot(metadata, selector, options2 = {}) {
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      return await this._retryWithProgressIfNotConnected(progress3, selector, true, true, (handle) => handle.ariaSnapshot(options2));
    }, this._page._timeoutSettings.timeout(options2));
  }
  async expect(metadata, selector, options2) {
    const result = await this._expectImpl(metadata, selector, options2);
    if (result.matches === options2.isNot)
      metadata.error = { error: { name: "Expect", message: "Expect failed" } };
    return result;
  }
  async _expectImpl(metadata, selector, options2) {
    const lastIntermediateResult = { isSet: false };
    try {
      let timeout = this._page._timeoutSettings.timeout(options2);
      const start = timeout > 0 ? monotonicTime() : 0;
      await new ProgressController(metadata, this).run(async (progress3) => {
        progress3.log(`${metadata.apiName}${timeout ? ` with timeout ${timeout}ms` : ""}`);
        progress3.log(`waiting for ${this._asLocator(selector)}`);
        await this._page.performActionPreChecks(progress3);
      }, timeout);
      try {
        const resultOneShot = await new ProgressController(metadata, this).run(async (progress3) => {
          return await this._expectInternal(progress3, selector, options2, lastIntermediateResult);
        });
        if (resultOneShot.matches !== options2.isNot)
          return resultOneShot;
      } catch (e) {
        if (isJavaScriptErrorInEvaluate(e) || isInvalidSelectorError(e))
          throw e;
      }
      if (timeout > 0) {
        const elapsed = monotonicTime() - start;
        timeout -= elapsed;
      }
      if (timeout < 0)
        return { matches: options2.isNot, log: compressCallLog(metadata.log), timedOut: true, received: lastIntermediateResult.received };
      return await new ProgressController(metadata, this).run(async (progress3) => {
        return await this.retryWithProgressAndTimeouts(progress3, [100, 250, 500, 1e3], async (continuePolling) => {
          await this._page.performActionPreChecks(progress3);
          const { matches, received } = await this._expectInternal(progress3, selector, options2, lastIntermediateResult);
          if (matches === options2.isNot) {
            return continuePolling;
          }
          return { matches, received };
        });
      }, timeout);
    } catch (e) {
      if (isJavaScriptErrorInEvaluate(e) || isInvalidSelectorError(e))
        throw e;
      const result = { matches: options2.isNot, log: compressCallLog(metadata.log) };
      if (lastIntermediateResult.isSet)
        result.received = lastIntermediateResult.received;
      if (e instanceof TimeoutError)
        result.timedOut = true;
      return result;
    }
  }
  async _expectInternal(progress3, selector, options2, lastIntermediateResult) {
    const selectorInFrame = await this.selectors.resolveFrameForSelector(selector, { strict: true });
    progress3.throwIfAborted();
    const { frame, info: info3 } = selectorInFrame || { frame: this, info: void 0 };
    const world = options2.expression === "to.have.property" ? "main" : info3?.world ?? "utility";
    const context2 = await frame._context(world);
    const injected = await context2.injectedScript();
    progress3.throwIfAborted();
    const { log: log4, matches, received, missingReceived } = await injected.evaluate(async (injected2, { info: info22, options: options22, callId }) => {
      const elements = info22 ? injected2.querySelectorAll(info22.parsed, document) : [];
      if (callId)
        injected2.markTargetElements(new Set(elements), callId);
      const isArray2 = options22.expression === "to.have.count" || options22.expression.endsWith(".array");
      let log22 = "";
      if (isArray2)
        log22 = `  locator resolved to ${elements.length} element${elements.length === 1 ? "" : "s"}`;
      else if (elements.length > 1)
        throw injected2.strictModeViolationError(info22.parsed, elements);
      else if (elements.length)
        log22 = `  locator resolved to ${injected2.previewNode(elements[0])}`;
      return { log: log22, ...await injected2.expect(elements[0], options22, elements) };
    }, { info: info3, options: options2, callId: progress3.metadata.id });
    if (log4)
      progress3.log(log4);
    if (matches === options2.isNot) {
      lastIntermediateResult.received = missingReceived ? "<element(s) not found>" : received;
      lastIntermediateResult.isSet = true;
      if (!missingReceived && !Array.isArray(received))
        progress3.log(`  unexpected value "${renderUnexpectedValue(options2.expression, received)}"`);
    }
    return { matches, received };
  }
  async _waitForFunctionExpression(metadata, expression, isFunction2, arg, options2, world = "main") {
    const controller = new ProgressController(metadata, this);
    if (typeof options2.pollingInterval === "number")
      assert3(options2.pollingInterval > 0, "Cannot poll with non-positive interval: " + options2.pollingInterval);
    expression = normalizeEvaluationExpression(expression, isFunction2);
    return controller.run(async (progress3) => {
      return this.retryWithProgressAndTimeouts(progress3, [100], async () => {
        const context2 = world === "main" ? await this._mainContext() : await this._utilityContext();
        const injectedScript = await context2.injectedScript();
        const handle = await injectedScript.evaluateHandle((injected, { expression: expression2, isFunction: isFunction22, polling, arg: arg2 }) => {
          const predicate = /* @__PURE__ */ __name(() => {
            let result2 = globalThis.eval(expression2);
            if (isFunction22 === true) {
              result2 = result2(arg2);
            } else if (isFunction22 === false) {
              result2 = result2;
            } else {
              if (typeof result2 === "function")
                result2 = result2(arg2);
            }
            return result2;
          }, "predicate");
          let fulfill;
          let reject;
          let aborted2 = false;
          const result = new Promise((f, r) => {
            fulfill = f;
            reject = r;
          });
          const next = /* @__PURE__ */ __name(() => {
            if (aborted2)
              return;
            try {
              const success = predicate();
              if (success) {
                fulfill(success);
                return;
              }
              if (typeof polling !== "number")
                injected.utils.builtins.requestAnimationFrame(next);
              else
                injected.utils.builtins.setTimeout(next, polling);
            } catch (e) {
              reject(e);
            }
          }, "next");
          next();
          return { result, abort: /* @__PURE__ */ __name(() => aborted2 = true, "abort") };
        }, { expression, isFunction: isFunction2, polling: options2.pollingInterval, arg });
        progress3.cleanupWhenAborted(() => handle.evaluate((h) => h.abort()).catch(() => {
        }));
        return handle.evaluateHandle((h) => h.result);
      });
    }, this._page._timeoutSettings.timeout(options2));
  }
  async waitForFunctionValueInUtility(progress3, pageFunction) {
    const expression = `() => {
      const result = (${pageFunction})();
      if (!result)
        return result;
      return JSON.stringify(result);
    }`;
    const handle = await this._waitForFunctionExpression(serverSideCallMetadata(), expression, true, void 0, { timeout: progress3.timeUntilDeadline() }, "utility");
    return JSON.parse(handle.rawValue());
  }
  async title() {
    const context2 = await this._utilityContext();
    return context2.evaluate(() => document.title);
  }
  async rafrafTimeout(timeout) {
    if (timeout === 0)
      return;
    const context2 = await this._utilityContext();
    await Promise.all([
      // wait for double raf
      context2.evaluate(() => new Promise((x) => {
        requestAnimationFrame(() => {
          requestAnimationFrame(x);
        });
      })),
      new Promise((fulfill) => setTimeout(fulfill, timeout))
    ]);
  }
  _onDetached() {
    this._stopNetworkIdleTimer();
    this._detachedScope.close(new Error("Frame was detached"));
    for (const data of this._contextData.values()) {
      if (data.context)
        data.context.contextDestroyed("Frame was detached");
      data.contextPromise.resolve({ destroyedReason: "Frame was detached" });
    }
    if (this._parentFrame)
      this._parentFrame._childFrames.delete(this);
    this._parentFrame = null;
  }
  async _callOnElementOnceMatches(metadata, selector, body, taskData, options2 = {}, scope) {
    const callbackText = body.toString();
    const controller = new ProgressController(metadata, this);
    return controller.run(async (progress3) => {
      progress3.log(`waiting for ${this._asLocator(selector)}`);
      const promise = this.retryWithProgressAndTimeouts(progress3, [0, 20, 50, 100, 100, 500], async (continuePolling) => {
        const resolved = await this.selectors.resolveInjectedForSelector(selector, options2, scope);
        progress3.throwIfAborted();
        if (!resolved)
          return continuePolling;
        const { log: log4, success, value } = await resolved.injected.evaluate((injected, { info: info3, callbackText: callbackText2, taskData: taskData2, callId, root }) => {
          const callback = injected.eval(callbackText2);
          const element = injected.querySelector(info3.parsed, root || document, info3.strict);
          if (!element)
            return { success: false };
          const log22 = `  locator resolved to ${injected.previewNode(element)}`;
          if (callId)
            injected.markTargetElements(/* @__PURE__ */ new Set([element]), callId);
          return { log: log22, success: true, value: callback(injected, element, taskData2) };
        }, { info: resolved.info, callbackText, taskData, callId: progress3.metadata.id, root: resolved.frame === this ? scope : void 0 });
        if (log4)
          progress3.log(log4);
        if (!success)
          return continuePolling;
        return value;
      });
      return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
    }, this._page._timeoutSettings.timeout(options2));
  }
  _setContext(world, context2) {
    const data = this._contextData.get(world);
    data.context = context2;
    if (context2)
      data.contextPromise.resolve(context2);
    else
      data.contextPromise = new ManualPromise();
  }
  _contextCreated(world, context2) {
    const data = this._contextData.get(world);
    if (data.context) {
      data.context.contextDestroyed("Execution context was destroyed, most likely because of a navigation");
      this._setContext(world, null);
    }
    this._setContext(world, context2);
  }
  _contextDestroyed(context2) {
    if (this._detachedScope.isClosed())
      return;
    context2.contextDestroyed("Execution context was destroyed, most likely because of a navigation");
    for (const [world, data] of this._contextData) {
      if (data.context === context2)
        this._setContext(world, null);
    }
  }
  _startNetworkIdleTimer() {
    assert3(!this._networkIdleTimer);
    if (this._firedLifecycleEvents.has("networkidle") || this._detachedScope.isClosed())
      return;
    this._networkIdleTimer = setTimeout(() => {
      this._firedNetworkIdleSelf = true;
      this._page.mainFrame()._recalculateNetworkIdle();
    }, 500);
  }
  _stopNetworkIdleTimer() {
    if (this._networkIdleTimer)
      clearTimeout(this._networkIdleTimer);
    this._networkIdleTimer = void 0;
    this._firedNetworkIdleSelf = false;
  }
  async extendInjectedScript(source7, arg) {
    const context2 = await this._context("main");
    const injectedScriptHandle = await context2.injectedScript();
    return injectedScriptHandle.evaluateHandle((injectedScript, { source: source22, arg: arg2 }) => {
      return injectedScript.extend(source22, arg2);
    }, { source: source7, arg });
  }
  async resetStorageForCurrentOriginBestEffort(newStorage) {
    const context2 = await this._utilityContext();
    await context2.evaluate(async ({ ls }) => {
      sessionStorage.clear();
      localStorage.clear();
      for (const entry of ls || [])
        localStorage[entry.name] = entry.value;
      const registrations = navigator.serviceWorker ? await navigator.serviceWorker.getRegistrations() : [];
      await Promise.all(registrations.map(async (r) => {
        if (!r.installing && !r.waiting && !r.active)
          r.unregister().catch(() => {
          });
        else
          await r.unregister().catch(() => {
          });
      }));
      for (const db of await indexedDB.databases?.() || []) {
        if (db.name)
          indexedDB.deleteDatabase(db.name);
      }
    }, { ls: newStorage?.localStorage }).catch(() => {
    });
  }
  _asLocator(selector) {
    return asLocator(this._page.attribution.playwright.options.sdkLanguage, selector);
  }
};
var SignalBarrier = class {
  static {
    __name(this, "SignalBarrier");
  }
  constructor(progress3) {
    this._protectCount = 0;
    this._promise = new ManualPromise();
    this._progress = progress3;
    this.retain();
  }
  waitFor() {
    this.release();
    return this._promise;
  }
  async addFrameNavigation(frame) {
    if (frame.parentFrame())
      return;
    this.retain();
    const waiter = helper.waitForEvent(null, frame, Frame.Events.InternalNavigation, (e) => {
      if (!e.isPublic)
        return false;
      if (!e.error && this._progress)
        this._progress.log(`  navigated to "${frame._url}"`);
      return true;
    });
    await LongStandingScope.raceMultiple([
      frame._page.openScope,
      frame._detachedScope
    ], waiter.promise).catch(() => {
    });
    waiter.dispose();
    this.release();
  }
  retain() {
    ++this._protectCount;
  }
  release() {
    --this._protectCount;
    if (!this._protectCount)
      this._promise.resolve();
  }
};
function verifyLifecycle(name, waitUntil) {
  if (waitUntil === "networkidle0")
    waitUntil = "networkidle";
  if (!kLifecycleEvents.has(waitUntil))
    throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
  return waitUntil;
}
__name(verifyLifecycle, "verifyLifecycle");
function renderUnexpectedValue(expression, received) {
  if (expression === "to.match.aria")
    return received ? received.raw : received;
  return received;
}
__name(renderUnexpectedValue, "renderUnexpectedValue");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/har/harTracer.js
var FALLBACK_HTTP_VERSION = "HTTP/1.1";
var HarTracer = class {
  static {
    __name(this, "HarTracer");
  }
  constructor(context2, page, delegate, options2) {
    this._barrierPromises = /* @__PURE__ */ new Set();
    this._pageEntries = /* @__PURE__ */ new Map();
    this._eventListeners = [];
    this._started = false;
    this._context = context2;
    this._page = page;
    this._delegate = delegate;
    this._options = options2;
    if (options2.slimMode) {
      options2.omitSecurityDetails = true;
      options2.omitCookies = true;
      options2.omitTiming = true;
      options2.omitServerIP = true;
      options2.omitSizes = true;
      options2.omitPages = true;
    }
    this._entrySymbol = Symbol("requestHarEntry");
    this._baseURL = context2 instanceof APIRequestContext ? context2._defaultOptions().baseURL : context2._options.baseURL;
  }
  start(options2) {
    if (this._started)
      return;
    this._options.omitScripts = options2.omitScripts;
    this._started = true;
    const apiRequest = this._context instanceof APIRequestContext ? this._context : this._context.fetchRequest;
    this._eventListeners = [
      eventsHelper.addEventListener(apiRequest, APIRequestContext.Events.Request, (event) => this._onAPIRequest(event)),
      eventsHelper.addEventListener(apiRequest, APIRequestContext.Events.RequestFinished, (event) => this._onAPIRequestFinished(event))
    ];
    if (this._context instanceof BrowserContext) {
      this._eventListeners.push(
        eventsHelper.addEventListener(this._context, BrowserContext.Events.Page, (page) => this._createPageEntryIfNeeded(page)),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.Request, (request4) => this._onRequest(request4)),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.RequestFinished, ({ request: request4, response }) => this._onRequestFinished(request4, response).catch(() => {
        })),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.RequestFailed, (request4) => this._onRequestFailed(request4)),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.Response, (response) => this._onResponse(response)),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.RequestAborted, (request4) => this._onRequestAborted(request4)),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.RequestFulfilled, (request4) => this._onRequestFulfilled(request4)),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.RequestContinued, (request4) => this._onRequestContinued(request4))
      );
    }
  }
  _shouldIncludeEntryWithUrl(urlString) {
    return !this._options.urlFilter || urlMatches(this._baseURL, urlString, this._options.urlFilter);
  }
  _entryForRequest(request4) {
    return request4[this._entrySymbol];
  }
  _createPageEntryIfNeeded(page) {
    if (!page)
      return;
    if (this._options.omitPages)
      return;
    if (this._page && page !== this._page)
      return;
    let pageEntry = this._pageEntries.get(page);
    if (!pageEntry) {
      const date = /* @__PURE__ */ new Date();
      pageEntry = {
        startedDateTime: date.toISOString(),
        id: page.guid,
        title: "",
        pageTimings: this._options.omitTiming ? {} : {
          onContentLoad: -1,
          onLoad: -1
        }
      };
      pageEntry[startedDateSymbol] = date;
      page.mainFrame().on(Frame.Events.AddLifecycle, (event) => {
        if (event === "load")
          this._onLoad(page, pageEntry);
        if (event === "domcontentloaded")
          this._onDOMContentLoaded(page, pageEntry);
      });
      this._pageEntries.set(page, pageEntry);
    }
    return pageEntry;
  }
  _onDOMContentLoaded(page, pageEntry) {
    const promise = page.mainFrame().evaluateExpression(String(() => {
      return {
        title: document.title,
        domContentLoaded: performance.timing.domContentLoadedEventStart
      };
    }), { isFunction: true, world: "utility" }).then((result) => {
      pageEntry.title = result.title;
      if (!this._options.omitTiming)
        pageEntry.pageTimings.onContentLoad = result.domContentLoaded;
    }).catch(() => {
    });
    this._addBarrier(page, promise);
  }
  _onLoad(page, pageEntry) {
    const promise = page.mainFrame().evaluateExpression(String(() => {
      return {
        title: document.title,
        loaded: performance.timing.loadEventStart
      };
    }), { isFunction: true, world: "utility" }).then((result) => {
      pageEntry.title = result.title;
      if (!this._options.omitTiming)
        pageEntry.pageTimings.onLoad = result.loaded;
    }).catch(() => {
    });
    this._addBarrier(page, promise);
  }
  _addBarrier(target, promise) {
    if (!target)
      return null;
    if (!this._options.waitForContentOnStop)
      return;
    const race = target.openScope.safeRace(promise);
    this._barrierPromises.add(race);
    race.then(() => this._barrierPromises.delete(race));
  }
  _onAPIRequest(event) {
    if (!this._shouldIncludeEntryWithUrl(event.url.toString()))
      return;
    const harEntry = createHarEntry(event.method, event.url, void 0, this._options);
    harEntry._apiRequest = true;
    if (!this._options.omitCookies)
      harEntry.request.cookies = event.cookies;
    harEntry.request.headers = Object.entries(event.headers).map(([name, value]) => ({ name, value }));
    harEntry.request.postData = this._postDataForBuffer(event.postData || null, event.headers["content-type"], this._options.content);
    if (!this._options.omitSizes)
      harEntry.request.bodySize = event.postData?.length || 0;
    event[this._entrySymbol] = harEntry;
    if (this._started)
      this._delegate.onEntryStarted(harEntry);
  }
  _onAPIRequestFinished(event) {
    const harEntry = this._entryForRequest(event.requestEvent);
    if (!harEntry)
      return;
    harEntry.response.status = event.statusCode;
    harEntry.response.statusText = event.statusMessage;
    harEntry.response.httpVersion = event.httpVersion;
    harEntry.response.redirectURL = event.headers.location || "";
    if (!this._options.omitServerIP) {
      harEntry.serverIPAddress = event.serverIPAddress;
      harEntry._serverPort = event.serverPort;
    }
    if (!this._options.omitTiming) {
      harEntry.timings = event.timings;
      this._computeHarEntryTotalTime(harEntry);
    }
    if (!this._options.omitSecurityDetails)
      harEntry._securityDetails = event.securityDetails;
    for (let i = 0; i < event.rawHeaders.length; i += 2) {
      harEntry.response.headers.push({
        name: event.rawHeaders[i],
        value: event.rawHeaders[i + 1]
      });
    }
    harEntry.response.cookies = this._options.omitCookies ? [] : event.cookies.map((c) => {
      return {
        ...c,
        expires: c.expires === -1 ? void 0 : safeDateToISOString(c.expires)
      };
    });
    const content = harEntry.response.content;
    const contentType = event.headers["content-type"];
    if (contentType)
      content.mimeType = contentType;
    this._storeResponseContent(event.body, content, "other");
    if (!this._options.omitSizes)
      harEntry.response.bodySize = event.body?.length ?? 0;
    if (this._started)
      this._delegate.onEntryFinished(harEntry);
  }
  _onRequest(request4) {
    if (!this._shouldIncludeEntryWithUrl(request4.url()))
      return;
    const page = request4.frame()?._page;
    if (this._page && page !== this._page)
      return;
    const url4 = parseURL2(request4.url());
    if (!url4)
      return;
    const pageEntry = this._createPageEntryIfNeeded(page);
    const harEntry = createHarEntry(request4.method(), url4, request4.frame()?.guid, this._options);
    if (pageEntry)
      harEntry.pageref = pageEntry.id;
    this._recordRequestHeadersAndCookies(harEntry, request4.headers());
    harEntry.request.postData = this._postDataForRequest(request4, this._options.content);
    if (!this._options.omitSizes)
      harEntry.request.bodySize = request4.bodySize();
    if (request4.redirectedFrom()) {
      const fromEntry = this._entryForRequest(request4.redirectedFrom());
      if (fromEntry)
        fromEntry.response.redirectURL = request4.url();
    }
    request4[this._entrySymbol] = harEntry;
    assert3(this._started);
    this._delegate.onEntryStarted(harEntry);
  }
  _recordRequestHeadersAndCookies(harEntry, headers) {
    if (!this._options.omitCookies) {
      harEntry.request.cookies = [];
      for (const header of headers.filter((header2) => header2.name.toLowerCase() === "cookie"))
        harEntry.request.cookies.push(...header.value.split(";").map(parseCookie));
    }
    harEntry.request.headers = headers;
  }
  _recordRequestOverrides(harEntry, request4) {
    if (!request4._hasOverrides() || !this._options.recordRequestOverrides)
      return;
    harEntry.request.method = request4.method();
    harEntry.request.url = request4.url();
    harEntry.request.postData = this._postDataForRequest(request4, this._options.content);
    this._recordRequestHeadersAndCookies(harEntry, request4.headers());
  }
  async _onRequestFinished(request4, response) {
    if (!response)
      return;
    const harEntry = this._entryForRequest(request4);
    if (!harEntry)
      return;
    const page = request4.frame()?._page;
    if (!this._options.omitServerIP) {
      this._addBarrier(page || request4.serviceWorker(), response.serverAddr().then((server) => {
        if (server?.ipAddress)
          harEntry.serverIPAddress = server.ipAddress;
        if (server?.port)
          harEntry._serverPort = server.port;
      }));
    }
    if (!this._options.omitSecurityDetails) {
      this._addBarrier(page || request4.serviceWorker(), response.securityDetails().then((details) => {
        if (details)
          harEntry._securityDetails = details;
      }));
    }
    const httpVersion = response.httpVersion();
    harEntry.request.httpVersion = httpVersion;
    harEntry.response.httpVersion = httpVersion;
    const compressionCalculationBarrier = this._options.omitSizes ? void 0 : {
      _encodedBodySize: -1,
      _decodedBodySize: -1,
      barrier: new ManualPromise(),
      _check: /* @__PURE__ */ __name(function() {
        if (this._encodedBodySize !== -1 && this._decodedBodySize !== -1) {
          harEntry.response.content.compression = Math.max(0, this._decodedBodySize - this._encodedBodySize);
          this.barrier.resolve();
        }
      }, "_check"),
      setEncodedBodySize: /* @__PURE__ */ __name(function(encodedBodySize) {
        this._encodedBodySize = encodedBodySize;
        this._check();
      }, "setEncodedBodySize"),
      setDecodedBodySize: /* @__PURE__ */ __name(function(decodedBodySize) {
        this._decodedBodySize = decodedBodySize;
        this._check();
      }, "setDecodedBodySize")
    };
    if (compressionCalculationBarrier)
      this._addBarrier(page || request4.serviceWorker(), compressionCalculationBarrier.barrier);
    const promise = response.body().then((buffer2) => {
      if (this._options.omitScripts && request4.resourceType() === "script") {
        compressionCalculationBarrier?.setDecodedBodySize(0);
        return;
      }
      const content = harEntry.response.content;
      compressionCalculationBarrier?.setDecodedBodySize(buffer2.length);
      this._storeResponseContent(buffer2, content, request4.resourceType());
    }).catch(() => {
      compressionCalculationBarrier?.setDecodedBodySize(0);
    }).then(() => {
      if (this._started)
        this._delegate.onEntryFinished(harEntry);
    });
    this._addBarrier(page || request4.serviceWorker(), promise);
    const timing = response.timing();
    harEntry.timings.receive = response.request()._responseEndTiming !== -1 ? helper.millisToRoundishMillis(response.request()._responseEndTiming - timing.responseStart) : -1;
    this._computeHarEntryTotalTime(harEntry);
    if (!this._options.omitSizes) {
      this._addBarrier(page || request4.serviceWorker(), response.sizes().then((sizes) => {
        harEntry.response.bodySize = sizes.responseBodySize;
        harEntry.response.headersSize = sizes.responseHeadersSize;
        harEntry.response._transferSize = sizes.transferSize;
        harEntry.request.headersSize = sizes.requestHeadersSize;
        compressionCalculationBarrier?.setEncodedBodySize(sizes.responseBodySize);
      }));
    }
  }
  async _onRequestFailed(request4) {
    const harEntry = this._entryForRequest(request4);
    if (!harEntry)
      return;
    if (request4._failureText !== null)
      harEntry.response._failureText = request4._failureText;
    this._recordRequestOverrides(harEntry, request4);
    if (this._started)
      this._delegate.onEntryFinished(harEntry);
  }
  _onRequestAborted(request4) {
    const harEntry = this._entryForRequest(request4);
    if (harEntry)
      harEntry._wasAborted = true;
  }
  _onRequestFulfilled(request4) {
    const harEntry = this._entryForRequest(request4);
    if (harEntry)
      harEntry._wasFulfilled = true;
  }
  _onRequestContinued(request4) {
    const harEntry = this._entryForRequest(request4);
    if (harEntry)
      harEntry._wasContinued = true;
  }
  _storeResponseContent(buffer2, content, resourceType) {
    if (!buffer2) {
      content.size = 0;
      return;
    }
    if (!this._options.omitSizes)
      content.size = buffer2.length;
    if (this._options.content === "embed") {
      if (isTextualMimeType(content.mimeType) && resourceType !== "font") {
        content.text = buffer2.toString();
      } else {
        content.text = buffer2.toString("base64");
        content.encoding = "base64";
      }
    } else if (this._options.content === "attach") {
      const sha1 = calculateSha1(buffer2) + "." + (mime2.getExtension(content.mimeType) || "dat");
      if (this._options.includeTraceInfo)
        content._sha1 = sha1;
      else
        content._file = sha1;
      if (this._started)
        this._delegate.onContentBlob(sha1, buffer2);
    }
  }
  _onResponse(response) {
    const harEntry = this._entryForRequest(response.request());
    if (!harEntry)
      return;
    const page = response.frame()?._page;
    const pageEntry = this._createPageEntryIfNeeded(page);
    const request4 = response.request();
    harEntry.response = {
      status: response.status(),
      statusText: response.statusText(),
      httpVersion: response.httpVersion(),
      // These are bad values that will be overwritten bellow.
      cookies: [],
      headers: [],
      content: {
        size: -1,
        mimeType: "x-unknown"
      },
      headersSize: -1,
      bodySize: -1,
      redirectURL: "",
      _transferSize: this._options.omitSizes ? void 0 : -1
    };
    if (!this._options.omitTiming) {
      const startDateTime = pageEntry ? pageEntry[startedDateSymbol].valueOf() : 0;
      const timing = response.timing();
      if (pageEntry && startDateTime > timing.startTime)
        pageEntry.startedDateTime = new Date(timing.startTime).toISOString();
      const dns = timing.domainLookupEnd !== -1 ? helper.millisToRoundishMillis(timing.domainLookupEnd - timing.domainLookupStart) : -1;
      const connect4 = timing.connectEnd !== -1 ? helper.millisToRoundishMillis(timing.connectEnd - timing.connectStart) : -1;
      const ssl = timing.connectEnd !== -1 ? helper.millisToRoundishMillis(timing.connectEnd - timing.secureConnectionStart) : -1;
      const wait = timing.responseStart !== -1 ? helper.millisToRoundishMillis(timing.responseStart - timing.requestStart) : -1;
      const receive = -1;
      harEntry.timings = {
        dns,
        connect: connect4,
        ssl,
        send: 0,
        wait,
        receive
      };
      this._computeHarEntryTotalTime(harEntry);
    }
    this._recordRequestOverrides(harEntry, request4);
    this._addBarrier(page || request4.serviceWorker(), request4.rawRequestHeaders().then((headers) => {
      this._recordRequestHeadersAndCookies(harEntry, headers);
    }));
    this._recordResponseHeaders(harEntry, response.headers());
    this._addBarrier(page || request4.serviceWorker(), response.rawResponseHeaders().then((headers) => {
      this._recordResponseHeaders(harEntry, headers);
    }));
  }
  _recordResponseHeaders(harEntry, headers) {
    if (!this._options.omitCookies) {
      harEntry.response.cookies = headers.filter((header) => header.name.toLowerCase() === "set-cookie").map((header) => parseCookie(header.value));
    }
    harEntry.response.headers = headers;
    const contentType = headers.find((header) => header.name.toLowerCase() === "content-type");
    if (contentType)
      harEntry.response.content.mimeType = contentType.value;
  }
  _computeHarEntryTotalTime(harEntry) {
    harEntry.time = [
      harEntry.timings.dns,
      harEntry.timings.connect,
      harEntry.timings.ssl,
      harEntry.timings.wait,
      harEntry.timings.receive
    ].reduce((pre, cur) => (cur || -1) > 0 ? cur + pre : pre, 0);
  }
  async flush() {
    await Promise.all(this._barrierPromises);
  }
  stop() {
    this._started = false;
    eventsHelper.removeEventListeners(this._eventListeners);
    this._barrierPromises.clear();
    const context2 = this._context instanceof BrowserContext ? this._context : void 0;
    const log4 = {
      version: "1.2",
      creator: {
        name: "Playwright",
        version: getPlaywrightVersion()
      },
      browser: {
        name: context2?._browser.options.name || "",
        version: context2?._browser.version() || ""
      },
      pages: this._pageEntries.size ? Array.from(this._pageEntries.values()) : void 0,
      entries: []
    };
    if (!this._options.omitTiming) {
      for (const pageEntry of log4.pages || []) {
        const startDateTime = pageEntry[startedDateSymbol].valueOf();
        if (typeof pageEntry.pageTimings.onContentLoad === "number" && pageEntry.pageTimings.onContentLoad >= 0)
          pageEntry.pageTimings.onContentLoad -= startDateTime;
        else
          pageEntry.pageTimings.onContentLoad = -1;
        if (typeof pageEntry.pageTimings.onLoad === "number" && pageEntry.pageTimings.onLoad >= 0)
          pageEntry.pageTimings.onLoad -= startDateTime;
        else
          pageEntry.pageTimings.onLoad = -1;
      }
    }
    this._pageEntries.clear();
    return log4;
  }
  _postDataForRequest(request4, content) {
    const postData = request4.postDataBuffer();
    if (!postData)
      return;
    const contentType = request4.headerValue("content-type");
    return this._postDataForBuffer(postData, contentType, content);
  }
  _postDataForBuffer(postData, contentType, content) {
    if (!postData)
      return;
    contentType ??= "application/octet-stream";
    const result = {
      mimeType: contentType,
      text: "",
      params: []
    };
    if (content === "embed" && contentType !== "application/octet-stream")
      result.text = postData.toString();
    if (content === "attach") {
      const sha1 = calculateSha1(postData) + "." + (mime2.getExtension(contentType) || "dat");
      if (this._options.includeTraceInfo)
        result._sha1 = sha1;
      else
        result._file = sha1;
      this._delegate.onContentBlob(sha1, postData);
    }
    if (contentType === "application/x-www-form-urlencoded") {
      const parsed = new URLSearchParams(postData.toString());
      for (const [name, value] of parsed.entries())
        result.params.push({ name, value });
    }
    return result;
  }
};
function createHarEntry(method, url4, frameref, options2) {
  const harEntry = {
    _frameref: options2.includeTraceInfo ? frameref : void 0,
    _monotonicTime: options2.includeTraceInfo ? monotonicTime() : void 0,
    startedDateTime: (/* @__PURE__ */ new Date()).toISOString(),
    time: -1,
    request: {
      method,
      url: url4.toString(),
      httpVersion: FALLBACK_HTTP_VERSION,
      cookies: [],
      headers: [],
      queryString: [...url4.searchParams].map((e) => ({ name: e[0], value: e[1] })),
      headersSize: -1,
      bodySize: -1
    },
    response: {
      status: -1,
      statusText: "",
      httpVersion: FALLBACK_HTTP_VERSION,
      cookies: [],
      headers: [],
      content: {
        size: -1,
        mimeType: "x-unknown"
      },
      headersSize: -1,
      bodySize: -1,
      redirectURL: "",
      _transferSize: options2.omitSizes ? void 0 : -1
    },
    cache: {},
    timings: {
      send: -1,
      wait: -1,
      receive: -1
    }
  };
  return harEntry;
}
__name(createHarEntry, "createHarEntry");
function parseCookie(c) {
  const cookie = {
    name: "",
    value: ""
  };
  let first = true;
  for (const pair of c.split(/; */)) {
    const indexOfEquals = pair.indexOf("=");
    const name = indexOfEquals !== -1 ? pair.substr(0, indexOfEquals).trim() : pair.trim();
    const value = indexOfEquals !== -1 ? pair.substr(indexOfEquals + 1, pair.length).trim() : "";
    if (first) {
      first = false;
      cookie.name = name;
      cookie.value = value;
      continue;
    }
    if (name === "Domain")
      cookie.domain = value;
    if (name === "Expires")
      cookie.expires = safeDateToISOString(value);
    if (name === "HttpOnly")
      cookie.httpOnly = true;
    if (name === "Max-Age")
      cookie.expires = safeDateToISOString(Date.now() + +value * 1e3);
    if (name === "Path")
      cookie.path = value;
    if (name === "SameSite")
      cookie.sameSite = value;
    if (name === "Secure")
      cookie.secure = true;
  }
  return cookie;
}
__name(parseCookie, "parseCookie");
function safeDateToISOString(value) {
  try {
    return new Date(value).toISOString();
  } catch (e) {
  }
}
__name(safeDateToISOString, "safeDateToISOString");
var startedDateSymbol = Symbol("startedDate");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/har/harRecorder.js
var HarRecorder = class {
  static {
    __name(this, "HarRecorder");
  }
  constructor(context2, page, options2) {
    this._isFlushed = false;
    this._entries = [];
    this._zipFile = null;
    this._writtenZipEntries = /* @__PURE__ */ new Set();
    this._artifact = new Artifact(context2, path11.join(context2._browser.options.artifactsDir, `${createGuid()}.har`));
    const urlFilterRe = options2.urlRegexSource !== void 0 && options2.urlRegexFlags !== void 0 ? new RegExp(options2.urlRegexSource, options2.urlRegexFlags) : void 0;
    const expectsZip = options2.path.endsWith(".zip");
    const content = options2.content || (expectsZip ? "attach" : "embed");
    this._tracer = new HarTracer(context2, page, this, {
      content,
      slimMode: options2.mode === "minimal",
      includeTraceInfo: false,
      recordRequestOverrides: true,
      waitForContentOnStop: true,
      urlFilter: urlFilterRe ?? options2.urlGlob
    });
    this._zipFile = content === "attach" || expectsZip ? new yazl2.ZipFile() : null;
    this._tracer.start({ omitScripts: false });
  }
  onEntryStarted(entry) {
    this._entries.push(entry);
  }
  onEntryFinished(entry) {
  }
  onContentBlob(sha1, buffer2) {
    if (!this._zipFile || this._writtenZipEntries.has(sha1))
      return;
    this._writtenZipEntries.add(sha1);
    this._zipFile.addBuffer(buffer2, sha1);
  }
  async flush() {
    if (this._isFlushed)
      return;
    this._isFlushed = true;
    await this._tracer.flush();
    const log4 = this._tracer.stop();
    log4.entries = this._entries;
    const harFileContent = jsonStringify({ log: log4 });
    if (this._zipFile) {
      const result = new ManualPromise();
      this._zipFile.on("error", (error4) => result.reject(error4));
      this._zipFile.addBuffer(Buffer.from(harFileContent, "utf-8"), "har.har");
      this._zipFile.end();
      this._zipFile.outputStream.pipe(fs.createWriteStream(this._artifact.localPath())).on("close", () => {
        result.resolve();
      });
      await result;
    } else {
      await fs.promises.writeFile(this._artifact.localPath(), harFileContent);
    }
  }
  async export() {
    await this.flush();
    this._artifact.reportFinished();
    return this._artifact;
  }
};
function jsonStringify(object) {
  const tokens = [];
  innerJsonStringify(object, tokens, "", false, void 0);
  return tokens.join("");
}
__name(jsonStringify, "jsonStringify");
function innerJsonStringify(object, tokens, indent, flat, parentKey) {
  if (typeof object !== "object" || object === null) {
    tokens.push(JSON.stringify(object));
    return;
  }
  const isArray2 = Array.isArray(object);
  if (!isArray2 && object.constructor.name !== "Object") {
    tokens.push(JSON.stringify(object));
    return;
  }
  const entries = isArray2 ? object : Object.entries(object).filter((e) => e[1] !== void 0);
  if (!entries.length) {
    tokens.push(isArray2 ? `[]` : `{}`);
    return;
  }
  const childIndent = `${indent}  `;
  let brackets;
  if (isArray2)
    brackets = flat ? { open: "[", close: "]" } : { open: `[
${childIndent}`, close: `
${indent}]` };
  else
    brackets = flat ? { open: "{ ", close: " }" } : { open: `{
${childIndent}`, close: `
${indent}}` };
  tokens.push(brackets.open);
  for (let i = 0; i < entries.length; ++i) {
    const entry = entries[i];
    if (i)
      tokens.push(flat ? `, ` : `,
${childIndent}`);
    if (!isArray2)
      tokens.push(`${JSON.stringify(entry[0])}: `);
    const key = isArray2 ? void 0 : entry[0];
    const flatten = flat || key === "timings" || parentKey === "headers";
    innerJsonStringify(isArray2 ? entry : entry[1], tokens, childIndent, flatten, key);
  }
  tokens.push(brackets.close);
}
__name(innerJsonStringify, "innerJsonStringify");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/contextRecorder.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter9 } from "node:events";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/recorderCollection.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter8 } from "node:events";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/recorderRunner.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/expectUtils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function serializeExpectedTextValues(items, options2 = {}) {
  return items.map((i) => ({
    string: isString2(i) ? i : void 0,
    regexSource: isRegExp4(i) ? i.source : void 0,
    regexFlags: isRegExp4(i) ? i.flags : void 0,
    matchSubstring: options2.matchSubstring,
    ignoreCase: options2.ignoreCase,
    normalizeWhiteSpace: options2.normalizeWhiteSpace
  }));
}
__name(serializeExpectedTextValues, "serializeExpectedTextValues");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/recorderRunner.js
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/codegen/language.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function generateCode(actions, languageGenerator, options2) {
  const header = languageGenerator.generateHeader(options2);
  const footer = languageGenerator.generateFooter(options2.saveStorage);
  const actionTexts = actions.map((a) => languageGenerator.generateAction(a)).filter(Boolean);
  const text = [header, ...actionTexts, footer].join("\n");
  return { header, footer, actionTexts, text };
}
__name(generateCode, "generateCode");
function sanitizeDeviceOptions(device, options2) {
  const cleanedOptions = {};
  for (const property in options2) {
    if (JSON.stringify(device[property]) !== JSON.stringify(options2[property]))
      cleanedOptions[property] = options2[property];
  }
  return cleanedOptions;
}
__name(sanitizeDeviceOptions, "sanitizeDeviceOptions");
function toSignalMap(action) {
  let popup;
  let download;
  let dialog;
  for (const signal of action.signals) {
    if (signal.name === "popup")
      popup = signal;
    else if (signal.name === "download")
      download = signal;
    else if (signal.name === "dialog")
      dialog = signal;
  }
  return {
    popup,
    download,
    dialog
  };
}
__name(toSignalMap, "toSignalMap");
function toKeyboardModifiers(modifiers) {
  const result = [];
  if (modifiers & 1)
    result.push("Alt");
  if (modifiers & 2)
    result.push("ControlOrMeta");
  if (modifiers & 4)
    result.push("ControlOrMeta");
  if (modifiers & 8)
    result.push("Shift");
  return result;
}
__name(toKeyboardModifiers, "toKeyboardModifiers");
function toClickOptionsForSourceCode(action) {
  const modifiers = toKeyboardModifiers(action.modifiers);
  const options2 = {};
  if (action.button !== "left")
    options2.button = action.button;
  if (modifiers.length)
    options2.modifiers = modifiers;
  if (action.clickCount > 2)
    options2.clickCount = action.clickCount;
  if (action.position)
    options2.position = action.position;
  return options2;
}
__name(toClickOptionsForSourceCode, "toClickOptionsForSourceCode");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/recorderUtils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function buildFullSelector(framePath, selector) {
  return [...framePath, selector].join(" >> internal:control=enter-frame >> ");
}
__name(buildFullSelector, "buildFullSelector");
function metadataToCallLog(metadata, status) {
  let title2 = metadata.apiName || metadata.method;
  if (metadata.method === "waitForEventInfo")
    title2 += `(${metadata.params.info.event})`;
  title2 = title2.replace("object.expect", "expect");
  if (metadata.error)
    status = "error";
  const params = {
    url: metadata.params?.url,
    selector: metadata.params?.selector
  };
  let duration = metadata.endTime ? metadata.endTime - metadata.startTime : void 0;
  if (typeof duration === "number" && metadata.pauseStartTime && metadata.pauseEndTime) {
    duration -= metadata.pauseEndTime - metadata.pauseStartTime;
    duration = Math.max(duration, 0);
  }
  const callLog = {
    id: metadata.id,
    messages: metadata.log,
    title: title2,
    status,
    error: metadata.error?.error?.message,
    params,
    duration
  };
  return callLog;
}
__name(metadataToCallLog, "metadataToCallLog");
function mainFrameForAction(pageAliases, actionInContext) {
  const pageAlias = actionInContext.frame.pageAlias;
  const page = [...pageAliases.entries()].find(([, alias]) => pageAlias === alias)?.[0];
  if (!page)
    throw new Error(`Internal error: page ${pageAlias} not found in [${[...pageAliases.values()]}]`);
  return page.mainFrame();
}
__name(mainFrameForAction, "mainFrameForAction");
function collapseActions(actions) {
  const result = [];
  for (const action of actions) {
    const lastAction = result[result.length - 1];
    const isSameAction = lastAction && lastAction.action.name === action.action.name && lastAction.frame.pageAlias === action.frame.pageAlias && lastAction.frame.framePath.join("|") === action.frame.framePath.join("|");
    const isSameSelector = lastAction && "selector" in lastAction.action && "selector" in action.action && action.action.selector === lastAction.action.selector;
    const shouldMerge = isSameAction && (action.action.name === "navigate" || action.action.name === "fill" && isSameSelector);
    if (!shouldMerge) {
      result.push(action);
      continue;
    }
    const startTime = result[result.length - 1].startTime;
    result[result.length - 1] = action;
    result[result.length - 1].startTime = startTime;
  }
  return result;
}
__name(collapseActions, "collapseActions");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/recorderRunner.js
async function performAction(pageAliases, actionInContext) {
  const callMetadata = serverSideCallMetadata();
  const mainFrame = mainFrameForAction(pageAliases, actionInContext);
  const { action } = actionInContext;
  const kActionTimeout = 5e3;
  if (action.name === "navigate") {
    await mainFrame.goto(callMetadata, action.url, { timeout: kActionTimeout });
    return;
  }
  if (action.name === "openPage")
    throw Error("Not reached");
  if (action.name === "closePage") {
    await mainFrame._page.close(callMetadata);
    return;
  }
  const selector = buildFullSelector(actionInContext.frame.framePath, action.selector);
  if (action.name === "click") {
    const options2 = toClickOptions(action);
    await mainFrame.click(callMetadata, selector, { ...options2, timeout: kActionTimeout, strict: true });
    return;
  }
  if (action.name === "press") {
    const modifiers = toKeyboardModifiers(action.modifiers);
    const shortcut = [...modifiers, action.key].join("+");
    await mainFrame.press(callMetadata, selector, shortcut, { timeout: kActionTimeout, strict: true });
    return;
  }
  if (action.name === "fill") {
    await mainFrame.fill(callMetadata, selector, action.text, { timeout: kActionTimeout, strict: true });
    return;
  }
  if (action.name === "setInputFiles") {
    await mainFrame.setInputFiles(callMetadata, selector, { selector, payloads: [], timeout: kActionTimeout, strict: true });
    return;
  }
  if (action.name === "check") {
    await mainFrame.check(callMetadata, selector, { timeout: kActionTimeout, strict: true });
    return;
  }
  if (action.name === "uncheck") {
    await mainFrame.uncheck(callMetadata, selector, { timeout: kActionTimeout, strict: true });
    return;
  }
  if (action.name === "select") {
    const values = action.options.map((value) => ({ value }));
    await mainFrame.selectOption(callMetadata, selector, [], values, { timeout: kActionTimeout, strict: true });
    return;
  }
  if (action.name === "assertChecked") {
    await mainFrame.expect(callMetadata, selector, {
      selector,
      expression: "to.be.checked",
      expectedValue: { checked: action.checked },
      isNot: !action.checked,
      timeout: kActionTimeout
    });
    return;
  }
  if (action.name === "assertText") {
    await mainFrame.expect(callMetadata, selector, {
      selector,
      expression: "to.have.text",
      expectedText: serializeExpectedTextValues([action.text], { matchSubstring: true, normalizeWhiteSpace: true }),
      isNot: false,
      timeout: kActionTimeout
    });
    return;
  }
  if (action.name === "assertValue") {
    await mainFrame.expect(callMetadata, selector, {
      selector,
      expression: "to.have.value",
      expectedValue: action.value,
      isNot: false,
      timeout: kActionTimeout
    });
    return;
  }
  if (action.name === "assertVisible") {
    await mainFrame.expect(callMetadata, selector, {
      selector,
      expression: "to.be.visible",
      isNot: false,
      timeout: kActionTimeout
    });
    return;
  }
  throw new Error("Internal error: unexpected action " + action.name);
}
__name(performAction, "performAction");
function toClickOptions(action) {
  const modifiers = toKeyboardModifiers(action.modifiers);
  const options2 = {};
  if (action.button !== "left")
    options2.button = action.button;
  if (modifiers.length)
    options2.modifiers = modifiers;
  if (action.clickCount > 1)
    options2.clickCount = action.clickCount;
  if (action.position)
    options2.position = action.position;
  return options2;
}
__name(toClickOptions, "toClickOptions");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/recorderCollection.js
var RecorderCollection = class extends EventEmitter8 {
  static {
    __name(this, "RecorderCollection");
  }
  constructor(pageAliases) {
    super();
    this._actions = [];
    this._enabled = false;
    this._pageAliases = pageAliases;
  }
  restart() {
    this._actions = [];
    this.emit("change", []);
  }
  setEnabled(enabled) {
    this._enabled = enabled;
  }
  async performAction(actionInContext) {
    await this._addAction(actionInContext, async () => {
      await performAction(this._pageAliases, actionInContext);
    });
  }
  addRecordedAction(actionInContext) {
    if (["openPage", "closePage"].includes(actionInContext.action.name)) {
      this._actions.push(actionInContext);
      this._fireChange();
      return;
    }
    this._addAction(actionInContext).catch(() => {
    });
  }
  async _addAction(actionInContext, callback) {
    if (!this._enabled)
      return;
    if (actionInContext.action.name === "openPage" || actionInContext.action.name === "closePage") {
      this._actions.push(actionInContext);
      this._fireChange();
      return;
    }
    this._actions.push(actionInContext);
    this._fireChange();
    await callback?.().catch();
    actionInContext.endTime = monotonicTime();
  }
  signal(pageAlias, frame, signal) {
    if (!this._enabled)
      return;
    if (signal.name === "navigation" && frame._page.mainFrame() === frame) {
      const timestamp2 = monotonicTime();
      const lastAction = this._actions[this._actions.length - 1];
      const signalThreshold = isUnderTest() ? 500 : 5e3;
      let generateGoto = false;
      if (!lastAction)
        generateGoto = true;
      else if (lastAction.action.name !== "click" && lastAction.action.name !== "press" && lastAction.action.name !== "fill")
        generateGoto = true;
      else if (timestamp2 - lastAction.startTime > signalThreshold)
        generateGoto = true;
      if (generateGoto) {
        this.addRecordedAction({
          frame: {
            pageAlias,
            framePath: []
          },
          action: {
            name: "navigate",
            url: frame.url(),
            signals: []
          },
          startTime: timestamp2,
          endTime: timestamp2
        });
      }
      return;
    }
    if (this._actions.length) {
      this._actions[this._actions.length - 1].action.signals.push(signal);
      this._fireChange();
      return;
    }
  }
  _fireChange() {
    if (!this._enabled)
      return;
    this.emit("change", collapseActions(this._actions));
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/generated/pollingRecorderSource.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source5 = '\nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, \'default\': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/recorder/pollingRecorder.ts\nvar pollingRecorder_exports = {};\n__export(pollingRecorder_exports, {\n  PollingRecorder: () => PollingRecorder,\n  default: () => pollingRecorder_default\n});\nmodule.exports = __toCommonJS(pollingRecorder_exports);\n\n// packages/injected/src/recorder/clipPaths.ts\nvar svgJson = { "tagName": "svg", "children": [{ "tagName": "defs", "children": [{ "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-gripper" }, "children": [{ "tagName": "path", "attrs": { "d": "M5 3h2v2H5zm0 4h2v2H5zm0 4h2v2H5zm4-8h2v2H9zm0 4h2v2H9zm0 4h2v2H9z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-circle-large-filled" }, "children": [{ "tagName": "path", "attrs": { "d": "M8 1a6.8 6.8 0 0 1 1.86.253 6.899 6.899 0 0 1 3.083 1.805 6.903 6.903 0 0 1 1.804 3.083C14.916 6.738 15 7.357 15 8s-.084 1.262-.253 1.86a6.9 6.9 0 0 1-.704 1.674 7.157 7.157 0 0 1-2.516 2.509 6.966 6.966 0 0 1-1.668.71A6.984 6.984 0 0 1 8 15a6.984 6.984 0 0 1-1.86-.246 7.098 7.098 0 0 1-1.674-.711 7.3 7.3 0 0 1-1.415-1.094 7.295 7.295 0 0 1-1.094-1.415 7.098 7.098 0 0 1-.71-1.675A6.985 6.985 0 0 1 1 8c0-.643.082-1.262.246-1.86a6.968 6.968 0 0 1 .711-1.667 7.156 7.156 0 0 1 2.509-2.516 6.895 6.895 0 0 1 1.675-.704A6.808 6.808 0 0 1 8 1z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-inspect" }, "children": [{ "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M1 3l1-1h12l1 1v6h-1V3H2v8h5v1H2l-1-1V3zm14.707 9.707L9 6v9.414l2.707-2.707h4zM10 13V8.414l3.293 3.293h-2L10 13z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-whole-word" }, "children": [{ "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M0 11H1V13H15V11H16V14H15H1H0V11Z" } }, { "tagName": "path", "attrs": { "d": "M6.84048 11H5.95963V10.1406H5.93814C5.555 10.7995 4.99104 11.1289 4.24625 11.1289C3.69839 11.1289 3.26871 10.9839 2.95718 10.6938C2.64924 10.4038 2.49527 10.0189 2.49527 9.53906C2.49527 8.51139 3.10041 7.91341 4.3107 7.74512L5.95963 7.51416C5.95963 6.57959 5.58186 6.1123 4.82632 6.1123C4.16389 6.1123 3.56591 6.33789 3.03238 6.78906V5.88672C3.57307 5.54297 4.19612 5.37109 4.90152 5.37109C6.19416 5.37109 6.84048 6.05501 6.84048 7.42285V11ZM5.95963 8.21777L4.63297 8.40039C4.22476 8.45768 3.91682 8.55973 3.70914 8.70654C3.50145 8.84977 3.39761 9.10579 3.39761 9.47461C3.39761 9.74316 3.4925 9.96338 3.68228 10.1353C3.87564 10.3035 4.13166 10.3877 4.45035 10.3877C4.8872 10.3877 5.24706 10.2355 5.52994 9.93115C5.8164 9.62321 5.95963 9.2347 5.95963 8.76562V8.21777Z" } }, { "tagName": "path", "attrs": { "d": "M9.3475 10.2051H9.32601V11H8.44515V2.85742H9.32601V6.4668H9.3475C9.78076 5.73633 10.4146 5.37109 11.2489 5.37109C11.9543 5.37109 12.5057 5.61816 12.9032 6.1123C13.3042 6.60286 13.5047 7.26172 13.5047 8.08887C13.5047 9.00911 13.2809 9.74674 12.8333 10.3018C12.3857 10.8532 11.7734 11.1289 10.9964 11.1289C10.2695 11.1289 9.71989 10.821 9.3475 10.2051ZM9.32601 7.98682V8.75488C9.32601 9.20964 9.47282 9.59635 9.76644 9.91504C10.0636 10.2301 10.4396 10.3877 10.8944 10.3877C11.4279 10.3877 11.8451 10.1836 12.1458 9.77539C12.4502 9.36719 12.6024 8.79964 12.6024 8.07275C12.6024 7.46045 12.4609 6.98063 12.1781 6.6333C11.8952 6.28597 11.512 6.1123 11.0286 6.1123C10.5166 6.1123 10.1048 6.29134 9.7933 6.64941C9.48177 7.00391 9.32601 7.44971 9.32601 7.98682Z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-eye" }, "children": [{ "tagName": "path", "attrs": { "d": "M7.99993 6.00316C9.47266 6.00316 10.6666 7.19708 10.6666 8.66981C10.6666 10.1426 9.47266 11.3365 7.99993 11.3365C6.52715 11.3365 5.33324 10.1426 5.33324 8.66981C5.33324 7.19708 6.52715 6.00316 7.99993 6.00316ZM7.99993 7.00315C7.07946 7.00315 6.33324 7.74935 6.33324 8.66981C6.33324 9.59028 7.07946 10.3365 7.99993 10.3365C8.9204 10.3365 9.6666 9.59028 9.6666 8.66981C9.6666 7.74935 8.9204 7.00315 7.99993 7.00315ZM7.99993 3.66675C11.0756 3.66675 13.7307 5.76675 14.4673 8.70968C14.5344 8.97755 14.3716 9.24908 14.1037 9.31615C13.8358 9.38315 13.5643 9.22041 13.4973 8.95248C12.8713 6.45205 10.6141 4.66675 7.99993 4.66675C5.38454 4.66675 3.12664 6.45359 2.50182 8.95555C2.43491 9.22341 2.16348 9.38635 1.89557 9.31948C1.62766 9.25255 1.46471 8.98115 1.53162 8.71321C2.26701 5.76856 4.9229 3.66675 7.99993 3.66675Z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-symbol-constant" }, "children": [{ "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M4 6h8v1H4V6zm8 3H4v1h8V9z" } }, { "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M1 4l1-1h12l1 1v8l-1 1H2l-1-1V4zm1 0v8h12V4H2z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-check" }, "children": [{ "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M14.431 3.323l-8.47 10-.79-.036-3.35-4.77.818-.574 2.978 4.24 8.051-9.506.764.646z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-close" }, "children": [{ "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M8 8.707l3.646 3.647.708-.707L8.707 8l3.647-3.646-.707-.708L8 7.293 4.354 3.646l-.707.708L7.293 8l-3.646 3.646.707.708L8 8.707z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-pass" }, "children": [{ "tagName": "path", "attrs": { "d": "M6.27 10.87h.71l4.56-4.56-.71-.71-4.2 4.21-1.92-1.92L4 8.6l2.27 2.27z" } }, { "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M8.6 1c1.6.1 3.1.9 4.2 2 1.3 1.4 2 3.1 2 5.1 0 1.6-.6 3.1-1.6 4.4-1 1.2-2.4 2.1-4 2.4-1.6.3-3.2.1-4.6-.7-1.4-.8-2.5-2-3.1-3.5C.9 9.2.8 7.5 1.3 6c.5-1.6 1.4-2.9 2.8-3.8C5.4 1.3 7 .9 8.6 1zm.5 12.9c1.3-.3 2.5-1 3.4-2.1.8-1.1 1.3-2.4 1.2-3.8 0-1.6-.6-3.2-1.7-4.3-1-1-2.2-1.6-3.6-1.7-1.3-.1-2.7.2-3.8 1-1.1.8-1.9 1.9-2.3 3.3-.4 1.3-.4 2.7.2 4 .6 1.3 1.5 2.3 2.7 3 1.2.7 2.6.9 3.9.6z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-gist" }, "children": [{ "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M10.57 1.14l3.28 3.3.15.36v9.7l-.5.5h-11l-.5-.5v-13l.5-.5h7.72l.35.14zM10 5h3l-3-3v3zM3 2v12h10V6H9.5L9 5.5V2H3zm2.062 7.533l1.817-1.828L6.17 7 4 9.179v.707l2.171 2.174.707-.707-1.816-1.82zM8.8 7.714l.7-.709 2.189 2.175v.709L9.5 12.062l-.705-.709 1.831-1.82L8.8 7.714z" } }] }] }] };\nvar clipPaths_default = svgJson;\n\n// packages/injected/src/recorder/recorder.ts\nvar HighlightColors = {\n  multiple: "#f6b26b7f",\n  single: "#6fa8dc7f",\n  assert: "#8acae480",\n  action: "#dc6f6f7f"\n};\nvar NoneTool = class {\n  cursor() {\n    return "default";\n  }\n};\nvar InspectTool = class {\n  constructor(recorder, assertVisibility) {\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n    this._recorder = recorder;\n    this._assertVisibility = assertVisibility;\n  }\n  cursor() {\n    return "pointer";\n  }\n  cleanup() {\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n  }\n  onClick(event) {\n    var _a;\n    consumeEvent(event);\n    if (event.button !== 0)\n      return;\n    if ((_a = this._hoveredModel) == null ? void 0 : _a.selector)\n      this._commit(this._hoveredModel.selector, this._hoveredModel);\n  }\n  onPointerDown(event) {\n    consumeEvent(event);\n  }\n  onPointerUp(event) {\n    consumeEvent(event);\n  }\n  onMouseDown(event) {\n    consumeEvent(event);\n  }\n  onMouseUp(event) {\n    consumeEvent(event);\n  }\n  onMouseMove(event) {\n    var _a;\n    consumeEvent(event);\n    let target = this._recorder.deepEventTarget(event);\n    if (!target.isConnected)\n      target = null;\n    if (this._hoveredElement === target)\n      return;\n    this._hoveredElement = target;\n    let model = null;\n    if (this._hoveredElement) {\n      const generated = this._recorder.injectedScript.generateSelector(this._hoveredElement, { testIdAttributeName: this._recorder.state.testIdAttributeName, multiple: false });\n      model = {\n        selector: generated.selector,\n        elements: generated.elements,\n        tooltipText: this._recorder.injectedScript.utils.asLocator(this._recorder.state.language, generated.selector),\n        color: this._assertVisibility ? HighlightColors.assert : HighlightColors.single\n      };\n    }\n    if (((_a = this._hoveredModel) == null ? void 0 : _a.selector) === (model == null ? void 0 : model.selector))\n      return;\n    this._hoveredModel = model;\n    this._recorder.updateHighlight(model, true);\n  }\n  onMouseEnter(event) {\n    consumeEvent(event);\n  }\n  onMouseLeave(event) {\n    consumeEvent(event);\n    const window = this._recorder.injectedScript.window;\n    if (window.top !== window && this._recorder.deepEventTarget(event).nodeType === Node.DOCUMENT_NODE)\n      this._reset(true);\n  }\n  onKeyDown(event) {\n    consumeEvent(event);\n    if (event.key === "Escape") {\n      if (this._assertVisibility)\n        this._recorder.setMode("recording");\n    }\n  }\n  onKeyUp(event) {\n    consumeEvent(event);\n  }\n  onScroll(event) {\n    this._reset(false);\n  }\n  _commit(selector, model) {\n    var _a;\n    if (this._assertVisibility) {\n      this._recorder.recordAction({\n        name: "assertVisible",\n        selector,\n        signals: []\n      });\n      this._recorder.setMode("recording");\n      (_a = this._recorder.overlay) == null ? void 0 : _a.flashToolSucceeded("assertingVisibility");\n    } else {\n      this._recorder.elementPicked(selector, model);\n    }\n  }\n  _reset(userGesture) {\n    this._hoveredElement = null;\n    this._hoveredModel = null;\n    this._recorder.updateHighlight(null, userGesture);\n  }\n};\nvar RecordActionTool = class {\n  constructor(recorder) {\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n    this._activeModel = null;\n    this._expectProgrammaticKeyUp = false;\n    this._recorder = recorder;\n    this._performingActions = new recorder.injectedScript.utils.builtins.Set();\n  }\n  cursor() {\n    return "pointer";\n  }\n  cleanup() {\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n    this._activeModel = null;\n    this._expectProgrammaticKeyUp = false;\n  }\n  onClick(event) {\n    if (isRangeInput(this._hoveredElement))\n      return;\n    if (event.button === 2 && event.type === "auxclick")\n      return;\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (this._actionInProgress(event))\n      return;\n    if (this._consumedDueToNoModel(event, this._hoveredModel))\n      return;\n    const checkbox = asCheckbox(this._recorder.deepEventTarget(event));\n    if (checkbox) {\n      this._performAction({\n        name: checkbox.checked ? "check" : "uncheck",\n        selector: this._hoveredModel.selector,\n        signals: []\n      });\n      return;\n    }\n    this._cancelPendingClickAction();\n    if (event.detail === 1) {\n      this._pendingClickAction = {\n        action: {\n          name: "click",\n          selector: this._hoveredModel.selector,\n          position: positionForEvent(event),\n          signals: [],\n          button: buttonForEvent(event),\n          modifiers: modifiersForEvent(event),\n          clickCount: event.detail\n        },\n        timeout: this._recorder.injectedScript.utils.builtins.setTimeout(() => this._commitPendingClickAction(), 200)\n      };\n    }\n  }\n  onDblClick(event) {\n    if (isRangeInput(this._hoveredElement))\n      return;\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (this._actionInProgress(event))\n      return;\n    if (this._consumedDueToNoModel(event, this._hoveredModel))\n      return;\n    this._cancelPendingClickAction();\n    this._performAction({\n      name: "click",\n      selector: this._hoveredModel.selector,\n      position: positionForEvent(event),\n      signals: [],\n      button: buttonForEvent(event),\n      modifiers: modifiersForEvent(event),\n      clickCount: event.detail\n    });\n  }\n  _commitPendingClickAction() {\n    if (this._pendingClickAction)\n      this._performAction(this._pendingClickAction.action);\n    this._cancelPendingClickAction();\n  }\n  _cancelPendingClickAction() {\n    if (this._pendingClickAction)\n      this._recorder.injectedScript.utils.builtins.clearTimeout(this._pendingClickAction.timeout);\n    this._pendingClickAction = void 0;\n  }\n  onContextMenu(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (this._actionInProgress(event))\n      return;\n    if (this._consumedDueToNoModel(event, this._hoveredModel))\n      return;\n    this._performAction({\n      name: "click",\n      selector: this._hoveredModel.selector,\n      position: positionForEvent(event),\n      signals: [],\n      button: "right",\n      modifiers: 0,\n      clickCount: 0\n    });\n  }\n  onPointerDown(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (!this._performingActions.size)\n      consumeEvent(event);\n  }\n  onPointerUp(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (!this._performingActions.size)\n      consumeEvent(event);\n  }\n  onMouseDown(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (!this._performingActions.size)\n      consumeEvent(event);\n    this._activeModel = this._hoveredModel;\n  }\n  onMouseUp(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (!this._performingActions.size)\n      consumeEvent(event);\n  }\n  onMouseMove(event) {\n    const target = this._recorder.deepEventTarget(event);\n    if (this._hoveredElement === target)\n      return;\n    this._hoveredElement = target;\n    this._updateModelForHoveredElement();\n  }\n  onMouseLeave(event) {\n    const window = this._recorder.injectedScript.window;\n    if (window.top !== window && this._recorder.deepEventTarget(event).nodeType === Node.DOCUMENT_NODE) {\n      this._hoveredElement = null;\n      this._updateModelForHoveredElement();\n    }\n  }\n  onFocus(event) {\n    this._onFocus(true);\n  }\n  onInput(event) {\n    const target = this._recorder.deepEventTarget(event);\n    if (target.nodeName === "INPUT" && target.type.toLowerCase() === "file") {\n      this._recorder.recordAction({\n        name: "setInputFiles",\n        selector: this._activeModel.selector,\n        signals: [],\n        files: [...target.files || []].map((file) => file.name)\n      });\n      return;\n    }\n    if (isRangeInput(target)) {\n      this._recorder.recordAction({\n        name: "fill",\n        // must use hoveredModel instead of activeModel for it to work in webkit\n        selector: this._hoveredModel.selector,\n        signals: [],\n        text: target.value\n      });\n      return;\n    }\n    if (["INPUT", "TEXTAREA"].includes(target.nodeName) || target.isContentEditable) {\n      if (target.nodeName === "INPUT" && ["checkbox", "radio"].includes(target.type.toLowerCase())) {\n        return;\n      }\n      if (this._consumedDueWrongTarget(event))\n        return;\n      this._recorder.recordAction({\n        name: "fill",\n        selector: this._activeModel.selector,\n        signals: [],\n        text: target.isContentEditable ? target.innerText : target.value\n      });\n    }\n    if (target.nodeName === "SELECT") {\n      const selectElement = target;\n      if (this._actionInProgress(event))\n        return;\n      this._performAction({\n        name: "select",\n        selector: this._activeModel.selector,\n        options: [...selectElement.selectedOptions].map((option) => option.value),\n        signals: []\n      });\n    }\n  }\n  onKeyDown(event) {\n    if (!this._shouldGenerateKeyPressFor(event))\n      return;\n    if (this._actionInProgress(event)) {\n      this._expectProgrammaticKeyUp = true;\n      return;\n    }\n    if (this._consumedDueWrongTarget(event))\n      return;\n    if (event.key === " ") {\n      const checkbox = asCheckbox(this._recorder.deepEventTarget(event));\n      if (checkbox) {\n        this._performAction({\n          name: checkbox.checked ? "uncheck" : "check",\n          selector: this._activeModel.selector,\n          signals: []\n        });\n        return;\n      }\n    }\n    this._performAction({\n      name: "press",\n      selector: this._activeModel.selector,\n      signals: [],\n      key: event.key,\n      modifiers: modifiersForEvent(event)\n    });\n  }\n  onKeyUp(event) {\n    if (!this._shouldGenerateKeyPressFor(event))\n      return;\n    if (!this._expectProgrammaticKeyUp) {\n      consumeEvent(event);\n      return;\n    }\n    this._expectProgrammaticKeyUp = false;\n  }\n  onScroll(event) {\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n    this._recorder.updateHighlight(null, false);\n  }\n  _onFocus(userGesture) {\n    const activeElement = deepActiveElement(this._recorder.document);\n    if (userGesture && activeElement === this._recorder.document.body)\n      return;\n    const result = activeElement ? this._recorder.injectedScript.generateSelector(activeElement, { testIdAttributeName: this._recorder.state.testIdAttributeName }) : null;\n    this._activeModel = result && result.selector ? { ...result, color: HighlightColors.action } : null;\n    if (userGesture) {\n      this._hoveredElement = activeElement;\n      this._updateModelForHoveredElement();\n    }\n  }\n  _shouldIgnoreMouseEvent(event) {\n    const target = this._recorder.deepEventTarget(event);\n    const nodeName = target.nodeName;\n    if (nodeName === "SELECT" || nodeName === "OPTION")\n      return true;\n    if (nodeName === "INPUT" && ["date", "range"].includes(target.type))\n      return true;\n    return false;\n  }\n  _actionInProgress(event) {\n    const isKeyEvent = event instanceof KeyboardEvent;\n    const isMouseOrPointerEvent = event instanceof MouseEvent || event instanceof PointerEvent;\n    for (const action of this._performingActions) {\n      if (isKeyEvent && action.name === "press" && event.key === action.key)\n        return true;\n      if (isMouseOrPointerEvent && (action.name === "click" || action.name === "check" || action.name === "uncheck"))\n        return true;\n    }\n    consumeEvent(event);\n    return false;\n  }\n  _consumedDueToNoModel(event, model) {\n    if (model)\n      return false;\n    consumeEvent(event);\n    return true;\n  }\n  _consumedDueWrongTarget(event) {\n    if (this._activeModel && this._activeModel.elements[0] === this._recorder.deepEventTarget(event))\n      return false;\n    consumeEvent(event);\n    return true;\n  }\n  _performAction(action) {\n    this._hoveredElement = null;\n    this._hoveredModel = null;\n    this._activeModel = null;\n    this._recorder.updateHighlight(null, false);\n    this._performingActions.add(action);\n    void this._recorder.performAction(action).then(() => {\n      this._performingActions.delete(action);\n      this._onFocus(false);\n      if (this._recorder.injectedScript.isUnderTest) {\n        console.error("Action performed for test: " + JSON.stringify({\n          // eslint-disable-line no-console\n          hovered: this._hoveredModel ? this._hoveredModel.selector : null,\n          active: this._activeModel ? this._activeModel.selector : null\n        }));\n      }\n    });\n  }\n  _shouldGenerateKeyPressFor(event) {\n    if (event.key === "Enter" && (this._recorder.deepEventTarget(event).nodeName === "TEXTAREA" || this._recorder.deepEventTarget(event).isContentEditable))\n      return false;\n    if (["Backspace", "Delete", "AltGraph"].includes(event.key))\n      return false;\n    if (event.key === "@" && event.code === "KeyL")\n      return false;\n    if (navigator.platform.includes("Mac")) {\n      if (event.key === "v" && event.metaKey)\n        return false;\n    } else {\n      if (event.key === "v" && event.ctrlKey)\n        return false;\n      if (event.key === "Insert" && event.shiftKey)\n        return false;\n    }\n    if (["Shift", "Control", "Meta", "Alt", "Process"].includes(event.key))\n      return false;\n    const hasModifier = event.ctrlKey || event.altKey || event.metaKey;\n    if (event.key.length === 1 && !hasModifier)\n      return !!asCheckbox(this._recorder.deepEventTarget(event));\n    return true;\n  }\n  _updateModelForHoveredElement() {\n    if (this._performingActions.size)\n      return;\n    if (!this._hoveredElement || !this._hoveredElement.isConnected) {\n      this._hoveredModel = null;\n      this._hoveredElement = null;\n      this._recorder.updateHighlight(null, true);\n      return;\n    }\n    const { selector, elements } = this._recorder.injectedScript.generateSelector(this._hoveredElement, { testIdAttributeName: this._recorder.state.testIdAttributeName });\n    if (this._hoveredModel && this._hoveredModel.selector === selector)\n      return;\n    this._hoveredModel = selector ? { selector, elements, color: HighlightColors.action } : null;\n    this._recorder.updateHighlight(this._hoveredModel, true);\n  }\n};\nvar TextAssertionTool = class {\n  constructor(recorder, kind) {\n    this._hoverHighlight = null;\n    this._action = null;\n    this._recorder = recorder;\n    this._textCache = new recorder.injectedScript.utils.builtins.Map();\n    this._kind = kind;\n    this._dialog = new Dialog(recorder);\n  }\n  cursor() {\n    return "pointer";\n  }\n  cleanup() {\n    this._dialog.close();\n    this._hoverHighlight = null;\n  }\n  onClick(event) {\n    consumeEvent(event);\n    if (this._kind === "value") {\n      this._commitAssertValue();\n    } else {\n      if (!this._dialog.isShowing())\n        this._showDialog();\n    }\n  }\n  onMouseDown(event) {\n    const target = this._recorder.deepEventTarget(event);\n    if (this._elementHasValue(target))\n      event.preventDefault();\n  }\n  onPointerUp(event) {\n    var _a;\n    const target = (_a = this._hoverHighlight) == null ? void 0 : _a.elements[0];\n    if (this._kind === "value" && target && (target.nodeName === "INPUT" || target.nodeName === "SELECT") && target.disabled) {\n      this._commitAssertValue();\n    }\n  }\n  onMouseMove(event) {\n    var _a;\n    if (this._dialog.isShowing())\n      return;\n    const target = this._recorder.deepEventTarget(event);\n    if (((_a = this._hoverHighlight) == null ? void 0 : _a.elements[0]) === target)\n      return;\n    if (this._kind === "text" || this._kind === "snapshot") {\n      this._hoverHighlight = this._recorder.injectedScript.utils.elementText(this._textCache, target).full ? { elements: [target], selector: "", color: HighlightColors.assert } : null;\n    } else if (this._elementHasValue(target)) {\n      const generated = this._recorder.injectedScript.generateSelector(target, { testIdAttributeName: this._recorder.state.testIdAttributeName });\n      this._hoverHighlight = { selector: generated.selector, elements: generated.elements, color: HighlightColors.assert };\n    } else {\n      this._hoverHighlight = null;\n    }\n    this._recorder.updateHighlight(this._hoverHighlight, true);\n  }\n  onKeyDown(event) {\n    if (event.key === "Escape")\n      this._recorder.setMode("recording");\n    consumeEvent(event);\n  }\n  onScroll(event) {\n    this._recorder.updateHighlight(this._hoverHighlight, false);\n  }\n  _elementHasValue(element) {\n    return element.nodeName === "TEXTAREA" || element.nodeName === "SELECT" || element.nodeName === "INPUT" && !["button", "image", "reset", "submit"].includes(element.type);\n  }\n  _generateAction() {\n    var _a;\n    this._textCache.clear();\n    const target = (_a = this._hoverHighlight) == null ? void 0 : _a.elements[0];\n    if (!target)\n      return null;\n    if (this._kind === "value") {\n      if (!this._elementHasValue(target))\n        return null;\n      const { selector } = this._recorder.injectedScript.generateSelector(target, { testIdAttributeName: this._recorder.state.testIdAttributeName });\n      if (target.nodeName === "INPUT" && ["checkbox", "radio"].includes(target.type.toLowerCase())) {\n        return {\n          name: "assertChecked",\n          selector,\n          signals: [],\n          // Interestingly, inputElement.checked is reversed inside this event handler.\n          checked: !target.checked\n        };\n      } else {\n        return {\n          name: "assertValue",\n          selector,\n          signals: [],\n          value: target.value\n        };\n      }\n    } else if (this._kind === "snapshot") {\n      const generated = this._recorder.injectedScript.generateSelector(target, { testIdAttributeName: this._recorder.state.testIdAttributeName, forTextExpect: true });\n      this._hoverHighlight = { selector: generated.selector, elements: generated.elements, color: HighlightColors.assert };\n      this._recorder.updateHighlight(this._hoverHighlight, true);\n      return {\n        name: "assertSnapshot",\n        selector: this._hoverHighlight.selector,\n        signals: [],\n        snapshot: this._recorder.injectedScript.ariaSnapshot(target, { mode: "regex" })\n      };\n    } else {\n      const generated = this._recorder.injectedScript.generateSelector(target, { testIdAttributeName: this._recorder.state.testIdAttributeName, forTextExpect: true });\n      this._hoverHighlight = { selector: generated.selector, elements: generated.elements, color: HighlightColors.assert };\n      this._recorder.updateHighlight(this._hoverHighlight, true);\n      return {\n        name: "assertText",\n        selector: this._hoverHighlight.selector,\n        signals: [],\n        text: this._recorder.injectedScript.utils.elementText(this._textCache, target).normalized,\n        substring: true\n      };\n    }\n  }\n  _renderValue(action) {\n    if ((action == null ? void 0 : action.name) === "assertText")\n      return this._recorder.injectedScript.utils.normalizeWhiteSpace(action.text);\n    if ((action == null ? void 0 : action.name) === "assertChecked")\n      return String(action.checked);\n    if ((action == null ? void 0 : action.name) === "assertValue")\n      return action.value;\n    if ((action == null ? void 0 : action.name) === "assertSnapshot")\n      return action.snapshot;\n    return "";\n  }\n  _commit() {\n    if (!this._action || !this._dialog.isShowing())\n      return;\n    this._dialog.close();\n    this._recorder.recordAction(this._action);\n    this._recorder.setMode("recording");\n  }\n  _showDialog() {\n    var _a, _b, _c, _d;\n    if (!((_a = this._hoverHighlight) == null ? void 0 : _a.elements[0]))\n      return;\n    this._action = this._generateAction();\n    if (((_b = this._action) == null ? void 0 : _b.name) === "assertText") {\n      this._showTextDialog(this._action);\n    } else if (((_c = this._action) == null ? void 0 : _c.name) === "assertSnapshot") {\n      this._recorder.recordAction(this._action);\n      this._recorder.setMode("recording");\n      (_d = this._recorder.overlay) == null ? void 0 : _d.flashToolSucceeded("assertingSnapshot");\n    }\n  }\n  _showTextDialog(action) {\n    const textElement = this._recorder.document.createElement("textarea");\n    textElement.setAttribute("spellcheck", "false");\n    textElement.value = this._renderValue(action);\n    textElement.classList.add("text-editor");\n    const updateAndValidate = () => {\n      var _a;\n      const newValue = this._recorder.injectedScript.utils.normalizeWhiteSpace(textElement.value);\n      const target = (_a = this._hoverHighlight) == null ? void 0 : _a.elements[0];\n      if (!target)\n        return;\n      action.text = newValue;\n      const targetText = this._recorder.injectedScript.utils.elementText(this._textCache, target).normalized;\n      const matches = newValue && targetText.includes(newValue);\n      textElement.classList.toggle("does-not-match", !matches);\n    };\n    textElement.addEventListener("input", updateAndValidate);\n    const label = "Assert that element contains text";\n    const dialogElement = this._dialog.show({\n      label,\n      body: textElement,\n      onCommit: () => this._commit()\n    });\n    const position = this._recorder.highlight.tooltipPosition(this._recorder.highlight.firstBox(), dialogElement);\n    this._dialog.moveTo(position.anchorTop, position.anchorLeft);\n    textElement.focus();\n  }\n  _commitAssertValue() {\n    var _a;\n    if (this._kind !== "value")\n      return;\n    const action = this._generateAction();\n    if (!action)\n      return;\n    this._recorder.recordAction(action);\n    this._recorder.setMode("recording");\n    (_a = this._recorder.overlay) == null ? void 0 : _a.flashToolSucceeded("assertingValue");\n  }\n};\nvar Overlay = class {\n  constructor(recorder) {\n    this._listeners = [];\n    this._offsetX = 0;\n    this._measure = { width: 0, height: 0 };\n    this._recorder = recorder;\n    const document = this._recorder.document;\n    this._overlayElement = document.createElement("x-pw-overlay");\n    const toolsListElement = document.createElement("x-pw-tools-list");\n    this._overlayElement.appendChild(toolsListElement);\n    this._dragHandle = document.createElement("x-pw-tool-gripper");\n    this._dragHandle.appendChild(document.createElement("x-div"));\n    toolsListElement.appendChild(this._dragHandle);\n    this._recordToggle = this._recorder.document.createElement("x-pw-tool-item");\n    this._recordToggle.title = "Record";\n    this._recordToggle.classList.add("record");\n    this._recordToggle.appendChild(this._recorder.document.createElement("x-div"));\n    toolsListElement.appendChild(this._recordToggle);\n    this._pickLocatorToggle = this._recorder.document.createElement("x-pw-tool-item");\n    this._pickLocatorToggle.title = "Pick locator";\n    this._pickLocatorToggle.classList.add("pick-locator");\n    this._pickLocatorToggle.appendChild(this._recorder.document.createElement("x-div"));\n    toolsListElement.appendChild(this._pickLocatorToggle);\n    this._assertVisibilityToggle = this._recorder.document.createElement("x-pw-tool-item");\n    this._assertVisibilityToggle.title = "Assert visibility";\n    this._assertVisibilityToggle.classList.add("visibility");\n    this._assertVisibilityToggle.appendChild(this._recorder.document.createElement("x-div"));\n    toolsListElement.appendChild(this._assertVisibilityToggle);\n    this._assertTextToggle = this._recorder.document.createElement("x-pw-tool-item");\n    this._assertTextToggle.title = "Assert text";\n    this._assertTextToggle.classList.add("text");\n    this._assertTextToggle.appendChild(this._recorder.document.createElement("x-div"));\n    toolsListElement.appendChild(this._assertTextToggle);\n    this._assertValuesToggle = this._recorder.document.createElement("x-pw-tool-item");\n    this._assertValuesToggle.title = "Assert value";\n    this._assertValuesToggle.classList.add("value");\n    this._assertValuesToggle.appendChild(this._recorder.document.createElement("x-div"));\n    toolsListElement.appendChild(this._assertValuesToggle);\n    this._assertSnapshotToggle = this._recorder.document.createElement("x-pw-tool-item");\n    this._assertSnapshotToggle.title = "Assert snapshot";\n    this._assertSnapshotToggle.classList.add("snapshot");\n    this._assertSnapshotToggle.appendChild(this._recorder.document.createElement("x-div"));\n    toolsListElement.appendChild(this._assertSnapshotToggle);\n    this._updateVisualPosition();\n    this._refreshListeners();\n  }\n  _refreshListeners() {\n    removeEventListeners(this._listeners);\n    this._listeners = [\n      addEventListener(this._dragHandle, "mousedown", (event) => {\n        this._dragState = { offsetX: this._offsetX, dragStart: { x: event.clientX, y: 0 } };\n      }),\n      addEventListener(this._recordToggle, "click", () => {\n        if (this._recordToggle.classList.contains("disabled"))\n          return;\n        this._recorder.setMode(this._recorder.state.mode === "none" || this._recorder.state.mode === "standby" || this._recorder.state.mode === "inspecting" ? "recording" : "standby");\n      }),\n      addEventListener(this._pickLocatorToggle, "click", () => {\n        if (this._pickLocatorToggle.classList.contains("disabled"))\n          return;\n        const newMode = {\n          "inspecting": "standby",\n          "none": "inspecting",\n          "standby": "inspecting",\n          "recording": "recording-inspecting",\n          "recording-inspecting": "recording",\n          "assertingText": "recording-inspecting",\n          "assertingVisibility": "recording-inspecting",\n          "assertingValue": "recording-inspecting",\n          "assertingSnapshot": "recording-inspecting"\n        };\n        this._recorder.setMode(newMode[this._recorder.state.mode]);\n      }),\n      addEventListener(this._assertVisibilityToggle, "click", () => {\n        if (!this._assertVisibilityToggle.classList.contains("disabled"))\n          this._recorder.setMode(this._recorder.state.mode === "assertingVisibility" ? "recording" : "assertingVisibility");\n      }),\n      addEventListener(this._assertTextToggle, "click", () => {\n        if (!this._assertTextToggle.classList.contains("disabled"))\n          this._recorder.setMode(this._recorder.state.mode === "assertingText" ? "recording" : "assertingText");\n      }),\n      addEventListener(this._assertValuesToggle, "click", () => {\n        if (!this._assertValuesToggle.classList.contains("disabled"))\n          this._recorder.setMode(this._recorder.state.mode === "assertingValue" ? "recording" : "assertingValue");\n      }),\n      addEventListener(this._assertSnapshotToggle, "click", () => {\n        if (!this._assertSnapshotToggle.classList.contains("disabled"))\n          this._recorder.setMode(this._recorder.state.mode === "assertingSnapshot" ? "recording" : "assertingSnapshot");\n      })\n    ];\n  }\n  install() {\n    this._recorder.highlight.appendChild(this._overlayElement);\n    this._refreshListeners();\n    this._updateVisualPosition();\n  }\n  contains(element) {\n    return this._recorder.injectedScript.utils.isInsideScope(this._overlayElement, element);\n  }\n  setUIState(state) {\n    this._recordToggle.classList.toggle("toggled", state.mode === "recording" || state.mode === "assertingText" || state.mode === "assertingVisibility" || state.mode === "assertingValue" || state.mode === "assertingSnapshot" || state.mode === "recording-inspecting");\n    this._pickLocatorToggle.classList.toggle("toggled", state.mode === "inspecting" || state.mode === "recording-inspecting");\n    this._assertVisibilityToggle.classList.toggle("toggled", state.mode === "assertingVisibility");\n    this._assertVisibilityToggle.classList.toggle("disabled", state.mode === "none" || state.mode === "standby" || state.mode === "inspecting");\n    this._assertTextToggle.classList.toggle("toggled", state.mode === "assertingText");\n    this._assertTextToggle.classList.toggle("disabled", state.mode === "none" || state.mode === "standby" || state.mode === "inspecting");\n    this._assertValuesToggle.classList.toggle("toggled", state.mode === "assertingValue");\n    this._assertValuesToggle.classList.toggle("disabled", state.mode === "none" || state.mode === "standby" || state.mode === "inspecting");\n    this._assertSnapshotToggle.classList.toggle("toggled", state.mode === "assertingSnapshot");\n    this._assertSnapshotToggle.classList.toggle("disabled", state.mode === "none" || state.mode === "standby" || state.mode === "inspecting");\n    if (this._offsetX !== state.overlay.offsetX) {\n      this._offsetX = state.overlay.offsetX;\n      this._updateVisualPosition();\n    }\n    if (state.mode === "none")\n      this._hideOverlay();\n    else\n      this._showOverlay();\n  }\n  flashToolSucceeded(tool) {\n    let element;\n    if (tool === "assertingVisibility")\n      element = this._assertVisibilityToggle;\n    else if (tool === "assertingSnapshot")\n      element = this._assertSnapshotToggle;\n    else\n      element = this._assertValuesToggle;\n    element.classList.add("succeeded");\n    this._recorder.injectedScript.utils.builtins.setTimeout(() => element.classList.remove("succeeded"), 2e3);\n  }\n  _hideOverlay() {\n    this._overlayElement.setAttribute("hidden", "true");\n  }\n  _showOverlay() {\n    if (!this._overlayElement.hasAttribute("hidden"))\n      return;\n    this._overlayElement.removeAttribute("hidden");\n    this._updateVisualPosition();\n  }\n  _updateVisualPosition() {\n    this._measure = this._overlayElement.getBoundingClientRect();\n    this._overlayElement.style.left = (this._recorder.injectedScript.window.innerWidth - this._measure.width) / 2 + this._offsetX + "px";\n  }\n  onMouseMove(event) {\n    if (!event.buttons) {\n      this._dragState = void 0;\n      return false;\n    }\n    if (this._dragState) {\n      this._offsetX = this._dragState.offsetX + event.clientX - this._dragState.dragStart.x;\n      const halfGapSize = (this._recorder.injectedScript.window.innerWidth - this._measure.width) / 2 - 10;\n      this._offsetX = Math.max(-halfGapSize, Math.min(halfGapSize, this._offsetX));\n      this._updateVisualPosition();\n      this._recorder.setOverlayState({ offsetX: this._offsetX });\n      consumeEvent(event);\n      return true;\n    }\n    return false;\n  }\n  onMouseUp(event) {\n    if (this._dragState) {\n      consumeEvent(event);\n      return true;\n    }\n    return false;\n  }\n  onClick(event) {\n    if (this._dragState) {\n      this._dragState = void 0;\n      consumeEvent(event);\n      return true;\n    }\n    return false;\n  }\n  onDblClick(event) {\n    return false;\n  }\n};\nvar Recorder = class {\n  constructor(injectedScript) {\n    this._listeners = [];\n    this._lastHighlightedSelector = void 0;\n    this._lastHighlightedAriaTemplateJSON = "undefined";\n    this.state = {\n      mode: "none",\n      testIdAttributeName: "data-testid",\n      language: "javascript",\n      overlay: { offsetX: 0 }\n    };\n    this._delegate = {};\n    this.document = injectedScript.document;\n    this.injectedScript = injectedScript;\n    this.highlight = injectedScript.createHighlight();\n    this._tools = {\n      "none": new NoneTool(),\n      "standby": new NoneTool(),\n      "inspecting": new InspectTool(this, false),\n      "recording": new RecordActionTool(this),\n      "recording-inspecting": new InspectTool(this, false),\n      "assertingText": new TextAssertionTool(this, "text"),\n      "assertingVisibility": new InspectTool(this, true),\n      "assertingValue": new TextAssertionTool(this, "value"),\n      "assertingSnapshot": new TextAssertionTool(this, "snapshot")\n    };\n    this._currentTool = this._tools.none;\n    if (injectedScript.window.top === injectedScript.window) {\n      this.overlay = new Overlay(this);\n      this.overlay.setUIState(this.state);\n    }\n    this._stylesheet = new injectedScript.window.CSSStyleSheet();\n    this._stylesheet.replaceSync(`\n      body[data-pw-cursor=pointer] *, body[data-pw-cursor=pointer] *::after { cursor: pointer !important; }\n      body[data-pw-cursor=text] *, body[data-pw-cursor=text] *::after { cursor: text !important; }\n    `);\n    this.installListeners();\n    injectedScript.utils.cacheNormalizedWhitespaces();\n    if (injectedScript.isUnderTest)\n      console.error("Recorder script ready for test");\n    injectedScript.consoleApi.install();\n  }\n  installListeners() {\n    var _a;\n    removeEventListeners(this._listeners);\n    this._listeners = [\n      addEventListener(this.document, "click", (event) => this._onClick(event), true),\n      addEventListener(this.document, "auxclick", (event) => this._onClick(event), true),\n      addEventListener(this.document, "dblclick", (event) => this._onDblClick(event), true),\n      addEventListener(this.document, "contextmenu", (event) => this._onContextMenu(event), true),\n      addEventListener(this.document, "dragstart", (event) => this._onDragStart(event), true),\n      addEventListener(this.document, "input", (event) => this._onInput(event), true),\n      addEventListener(this.document, "keydown", (event) => this._onKeyDown(event), true),\n      addEventListener(this.document, "keyup", (event) => this._onKeyUp(event), true),\n      addEventListener(this.document, "pointerdown", (event) => this._onPointerDown(event), true),\n      addEventListener(this.document, "pointerup", (event) => this._onPointerUp(event), true),\n      addEventListener(this.document, "mousedown", (event) => this._onMouseDown(event), true),\n      addEventListener(this.document, "mouseup", (event) => this._onMouseUp(event), true),\n      addEventListener(this.document, "mousemove", (event) => this._onMouseMove(event), true),\n      addEventListener(this.document, "mouseleave", (event) => this._onMouseLeave(event), true),\n      addEventListener(this.document, "mouseenter", (event) => this._onMouseEnter(event), true),\n      addEventListener(this.document, "focus", (event) => this._onFocus(event), true),\n      addEventListener(this.document, "scroll", (event) => this._onScroll(event), true)\n    ];\n    this.highlight.install();\n    let recreationInterval;\n    const recreate = () => {\n      this.highlight.install();\n      recreationInterval = this.injectedScript.utils.builtins.setTimeout(recreate, 500);\n    };\n    recreationInterval = this.injectedScript.utils.builtins.setTimeout(recreate, 500);\n    this._listeners.push(() => this.injectedScript.utils.builtins.clearTimeout(recreationInterval));\n    this.highlight.appendChild(createSvgElement(this.document, clipPaths_default));\n    (_a = this.overlay) == null ? void 0 : _a.install();\n    this.document.adoptedStyleSheets.push(this._stylesheet);\n  }\n  _switchCurrentTool() {\n    var _a, _b, _c;\n    const newTool = this._tools[this.state.mode];\n    if (newTool === this._currentTool)\n      return;\n    (_b = (_a = this._currentTool).cleanup) == null ? void 0 : _b.call(_a);\n    this.clearHighlight();\n    this._currentTool = newTool;\n    (_c = this.injectedScript.document.body) == null ? void 0 : _c.setAttribute("data-pw-cursor", newTool.cursor());\n  }\n  setUIState(state, delegate) {\n    var _a;\n    this._delegate = delegate;\n    if (state.actionPoint && this.state.actionPoint && state.actionPoint.x === this.state.actionPoint.x && state.actionPoint.y === this.state.actionPoint.y) {\n    } else if (!state.actionPoint && !this.state.actionPoint) {\n    } else {\n      if (state.actionPoint)\n        this.highlight.showActionPoint(state.actionPoint.x, state.actionPoint.y);\n      else\n        this.highlight.hideActionPoint();\n    }\n    this.state = state;\n    this.highlight.setLanguage(state.language);\n    this._switchCurrentTool();\n    (_a = this.overlay) == null ? void 0 : _a.setUIState(state);\n    let highlight = "noop";\n    if (state.actionSelector !== this._lastHighlightedSelector) {\n      const entries = state.actionSelector ? entriesForSelectorHighlight(this.injectedScript, state.language, state.actionSelector, this.document) : null;\n      highlight = (entries == null ? void 0 : entries.length) ? entries : "clear";\n      this._lastHighlightedSelector = (entries == null ? void 0 : entries.length) ? state.actionSelector : void 0;\n    }\n    const ariaTemplateJSON = JSON.stringify(state.ariaTemplate);\n    if (this._lastHighlightedAriaTemplateJSON !== ariaTemplateJSON) {\n      const elements = state.ariaTemplate ? this.injectedScript.getAllByAria(this.document, state.ariaTemplate) : [];\n      if (elements.length) {\n        const color = elements.length > 1 ? HighlightColors.multiple : HighlightColors.single;\n        highlight = elements.map((element) => ({ element, color }));\n        this._lastHighlightedAriaTemplateJSON = ariaTemplateJSON;\n      } else {\n        if (!this._lastHighlightedSelector)\n          highlight = "clear";\n        this._lastHighlightedAriaTemplateJSON = "undefined";\n      }\n    }\n    if (highlight === "clear")\n      this.highlight.clearHighlight();\n    else if (highlight !== "noop")\n      this.highlight.updateHighlight(highlight);\n  }\n  clearHighlight() {\n    this.updateHighlight(null, false);\n  }\n  _onClick(event) {\n    var _a, _b, _c;\n    if (!event.isTrusted)\n      return;\n    if ((_a = this.overlay) == null ? void 0 : _a.onClick(event))\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_c = (_b = this._currentTool).onClick) == null ? void 0 : _c.call(_b, event);\n  }\n  _onDblClick(event) {\n    var _a, _b, _c;\n    if (!event.isTrusted)\n      return;\n    if ((_a = this.overlay) == null ? void 0 : _a.onDblClick(event))\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_c = (_b = this._currentTool).onDblClick) == null ? void 0 : _c.call(_b, event);\n  }\n  _onContextMenu(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onContextMenu) == null ? void 0 : _b.call(_a, event);\n  }\n  _onDragStart(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onDragStart) == null ? void 0 : _b.call(_a, event);\n  }\n  _onPointerDown(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onPointerDown) == null ? void 0 : _b.call(_a, event);\n  }\n  _onPointerUp(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onPointerUp) == null ? void 0 : _b.call(_a, event);\n  }\n  _onMouseDown(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onMouseDown) == null ? void 0 : _b.call(_a, event);\n  }\n  _onMouseUp(event) {\n    var _a, _b, _c;\n    if (!event.isTrusted)\n      return;\n    if ((_a = this.overlay) == null ? void 0 : _a.onMouseUp(event))\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_c = (_b = this._currentTool).onMouseUp) == null ? void 0 : _c.call(_b, event);\n  }\n  _onMouseMove(event) {\n    var _a, _b, _c;\n    if (!event.isTrusted)\n      return;\n    if ((_a = this.overlay) == null ? void 0 : _a.onMouseMove(event))\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_c = (_b = this._currentTool).onMouseMove) == null ? void 0 : _c.call(_b, event);\n  }\n  _onMouseEnter(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onMouseEnter) == null ? void 0 : _b.call(_a, event);\n  }\n  _onMouseLeave(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onMouseLeave) == null ? void 0 : _b.call(_a, event);\n  }\n  _onFocus(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onFocus) == null ? void 0 : _b.call(_a, event);\n  }\n  _onScroll(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    this._lastHighlightedSelector = void 0;\n    this._lastHighlightedAriaTemplateJSON = "undefined";\n    this.highlight.hideActionPoint();\n    (_b = (_a = this._currentTool).onScroll) == null ? void 0 : _b.call(_a, event);\n  }\n  _onInput(event) {\n    var _a, _b;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onInput) == null ? void 0 : _b.call(_a, event);\n  }\n  _onKeyDown(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onKeyDown) == null ? void 0 : _b.call(_a, event);\n  }\n  _onKeyUp(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onKeyUp) == null ? void 0 : _b.call(_a, event);\n  }\n  updateHighlight(model, userGesture) {\n    this._lastHighlightedSelector = void 0;\n    this._lastHighlightedAriaTemplateJSON = "undefined";\n    this._updateHighlight(model, userGesture);\n  }\n  _updateHighlight(model, userGesture) {\n    var _a, _b;\n    let tooltipText = model == null ? void 0 : model.tooltipText;\n    if (tooltipText === void 0 && (model == null ? void 0 : model.selector))\n      tooltipText = this.injectedScript.utils.asLocator(this.state.language, model.selector);\n    if (model)\n      this.highlight.updateHighlight(model.elements.map((element) => ({ element, color: model.color, tooltipText })));\n    else\n      this.highlight.clearHighlight();\n    if (userGesture)\n      (_b = (_a = this._delegate).highlightUpdated) == null ? void 0 : _b.call(_a);\n  }\n  _ignoreOverlayEvent(event) {\n    return event.composedPath().some((e) => {\n      const nodeName = e.nodeName || "";\n      return nodeName.toLowerCase() === "x-pw-glass";\n    });\n  }\n  deepEventTarget(event) {\n    var _a;\n    for (const element of event.composedPath()) {\n      if (!((_a = this.overlay) == null ? void 0 : _a.contains(element)))\n        return element;\n    }\n    return event.composedPath()[0];\n  }\n  setMode(mode) {\n    var _a, _b;\n    void ((_b = (_a = this._delegate).setMode) == null ? void 0 : _b.call(_a, mode));\n  }\n  async performAction(action) {\n    var _a, _b;\n    await ((_b = (_a = this._delegate).performAction) == null ? void 0 : _b.call(_a, action).catch(() => {\n    }));\n  }\n  recordAction(action) {\n    var _a, _b;\n    void ((_b = (_a = this._delegate).recordAction) == null ? void 0 : _b.call(_a, action));\n  }\n  setOverlayState(state) {\n    var _a, _b;\n    void ((_b = (_a = this._delegate).setOverlayState) == null ? void 0 : _b.call(_a, state));\n  }\n  elementPicked(selector, model) {\n    var _a, _b;\n    const ariaSnapshot = this.injectedScript.ariaSnapshot(model.elements[0]);\n    void ((_b = (_a = this._delegate).elementPicked) == null ? void 0 : _b.call(_a, { selector, ariaSnapshot }));\n  }\n};\nvar Dialog = class {\n  constructor(recorder) {\n    this._dialogElement = null;\n    this._recorder = recorder;\n  }\n  isShowing() {\n    return !!this._dialogElement;\n  }\n  show(options) {\n    const acceptButton = this._recorder.document.createElement("x-pw-tool-item");\n    acceptButton.title = "Accept";\n    acceptButton.classList.add("accept");\n    acceptButton.appendChild(this._recorder.document.createElement("x-div"));\n    acceptButton.addEventListener("click", () => options.onCommit());\n    const cancelButton = this._recorder.document.createElement("x-pw-tool-item");\n    cancelButton.title = "Close";\n    cancelButton.classList.add("cancel");\n    cancelButton.appendChild(this._recorder.document.createElement("x-div"));\n    cancelButton.addEventListener("click", () => {\n      var _a;\n      this.close();\n      (_a = options.onCancel) == null ? void 0 : _a.call(options);\n    });\n    this._dialogElement = this._recorder.document.createElement("x-pw-dialog");\n    this._keyboardListener = (event) => {\n      var _a;\n      if (event.key === "Escape") {\n        this.close();\n        (_a = options.onCancel) == null ? void 0 : _a.call(options);\n        return;\n      }\n      if (event.key === "Enter" && (event.ctrlKey || event.metaKey)) {\n        if (this._dialogElement)\n          options.onCommit();\n        return;\n      }\n    };\n    this._recorder.document.addEventListener("keydown", this._keyboardListener, true);\n    const toolbarElement = this._recorder.document.createElement("x-pw-tools-list");\n    const labelElement = this._recorder.document.createElement("label");\n    labelElement.textContent = options.label;\n    toolbarElement.appendChild(labelElement);\n    toolbarElement.appendChild(this._recorder.document.createElement("x-spacer"));\n    toolbarElement.appendChild(acceptButton);\n    toolbarElement.appendChild(cancelButton);\n    this._dialogElement.appendChild(toolbarElement);\n    const bodyElement = this._recorder.document.createElement("x-pw-dialog-body");\n    bodyElement.appendChild(options.body);\n    this._dialogElement.appendChild(bodyElement);\n    this._recorder.highlight.appendChild(this._dialogElement);\n    return this._dialogElement;\n  }\n  moveTo(top, left) {\n    if (!this._dialogElement)\n      return;\n    this._dialogElement.style.top = top + "px";\n    this._dialogElement.style.left = left + "px";\n  }\n  close() {\n    if (!this._dialogElement)\n      return;\n    this._dialogElement.remove();\n    this._recorder.document.removeEventListener("keydown", this._keyboardListener);\n    this._dialogElement = null;\n  }\n};\nfunction deepActiveElement(document) {\n  let activeElement = document.activeElement;\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n    activeElement = activeElement.shadowRoot.activeElement;\n  return activeElement;\n}\nfunction modifiersForEvent(event) {\n  return (event.altKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);\n}\nfunction buttonForEvent(event) {\n  switch (event.which) {\n    case 1:\n      return "left";\n    case 2:\n      return "middle";\n    case 3:\n      return "right";\n  }\n  return "left";\n}\nfunction positionForEvent(event) {\n  const targetElement = event.target;\n  if (targetElement.nodeName !== "CANVAS")\n    return;\n  return {\n    x: event.offsetX,\n    y: event.offsetY\n  };\n}\nfunction consumeEvent(e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.stopImmediatePropagation();\n}\nfunction asCheckbox(node) {\n  if (!node || node.nodeName !== "INPUT")\n    return null;\n  const inputElement = node;\n  return ["checkbox", "radio"].includes(inputElement.type) ? inputElement : null;\n}\nfunction isRangeInput(node) {\n  if (!node || node.nodeName !== "INPUT")\n    return false;\n  const inputElement = node;\n  return inputElement.type.toLowerCase() === "range";\n}\nfunction addEventListener(target, eventName, listener, useCapture) {\n  target.addEventListener(eventName, listener, useCapture);\n  const remove = () => {\n    target.removeEventListener(eventName, listener, useCapture);\n  };\n  return remove;\n}\nfunction removeEventListeners(listeners) {\n  for (const listener of listeners)\n    listener();\n  listeners.splice(0, listeners.length);\n}\nfunction entriesForSelectorHighlight(injectedScript, language, selector, ownerDocument) {\n  try {\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, ownerDocument);\n    const color = elements.length > 1 ? HighlightColors.multiple : HighlightColors.single;\n    const locator = injectedScript.utils.asLocator(language, selector);\n    return elements.map((element, index) => {\n      const suffix = elements.length > 1 ? ` [${index + 1} of ${elements.length}]` : "";\n      return { element, color, tooltipText: locator + suffix };\n    });\n  } catch (e) {\n    return [];\n  }\n}\nfunction createSvgElement(doc, { tagName, attrs, children }) {\n  const elem = doc.createElementNS("http://www.w3.org/2000/svg", tagName);\n  if (attrs) {\n    for (const [k, v] of Object.entries(attrs))\n      elem.setAttribute(k, v);\n  }\n  if (children) {\n    for (const c of children)\n      elem.appendChild(createSvgElement(doc, c));\n  }\n  return elem;\n}\n\n// packages/injected/src/recorder/pollingRecorder.ts\nvar PollingRecorder = class {\n  constructor(injectedScript) {\n    this._recorder = new Recorder(injectedScript);\n    this._embedder = injectedScript.window;\n    injectedScript.onGlobalListenersRemoved.add(() => this._recorder.installListeners());\n    const refreshOverlay = () => {\n      this._lastStateJSON = void 0;\n      this._pollRecorderMode().catch((e) => console.log(e));\n    };\n    this._embedder.__pw_refreshOverlay = refreshOverlay;\n    refreshOverlay();\n  }\n  async _pollRecorderMode() {\n    const pollPeriod = 1e3;\n    if (this._pollRecorderModeTimer)\n      this._recorder.injectedScript.utils.builtins.clearTimeout(this._pollRecorderModeTimer);\n    const state = await this._embedder.__pw_recorderState().catch(() => null);\n    if (!state) {\n      this._pollRecorderModeTimer = this._recorder.injectedScript.utils.builtins.setTimeout(() => this._pollRecorderMode(), pollPeriod);\n      return;\n    }\n    const stringifiedState = JSON.stringify(state);\n    if (this._lastStateJSON !== stringifiedState) {\n      this._lastStateJSON = stringifiedState;\n      const win = this._recorder.document.defaultView;\n      if (win.top !== win) {\n        state.actionPoint = void 0;\n      }\n      this._recorder.setUIState(state, this);\n    }\n    this._pollRecorderModeTimer = this._recorder.injectedScript.utils.builtins.setTimeout(() => this._pollRecorderMode(), pollPeriod);\n  }\n  async performAction(action) {\n    await this._embedder.__pw_recorderPerformAction(action);\n  }\n  async recordAction(action) {\n    await this._embedder.__pw_recorderRecordAction(action);\n  }\n  async elementPicked(elementInfo) {\n    await this._embedder.__pw_recorderElementPicked(elementInfo);\n  }\n  async setMode(mode) {\n    await this._embedder.__pw_recorderSetMode(mode);\n  }\n  async setOverlayState(state) {\n    await this._embedder.__pw_recorderSetOverlayState(state);\n  }\n};\nvar pollingRecorder_default = PollingRecorder;\n';

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/timeoutRunner.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function raceAgainstDeadline(cb, deadline) {
  let timer;
  return Promise.race([
    cb().then((result) => {
      return { result, timedOut: false };
    }),
    new Promise((resolve) => {
      const kMaxDeadline = 2147483647;
      const timeout = (deadline || kMaxDeadline) - monotonicTime();
      timer = setTimeout2(() => resolve({ timedOut: true }), timeout);
    })
  ]).finally(() => {
    clearTimeout2(timer);
  });
}
__name(raceAgainstDeadline, "raceAgainstDeadline");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/contextRecorder.js
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/codegen/languages.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/codegen/csharp.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/deviceDescriptors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/deviceDescriptorsSource.json.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var deviceDescriptorsSource = {
  "Blackberry PlayBook": { "userAgent": "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/18.4 Safari/536.2+", "viewport": { "width": 600, "height": 1024 }, "deviceScaleFactor": 1, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Blackberry PlayBook landscape": { "userAgent": "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/18.4 Safari/536.2+", "viewport": { "width": 1024, "height": 600 }, "deviceScaleFactor": 1, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "BlackBerry Z30": { "userAgent": "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/18.4 Mobile Safari/537.10+", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "BlackBerry Z30 landscape": { "userAgent": "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/18.4 Mobile Safari/537.10+", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy Note 3": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/18.4 Mobile Safari/534.30", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy Note 3 landscape": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/18.4 Mobile Safari/534.30", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy Note II": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/18.4 Mobile Safari/534.30", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy Note II landscape": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/18.4 Mobile Safari/534.30", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy S III": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/18.4 Mobile Safari/534.30", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy S III landscape": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/18.4 Mobile Safari/534.30", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy S5": { "userAgent": "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy S5 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy S8": { "userAgent": "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 360, "height": 740 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy S8 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 740, "height": 360 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy S9+": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 320, "height": 658 }, "deviceScaleFactor": 4.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy S9+ landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 658, "height": 320 }, "deviceScaleFactor": 4.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy Tab S4": { "userAgent": "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Safari/537.36", "viewport": { "width": 712, "height": 1138 }, "deviceScaleFactor": 2.25, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy Tab S4 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Safari/537.36", "viewport": { "width": 1138, "height": 712 }, "deviceScaleFactor": 2.25, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "iPad (gen 5)": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "viewport": { "width": 768, "height": 1024 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad (gen 5) landscape": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "viewport": { "width": 1024, "height": 768 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad (gen 6)": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "viewport": { "width": 768, "height": 1024 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad (gen 6) landscape": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "viewport": { "width": 1024, "height": 768 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad (gen 7)": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "viewport": { "width": 810, "height": 1080 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad (gen 7) landscape": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "viewport": { "width": 1080, "height": 810 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad Mini": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "viewport": { "width": 768, "height": 1024 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad Mini landscape": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "viewport": { "width": 1024, "height": 768 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad Pro 11": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "viewport": { "width": 834, "height": 1194 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad Pro 11 landscape": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "viewport": { "width": 1194, "height": 834 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 6": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 375, "height": 667 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 6 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 667, "height": 375 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 6 Plus": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 414, "height": 736 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 6 Plus landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 736, "height": 414 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 7": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 375, "height": 667 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 7 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 667, "height": 375 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 7 Plus": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 414, "height": 736 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 7 Plus landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 736, "height": 414 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 8": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 375, "height": 667 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 8 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 667, "height": 375 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 8 Plus": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 414, "height": 736 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 8 Plus landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 736, "height": 414 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone SE": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/18.4 Mobile/14E304 Safari/602.1", "viewport": { "width": 320, "height": 568 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone SE landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/18.4 Mobile/14E304 Safari/602.1", "viewport": { "width": 568, "height": 320 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone X": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 375, "height": 812 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone X landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.4 Mobile/15A372 Safari/604.1", "viewport": { "width": 812, "height": 375 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone XR": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "viewport": { "width": 414, "height": 896 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone XR landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "viewport": { "width": 896, "height": 414 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 11": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 414, "height": 896 }, "viewport": { "width": 414, "height": 715 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 11 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 414, "height": 896 }, "viewport": { "width": 800, "height": 364 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 11 Pro": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 375, "height": 812 }, "viewport": { "width": 375, "height": 635 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 11 Pro landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 375, "height": 812 }, "viewport": { "width": 724, "height": 325 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 11 Pro Max": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 414, "height": 896 }, "viewport": { "width": 414, "height": 715 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 11 Pro Max landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 414, "height": 896 }, "viewport": { "width": 808, "height": 364 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 390, "height": 664 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 750, "height": 340 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 Pro": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 390, "height": 664 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 Pro landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 750, "height": 340 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 Pro Max": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 428, "height": 926 }, "viewport": { "width": 428, "height": 746 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 Pro Max landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 428, "height": 926 }, "viewport": { "width": 832, "height": 378 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 Mini": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 375, "height": 812 }, "viewport": { "width": 375, "height": 629 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 Mini landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 375, "height": 812 }, "viewport": { "width": 712, "height": 325 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 390, "height": 664 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 750, "height": 342 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 Pro": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 390, "height": 664 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 Pro landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 750, "height": 342 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 Pro Max": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 428, "height": 926 }, "viewport": { "width": 428, "height": 746 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 Pro Max landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 428, "height": 926 }, "viewport": { "width": 832, "height": 380 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 Mini": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 375, "height": 812 }, "viewport": { "width": 375, "height": 629 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 Mini landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 375, "height": 812 }, "viewport": { "width": 712, "height": 327 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 390, "height": 664 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 750, "height": 340 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 Plus": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 428, "height": 926 }, "viewport": { "width": 428, "height": 746 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 Plus landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 428, "height": 926 }, "viewport": { "width": 832, "height": 378 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 Pro": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 393, "height": 852 }, "viewport": { "width": 393, "height": 660 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 Pro landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 393, "height": 852 }, "viewport": { "width": 734, "height": 343 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 Pro Max": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 430, "height": 932 }, "viewport": { "width": 430, "height": 740 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 Pro Max landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 430, "height": 932 }, "viewport": { "width": 814, "height": 380 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 393, "height": 852 }, "viewport": { "width": 393, "height": 659 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 393, "height": 852 }, "viewport": { "width": 734, "height": 343 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 Plus": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 430, "height": 932 }, "viewport": { "width": 430, "height": 739 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 Plus landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 430, "height": 932 }, "viewport": { "width": 814, "height": 380 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 Pro": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 393, "height": 852 }, "viewport": { "width": 393, "height": 659 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 Pro landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 393, "height": 852 }, "viewport": { "width": 734, "height": 343 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 Pro Max": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 430, "height": 932 }, "viewport": { "width": 430, "height": 739 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 Pro Max landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1", "screen": { "width": 430, "height": 932 }, "viewport": { "width": 814, "height": 380 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Kindle Fire HDX": { "userAgent": "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true", "viewport": { "width": 800, "height": 1280 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Kindle Fire HDX landscape": { "userAgent": "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true", "viewport": { "width": 1280, "height": 800 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "LG Optimus L70": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 384, "height": 640 }, "deviceScaleFactor": 1.25, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "LG Optimus L70 landscape": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 640, "height": 384 }, "deviceScaleFactor": 1.25, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Microsoft Lumia 550": { "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36 Edge/14.14263", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Microsoft Lumia 550 landscape": { "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36 Edge/14.14263", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Microsoft Lumia 950": { "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36 Edge/14.14263", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 4, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Microsoft Lumia 950 landscape": { "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36 Edge/14.14263", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 4, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 10": { "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Safari/537.36", "viewport": { "width": 800, "height": 1280 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 10 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Safari/537.36", "viewport": { "width": 1280, "height": 800 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 4": { "userAgent": "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 384, "height": 640 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 4 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 640, "height": 384 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 5": { "userAgent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 5 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 5X": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 412, "height": 732 }, "deviceScaleFactor": 2.625, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 5X landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 732, "height": 412 }, "deviceScaleFactor": 2.625, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 6": { "userAgent": "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 412, "height": 732 }, "deviceScaleFactor": 3.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 6 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 732, "height": 412 }, "deviceScaleFactor": 3.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 6P": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 412, "height": 732 }, "deviceScaleFactor": 3.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 6P landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 732, "height": 412 }, "deviceScaleFactor": 3.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 7": { "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Safari/537.36", "viewport": { "width": 600, "height": 960 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 7 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Safari/537.36", "viewport": { "width": 960, "height": 600 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nokia Lumia 520": { "userAgent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)", "viewport": { "width": 320, "height": 533 }, "deviceScaleFactor": 1.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nokia Lumia 520 landscape": { "userAgent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)", "viewport": { "width": 533, "height": 320 }, "deviceScaleFactor": 1.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nokia N9": { "userAgent": "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13", "viewport": { "width": 480, "height": 854 }, "deviceScaleFactor": 1, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Nokia N9 landscape": { "userAgent": "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13", "viewport": { "width": 854, "height": 480 }, "deviceScaleFactor": 1, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Pixel 2": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 411, "height": 731 }, "deviceScaleFactor": 2.625, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 2 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 731, "height": 411 }, "deviceScaleFactor": 2.625, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 2 XL": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 411, "height": 823 }, "deviceScaleFactor": 3.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 2 XL landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 823, "height": 411 }, "deviceScaleFactor": 3.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 3": { "userAgent": "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 393, "height": 786 }, "deviceScaleFactor": 2.75, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 3 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 786, "height": 393 }, "deviceScaleFactor": 2.75, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 4": { "userAgent": "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 353, "height": 745 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 4 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 745, "height": 353 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 4a (5G)": { "userAgent": "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "screen": { "width": 412, "height": 892 }, "viewport": { "width": 412, "height": 765 }, "deviceScaleFactor": 2.63, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 4a (5G) landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "screen": { "height": 892, "width": 412 }, "viewport": { "width": 840, "height": 312 }, "deviceScaleFactor": 2.63, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 5": { "userAgent": "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "screen": { "width": 393, "height": 851 }, "viewport": { "width": 393, "height": 727 }, "deviceScaleFactor": 2.75, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 5 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "screen": { "width": 851, "height": 393 }, "viewport": { "width": 802, "height": 293 }, "deviceScaleFactor": 2.75, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 7": { "userAgent": "Mozilla/5.0 (Linux; Android 14; Pixel 7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "screen": { "width": 412, "height": 915 }, "viewport": { "width": 412, "height": 839 }, "deviceScaleFactor": 2.625, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 7 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 14; Pixel 7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "screen": { "width": 915, "height": 412 }, "viewport": { "width": 863, "height": 360 }, "deviceScaleFactor": 2.625, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Moto G4": { "userAgent": "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Moto G4 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Mobile Safari/537.36", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Desktop Chrome HiDPI": { "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Safari/537.36", "screen": { "width": 1792, "height": 1120 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 2, "isMobile": false, "hasTouch": false, "defaultBrowserType": "chromium" },
  "Desktop Edge HiDPI": { "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Safari/537.36 Edg/136.0.7103.33", "screen": { "width": 1792, "height": 1120 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 2, "isMobile": false, "hasTouch": false, "defaultBrowserType": "chromium" },
  "Desktop Firefox HiDPI": { "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0", "screen": { "width": 1792, "height": 1120 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 2, "isMobile": false, "hasTouch": false, "defaultBrowserType": "firefox" },
  "Desktop Safari": { "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Safari/605.1.15", "screen": { "width": 1792, "height": 1120 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 2, "isMobile": false, "hasTouch": false, "defaultBrowserType": "webkit" },
  "Desktop Chrome": { "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Safari/537.36", "screen": { "width": 1920, "height": 1080 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 1, "isMobile": false, "hasTouch": false, "defaultBrowserType": "chromium" },
  "Desktop Edge": { "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.33 Safari/537.36 Edg/136.0.7103.33", "screen": { "width": 1920, "height": 1080 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 1, "isMobile": false, "hasTouch": false, "defaultBrowserType": "chromium" },
  "Desktop Firefox": { "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0", "screen": { "width": 1920, "height": 1080 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 1, "isMobile": false, "hasTouch": false, "defaultBrowserType": "firefox" }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/deviceDescriptors.js
var deviceDescriptors = deviceDescriptorsSource;

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/codegen/csharp.js
var CSharpLanguageGenerator = class {
  static {
    __name(this, "CSharpLanguageGenerator");
  }
  constructor(mode) {
    this.groupName = ".NET C#";
    this.highlighter = "csharp";
    if (mode === "library") {
      this.name = "Library";
      this.id = "csharp";
    } else if (mode === "mstest") {
      this.name = "MSTest";
      this.id = "csharp-mstest";
    } else if (mode === "nunit") {
      this.name = "NUnit";
      this.id = "csharp-nunit";
    } else {
      throw new Error(`Unknown C# language mode: ${mode}`);
    }
    this._mode = mode;
  }
  generateAction(actionInContext) {
    const action = this._generateActionInner(actionInContext);
    if (action)
      return action;
    return "";
  }
  _generateActionInner(actionInContext) {
    const action = actionInContext.action;
    if (this._mode !== "library" && (action.name === "openPage" || action.name === "closePage"))
      return "";
    let pageAlias = actionInContext.frame.pageAlias;
    if (this._mode !== "library")
      pageAlias = pageAlias.replace("page", "Page");
    const formatter = new CSharpFormatter(this._mode === "library" ? 0 : 8);
    if (action.name === "openPage") {
      formatter.add(`var ${pageAlias} = await context.NewPageAsync();`);
      if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
        formatter.add(`await ${pageAlias}.GotoAsync(${quote(action.url)});`);
      return formatter.format();
    }
    const locators = actionInContext.frame.framePath.map((selector) => `.${this._asLocator(selector)}.ContentFrame`);
    const subject = `${pageAlias}${locators.join("")}`;
    const signals3 = toSignalMap(action);
    if (signals3.dialog) {
      formatter.add(`    void ${pageAlias}_Dialog${signals3.dialog.dialogAlias}_EventHandler(object sender, IDialog dialog)
      {
          Console.WriteLine($"Dialog message: {dialog.Message}");
          dialog.DismissAsync();
          ${pageAlias}.Dialog -= ${pageAlias}_Dialog${signals3.dialog.dialogAlias}_EventHandler;
      }
      ${pageAlias}.Dialog += ${pageAlias}_Dialog${signals3.dialog.dialogAlias}_EventHandler;`);
    }
    const lines = [];
    lines.push(this._generateActionCall(subject, actionInContext));
    if (signals3.download) {
      lines.unshift(`var download${signals3.download.downloadAlias} = await ${pageAlias}.RunAndWaitForDownloadAsync(async () =>
{`);
      lines.push(`});`);
    }
    if (signals3.popup) {
      lines.unshift(`var ${signals3.popup.popupAlias} = await ${pageAlias}.RunAndWaitForPopupAsync(async () =>
{`);
      lines.push(`});`);
    }
    for (const line of lines)
      formatter.add(line);
    return formatter.format();
  }
  _generateActionCall(subject, actionInContext) {
    const action = actionInContext.action;
    switch (action.name) {
      case "openPage":
        throw Error("Not reached");
      case "closePage":
        return `await ${subject}.CloseAsync();`;
      case "click": {
        let method = "Click";
        if (action.clickCount === 2)
          method = "DblClick";
        const options2 = toClickOptionsForSourceCode(action);
        if (!Object.entries(options2).length)
          return `await ${subject}.${this._asLocator(action.selector)}.${method}Async();`;
        const optionsString = formatObject(options2, "    ", "Locator" + method + "Options");
        return `await ${subject}.${this._asLocator(action.selector)}.${method}Async(${optionsString});`;
      }
      case "check":
        return `await ${subject}.${this._asLocator(action.selector)}.CheckAsync();`;
      case "uncheck":
        return `await ${subject}.${this._asLocator(action.selector)}.UncheckAsync();`;
      case "fill":
        return `await ${subject}.${this._asLocator(action.selector)}.FillAsync(${quote(action.text)});`;
      case "setInputFiles":
        return `await ${subject}.${this._asLocator(action.selector)}.SetInputFilesAsync(${formatObject(action.files)});`;
      case "press": {
        const modifiers = toKeyboardModifiers(action.modifiers);
        const shortcut = [...modifiers, action.key].join("+");
        return `await ${subject}.${this._asLocator(action.selector)}.PressAsync(${quote(shortcut)});`;
      }
      case "navigate":
        return `await ${subject}.GotoAsync(${quote(action.url)});`;
      case "select":
        return `await ${subject}.${this._asLocator(action.selector)}.SelectOptionAsync(${formatObject(action.options)});`;
      case "assertText":
        return `await Expect(${subject}.${this._asLocator(action.selector)}).${action.substring ? "ToContainTextAsync" : "ToHaveTextAsync"}(${quote(action.text)});`;
      case "assertChecked":
        return `await Expect(${subject}.${this._asLocator(action.selector)})${action.checked ? "" : ".Not"}.ToBeCheckedAsync();`;
      case "assertVisible":
        return `await Expect(${subject}.${this._asLocator(action.selector)}).ToBeVisibleAsync();`;
      case "assertValue": {
        const assertion = action.value ? `ToHaveValueAsync(${quote(action.value)})` : `ToBeEmptyAsync()`;
        return `await Expect(${subject}.${this._asLocator(action.selector)}).${assertion};`;
      }
      case "assertSnapshot":
        return `await Expect(${subject}.${this._asLocator(action.selector)}).ToMatchAriaSnapshotAsync(${quote(action.snapshot)});`;
    }
  }
  _asLocator(selector) {
    return asLocator("csharp", selector);
  }
  generateHeader(options2) {
    if (this._mode === "library")
      return this.generateStandaloneHeader(options2);
    return this.generateTestRunnerHeader(options2);
  }
  generateStandaloneHeader(options2) {
    const formatter = new CSharpFormatter(0);
    formatter.add(`
      using Microsoft.Playwright;
      using System;
      using System.Threading.Tasks;

      using var playwright = await Playwright.CreateAsync();
      await using var browser = await playwright.${toPascal(options2.browserName)}.LaunchAsync(${formatObject(options2.launchOptions, "    ", "BrowserTypeLaunchOptions")});
      var context = await browser.NewContextAsync(${formatContextOptions(options2.contextOptions, options2.deviceName)});`);
    if (options2.contextOptions.recordHar) {
      const url4 = options2.contextOptions.recordHar.urlFilter;
      formatter.add(`      await context.RouteFromHARAsync(${quote(options2.contextOptions.recordHar.path)}${url4 ? `, ${formatObject({ url: url4 }, "    ", "BrowserContextRouteFromHAROptions")}` : ""});`);
    }
    formatter.newLine();
    return formatter.format();
  }
  generateTestRunnerHeader(options2) {
    const formatter = new CSharpFormatter(0);
    formatter.add(`
      using Microsoft.Playwright.${this._mode === "nunit" ? "NUnit" : "MSTest"};
      using Microsoft.Playwright;

      ${this._mode === "nunit" ? `[Parallelizable(ParallelScope.Self)]
      [TestFixture]` : "[TestClass]"}
      public class Tests : PageTest
      {`);
    const formattedContextOptions = formatContextOptions(options2.contextOptions, options2.deviceName);
    if (formattedContextOptions) {
      formatter.add(`public override BrowserNewContextOptions ContextOptions()
      {
          return ${formattedContextOptions};
      }`);
      formatter.newLine();
    }
    formatter.add(`    [${this._mode === "nunit" ? "Test" : "TestMethod"}]
    public async Task MyTest()
    {`);
    if (options2.contextOptions.recordHar) {
      const url4 = options2.contextOptions.recordHar.urlFilter;
      formatter.add(`    await Context.RouteFromHARAsync(${quote(options2.contextOptions.recordHar.path)}${url4 ? `, ${formatObject({ url: url4 }, "    ", "BrowserContextRouteFromHAROptions")}` : ""});`);
    }
    return formatter.format();
  }
  generateFooter(saveStorage) {
    const offset = this._mode === "library" ? "" : "        ";
    let storageStateLine = saveStorage ? `
${offset}await context.StorageStateAsync(new BrowserContextStorageStateOptions
${offset}{
${offset}    Path = ${quote(saveStorage)}
${offset}});
` : "";
    if (this._mode !== "library")
      storageStateLine += `    }
}
`;
    return storageStateLine;
  }
};
function formatObject(value, indent = "    ", name = "") {
  if (typeof value === "string") {
    if (["permissions", "colorScheme", "modifiers", "button", "recordHarContent", "recordHarMode", "serviceWorkers"].includes(name))
      return `${getClassName(name)}.${toPascal(value)}`;
    return quote(value);
  }
  if (Array.isArray(value))
    return `new[] { ${value.map((o) => formatObject(o, indent, name)).join(", ")} }`;
  if (typeof value === "object") {
    const keys = Object.keys(value).filter((key) => value[key] !== void 0).sort();
    if (!keys.length)
      return name ? `new ${getClassName(name)}` : "";
    const tokens = [];
    for (const key of keys) {
      const property = getPropertyName(key);
      tokens.push(`${property} = ${formatObject(value[key], indent, key)},`);
    }
    if (name)
      return `new ${getClassName(name)}
{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
    return `{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
  }
  if (name === "latitude" || name === "longitude")
    return String(value) + "m";
  return String(value);
}
__name(formatObject, "formatObject");
function getClassName(value) {
  switch (value) {
    case "viewport":
      return "ViewportSize";
    case "proxy":
      return "ProxySettings";
    case "permissions":
      return "ContextPermission";
    case "modifiers":
      return "KeyboardModifier";
    case "button":
      return "MouseButton";
    case "recordHarMode":
      return "HarMode";
    case "recordHarContent":
      return "HarContentPolicy";
    case "serviceWorkers":
      return "ServiceWorkerPolicy";
    default:
      return toPascal(value);
  }
}
__name(getClassName, "getClassName");
function getPropertyName(key) {
  switch (key) {
    case "storageState":
      return "StorageStatePath";
    case "viewport":
      return "ViewportSize";
    default:
      return toPascal(key);
  }
}
__name(getPropertyName, "getPropertyName");
function toPascal(value) {
  return value[0].toUpperCase() + value.slice(1);
}
__name(toPascal, "toPascal");
function formatContextOptions(contextOptions, deviceName) {
  let options2 = { ...contextOptions };
  delete options2.recordHar;
  const device = deviceName && deviceDescriptors[deviceName];
  if (!device) {
    if (!Object.entries(options2).length)
      return "";
    return formatObject(options2, "    ", "BrowserNewContextOptions");
  }
  options2 = sanitizeDeviceOptions(device, options2);
  if (!Object.entries(options2).length)
    return `playwright.Devices[${quote(deviceName)}]`;
  return formatObject(options2, "    ", `BrowserNewContextOptions(playwright.Devices[${quote(deviceName)}])`);
}
__name(formatContextOptions, "formatContextOptions");
var CSharpFormatter = class {
  static {
    __name(this, "CSharpFormatter");
  }
  constructor(offset = 0) {
    this._lines = [];
    this._baseIndent = " ".repeat(4);
    this._baseOffset = " ".repeat(offset);
  }
  prepend(text) {
    this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
  }
  add(text) {
    this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
  }
  newLine() {
    this._lines.push("");
  }
  format() {
    let spaces = "";
    let previousLine = "";
    return this._lines.map((line) => {
      if (line === "")
        return line;
      if (line.startsWith("}") || line.startsWith("]") || line.includes("});") || line === ");")
        spaces = spaces.substring(this._baseIndent.length);
      const extraSpaces = /^(for|while|if).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
      previousLine = line;
      line = spaces + extraSpaces + line;
      if (line.endsWith("{") || line.endsWith("[") || line.endsWith("("))
        spaces += this._baseIndent;
      if (line.endsWith("));"))
        spaces = spaces.substring(this._baseIndent.length);
      return this._baseOffset + line;
    }).join("\n");
  }
};
function quote(text) {
  return escapeWithQuotes(text, '"');
}
__name(quote, "quote");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/codegen/java.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/codegen/javascript.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var JavaScriptLanguageGenerator = class {
  static {
    __name(this, "JavaScriptLanguageGenerator");
  }
  constructor(isTest) {
    this.groupName = "Node.js";
    this.highlighter = "javascript";
    this.id = isTest ? "playwright-test" : "javascript";
    this.name = isTest ? "Test Runner" : "Library";
    this._isTest = isTest;
  }
  generateAction(actionInContext) {
    const action = actionInContext.action;
    if (this._isTest && (action.name === "openPage" || action.name === "closePage"))
      return "";
    const pageAlias = actionInContext.frame.pageAlias;
    const formatter = new JavaScriptFormatter(2);
    if (action.name === "openPage") {
      formatter.add(`const ${pageAlias} = await context.newPage();`);
      if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
        formatter.add(`await ${pageAlias}.goto(${quote2(action.url)});`);
      return formatter.format();
    }
    const locators = actionInContext.frame.framePath.map((selector) => `.${this._asLocator(selector)}.contentFrame()`);
    const subject = `${pageAlias}${locators.join("")}`;
    const signals3 = toSignalMap(action);
    if (signals3.dialog) {
      formatter.add(`  ${pageAlias}.once('dialog', dialog => {
    console.log(\`Dialog message: \${dialog.message()}\`);
    dialog.dismiss().catch(() => {});
  });`);
    }
    if (signals3.popup)
      formatter.add(`const ${signals3.popup.popupAlias}Promise = ${pageAlias}.waitForEvent('popup');`);
    if (signals3.download)
      formatter.add(`const download${signals3.download.downloadAlias}Promise = ${pageAlias}.waitForEvent('download');`);
    formatter.add(wrapWithStep(actionInContext.description, this._generateActionCall(subject, actionInContext)));
    if (signals3.popup)
      formatter.add(`const ${signals3.popup.popupAlias} = await ${signals3.popup.popupAlias}Promise;`);
    if (signals3.download)
      formatter.add(`const download${signals3.download.downloadAlias} = await download${signals3.download.downloadAlias}Promise;`);
    return formatter.format();
  }
  _generateActionCall(subject, actionInContext) {
    const action = actionInContext.action;
    switch (action.name) {
      case "openPage":
        throw Error("Not reached");
      case "closePage":
        return `await ${subject}.close();`;
      case "click": {
        let method = "click";
        if (action.clickCount === 2)
          method = "dblclick";
        const options2 = toClickOptionsForSourceCode(action);
        const optionsString = formatOptions(options2);
        return `await ${subject}.${this._asLocator(action.selector)}.${method}(${optionsString});`;
      }
      case "check":
        return `await ${subject}.${this._asLocator(action.selector)}.check();`;
      case "uncheck":
        return `await ${subject}.${this._asLocator(action.selector)}.uncheck();`;
      case "fill":
        return `await ${subject}.${this._asLocator(action.selector)}.fill(${quote2(action.text)});`;
      case "setInputFiles":
        return `await ${subject}.${this._asLocator(action.selector)}.setInputFiles(${formatObject2(action.files.length === 1 ? action.files[0] : action.files)});`;
      case "press": {
        const modifiers = toKeyboardModifiers(action.modifiers);
        const shortcut = [...modifiers, action.key].join("+");
        return `await ${subject}.${this._asLocator(action.selector)}.press(${quote2(shortcut)});`;
      }
      case "navigate":
        return `await ${subject}.goto(${quote2(action.url)});`;
      case "select":
        return `await ${subject}.${this._asLocator(action.selector)}.selectOption(${formatObject2(action.options.length === 1 ? action.options[0] : action.options)});`;
      case "assertText":
        return `${this._isTest ? "" : "// "}await expect(${subject}.${this._asLocator(action.selector)}).${action.substring ? "toContainText" : "toHaveText"}(${quote2(action.text)});`;
      case "assertChecked":
        return `${this._isTest ? "" : "// "}await expect(${subject}.${this._asLocator(action.selector)})${action.checked ? "" : ".not"}.toBeChecked();`;
      case "assertVisible":
        return `${this._isTest ? "" : "// "}await expect(${subject}.${this._asLocator(action.selector)}).toBeVisible();`;
      case "assertValue": {
        const assertion = action.value ? `toHaveValue(${quote2(action.value)})` : `toBeEmpty()`;
        return `${this._isTest ? "" : "// "}await expect(${subject}.${this._asLocator(action.selector)}).${assertion};`;
      }
      case "assertSnapshot": {
        const commentIfNeeded = this._isTest ? "" : "// ";
        return `${commentIfNeeded}await expect(${subject}.${this._asLocator(action.selector)}).toMatchAriaSnapshot(${quoteMultiline(action.snapshot, `${commentIfNeeded}  `)});`;
      }
    }
  }
  _asLocator(selector) {
    return asLocator("javascript", selector);
  }
  generateHeader(options2) {
    if (this._isTest)
      return this.generateTestHeader(options2);
    return this.generateStandaloneHeader(options2);
  }
  generateFooter(saveStorage) {
    if (this._isTest)
      return this.generateTestFooter(saveStorage);
    return this.generateStandaloneFooter(saveStorage);
  }
  generateTestHeader(options2) {
    const formatter = new JavaScriptFormatter();
    const useText = formatContextOptions2(options2.contextOptions, options2.deviceName, this._isTest);
    formatter.add(`
      import { test, expect${options2.deviceName ? ", devices" : ""} } from '@playwright/test';
${useText ? "\ntest.use(" + useText + ");\n" : ""}
      test('test', async ({ page }) => {`);
    if (options2.contextOptions.recordHar) {
      const url4 = options2.contextOptions.recordHar.urlFilter;
      formatter.add(`  await page.routeFromHAR(${quote2(options2.contextOptions.recordHar.path)}${url4 ? `, ${formatOptions({ url: url4 })}` : ""});`);
    }
    return formatter.format();
  }
  generateTestFooter(saveStorage) {
    return `});`;
  }
  generateStandaloneHeader(options2) {
    const formatter = new JavaScriptFormatter();
    formatter.add(`
      const { ${options2.browserName}${options2.deviceName ? ", devices" : ""} } = require('playwright');

      (async () => {
        const browser = await ${options2.browserName}.launch(${formatObjectOrVoid(options2.launchOptions)});
        const context = await browser.newContext(${formatContextOptions2(options2.contextOptions, options2.deviceName)});`);
    if (options2.contextOptions.recordHar)
      formatter.add(`        await context.routeFromHAR(${quote2(options2.contextOptions.recordHar.path)});`);
    return formatter.format();
  }
  generateStandaloneFooter(saveStorage) {
    const storageStateLine = saveStorage ? `
  await context.storageState({ path: ${quote2(saveStorage)} });` : "";
    return `
  // ---------------------${storageStateLine}
  await context.close();
  await browser.close();
})();`;
  }
};
function formatOptions(value, hasArguments) {
  const keys = Object.keys(value);
  if (!keys.length)
    return "";
  return "" + formatObject2(value);
}
__name(formatOptions, "formatOptions");
function formatObject2(value, indent = "  ") {
  if (typeof value === "string")
    return quote2(value);
  if (Array.isArray(value))
    return `[${value.map((o) => formatObject2(o)).join(", ")}]`;
  if (typeof value === "object") {
    const keys = Object.keys(value).filter((key) => value[key] !== void 0).sort();
    if (!keys.length)
      return "{}";
    const tokens = [];
    for (const key of keys)
      tokens.push(`${key}: ${formatObject2(value[key])}`);
    return `{
${indent}${tokens.join(`,
${indent}`)}
}`;
  }
  return String(value);
}
__name(formatObject2, "formatObject");
function formatObjectOrVoid(value, indent = "  ") {
  const result = formatObject2(value, indent);
  return result === "{}" ? "" : result;
}
__name(formatObjectOrVoid, "formatObjectOrVoid");
function formatContextOptions2(options2, deviceName, isTest) {
  const device = deviceName && deviceDescriptors[deviceName];
  options2 = { ...options2, recordHar: void 0 };
  if (!device)
    return formatObjectOrVoid(options2);
  let serializedObject = formatObjectOrVoid(sanitizeDeviceOptions(device, options2));
  if (!serializedObject)
    serializedObject = "{\n}";
  const lines = serializedObject.split("\n");
  lines.splice(1, 0, `...devices[${quote2(deviceName)}],`);
  return lines.join("\n");
}
__name(formatContextOptions2, "formatContextOptions");
var JavaScriptFormatter = class {
  static {
    __name(this, "JavaScriptFormatter");
  }
  constructor(offset = 0) {
    this._lines = [];
    this._baseIndent = " ".repeat(2);
    this._baseOffset = " ".repeat(offset);
  }
  prepend(text) {
    const trim = isMultilineString(text) ? (line) => line : (line) => line.trim();
    this._lines = text.trim().split("\n").map(trim).concat(this._lines);
  }
  add(text) {
    const trim = isMultilineString(text) ? (line) => line : (line) => line.trim();
    this._lines.push(...text.trim().split("\n").map(trim));
  }
  newLine() {
    this._lines.push("");
  }
  format() {
    let spaces = "";
    let previousLine = "";
    return this._lines.map((line) => {
      if (line === "")
        return line;
      if (line.startsWith("}") || line.startsWith("]"))
        spaces = spaces.substring(this._baseIndent.length);
      const extraSpaces = /^(for|while|if|try).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
      previousLine = line;
      const callCarryOver = line.startsWith(".set");
      line = spaces + extraSpaces + (callCarryOver ? this._baseIndent : "") + line;
      if (line.endsWith("{") || line.endsWith("["))
        spaces += this._baseIndent;
      return this._baseOffset + line;
    }).join("\n");
  }
};
function quote2(text) {
  return escapeWithQuotes(text, "'");
}
__name(quote2, "quote");
function wrapWithStep(description, body) {
  return description ? `await test.step(\`${description}\`, async () => {
${body}
});` : body;
}
__name(wrapWithStep, "wrapWithStep");
function quoteMultiline(text, indent = "  ") {
  const escape = /* @__PURE__ */ __name((text2) => text2.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$\{/g, "\\${"), "escape");
  const lines = text.split("\n");
  if (lines.length === 1)
    return "`" + escape(text) + "`";
  return "`\n" + lines.map((line) => indent + escape(line).replace(/\${/g, "\\${")).join("\n") + `
${indent}\``;
}
__name(quoteMultiline, "quoteMultiline");
function isMultilineString(text) {
  return text.match(/`[\S\s]*`/)?.[0].includes("\n");
}
__name(isMultilineString, "isMultilineString");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/codegen/java.js
import "node:path";
import "node:url";
var JavaLanguageGenerator = class {
  static {
    __name(this, "JavaLanguageGenerator");
  }
  constructor(mode) {
    this.groupName = "Java";
    this.highlighter = "java";
    if (mode === "library") {
      this.name = "Library";
      this.id = "java";
    } else if (mode === "junit") {
      this.name = "JUnit";
      this.id = "java-junit";
    } else {
      throw new Error(`Unknown Java language mode: ${mode}`);
    }
    this._mode = mode;
  }
  generateAction(actionInContext) {
    const action = actionInContext.action;
    const pageAlias = actionInContext.frame.pageAlias;
    const offset = this._mode === "junit" ? 4 : 6;
    const formatter = new JavaScriptFormatter(offset);
    if (this._mode !== "library" && (action.name === "openPage" || action.name === "closePage"))
      return "";
    if (action.name === "openPage") {
      formatter.add(`Page ${pageAlias} = context.newPage();`);
      if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
        formatter.add(`${pageAlias}.navigate(${quote3(action.url)});`);
      return formatter.format();
    }
    const locators = actionInContext.frame.framePath.map((selector) => `.${this._asLocator(selector, false)}.contentFrame()`);
    const subject = `${pageAlias}${locators.join("")}`;
    const signals3 = toSignalMap(action);
    if (signals3.dialog) {
      formatter.add(`  ${pageAlias}.onceDialog(dialog -> {
        System.out.println(String.format("Dialog message: %s", dialog.message()));
        dialog.dismiss();
      });`);
    }
    let code = this._generateActionCall(subject, actionInContext, !!actionInContext.frame.framePath.length);
    if (signals3.popup) {
      code = `Page ${signals3.popup.popupAlias} = ${pageAlias}.waitForPopup(() -> {
        ${code}
      });`;
    }
    if (signals3.download) {
      code = `Download download${signals3.download.downloadAlias} = ${pageAlias}.waitForDownload(() -> {
        ${code}
      });`;
    }
    formatter.add(code);
    return formatter.format();
  }
  _generateActionCall(subject, actionInContext, inFrameLocator) {
    const action = actionInContext.action;
    switch (action.name) {
      case "openPage":
        throw Error("Not reached");
      case "closePage":
        return `${subject}.close();`;
      case "click": {
        let method = "click";
        if (action.clickCount === 2)
          method = "dblclick";
        const options2 = toClickOptionsForSourceCode(action);
        const optionsText = formatClickOptions(options2);
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.${method}(${optionsText});`;
      }
      case "check":
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.check();`;
      case "uncheck":
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.uncheck();`;
      case "fill":
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.fill(${quote3(action.text)});`;
      case "setInputFiles":
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.setInputFiles(${formatPath(action.files.length === 1 ? action.files[0] : action.files)});`;
      case "press": {
        const modifiers = toKeyboardModifiers(action.modifiers);
        const shortcut = [...modifiers, action.key].join("+");
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.press(${quote3(shortcut)});`;
      }
      case "navigate":
        return `${subject}.navigate(${quote3(action.url)});`;
      case "select":
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.selectOption(${formatSelectOption(action.options.length === 1 ? action.options[0] : action.options)});`;
      case "assertText":
        return `assertThat(${subject}.${this._asLocator(action.selector, inFrameLocator)}).${action.substring ? "containsText" : "hasText"}(${quote3(action.text)});`;
      case "assertChecked":
        return `assertThat(${subject}.${this._asLocator(action.selector, inFrameLocator)})${action.checked ? "" : ".not()"}.isChecked();`;
      case "assertVisible":
        return `assertThat(${subject}.${this._asLocator(action.selector, inFrameLocator)}).isVisible();`;
      case "assertValue": {
        const assertion = action.value ? `hasValue(${quote3(action.value)})` : `isEmpty()`;
        return `assertThat(${subject}.${this._asLocator(action.selector, inFrameLocator)}).${assertion};`;
      }
      case "assertSnapshot":
        return `assertThat(${subject}.${this._asLocator(action.selector, inFrameLocator)}).matchesAriaSnapshot(${quote3(action.snapshot)});`;
    }
  }
  _asLocator(selector, inFrameLocator) {
    return asLocator("java", selector, inFrameLocator);
  }
  generateHeader(options2) {
    const formatter = new JavaScriptFormatter();
    if (this._mode === "junit") {
      formatter.add(`
      import com.microsoft.playwright.junit.UsePlaywright;
      import com.microsoft.playwright.Page;
      import com.microsoft.playwright.options.*;

      ${options2.contextOptions.recordHar ? `import java.nio.file.Paths;
` : ""}import org.junit.jupiter.api.*;
      import static com.microsoft.playwright.assertions.PlaywrightAssertions.*;

      @UsePlaywright
      public class TestExample {
        @Test
        void test(Page page) {`);
      if (options2.contextOptions.recordHar) {
        const url4 = options2.contextOptions.recordHar.urlFilter;
        const recordHarOptions = typeof url4 === "string" ? `, new Page.RouteFromHAROptions()
            .setUrl(${quote3(url4)})` : "";
        formatter.add(`          page.routeFromHAR(Paths.get(${quote3(options2.contextOptions.recordHar.path)})${recordHarOptions});`);
      }
      return formatter.format();
    }
    formatter.add(`
    import com.microsoft.playwright.*;
    import com.microsoft.playwright.options.*;
    import static com.microsoft.playwright.assertions.PlaywrightAssertions.assertThat;
    ${options2.contextOptions.recordHar ? `import java.nio.file.Paths;
` : ""}import java.util.*;

    public class Example {
      public static void main(String[] args) {
        try (Playwright playwright = Playwright.create()) {
          Browser browser = playwright.${options2.browserName}().launch(${formatLaunchOptions(options2.launchOptions)});
          BrowserContext context = browser.newContext(${formatContextOptions3(options2.contextOptions, options2.deviceName)});`);
    if (options2.contextOptions.recordHar) {
      const url4 = options2.contextOptions.recordHar.urlFilter;
      const recordHarOptions = typeof url4 === "string" ? `, new BrowserContext.RouteFromHAROptions()
          .setUrl(${quote3(url4)})` : "";
      formatter.add(`          context.routeFromHAR(Paths.get(${quote3(options2.contextOptions.recordHar.path)})${recordHarOptions});`);
    }
    return formatter.format();
  }
  generateFooter(saveStorage) {
    const storageStateLine = saveStorage ? `
      context.storageState(new BrowserContext.StorageStateOptions().setPath(${quote3(saveStorage)}));
` : "";
    if (this._mode === "junit") {
      return `${storageStateLine}  }
}`;
    }
    return `${storageStateLine}    }
  }
}`;
  }
};
function formatPath(files) {
  if (Array.isArray(files)) {
    if (files.length === 0)
      return "new Path[0]";
    return `new Path[] {${files.map((s) => "Paths.get(" + quote3(s) + ")").join(", ")}}`;
  }
  return `Paths.get(${quote3(files)})`;
}
__name(formatPath, "formatPath");
function formatSelectOption(options2) {
  if (Array.isArray(options2)) {
    if (options2.length === 0)
      return "new String[0]";
    return `new String[] {${options2.map((s) => quote3(s)).join(", ")}}`;
  }
  return quote3(options2);
}
__name(formatSelectOption, "formatSelectOption");
function formatLaunchOptions(options2) {
  const lines = [];
  if (!Object.keys(options2).filter((key) => options2[key] !== void 0).length)
    return "";
  lines.push("new BrowserType.LaunchOptions()");
  if (options2.channel)
    lines.push(`  .setChannel(${quote3(options2.channel)})`);
  if (typeof options2.headless === "boolean")
    lines.push(`  .setHeadless(false)`);
  return lines.join("\n");
}
__name(formatLaunchOptions, "formatLaunchOptions");
function formatContextOptions3(contextOptions, deviceName) {
  const lines = [];
  if (!Object.keys(contextOptions).length && !deviceName)
    return "";
  const device = deviceName ? deviceDescriptors[deviceName] : {};
  const options2 = { ...device, ...contextOptions };
  lines.push("new Browser.NewContextOptions()");
  if (options2.acceptDownloads)
    lines.push(`  .setAcceptDownloads(true)`);
  if (options2.bypassCSP)
    lines.push(`  .setBypassCSP(true)`);
  if (options2.colorScheme)
    lines.push(`  .setColorScheme(ColorScheme.${options2.colorScheme.toUpperCase()})`);
  if (options2.deviceScaleFactor)
    lines.push(`  .setDeviceScaleFactor(${options2.deviceScaleFactor})`);
  if (options2.geolocation)
    lines.push(`  .setGeolocation(${options2.geolocation.latitude}, ${options2.geolocation.longitude})`);
  if (options2.hasTouch)
    lines.push(`  .setHasTouch(${options2.hasTouch})`);
  if (options2.isMobile)
    lines.push(`  .setIsMobile(${options2.isMobile})`);
  if (options2.locale)
    lines.push(`  .setLocale(${quote3(options2.locale)})`);
  if (options2.proxy)
    lines.push(`  .setProxy(new Proxy(${quote3(options2.proxy.server)}))`);
  if (options2.serviceWorkers)
    lines.push(`  .setServiceWorkers(ServiceWorkerPolicy.${options2.serviceWorkers.toUpperCase()})`);
  if (options2.storageState)
    lines.push(`  .setStorageStatePath(Paths.get(${quote3(options2.storageState)}))`);
  if (options2.timezoneId)
    lines.push(`  .setTimezoneId(${quote3(options2.timezoneId)})`);
  if (options2.userAgent)
    lines.push(`  .setUserAgent(${quote3(options2.userAgent)})`);
  if (options2.viewport)
    lines.push(`  .setViewportSize(${options2.viewport.width}, ${options2.viewport.height})`);
  return lines.join("\n");
}
__name(formatContextOptions3, "formatContextOptions");
function formatClickOptions(options2) {
  const lines = [];
  if (options2.button)
    lines.push(`  .setButton(MouseButton.${options2.button.toUpperCase()})`);
  if (options2.modifiers)
    lines.push(`  .setModifiers(Arrays.asList(${options2.modifiers.map((m) => `KeyboardModifier.${m.toUpperCase()}`).join(", ")}))`);
  if (options2.clickCount)
    lines.push(`  .setClickCount(${options2.clickCount})`);
  if (options2.position)
    lines.push(`  .setPosition(${options2.position.x}, ${options2.position.y})`);
  if (!lines.length)
    return "";
  lines.unshift(`new Locator.ClickOptions()`);
  return lines.join("\n");
}
__name(formatClickOptions, "formatClickOptions");
function quote3(text) {
  return escapeWithQuotes(text, '"');
}
__name(quote3, "quote");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/codegen/jsonl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var JsonlLanguageGenerator = class {
  static {
    __name(this, "JsonlLanguageGenerator");
  }
  constructor() {
    this.id = "jsonl";
    this.groupName = "";
    this.name = "JSONL";
    this.highlighter = "javascript";
  }
  generateAction(actionInContext) {
    const locator = actionInContext.action.selector ? JSON.parse(asLocator("jsonl", actionInContext.action.selector)) : void 0;
    const entry = {
      ...actionInContext.action,
      ...actionInContext.frame,
      locator
    };
    return JSON.stringify(entry);
  }
  generateHeader(options2) {
    return JSON.stringify(options2);
  }
  generateFooter(saveStorage) {
    return "";
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/codegen/python.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var PythonLanguageGenerator = class {
  static {
    __name(this, "PythonLanguageGenerator");
  }
  constructor(isAsync, isPyTest) {
    this.groupName = "Python";
    this.highlighter = "python";
    this.id = isPyTest ? "python-pytest" : isAsync ? "python-async" : "python";
    this.name = isPyTest ? "Pytest" : isAsync ? "Library Async" : "Library";
    this._isAsync = isAsync;
    this._isPyTest = isPyTest;
    this._awaitPrefix = isAsync ? "await " : "";
    this._asyncPrefix = isAsync ? "async " : "";
  }
  generateAction(actionInContext) {
    const action = actionInContext.action;
    if (this._isPyTest && (action.name === "openPage" || action.name === "closePage"))
      return "";
    const pageAlias = actionInContext.frame.pageAlias;
    const formatter = new PythonFormatter(4);
    if (action.name === "openPage") {
      formatter.add(`${pageAlias} = ${this._awaitPrefix}context.new_page()`);
      if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
        formatter.add(`${this._awaitPrefix}${pageAlias}.goto(${quote4(action.url)})`);
      return formatter.format();
    }
    const locators = actionInContext.frame.framePath.map((selector) => `.${this._asLocator(selector)}.content_frame`);
    const subject = `${pageAlias}${locators.join("")}`;
    const signals3 = toSignalMap(action);
    if (signals3.dialog)
      formatter.add(`  ${pageAlias}.once("dialog", lambda dialog: dialog.dismiss())`);
    let code = `${this._awaitPrefix}${this._generateActionCall(subject, actionInContext)}`;
    if (signals3.popup) {
      code = `${this._asyncPrefix}with ${pageAlias}.expect_popup() as ${signals3.popup.popupAlias}_info {
        ${code}
      }
      ${signals3.popup.popupAlias} = ${this._awaitPrefix}${signals3.popup.popupAlias}_info.value`;
    }
    if (signals3.download) {
      code = `${this._asyncPrefix}with ${pageAlias}.expect_download() as download${signals3.download.downloadAlias}_info {
        ${code}
      }
      download${signals3.download.downloadAlias} = ${this._awaitPrefix}download${signals3.download.downloadAlias}_info.value`;
    }
    formatter.add(code);
    return formatter.format();
  }
  _generateActionCall(subject, actionInContext) {
    const action = actionInContext.action;
    switch (action.name) {
      case "openPage":
        throw Error("Not reached");
      case "closePage":
        return `${subject}.close()`;
      case "click": {
        let method = "click";
        if (action.clickCount === 2)
          method = "dblclick";
        const options2 = toClickOptionsForSourceCode(action);
        const optionsString = formatOptions2(options2, false);
        return `${subject}.${this._asLocator(action.selector)}.${method}(${optionsString})`;
      }
      case "check":
        return `${subject}.${this._asLocator(action.selector)}.check()`;
      case "uncheck":
        return `${subject}.${this._asLocator(action.selector)}.uncheck()`;
      case "fill":
        return `${subject}.${this._asLocator(action.selector)}.fill(${quote4(action.text)})`;
      case "setInputFiles":
        return `${subject}.${this._asLocator(action.selector)}.set_input_files(${formatValue(action.files.length === 1 ? action.files[0] : action.files)})`;
      case "press": {
        const modifiers = toKeyboardModifiers(action.modifiers);
        const shortcut = [...modifiers, action.key].join("+");
        return `${subject}.${this._asLocator(action.selector)}.press(${quote4(shortcut)})`;
      }
      case "navigate":
        return `${subject}.goto(${quote4(action.url)})`;
      case "select":
        return `${subject}.${this._asLocator(action.selector)}.select_option(${formatValue(action.options.length === 1 ? action.options[0] : action.options)})`;
      case "assertText":
        return `expect(${subject}.${this._asLocator(action.selector)}).${action.substring ? "to_contain_text" : "to_have_text"}(${quote4(action.text)})`;
      case "assertChecked":
        return `expect(${subject}.${this._asLocator(action.selector)}).${action.checked ? "to_be_checked()" : "not_to_be_checked()"}`;
      case "assertVisible":
        return `expect(${subject}.${this._asLocator(action.selector)}).to_be_visible()`;
      case "assertValue": {
        const assertion = action.value ? `to_have_value(${quote4(action.value)})` : `to_be_empty()`;
        return `expect(${subject}.${this._asLocator(action.selector)}).${assertion};`;
      }
      case "assertSnapshot":
        return `expect(${subject}.${this._asLocator(action.selector)}).to_match_aria_snapshot(${quote4(action.snapshot)})`;
    }
  }
  _asLocator(selector) {
    return asLocator("python", selector);
  }
  generateHeader(options2) {
    const formatter = new PythonFormatter();
    const recordHar = options2.contextOptions.recordHar;
    if (this._isPyTest) {
      const contextOptions = formatContextOptions4(
        options2.contextOptions,
        options2.deviceName,
        true
        /* asDict */
      );
      const fixture = contextOptions ? `

@pytest.fixture(scope="session")
def browser_context_args(browser_context_args, playwright) {
    return {${contextOptions}}
}
` : "";
      formatter.add(`${options2.deviceName || contextOptions ? "import pytest\n" : ""}import re
from playwright.sync_api import Page, expect
${fixture}

def test_example(page: Page) -> None {`);
      if (recordHar)
        formatter.add(`    page.route_from_har(${quote4(recordHar.path)}${typeof recordHar.urlFilter === "string" ? `, url=${quote4(recordHar.urlFilter)}` : ""})`);
    } else if (this._isAsync) {
      formatter.add(`
import asyncio
import re
from playwright.async_api import Playwright, async_playwright, expect


async def run(playwright: Playwright) -> None {
    browser = await playwright.${options2.browserName}.launch(${formatOptions2(options2.launchOptions, false)})
    context = await browser.new_context(${formatContextOptions4(options2.contextOptions, options2.deviceName)})`);
      if (recordHar)
        formatter.add(`    await context.route_from_har(${quote4(recordHar.path)}${typeof recordHar.urlFilter === "string" ? `, url=${quote4(recordHar.urlFilter)}` : ""})`);
    } else {
      formatter.add(`
import re
from playwright.sync_api import Playwright, sync_playwright, expect


def run(playwright: Playwright) -> None {
    browser = playwright.${options2.browserName}.launch(${formatOptions2(options2.launchOptions, false)})
    context = browser.new_context(${formatContextOptions4(options2.contextOptions, options2.deviceName)})`);
      if (recordHar)
        formatter.add(`    context.route_from_har(${quote4(recordHar.path)}${typeof recordHar.urlFilter === "string" ? `, url=${quote4(recordHar.urlFilter)}` : ""})`);
    }
    return formatter.format();
  }
  generateFooter(saveStorage) {
    if (this._isPyTest) {
      return "";
    } else if (this._isAsync) {
      const storageStateLine = saveStorage ? `
    await context.storage_state(path=${quote4(saveStorage)})` : "";
      return `
    # ---------------------${storageStateLine}
    await context.close()
    await browser.close()


async def main() -> None:
    async with async_playwright() as playwright:
        await run(playwright)


asyncio.run(main())
`;
    } else {
      const storageStateLine = saveStorage ? `
    context.storage_state(path=${quote4(saveStorage)})` : "";
      return `
    # ---------------------${storageStateLine}
    context.close()
    browser.close()


with sync_playwright() as playwright:
    run(playwright)
`;
    }
  }
};
function formatValue(value) {
  if (value === false)
    return "False";
  if (value === true)
    return "True";
  if (value === void 0)
    return "None";
  if (Array.isArray(value))
    return `[${value.map(formatValue).join(", ")}]`;
  if (typeof value === "string")
    return quote4(value);
  if (typeof value === "object")
    return JSON.stringify(value);
  return String(value);
}
__name(formatValue, "formatValue");
function formatOptions2(value, hasArguments, asDict) {
  const keys = Object.keys(value).filter((key) => value[key] !== void 0).sort();
  if (!keys.length)
    return "";
  return (hasArguments ? ", " : "") + keys.map((key) => {
    if (asDict)
      return `"${toSnakeCase(key)}": ${formatValue(value[key])}`;
    return `${toSnakeCase(key)}=${formatValue(value[key])}`;
  }).join(", ");
}
__name(formatOptions2, "formatOptions");
function formatContextOptions4(options2, deviceName, asDict) {
  options2 = { ...options2, recordHar: void 0 };
  const device = deviceName && deviceDescriptors[deviceName];
  if (!device)
    return formatOptions2(options2, false, asDict);
  return `**playwright.devices[${quote4(deviceName)}]` + formatOptions2(sanitizeDeviceOptions(device, options2), true, asDict);
}
__name(formatContextOptions4, "formatContextOptions");
var PythonFormatter = class {
  static {
    __name(this, "PythonFormatter");
  }
  constructor(offset = 0) {
    this._lines = [];
    this._baseIndent = " ".repeat(4);
    this._baseOffset = " ".repeat(offset);
  }
  prepend(text) {
    this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
  }
  add(text) {
    this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
  }
  newLine() {
    this._lines.push("");
  }
  format() {
    let spaces = "";
    const lines = [];
    this._lines.forEach((line) => {
      if (line === "")
        return lines.push(line);
      if (line === "}") {
        spaces = spaces.substring(this._baseIndent.length);
        return;
      }
      line = spaces + line;
      if (line.endsWith("{")) {
        spaces += this._baseIndent;
        line = line.substring(0, line.length - 1).trimEnd() + ":";
      }
      return lines.push(this._baseOffset + line);
    });
    return lines.join("\n");
  }
};
function quote4(text) {
  return escapeWithQuotes(text, '"');
}
__name(quote4, "quote");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/codegen/languages.js
function languageSet() {
  return /* @__PURE__ */ new Set([
    new JavaLanguageGenerator("junit"),
    new JavaLanguageGenerator("library"),
    new JavaScriptLanguageGenerator(
      /* isPlaywrightTest */
      false
    ),
    new JavaScriptLanguageGenerator(
      /* isPlaywrightTest */
      true
    ),
    new PythonLanguageGenerator(
      /* isAsync */
      false,
      /* isPytest */
      true
    ),
    new PythonLanguageGenerator(
      /* isAsync */
      false,
      /* isPytest */
      false
    ),
    new PythonLanguageGenerator(
      /* isAsync */
      true,
      /* isPytest */
      false
    ),
    new CSharpLanguageGenerator("mstest"),
    new CSharpLanguageGenerator("nunit"),
    new CSharpLanguageGenerator("library"),
    new JsonlLanguageGenerator()
  ]);
}
__name(languageSet, "languageSet");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/throttledFile.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ThrottledFile = class {
  static {
    __name(this, "ThrottledFile");
  }
  constructor(file) {
    this._file = file;
  }
  setContent(text) {
    this._text = text;
    if (!this._timer)
      this._timer = setTimeout(() => this.flush(), 250);
  }
  flush() {
    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = void 0;
    }
    if (this._text)
      fs.writeFileSync(this._file, this._text);
    this._text = void 0;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/contextRecorder.js
var ContextRecorder = class _ContextRecorder extends EventEmitter9 {
  static {
    __name(this, "ContextRecorder");
  }
  constructor(context2, params, delegate) {
    super();
    this._pageAliases = /* @__PURE__ */ new Map();
    this._lastPopupOrdinal = 0;
    this._lastDialogOrdinal = -1;
    this._lastDownloadOrdinal = -1;
    this._throttledOutputFile = null;
    this._orderedLanguages = [];
    this._listeners = [];
    this._context = context2;
    this._params = params;
    this._delegate = delegate;
    this._recorderSources = [];
    const language = params.language || context2.attribution.playwright.options.sdkLanguage;
    this.setOutput(language, params.outputFile);
    const languageGeneratorOptions = {
      browserName: context2._browser.options.name,
      launchOptions: { headless: false, ...params.launchOptions, tracesDir: void 0 },
      contextOptions: { ...params.contextOptions },
      deviceName: params.device,
      saveStorage: params.saveStorage
    };
    this._collection = new RecorderCollection(this._pageAliases);
    this._collection.on("change", (actions) => {
      this._recorderSources = [];
      for (const languageGenerator of this._orderedLanguages) {
        const { header, footer, actionTexts, text } = generateCode(actions, languageGenerator, languageGeneratorOptions);
        const source7 = {
          isRecorded: true,
          label: languageGenerator.name,
          group: languageGenerator.groupName,
          id: languageGenerator.id,
          text,
          header,
          footer,
          actions: actionTexts,
          language: languageGenerator.highlighter,
          highlight: []
        };
        source7.revealLine = text.split("\n").length - 1;
        this._recorderSources.push(source7);
        if (languageGenerator === this._orderedLanguages[0])
          this._throttledOutputFile?.setContent(source7.text);
      }
      this.emit(_ContextRecorder.Events.Change, {
        sources: this._recorderSources,
        actions
      });
    });
    context2.on(BrowserContext.Events.BeforeClose, () => {
      this._throttledOutputFile?.flush();
    });
    this._listeners.push(eventsHelper.addEventListener(process, "exit", () => {
      this._throttledOutputFile?.flush();
    }));
    this.setEnabled(params.mode === "recording");
  }
  static {
    this.Events = {
      Change: "change"
    };
  }
  setOutput(codegenId, outputFile) {
    const languages = languageSet();
    const primaryLanguage = [...languages].find((l) => l.id === codegenId);
    if (!primaryLanguage)
      throw new Error(`
===============================
Unsupported language: '${codegenId}'
===============================
`);
    languages.delete(primaryLanguage);
    this._orderedLanguages = [primaryLanguage, ...languages];
    this._throttledOutputFile = outputFile ? new ThrottledFile(outputFile) : null;
    this._collection?.restart();
  }
  languageName(id) {
    for (const lang of this._orderedLanguages) {
      if (!id || lang.id === id)
        return lang.highlighter;
    }
    return "javascript";
  }
  async install() {
    this._context.on(BrowserContext.Events.Page, (page) => this._onPage(page));
    for (const page of this._context.pages())
      this._onPage(page);
    this._context.on(BrowserContext.Events.Dialog, (dialog) => this._onDialog(dialog.page()));
    await this._context.exposeBinding(
      "__pw_recorderPerformAction",
      false,
      (source7, action) => this._performAction(source7.frame, action)
    );
    await this._context.exposeBinding(
      "__pw_recorderRecordAction",
      false,
      (source7, action) => this._recordAction(source7.frame, action)
    );
    await this._context.extendInjectedScript(source5);
  }
  setEnabled(enabled) {
    this._collection.setEnabled(enabled);
  }
  dispose() {
    eventsHelper.removeEventListeners(this._listeners);
  }
  async _onPage(page) {
    const frame = page.mainFrame();
    page.on("close", () => {
      this._collection.addRecordedAction({
        frame: this._describeMainFrame(page),
        action: {
          name: "closePage",
          signals: []
        },
        startTime: monotonicTime()
      });
      this._pageAliases.delete(page);
    });
    frame.on(Frame.Events.InternalNavigation, (event) => {
      if (event.isPublic)
        this._onFrameNavigated(frame, page);
    });
    page.on(Page.Events.Download, () => this._onDownload(page));
    const suffix = this._pageAliases.size ? String(++this._lastPopupOrdinal) : "";
    const pageAlias = "page" + suffix;
    this._pageAliases.set(page, pageAlias);
    if (page.opener()) {
      this._onPopup(page.opener(), page);
    } else {
      this._collection.addRecordedAction({
        frame: this._describeMainFrame(page),
        action: {
          name: "openPage",
          url: page.mainFrame().url(),
          signals: []
        },
        startTime: monotonicTime()
      });
    }
  }
  clearScript() {
    this._collection.restart();
    if (this._params.mode === "recording") {
      for (const page of this._context.pages())
        this._onFrameNavigated(page.mainFrame(), page);
    }
  }
  runTask(task) {
  }
  _describeMainFrame(page) {
    return {
      pageAlias: this._pageAliases.get(page),
      framePath: []
    };
  }
  async _describeFrame(frame) {
    return {
      pageAlias: this._pageAliases.get(frame._page),
      framePath: await generateFrameSelector(frame)
    };
  }
  testIdAttributeName() {
    return this._params.testIdAttributeName || this._context.selectors().testIdAttributeName() || "data-testid";
  }
  async _createActionInContext(frame, action) {
    const frameDescription = await this._describeFrame(frame);
    const actionInContext = {
      frame: frameDescription,
      action,
      description: void 0,
      startTime: monotonicTime()
    };
    await this._delegate.rewriteActionInContext?.(this._pageAliases, actionInContext);
    return actionInContext;
  }
  async _performAction(frame, action) {
    await this._collection.performAction(await this._createActionInContext(frame, action));
  }
  async _recordAction(frame, action) {
    this._collection.addRecordedAction(await this._createActionInContext(frame, action));
  }
  _onFrameNavigated(frame, page) {
    const pageAlias = this._pageAliases.get(page);
    this._collection.signal(pageAlias, frame, { name: "navigation", url: frame.url() });
  }
  _onPopup(page, popup) {
    const pageAlias = this._pageAliases.get(page);
    const popupAlias = this._pageAliases.get(popup);
    this._collection.signal(pageAlias, page.mainFrame(), { name: "popup", popupAlias });
  }
  _onDownload(page) {
    const pageAlias = this._pageAliases.get(page);
    ++this._lastDownloadOrdinal;
    this._collection.signal(pageAlias, page.mainFrame(), { name: "download", downloadAlias: this._lastDownloadOrdinal ? String(this._lastDownloadOrdinal) : "" });
  }
  _onDialog(page) {
    const pageAlias = this._pageAliases.get(page);
    ++this._lastDialogOrdinal;
    this._collection.signal(pageAlias, page.mainFrame(), { name: "dialog", dialogAlias: this._lastDialogOrdinal ? String(this._lastDialogOrdinal) : "" });
  }
};
async function generateFrameSelector(frame) {
  const selectorPromises = [];
  while (frame) {
    const parent = frame.parentFrame();
    if (!parent)
      break;
    selectorPromises.push(generateFrameSelectorInParent(parent, frame));
    frame = parent;
  }
  const result = await Promise.all(selectorPromises);
  return result.reverse();
}
__name(generateFrameSelector, "generateFrameSelector");
async function generateFrameSelectorInParent(parent, frame) {
  const result = await raceAgainstDeadline(async () => {
    try {
      const frameElement = await frame.frameElement();
      if (!frameElement || !parent)
        return;
      const utility = await parent._utilityContext();
      const injected = await utility.injectedScript();
      const selector = await injected.evaluate((injected2, element) => {
        return injected2.generateSelectorSimple(element);
      }, frameElement);
      return selector;
    } catch (e) {
    }
  }, monotonicTime() + 2e3);
  if (!result.timedOut && result.result)
    return result.result;
  if (frame.name())
    return `iframe[name=${quoteCSSAttributeValue(frame.name())}]`;
  return `iframe[src=${quoteCSSAttributeValue(frame.url())}]`;
}
__name(generateFrameSelectorInParent, "generateFrameSelectorInParent");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/locatorParser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseLocator(locator, testIdAttributeName2) {
  locator = locator.replace(/AriaRole\s*\.\s*([\w]+)/g, (_, group3) => group3.toLowerCase()).replace(/(get_by_role|getByRole)\s*\(\s*(?:["'`])([^'"`]+)['"`]/g, (_, group1, group22) => `${group1}(${group22.toLowerCase()}`);
  const params = [];
  let template = "";
  for (let i = 0; i < locator.length; ++i) {
    const quote5 = locator[i];
    if (quote5 !== '"' && quote5 !== "'" && quote5 !== "`" && quote5 !== "/") {
      template += quote5;
      continue;
    }
    const isRegexEscaping = locator[i - 1] === "r" || locator[i] === "/";
    ++i;
    let text = "";
    while (i < locator.length) {
      if (locator[i] === "\\") {
        if (isRegexEscaping) {
          if (locator[i + 1] !== quote5)
            text += locator[i];
          ++i;
          text += locator[i];
        } else {
          ++i;
          if (locator[i] === "n")
            text += "\n";
          else if (locator[i] === "r")
            text += "\r";
          else if (locator[i] === "t")
            text += "	";
          else
            text += locator[i];
        }
        ++i;
        continue;
      }
      if (locator[i] !== quote5) {
        text += locator[i++];
        continue;
      }
      break;
    }
    params.push({ quote: quote5, text });
    template += (quote5 === "/" ? "r" : "") + "$" + params.length;
  }
  template = template.toLowerCase().replace(/get_by_alt_text/g, "getbyalttext").replace(/get_by_test_id/g, "getbytestid").replace(/get_by_([\w]+)/g, "getby$1").replace(/has_not_text/g, "hasnottext").replace(/has_text/g, "hastext").replace(/has_not/g, "hasnot").replace(/frame_locator/g, "framelocator").replace(/content_frame/g, "contentframe").replace(/[{}\s]/g, "").replace(/new\(\)/g, "").replace(/new[\w]+\.[\w]+options\(\)/g, "").replace(/\.set/g, ",set").replace(/\.or_\(/g, "or(").replace(/\.and_\(/g, "and(").replace(/:/g, "=").replace(/,re\.ignorecase/g, "i").replace(/,pattern.case_insensitive/g, "i").replace(/,regexoptions.ignorecase/g, "i").replace(/re.compile\(([^)]+)\)/g, "$1").replace(/pattern.compile\(([^)]+)\)/g, "r$1").replace(/newregex\(([^)]+)\)/g, "r$1").replace(/string=/g, "=").replace(/regex=/g, "=").replace(/,,/g, ",").replace(/,\)/g, ")");
  const preferredQuote = params.map((p) => p.quote).filter((quote5) => "'\"`".includes(quote5))[0];
  return { selector: transform(template, params, testIdAttributeName2), preferredQuote };
}
__name(parseLocator, "parseLocator");
function countParams(template) {
  return [...template.matchAll(/\$\d+/g)].length;
}
__name(countParams, "countParams");
function shiftParams(template, sub) {
  return template.replace(/\$(\d+)/g, (_, ordinal) => `$${ordinal - sub}`);
}
__name(shiftParams, "shiftParams");
function transform(template, params, testIdAttributeName2) {
  while (true) {
    const hasMatch = template.match(/filter\(,?(has=|hasnot=|sethas\(|sethasnot\()/);
    if (!hasMatch)
      break;
    const start = hasMatch.index + hasMatch[0].length;
    let balance = 0;
    let end = start;
    for (; end < template.length; end++) {
      if (template[end] === "(")
        balance++;
      else if (template[end] === ")")
        balance--;
      if (balance < 0)
        break;
    }
    let prefix = template.substring(0, start);
    let extraSymbol = 0;
    if (["sethas(", "sethasnot("].includes(hasMatch[1])) {
      extraSymbol = 1;
      prefix = prefix.replace(/sethas\($/, "has=").replace(/sethasnot\($/, "hasnot=");
    }
    const paramsCountBeforeHas = countParams(template.substring(0, start));
    const hasTemplate = shiftParams(template.substring(start, end), paramsCountBeforeHas);
    const paramsCountInHas = countParams(hasTemplate);
    const hasParams = params.slice(paramsCountBeforeHas, paramsCountBeforeHas + paramsCountInHas);
    const hasSelector = JSON.stringify(transform(hasTemplate, hasParams, testIdAttributeName2));
    template = prefix.replace(/=$/, "2=") + `$${paramsCountBeforeHas + 1}` + shiftParams(template.substring(end + extraSymbol), paramsCountInHas - 1);
    const paramsBeforeHas = params.slice(0, paramsCountBeforeHas);
    const paramsAfterHas = params.slice(paramsCountBeforeHas + paramsCountInHas);
    params = paramsBeforeHas.concat([{ quote: '"', text: hasSelector }]).concat(paramsAfterHas);
  }
  template = template.replace(/\,set([\w]+)\(([^)]+)\)/g, (_, group1, group22) => "," + group1.toLowerCase() + "=" + group22.toLowerCase()).replace(/framelocator\(([^)]+)\)/g, "$1.internal:control=enter-frame").replace(/contentframe(\(\))?/g, "internal:control=enter-frame").replace(/locator\(([^)]+),hastext=([^),]+)\)/g, "locator($1).internal:has-text=$2").replace(/locator\(([^)]+),hasnottext=([^),]+)\)/g, "locator($1).internal:has-not-text=$2").replace(/locator\(([^)]+),hastext=([^),]+)\)/g, "locator($1).internal:has-text=$2").replace(/locator\(([^)]+)\)/g, "$1").replace(/getbyrole\(([^)]+)\)/g, "internal:role=$1").replace(/getbytext\(([^)]+)\)/g, "internal:text=$1").replace(/getbylabel\(([^)]+)\)/g, "internal:label=$1").replace(/getbytestid\(([^)]+)\)/g, `internal:testid=[${testIdAttributeName2}=$1]`).replace(/getby(placeholder|alt|title)(?:text)?\(([^)]+)\)/g, "internal:attr=[$1=$2]").replace(/first(\(\))?/g, "nth=0").replace(/last(\(\))?/g, "nth=-1").replace(/nth\(([^)]+)\)/g, "nth=$1").replace(/filter\(,?visible=true\)/g, "visible=true").replace(/filter\(,?visible=false\)/g, "visible=false").replace(/filter\(,?hastext=([^)]+)\)/g, "internal:has-text=$1").replace(/filter\(,?hasnottext=([^)]+)\)/g, "internal:has-not-text=$1").replace(/filter\(,?has2=([^)]+)\)/g, "internal:has=$1").replace(/filter\(,?hasnot2=([^)]+)\)/g, "internal:has-not=$1").replace(/,exact=false/g, "").replace(/,exact=true/g, "s").replace(/,includehidden=/g, ",include-hidden=").replace(/\,/g, "][");
  const parts = template.split(".");
  for (let index2 = 0; index2 < parts.length - 1; index2++) {
    if (parts[index2] === "internal:control=enter-frame" && parts[index2 + 1].startsWith("nth=")) {
      const [nth] = parts.splice(index2, 1);
      parts.splice(index2 + 1, 0, nth);
    }
  }
  return parts.map((t) => {
    if (!t.startsWith("internal:") || t === "internal:control")
      return t.replace(/\$(\d+)/g, (_, ordinal) => {
        const param = params[+ordinal - 1];
        return param.text;
      });
    t = t.includes("[") ? t.replace(/\]/, "") + "]" : t;
    t = t.replace(/(?:r)\$(\d+)(i)?/g, (_, ordinal, suffix) => {
      const param = params[+ordinal - 1];
      if (t.startsWith("internal:attr") || t.startsWith("internal:testid") || t.startsWith("internal:role"))
        return escapeForAttributeSelector(new RegExp(param.text), false) + (suffix || "");
      return escapeForTextSelector(new RegExp(param.text, suffix), false);
    }).replace(/\$(\d+)(i|s)?/g, (_, ordinal, suffix) => {
      const param = params[+ordinal - 1];
      if (t.startsWith("internal:has=") || t.startsWith("internal:has-not="))
        return param.text;
      if (t.startsWith("internal:testid"))
        return escapeForAttributeSelector(param.text, true);
      if (t.startsWith("internal:attr") || t.startsWith("internal:role"))
        return escapeForAttributeSelector(param.text, suffix === "s");
      return escapeForTextSelector(param.text, suffix === "s");
    });
    return t;
  }).join(" >> ");
}
__name(transform, "transform");
function locatorOrSelectorAsSelector(language, locator, testIdAttributeName2) {
  try {
    return unsafeLocatorOrSelectorAsSelector(language, locator, testIdAttributeName2);
  } catch (e) {
    return "";
  }
}
__name(locatorOrSelectorAsSelector, "locatorOrSelectorAsSelector");
function unsafeLocatorOrSelectorAsSelector(language, locator, testIdAttributeName2) {
  try {
    parseSelector(locator);
    return locator;
  } catch (e) {
  }
  const { selector, preferredQuote } = parseLocator(locator, testIdAttributeName2);
  const locators = asLocators(language, selector, void 0, void 0, preferredQuote);
  const digest = digestForComparison(language, locator);
  if (locators.some((candidate) => digestForComparison(language, candidate) === digest))
    return selector;
  return "";
}
__name(unsafeLocatorOrSelectorAsSelector, "unsafeLocatorOrSelectorAsSelector");
function digestForComparison(language, locator) {
  locator = locator.replace(/\s/g, "");
  if (language === "javascript")
    locator = locator.replace(/\\?["`]/g, "'").replace(/,{}/g, "");
  return locator;
}
__name(digestForComparison, "digestForComparison");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder.js
var recorderSymbol = Symbol("recorderSymbol");
var Recorder = class _Recorder {
  static {
    __name(this, "Recorder");
  }
  constructor(context2, params) {
    this._highlightedElement = {};
    this._overlayState = { offsetX: 0 };
    this._recorderApp = null;
    this._currentCallsMetadata = /* @__PURE__ */ new Map();
    this._recorderSources = [];
    this._userSources = /* @__PURE__ */ new Map();
    this._omitCallTracking = false;
    this._mode = params.mode || "none";
    this.handleSIGINT = params.handleSIGINT;
    this._contextRecorder = new ContextRecorder(context2, params, {});
    this._context = context2;
    this._omitCallTracking = !!params.omitCallTracking;
    this._debugger = context2.debugger();
    context2.instrumentation.addListener(this, context2);
    this._currentLanguage = this._contextRecorder.languageName();
    if (isUnderTest()) {
      this._overlayState.offsetX = 200;
    }
  }
  static async showInspector(context2, params, recorderAppFactory) {
    if (isUnderTest())
      params.language = process.env.TEST_INSPECTOR_LANGUAGE;
    return await _Recorder.show(context2, recorderAppFactory, params);
  }
  static showInspectorNoReply(context2, recorderAppFactory) {
    _Recorder.showInspector(context2, {}, recorderAppFactory).catch(() => {
    });
  }
  static show(context2, recorderAppFactory, params) {
    let recorderPromise = context2[recorderSymbol];
    if (!recorderPromise) {
      recorderPromise = _Recorder._create(context2, recorderAppFactory, params);
      context2[recorderSymbol] = recorderPromise;
    }
    return recorderPromise;
  }
  static async _create(context2, recorderAppFactory, params = {}) {
    const recorder = new _Recorder(context2, params);
    const recorderApp = await recorderAppFactory(recorder);
    await recorder._install(recorderApp);
    return recorder;
  }
  async _install(recorderApp) {
    this._recorderApp = recorderApp;
    recorderApp.once("close", () => {
      this._debugger.resume(false);
      this._recorderApp = null;
    });
    recorderApp.on("event", (data) => {
      if (data.event === "setMode") {
        this.setMode(data.params.mode);
        return;
      }
      if (data.event === "highlightRequested") {
        if (data.params.selector)
          this.setHighlightedSelector(this._currentLanguage, data.params.selector);
        if (data.params.ariaTemplate)
          this.setHighlightedAriaTemplate(data.params.ariaTemplate);
        return;
      }
      if (data.event === "step") {
        this._debugger.resume(true);
        return;
      }
      if (data.event === "fileChanged") {
        this._currentLanguage = this._contextRecorder.languageName(data.params.file);
        this._refreshOverlay();
        return;
      }
      if (data.event === "resume") {
        this._debugger.resume(false);
        return;
      }
      if (data.event === "pause") {
        this._debugger.pauseOnNextStatement();
        return;
      }
      if (data.event === "clear") {
        this._contextRecorder.clearScript();
        return;
      }
      if (data.event === "runTask") {
        this._contextRecorder.runTask(data.params.task);
        return;
      }
    });
    await Promise.all([
      recorderApp.setMode(this._mode),
      recorderApp.setPaused(this._debugger.isPaused()),
      this._pushAllSources()
    ]);
    this._context.once(BrowserContext.Events.Close, () => {
      this._contextRecorder.dispose();
      this._context.instrumentation.removeListener(this);
      this._recorderApp?.close().catch(() => {
      });
    });
    this._contextRecorder.on(ContextRecorder.Events.Change, (data) => {
      this._recorderSources = data.sources;
      recorderApp.setActions(data.actions, data.sources);
      recorderApp.setRunningFile(void 0);
      this._pushAllSources();
    });
    await this._context.exposeBinding("__pw_recorderState", false, async (source7) => {
      let actionSelector;
      let actionPoint;
      const hasActiveScreenshotCommand = [...this._currentCallsMetadata.keys()].some(isScreenshotCommand);
      if (!hasActiveScreenshotCommand) {
        actionSelector = await this._scopeHighlightedSelectorToFrame(source7.frame);
        for (const [metadata, sdkObject] of this._currentCallsMetadata) {
          if (source7.page === sdkObject.attribution.page) {
            actionPoint = metadata.point || actionPoint;
            actionSelector = actionSelector || metadata.params.selector;
          }
        }
      }
      const uiState = {
        mode: this._mode,
        actionPoint,
        actionSelector,
        ariaTemplate: this._highlightedElement.ariaTemplate,
        language: this._currentLanguage,
        testIdAttributeName: this._contextRecorder.testIdAttributeName(),
        overlay: this._overlayState
      };
      return uiState;
    });
    await this._context.exposeBinding("__pw_recorderElementPicked", false, async ({ frame }, elementInfo) => {
      const selectorChain = await generateFrameSelector(frame);
      await this._recorderApp?.elementPicked({ selector: buildFullSelector(selectorChain, elementInfo.selector), ariaSnapshot: elementInfo.ariaSnapshot }, true);
    });
    await this._context.exposeBinding("__pw_recorderSetMode", false, async ({ frame }, mode) => {
      if (frame.parentFrame())
        return;
      this.setMode(mode);
    });
    await this._context.exposeBinding("__pw_recorderSetOverlayState", false, async ({ frame }, state) => {
      if (frame.parentFrame())
        return;
      this._overlayState = state;
    });
    await this._context.exposeBinding("__pw_resume", false, () => {
      this._debugger.resume(false);
    });
    await this._contextRecorder.install();
    if (this._debugger.isPaused())
      this._pausedStateChanged();
    this._debugger.on(Debugger.Events.PausedStateChanged, () => this._pausedStateChanged());
    this._context.recorderAppForTest = this._recorderApp;
  }
  _pausedStateChanged() {
    for (const { metadata, sdkObject } of this._debugger.pausedDetails()) {
      if (!this._currentCallsMetadata.has(metadata))
        this.onBeforeCall(sdkObject, metadata);
    }
    this._recorderApp?.setPaused(this._debugger.isPaused());
    this._updateUserSources();
    this.updateCallLog([...this._currentCallsMetadata.keys()]);
  }
  setMode(mode) {
    if (this._mode === mode)
      return;
    this._highlightedElement = {};
    this._mode = mode;
    this._recorderApp?.setMode(this._mode);
    this._contextRecorder.setEnabled(this._isRecording());
    this._debugger.setMuted(this._isRecording());
    if (this._mode !== "none" && this._mode !== "standby" && this._context.pages().length === 1)
      this._context.pages()[0].bringToFront().catch(() => {
      });
    this._refreshOverlay();
  }
  resume() {
    this._debugger.resume(false);
  }
  mode() {
    return this._mode;
  }
  setHighlightedSelector(language, selector) {
    this._highlightedElement = { selector: locatorOrSelectorAsSelector(language, selector, this._context.selectors().testIdAttributeName()) };
    this._refreshOverlay();
  }
  setHighlightedAriaTemplate(ariaTemplate) {
    this._highlightedElement = { ariaTemplate };
    this._refreshOverlay();
  }
  hideHighlightedSelector() {
    this._highlightedElement = {};
    this._refreshOverlay();
  }
  async _scopeHighlightedSelectorToFrame(frame) {
    if (!this._highlightedElement.selector)
      return;
    try {
      const mainFrame = frame._page.mainFrame();
      const resolved = await mainFrame.selectors.resolveFrameForSelector(this._highlightedElement.selector);
      if (!resolved)
        return "";
      if (resolved?.frame === mainFrame)
        return stringifySelector(resolved.info.parsed);
      if (resolved?.frame === frame)
        return stringifySelector(resolved.info.parsed);
      return "";
    } catch {
      return "";
    }
  }
  setOutput(codegenId, outputFile) {
    this._contextRecorder.setOutput(codegenId, outputFile);
  }
  _refreshOverlay() {
    for (const page of this._context.pages()) {
      for (const frame of page.frames())
        frame.evaluateExpression("window.__pw_refreshOverlay()").catch(() => {
        });
    }
  }
  async onBeforeCall(sdkObject, metadata) {
    if (this._omitCallTracking || this._isRecording())
      return;
    this._currentCallsMetadata.set(metadata, sdkObject);
    this._updateUserSources();
    this.updateCallLog([metadata]);
    if (isScreenshotCommand(metadata))
      this.hideHighlightedSelector();
    else if (metadata.params && metadata.params.selector)
      this._highlightedElement = { selector: metadata.params.selector };
  }
  async onAfterCall(sdkObject, metadata) {
    if (this._omitCallTracking || this._isRecording())
      return;
    if (!metadata.error)
      this._currentCallsMetadata.delete(metadata);
    this._updateUserSources();
    this.updateCallLog([metadata]);
  }
  _updateUserSources() {
    for (const source7 of this._userSources.values()) {
      source7.highlight = [];
      source7.revealLine = void 0;
    }
    let fileToSelect = void 0;
    for (const metadata of this._currentCallsMetadata.keys()) {
      if (!metadata.location)
        continue;
      const { file, line } = metadata.location;
      let source7 = this._userSources.get(file);
      if (!source7) {
        source7 = { isRecorded: false, label: file, id: file, text: this._readSource(file), highlight: [], language: languageForFile(file) };
        this._userSources.set(file, source7);
      }
      if (line) {
        const paused = this._debugger.isPaused(metadata);
        source7.highlight.push({ line, type: metadata.error ? "error" : paused ? "paused" : "running" });
        source7.revealLine = line;
        fileToSelect = source7.id;
      }
    }
    this._pushAllSources();
    if (fileToSelect)
      this._recorderApp?.setRunningFile(fileToSelect);
  }
  _pushAllSources() {
    const primaryPage = this._context.pages()[0];
    this._recorderApp?.setSources([...this._recorderSources, ...this._userSources.values()], primaryPage?.mainFrame().url());
  }
  async onBeforeInputAction(sdkObject, metadata) {
  }
  async onCallLog(sdkObject, metadata, logName, message) {
    this.updateCallLog([metadata]);
  }
  updateCallLog(metadatas) {
    if (this._isRecording())
      return;
    const logs = [];
    for (const metadata of metadatas) {
      if (!metadata.method || metadata.internal)
        continue;
      let status = "done";
      if (this._currentCallsMetadata.has(metadata))
        status = "in-progress";
      if (this._debugger.isPaused(metadata))
        status = "paused";
      logs.push(metadataToCallLog(metadata, status));
    }
    this._recorderApp?.updateCallLogs(logs);
  }
  _isRecording() {
    return ["recording", "assertingText", "assertingVisibility", "assertingValue", "assertingSnapshot"].includes(this._mode);
  }
  _readSource(fileName) {
    try {
      return fs.readFileSync(fileName, "utf-8");
    } catch (e) {
      return "// No source available";
    }
  }
};
function isScreenshotCommand(metadata) {
  return metadata.method.toLowerCase().includes("screenshot");
}
__name(isScreenshotCommand, "isScreenshotCommand");
function languageForFile(file) {
  if (file.endsWith(".py"))
    return "python";
  if (file.endsWith(".java"))
    return "java";
  if (file.endsWith(".cs"))
    return "csharp";
  return "javascript";
}
__name(languageForFile, "languageForFile");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/recorderApp.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/_virtual/empty.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/mocks/empty.js
var empty_exports = {};
__export(empty_exports, {
  default: () => empty
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var empty = {};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/_virtual/empty.js
var require$$06 = /* @__PURE__ */ getAugmentedNamespace2(empty_exports);

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/recorderApp.js
import { EventEmitter as EventEmitter10 } from "node:events";
import path13 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/launchApp.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path12 from "node:path";
import "node:url";
async function launchApp(browserType, options2) {
  const args = [...options2.persistentContextOptions?.args ?? []];
  let channel2 = options2.persistentContextOptions?.channel;
  if (browserType.name() === "chromium") {
    args.push(
      "--app=data:text/html,",
      `--window-size=${options2.windowSize.width},${options2.windowSize.height}`,
      ...options2.windowPosition ? [`--window-position=${options2.windowPosition.x},${options2.windowPosition.y}`] : [],
      "--test-type="
    );
    if (!channel2 && !options2.persistentContextOptions?.executablePath)
      channel2 = findChromiumChannel(options2.sdkLanguage);
  }
  const context2 = await browserType.launchPersistentContext(serverSideCallMetadata(), "", {
    ignoreDefaultArgs: ["--enable-automation"],
    ...options2?.persistentContextOptions,
    channel: channel2,
    noDefaultViewport: options2.persistentContextOptions?.noDefaultViewport ?? true,
    acceptDownloads: options2?.persistentContextOptions?.acceptDownloads ?? (isUnderTest() ? "accept" : "internal-browser-default"),
    colorScheme: options2?.persistentContextOptions?.colorScheme ?? "no-override",
    args
  });
  const [page] = context2.pages();
  if (browserType.name() === "chromium" && process.platform === "darwin") {
    context2.on("page", async (newPage) => {
      if (newPage.mainFrame().url() === "chrome://new-tab-page/") {
        await page.bringToFront();
        await newPage.close(serverSideCallMetadata());
      }
    });
  }
  if (browserType.name() === "chromium")
    await installAppIcon(page);
  return { context: context2, page };
}
__name(launchApp, "launchApp");
async function installAppIcon(page) {
  const icon = await fs.promises.readFile(__require.resolve("./chromium/appIcon.png"));
  const crPage = page._delegate;
  await crPage._mainFrameSession._client.send("Browser.setDockTile", {
    image: icon.toString("base64")
  });
}
__name(installAppIcon, "installAppIcon");
async function syncLocalStorageWithSettings(page, appName) {
  if (isUnderTest())
    return;
  const settingsFile = path12.join(registryDirectory, ".settings", `${appName}.json`);
  await page.exposeBinding("_saveSerializedSettings", false, (_, settings2) => {
    fs.mkdirSync(path12.dirname(settingsFile), { recursive: true });
    fs.writeFileSync(settingsFile, settings2);
  });
  const settings = await fs.promises.readFile(settingsFile, "utf-8").catch(() => "{}");
  await page.addInitScript(
    `(${String((settings2) => {
      if (location && location.protocol === "data:")
        return;
      if (window.top !== window)
        return;
      Object.entries(settings2).map(([k, v]) => localStorage[k] = v);
      window.saveSettings = () => {
        window._saveSerializedSettings(JSON.stringify({ ...localStorage }));
      };
    })})(${settings});
  `
  );
}
__name(syncLocalStorageWithSettings, "syncLocalStorageWithSettings");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/recorder/recorderApp.js
var EmptyRecorderApp = class extends EventEmitter10 {
  static {
    __name(this, "EmptyRecorderApp");
  }
  async close() {
  }
  async setPaused(paused) {
  }
  async setMode(mode) {
  }
  async setRunningFile(file) {
  }
  async elementPicked(elementInfo, userGesture) {
  }
  async updateCallLogs(callLogs) {
  }
  async setSources(sources, primaryPageURL) {
  }
  async setActions(actions, sources) {
  }
};
var RecorderApp = class _RecorderApp extends EventEmitter10 {
  static {
    __name(this, "RecorderApp");
  }
  constructor(recorder, page, wsEndpoint) {
    super();
    this.setMaxListeners(0);
    this._recorder = recorder;
    this._page = page;
    this.wsEndpointForTest = wsEndpoint;
  }
  async close() {
    await this._page.context().close({ reason: "Recorder window closed" });
  }
  async _init() {
    await syncLocalStorageWithSettings(this._page, "recorder");
    await this._page._setServerRequestInterceptor((route) => {
      if (!route.request().url().startsWith("https://playwright/"))
        return false;
      const uri = route.request().url().substring("https://playwright/".length);
      const file = __require.resolve("../../vite/recorder/" + uri);
      fs.promises.readFile(file).then((buffer2) => {
        route.fulfill({
          status: 200,
          headers: [
            { name: "Content-Type", value: mime2.getType(path13.extname(file)) || "application/octet-stream" }
          ],
          body: buffer2.toString("base64"),
          isBase64: true
        }).catch(() => {
        });
      });
      return true;
    });
    await this._page.exposeBinding("dispatch", false, (_, data) => this.emit("event", data));
    this._page.once("close", () => {
      this.emit("close");
      this._page.context().close({ reason: "Recorder window closed" }).catch(() => {
      });
    });
    const mainFrame = this._page.mainFrame();
    await mainFrame.goto(serverSideCallMetadata(), process.env.PW_HMR ? "http://localhost:44225" : "https://playwright/index.html");
  }
  static factory(context2) {
    return async (recorder) => {
      if (process.env.PW_CODEGEN_NO_INSPECTOR)
        return new EmptyRecorderApp();
      return await _RecorderApp._open(recorder, context2);
    };
  }
  static async _open(recorder, inspectedContext) {
    const sdkLanguage = inspectedContext.attribution.playwright.options.sdkLanguage;
    const headed = !!inspectedContext._browser.options.headful;
    const recorderPlaywright = require$$06.createPlaywright({ sdkLanguage: "javascript", isInternalPlaywright: true });
    const { context: context2, page } = await launchApp(recorderPlaywright.chromium, {
      sdkLanguage,
      windowSize: { width: 600, height: 600 },
      windowPosition: { x: 1020, y: 10 },
      persistentContextOptions: {
        noDefaultViewport: true,
        headless: !!process.env.PWTEST_CLI_HEADLESS || isUnderTest() && !headed,
        useWebSocket: isUnderTest(),
        handleSIGINT: recorder.handleSIGINT,
        executablePath: inspectedContext._browser.options.isChromium ? inspectedContext._browser.options.customExecutablePath : void 0,
        // Use the same channel as the inspected context to guarantee that the browser is installed.
        channel: inspectedContext._browser.options.isChromium ? inspectedContext._browser.options.channel : void 0
      }
    });
    const controller = new ProgressController(serverSideCallMetadata(), context2._browser);
    await controller.run(async (progress3) => {
      await context2._browser._defaultContext._loadDefaultContextAsIs(progress3);
    });
    const result = new _RecorderApp(recorder, page, context2._browser.options.wsEndpoint);
    await result._init();
    return result;
  }
  async setMode(mode) {
    await this._page.mainFrame().evaluateExpression(((mode2) => {
      window.playwrightSetMode(mode2);
    }).toString(), { isFunction: true }, mode).catch(() => {
    });
  }
  async setRunningFile(file) {
    await this._page.mainFrame().evaluateExpression(((file2) => {
      window.playwrightSetRunningFile(file2);
    }).toString(), { isFunction: true }, file).catch(() => {
    });
  }
  async setPaused(paused) {
    await this._page.mainFrame().evaluateExpression(((paused2) => {
      window.playwrightSetPaused(paused2);
    }).toString(), { isFunction: true }, paused).catch(() => {
    });
  }
  async setSources(sources, primaryPageURL) {
    await this._page.mainFrame().evaluateExpression((({ sources: sources2, primaryPageURL: primaryPageURL2 }) => {
      window.playwrightSetSources(sources2, primaryPageURL2);
    }).toString(), { isFunction: true }, { sources, primaryPageURL }).catch(() => {
    });
    if (process.env.PWTEST_CLI_IS_UNDER_TEST && sources.length) {
      if (process._didSetSourcesForTest(sources[0].text))
        this.close();
    }
  }
  async setActions(actions, sources) {
  }
  async elementPicked(elementInfo, userGesture) {
    if (userGesture)
      this._page.bringToFront();
    await this._page.mainFrame().evaluateExpression(((param) => {
      window.playwrightElementPicked(param.elementInfo, param.userGesture);
    }).toString(), { isFunction: true }, { elementInfo, userGesture }).catch(() => {
    });
  }
  async updateCallLogs(callLogs) {
    await this._page.mainFrame().evaluateExpression(((callLogs2) => {
      window.playwrightUpdateLogs(callLogs2);
    }).toString(), { isFunction: true }, callLogs).catch(() => {
    });
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/storageScript.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function collect(serializersSource, builtins2, isFirefox, recordIndexedDB) {
  const { serializeAsCallArgument: serializeAsCallArgument2 } = serializersSource(builtins2);
  async function collectDB(dbInfo) {
    if (!dbInfo.name)
      throw new Error("Database name is empty");
    if (!dbInfo.version)
      throw new Error("Database version is unset");
    function idbRequestToPromise(request4) {
      return new Promise((resolve, reject) => {
        request4.addEventListener("success", () => resolve(request4.result));
        request4.addEventListener("error", () => reject(request4.error));
      });
    }
    __name(idbRequestToPromise, "idbRequestToPromise");
    function isPlainObject2(v) {
      const ctor = v?.constructor;
      if (isFirefox) {
        const constructorImpl = ctor?.toString();
        if (constructorImpl?.startsWith("function Object() {") && constructorImpl?.includes("[native code]"))
          return true;
      }
      return ctor === Object;
    }
    __name(isPlainObject2, "isPlainObject");
    function trySerialize(value) {
      let trivial = true;
      const encoded = serializeAsCallArgument2(value, (v) => {
        const isTrivial = isPlainObject2(v) || Array.isArray(v) || typeof v === "string" || typeof v === "number" || typeof v === "boolean" || Object.is(v, null);
        if (!isTrivial)
          trivial = false;
        return { fallThrough: v };
      });
      if (trivial)
        return { trivial: value };
      return { encoded };
    }
    __name(trySerialize, "trySerialize");
    const db = await idbRequestToPromise(indexedDB.open(dbInfo.name));
    const transaction = db.transaction(db.objectStoreNames, "readonly");
    const stores = await Promise.all([...db.objectStoreNames].map(async (storeName) => {
      const objectStore = transaction.objectStore(storeName);
      const keys = await idbRequestToPromise(objectStore.getAllKeys());
      const records = await Promise.all(keys.map(async (key) => {
        const record = {};
        if (objectStore.keyPath === null) {
          const { encoded: encoded2, trivial: trivial2 } = trySerialize(key);
          if (trivial2)
            record.key = trivial2;
          else
            record.keyEncoded = encoded2;
        }
        const value = await idbRequestToPromise(objectStore.get(key));
        const { encoded, trivial } = trySerialize(value);
        if (trivial)
          record.value = trivial;
        else
          record.valueEncoded = encoded;
        return record;
      }));
      const indexes = [...objectStore.indexNames].map((indexName) => {
        const index2 = objectStore.index(indexName);
        return {
          name: index2.name,
          keyPath: typeof index2.keyPath === "string" ? index2.keyPath : void 0,
          keyPathArray: Array.isArray(index2.keyPath) ? index2.keyPath : void 0,
          multiEntry: index2.multiEntry,
          unique: index2.unique
        };
      });
      return {
        name: storeName,
        records,
        indexes,
        autoIncrement: objectStore.autoIncrement,
        keyPath: typeof objectStore.keyPath === "string" ? objectStore.keyPath : void 0,
        keyPathArray: Array.isArray(objectStore.keyPath) ? objectStore.keyPath : void 0
      };
    }));
    return {
      name: dbInfo.name,
      version: dbInfo.version,
      stores
    };
  }
  __name(collectDB, "collectDB");
  return {
    localStorage: Object.keys(localStorage).map((name) => ({ name, value: localStorage.getItem(name) })),
    indexedDB: recordIndexedDB ? await Promise.all((await indexedDB.databases()).map(collectDB)).catch((e) => {
      throw new Error("Unable to serialize IndexedDB: " + e.message);
    }) : void 0
  };
}
__name(collect, "collect");
async function restore(serializersSource, builtins2, originState) {
  const { parseEvaluationResultValue: parseEvaluationResultValue2 } = serializersSource(builtins2);
  for (const { name, value } of originState.localStorage || [])
    localStorage.setItem(name, value);
  await Promise.all((originState.indexedDB ?? []).map(async (dbInfo) => {
    const openRequest = indexedDB.open(dbInfo.name, dbInfo.version);
    openRequest.addEventListener("upgradeneeded", () => {
      const db2 = openRequest.result;
      for (const store of dbInfo.stores) {
        const objectStore = db2.createObjectStore(store.name, { autoIncrement: store.autoIncrement, keyPath: store.keyPathArray ?? store.keyPath });
        for (const index2 of store.indexes)
          objectStore.createIndex(index2.name, index2.keyPathArray ?? index2.keyPath, { unique: index2.unique, multiEntry: index2.multiEntry });
      }
    });
    function idbRequestToPromise(request4) {
      return new Promise((resolve, reject) => {
        request4.addEventListener("success", () => resolve(request4.result));
        request4.addEventListener("error", () => reject(request4.error));
      });
    }
    __name(idbRequestToPromise, "idbRequestToPromise");
    const db = await idbRequestToPromise(openRequest);
    const transaction = db.transaction(db.objectStoreNames, "readwrite");
    await Promise.all(dbInfo.stores.map(async (store) => {
      const objectStore = transaction.objectStore(store.name);
      await Promise.all(store.records.map(async (record) => {
        await idbRequestToPromise(
          objectStore.add(
            record.value ?? parseEvaluationResultValue2(record.valueEncoded),
            record.key ?? parseEvaluationResultValue2(record.keyEncoded)
          )
        );
      }));
    }));
  })).catch((e) => {
    throw new Error("Unable to restore IndexedDB: " + e.message);
  });
}
__name(restore, "restore");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/trace/recorder/tracing.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path14 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/trace/recorder/snapshotter.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/injected/snapshotterInjected.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function frameSnapshotStreamer(snapshotStreamer, removeNoScript) {
  if (window[snapshotStreamer])
    return;
  const kShadowAttribute = "__playwright_shadow_root_";
  const kValueAttribute = "__playwright_value_";
  const kCheckedAttribute = "__playwright_checked_";
  const kSelectedAttribute = "__playwright_selected_";
  const kScrollTopAttribute = "__playwright_scroll_top_";
  const kScrollLeftAttribute = "__playwright_scroll_left_";
  const kStyleSheetAttribute = "__playwright_style_sheet_";
  const kTargetAttribute = "__playwright_target__";
  const kCustomElementsAttribute = "__playwright_custom_elements__";
  const kCurrentSrcAttribute = "__playwright_current_src__";
  const kBoundingRectAttribute = "__playwright_bounding_rect__";
  const kPopoverOpenAttribute = "__playwright_popover_open_";
  const kDialogOpenAttribute = "__playwright_dialog_open_";
  const kSnapshotFrameId = Symbol("__playwright_snapshot_frameid_");
  const kCachedData = Symbol("__playwright_snapshot_cache_");
  const kEndOfList = Symbol("__playwright_end_of_list_");
  function resetCachedData(obj) {
    delete obj[kCachedData];
  }
  __name(resetCachedData, "resetCachedData");
  function ensureCachedData(obj) {
    if (!obj[kCachedData])
      obj[kCachedData] = {};
    return obj[kCachedData];
  }
  __name(ensureCachedData, "ensureCachedData");
  function removeHash(url4) {
    try {
      const u = new URL(url4);
      u.hash = "";
      return u.toString();
    } catch (e) {
      return url4;
    }
  }
  __name(removeHash, "removeHash");
  class Streamer {
    static {
      __name(this, "Streamer");
    }
    constructor() {
      this._lastSnapshotNumber = 0;
      this._staleStyleSheets = /* @__PURE__ */ new Set();
      this._readingStyleSheet = false;
      const invalidateCSSGroupingRule = /* @__PURE__ */ __name((rule) => {
        if (rule.parentStyleSheet)
          this._invalidateStyleSheet(rule.parentStyleSheet);
      }, "invalidateCSSGroupingRule");
      this._interceptNativeMethod(window.CSSStyleSheet.prototype, "insertRule", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeMethod(window.CSSStyleSheet.prototype, "deleteRule", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeMethod(window.CSSStyleSheet.prototype, "addRule", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeMethod(window.CSSStyleSheet.prototype, "removeRule", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeGetter(window.CSSStyleSheet.prototype, "rules", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeGetter(window.CSSStyleSheet.prototype, "cssRules", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeMethod(window.CSSStyleSheet.prototype, "replaceSync", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeMethod(window.CSSGroupingRule.prototype, "insertRule", invalidateCSSGroupingRule);
      this._interceptNativeMethod(window.CSSGroupingRule.prototype, "deleteRule", invalidateCSSGroupingRule);
      this._interceptNativeGetter(window.CSSGroupingRule.prototype, "cssRules", invalidateCSSGroupingRule);
      this._interceptNativeAsyncMethod(window.CSSStyleSheet.prototype, "replace", (sheet) => this._invalidateStyleSheet(sheet));
      this._fakeBase = document.createElement("base");
      this._observer = new MutationObserver((list) => this._handleMutations(list));
      const observerConfig = { attributes: true, subtree: true };
      this._observer.observe(document, observerConfig);
      this._refreshListenersWhenNeeded();
    }
    _refreshListenersWhenNeeded() {
      this._refreshListeners();
      const customEventName = "__playwright_snapshotter_global_listeners_check__";
      let seenEvent = false;
      const handleCustomEvent = /* @__PURE__ */ __name(() => seenEvent = true, "handleCustomEvent");
      window.addEventListener(customEventName, handleCustomEvent);
      const observer = new MutationObserver((entries) => {
        const newDocumentElement = entries.some((entry) => Array.from(entry.addedNodes).includes(document.documentElement));
        if (newDocumentElement) {
          seenEvent = false;
          window.dispatchEvent(new CustomEvent(customEventName));
          if (!seenEvent) {
            window.addEventListener(customEventName, handleCustomEvent);
            this._refreshListeners();
          }
        }
      });
      observer.observe(document, { childList: true });
    }
    _refreshListeners() {
      document.addEventListener("__playwright_mark_target__", (event) => {
        if (!event.detail)
          return;
        const callId = event.detail;
        event.composedPath()[0].__playwright_target__ = callId;
      });
      document.addEventListener("__playwright_unmark_target__", (event) => {
        if (!event.detail)
          return;
        const callId = event.detail;
        if (event.composedPath()[0].__playwright_target__ === callId)
          delete event.composedPath()[0].__playwright_target__;
      });
    }
    _interceptNativeMethod(obj, method, cb) {
      const native = obj[method];
      if (!native)
        return;
      obj[method] = function(...args) {
        const result = native.call(this, ...args);
        cb(this, result);
        return result;
      };
    }
    _interceptNativeAsyncMethod(obj, method, cb) {
      const native = obj[method];
      if (!native)
        return;
      obj[method] = async function(...args) {
        const result = await native.call(this, ...args);
        cb(this, result);
        return result;
      };
    }
    _interceptNativeGetter(obj, prop, cb) {
      const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      Object.defineProperty(obj, prop, {
        ...descriptor,
        get: /* @__PURE__ */ __name(function() {
          const result = descriptor.get.call(this);
          cb(this, result);
          return result;
        }, "get")
      });
    }
    _handleMutations(list) {
      for (const mutation of list)
        ensureCachedData(mutation.target).attributesCached = void 0;
    }
    _invalidateStyleSheet(sheet) {
      if (this._readingStyleSheet)
        return;
      this._staleStyleSheets.add(sheet);
    }
    _updateStyleElementStyleSheetTextIfNeeded(sheet, forceText) {
      const data = ensureCachedData(sheet);
      if (this._staleStyleSheets.has(sheet) || forceText && data.cssText === void 0) {
        this._staleStyleSheets.delete(sheet);
        try {
          data.cssText = this._getSheetText(sheet);
        } catch (e) {
          data.cssText = "";
        }
      }
      return data.cssText;
    }
    // Returns either content, ref, or no override.
    _updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber) {
      const data = ensureCachedData(sheet);
      if (this._staleStyleSheets.has(sheet)) {
        this._staleStyleSheets.delete(sheet);
        try {
          data.cssText = this._getSheetText(sheet);
          data.cssRef = snapshotNumber;
          return data.cssText;
        } catch (e) {
        }
      }
      return data.cssRef === void 0 ? void 0 : snapshotNumber - data.cssRef;
    }
    markIframe(iframeElement, frameId) {
      iframeElement[kSnapshotFrameId] = frameId;
    }
    reset() {
      this._staleStyleSheets.clear();
      const visitNode = /* @__PURE__ */ __name((node2) => {
        resetCachedData(node2);
        if (node2.nodeType === Node.ELEMENT_NODE) {
          const element = node2;
          if (element.shadowRoot)
            visitNode(element.shadowRoot);
        }
        for (let child = node2.firstChild; child; child = child.nextSibling)
          visitNode(child);
      }, "visitNode");
      visitNode(document.documentElement);
      visitNode(this._fakeBase);
    }
    __sanitizeMetaAttribute(name, value, httpEquiv) {
      if (name === "charset")
        return "utf-8";
      if (httpEquiv.toLowerCase() !== "content-type" || name !== "content")
        return value;
      const [type2, ...params] = value.split(";");
      if (type2 !== "text/html" || params.length <= 0)
        return value;
      const charsetParamIdx = params.findIndex((param) => param.trim().startsWith("charset="));
      if (charsetParamIdx > -1)
        params[charsetParamIdx] = "charset=utf-8";
      return `${type2}; ${params.join("; ")}`;
    }
    _sanitizeUrl(url4) {
      if (url4.startsWith("javascript:") || url4.startsWith("vbscript:"))
        return "";
      return url4;
    }
    _sanitizeSrcSet(srcset) {
      return srcset.split(",").map((src2) => {
        src2 = src2.trim();
        const spaceIndex = src2.lastIndexOf(" ");
        if (spaceIndex === -1)
          return this._sanitizeUrl(src2);
        return this._sanitizeUrl(src2.substring(0, spaceIndex).trim()) + src2.substring(spaceIndex);
      }).join(", ");
    }
    _resolveUrl(base, url4) {
      if (url4 === "")
        return "";
      try {
        return new URL(url4, base).href;
      } catch (e) {
        return url4;
      }
    }
    _getSheetBase(sheet) {
      let rootSheet = sheet;
      while (rootSheet.parentStyleSheet)
        rootSheet = rootSheet.parentStyleSheet;
      if (rootSheet.ownerNode)
        return rootSheet.ownerNode.baseURI;
      return document.baseURI;
    }
    _getSheetText(sheet) {
      this._readingStyleSheet = true;
      try {
        const rules = [];
        for (const rule of sheet.cssRules)
          rules.push(rule.cssText);
        return rules.join("\n");
      } finally {
        this._readingStyleSheet = false;
      }
    }
    captureSnapshot() {
      const timestamp2 = performance.now();
      const snapshotNumber = ++this._lastSnapshotNumber;
      let nodeCounter = 0;
      let shadowDomNesting = 0;
      let headNesting = 0;
      this._handleMutations(this._observer.takeRecords());
      const definedCustomElements = /* @__PURE__ */ new Set();
      const visitNode = /* @__PURE__ */ __name((node2) => {
        const nodeType = node2.nodeType;
        const nodeName = nodeType === Node.DOCUMENT_FRAGMENT_NODE ? "template" : node2.nodeName;
        if (nodeType !== Node.ELEMENT_NODE && nodeType !== Node.DOCUMENT_FRAGMENT_NODE && nodeType !== Node.TEXT_NODE)
          return;
        if (nodeName === "SCRIPT")
          return;
        if (nodeName === "LINK" && nodeType === Node.ELEMENT_NODE) {
          const rel = node2.getAttribute("rel")?.toLowerCase();
          if (rel === "preload" || rel === "prefetch")
            return;
        }
        if (removeNoScript && nodeName === "NOSCRIPT")
          return;
        if (nodeName === "META" && node2.httpEquiv.toLowerCase() === "content-security-policy")
          return;
        if ((nodeName === "IFRAME" || nodeName === "FRAME") && headNesting)
          return;
        const data = ensureCachedData(node2);
        const values = [];
        let equals2 = !!data.cached;
        let extraNodes = 0;
        const expectValue = /* @__PURE__ */ __name((value) => {
          equals2 = equals2 && data.cached[values.length] === value;
          values.push(value);
        }, "expectValue");
        const checkAndReturn = /* @__PURE__ */ __name((n) => {
          data.attributesCached = true;
          if (equals2)
            return { equals: true, n: [[snapshotNumber - data.ref[0], data.ref[1]]] };
          nodeCounter += extraNodes;
          data.ref = [snapshotNumber, nodeCounter++];
          data.cached = values;
          return { equals: false, n };
        }, "checkAndReturn");
        if (nodeType === Node.TEXT_NODE) {
          const value = node2.nodeValue || "";
          expectValue(value);
          return checkAndReturn(value);
        }
        if (nodeName === "STYLE") {
          const sheet = node2.sheet;
          let cssText;
          if (sheet)
            cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet);
          cssText = cssText || node2.textContent || "";
          expectValue(cssText);
          extraNodes++;
          return checkAndReturn([nodeName, {}, cssText]);
        }
        const attrs = {};
        const result2 = [nodeName, attrs];
        const visitChild = /* @__PURE__ */ __name((child) => {
          const snapshot = visitNode(child);
          if (snapshot) {
            result2.push(snapshot.n);
            expectValue(child);
            equals2 = equals2 && snapshot.equals;
          }
        }, "visitChild");
        const visitChildStyleSheet = /* @__PURE__ */ __name((child) => {
          const snapshot = visitStyleSheet(child);
          if (snapshot) {
            result2.push(snapshot.n);
            expectValue(child);
            equals2 = equals2 && snapshot.equals;
          }
        }, "visitChildStyleSheet");
        if (nodeType === Node.DOCUMENT_FRAGMENT_NODE)
          attrs[kShadowAttribute] = "open";
        if (nodeType === Node.ELEMENT_NODE) {
          const element = node2;
          if (element.localName.includes("-") && window.customElements?.get(element.localName))
            definedCustomElements.add(element.localName);
          if (nodeName === "INPUT" || nodeName === "TEXTAREA") {
            const value = element.value;
            expectValue(kValueAttribute);
            expectValue(value);
            attrs[kValueAttribute] = value;
          }
          if (nodeName === "INPUT" && ["checkbox", "radio"].includes(element.type)) {
            const value = element.checked ? "true" : "false";
            expectValue(kCheckedAttribute);
            expectValue(value);
            attrs[kCheckedAttribute] = value;
          }
          if (nodeName === "OPTION") {
            const value = element.selected ? "true" : "false";
            expectValue(kSelectedAttribute);
            expectValue(value);
            attrs[kSelectedAttribute] = value;
          }
          if (nodeName === "CANVAS" || nodeName === "IFRAME" || nodeName === "FRAME") {
            const boundingRect = element.getBoundingClientRect();
            const value = JSON.stringify({
              left: boundingRect.left,
              top: boundingRect.top,
              right: boundingRect.right,
              bottom: boundingRect.bottom
            });
            expectValue(kBoundingRectAttribute);
            expectValue(value);
            attrs[kBoundingRectAttribute] = value;
          }
          if (element.popover && element.matches && element.matches(":popover-open")) {
            const value = "true";
            expectValue(kPopoverOpenAttribute);
            expectValue(value);
            attrs[kPopoverOpenAttribute] = value;
          }
          if (nodeName === "DIALOG" && element.open) {
            const value = element.matches(":modal") ? "modal" : "true";
            expectValue(kDialogOpenAttribute);
            expectValue(value);
            attrs[kDialogOpenAttribute] = value;
          }
          if (element.scrollTop) {
            expectValue(kScrollTopAttribute);
            expectValue(element.scrollTop);
            attrs[kScrollTopAttribute] = "" + element.scrollTop;
          }
          if (element.scrollLeft) {
            expectValue(kScrollLeftAttribute);
            expectValue(element.scrollLeft);
            attrs[kScrollLeftAttribute] = "" + element.scrollLeft;
          }
          if (element.shadowRoot) {
            ++shadowDomNesting;
            visitChild(element.shadowRoot);
            --shadowDomNesting;
          }
          if ("__playwright_target__" in element) {
            expectValue(kTargetAttribute);
            expectValue(element["__playwright_target__"]);
            attrs[kTargetAttribute] = element["__playwright_target__"];
          }
        }
        if (nodeName === "HEAD") {
          ++headNesting;
          this._fakeBase.setAttribute("href", document.baseURI);
          visitChild(this._fakeBase);
        }
        for (let child = node2.firstChild; child; child = child.nextSibling)
          visitChild(child);
        if (nodeName === "HEAD")
          --headNesting;
        expectValue(kEndOfList);
        let documentOrShadowRoot = null;
        if (node2.ownerDocument.documentElement === node2)
          documentOrShadowRoot = node2.ownerDocument;
        else if (node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
          documentOrShadowRoot = node2;
        if (documentOrShadowRoot) {
          for (const sheet of documentOrShadowRoot.adoptedStyleSheets || [])
            visitChildStyleSheet(sheet);
          expectValue(kEndOfList);
        }
        if (nodeName === "IFRAME" || nodeName === "FRAME") {
          const element = node2;
          const frameId = element[kSnapshotFrameId];
          const name = "src";
          const value = frameId ? `/snapshot/${frameId}` : "";
          expectValue(name);
          expectValue(value);
          attrs[name] = value;
        }
        if (nodeName === "BODY" && definedCustomElements.size) {
          const value = [...definedCustomElements].join(",");
          expectValue(kCustomElementsAttribute);
          expectValue(value);
          attrs[kCustomElementsAttribute] = value;
        }
        if (nodeName === "IMG" || nodeName === "PICTURE") {
          const value = nodeName === "PICTURE" ? "" : this._sanitizeUrl(node2.currentSrc);
          expectValue(kCurrentSrcAttribute);
          expectValue(value);
          attrs[kCurrentSrcAttribute] = value;
        }
        if (equals2 && data.attributesCached && !shadowDomNesting)
          return checkAndReturn(result2);
        if (nodeType === Node.ELEMENT_NODE) {
          const element = node2;
          for (let i = 0; i < element.attributes.length; i++) {
            const name = element.attributes[i].name;
            if (nodeName === "LINK" && name === "integrity")
              continue;
            if (nodeName === "IFRAME" && (name === "src" || name === "srcdoc" || name === "sandbox"))
              continue;
            if (nodeName === "FRAME" && name === "src")
              continue;
            if (nodeName === "DIALOG" && name === "open")
              continue;
            let value = element.attributes[i].value;
            if (nodeName === "META")
              value = this.__sanitizeMetaAttribute(name, value, node2.httpEquiv);
            else if (name === "src" && nodeName === "IMG")
              value = this._sanitizeUrl(value);
            else if (name === "srcset" && nodeName === "IMG")
              value = this._sanitizeSrcSet(value);
            else if (name === "srcset" && nodeName === "SOURCE")
              value = this._sanitizeSrcSet(value);
            else if (name === "href" && nodeName === "LINK")
              value = this._sanitizeUrl(value);
            else if (name.startsWith("on"))
              value = "";
            expectValue(name);
            expectValue(value);
            attrs[name] = value;
          }
          expectValue(kEndOfList);
        }
        if (result2.length === 2 && !Object.keys(attrs).length)
          result2.pop();
        return checkAndReturn(result2);
      }, "visitNode");
      const visitStyleSheet = /* @__PURE__ */ __name((sheet) => {
        const data = ensureCachedData(sheet);
        const oldCSSText = data.cssText;
        const cssText = this._updateStyleElementStyleSheetTextIfNeeded(
          sheet,
          true
          /* forceText */
        );
        if (cssText === oldCSSText)
          return { equals: true, n: [[snapshotNumber - data.ref[0], data.ref[1]]] };
        data.ref = [snapshotNumber, nodeCounter++];
        return {
          equals: false,
          n: ["template", {
            [kStyleSheetAttribute]: cssText
          }]
        };
      }, "visitStyleSheet");
      let html;
      if (document.documentElement) {
        const { n } = visitNode(document.documentElement);
        html = n;
      } else {
        html = ["html"];
      }
      const result = {
        html,
        doctype: document.doctype ? document.doctype.name : void 0,
        resourceOverrides: [],
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight
        },
        url: location.href,
        wallTime: Date.now(),
        collectionTime: 0
      };
      for (const sheet of this._staleStyleSheets) {
        if (sheet.href === null)
          continue;
        const content = this._updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber);
        if (content === void 0) {
          continue;
        }
        const base = this._getSheetBase(sheet);
        const url4 = removeHash(this._resolveUrl(base, sheet.href));
        result.resourceOverrides.push({ url: url4, content, contentType: "text/css" });
      }
      result.collectionTime = performance.now() - timestamp2;
      return result;
    }
  }
  window[snapshotStreamer] = new Streamer();
}
__name(frameSnapshotStreamer, "frameSnapshotStreamer");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/trace/recorder/snapshotter.js
var Snapshotter = class {
  static {
    __name(this, "Snapshotter");
  }
  constructor(context2, delegate) {
    this._eventListeners = [];
    this._initialized = false;
    this._started = false;
    this._context = context2;
    this._delegate = delegate;
    const guid = createGuid();
    this._snapshotStreamer = "__playwright_snapshot_streamer_" + guid;
  }
  started() {
    return this._started;
  }
  async start() {
    this._started = true;
    if (!this._initialized) {
      this._initialized = true;
      await this._initialize();
    }
    await this.reset();
  }
  async reset() {
    if (this._started)
      await this._runInAllFrames(`window["${this._snapshotStreamer}"].reset()`);
  }
  async stop() {
    this._started = false;
  }
  resetForReuse() {
    this._initialized = false;
  }
  async _initialize() {
    for (const page of this._context.pages())
      this._onPage(page);
    this._eventListeners = [
      eventsHelper.addEventListener(this._context, BrowserContext.Events.Page, this._onPage.bind(this))
    ];
    const { javaScriptEnabled } = this._context._options;
    let initScript = `((__name => (${frameSnapshotStreamer}))(t => t))`;
    initScript = `(${initScript})("${this._snapshotStreamer}", ${javaScriptEnabled || javaScriptEnabled === void 0})`;
    await this._context.addInitScript(initScript);
    await this._runInAllFrames(initScript);
  }
  async _runInAllFrames(expression) {
    const frames = [];
    for (const page of this._context.pages())
      frames.push(...page.frames());
    await Promise.all(frames.map((frame) => {
      return frame.nonStallingRawEvaluateInExistingMainContext(expression).catch((e) => debugLogger.log("error", e));
    }));
  }
  dispose() {
    eventsHelper.removeEventListeners(this._eventListeners);
  }
  async captureSnapshot(page, callId, snapshotName) {
    const expression = `window["${this._snapshotStreamer}"].captureSnapshot(${JSON.stringify(snapshotName)})`;
    const snapshots = page.frames().map(async (frame) => {
      const data = await frame.nonStallingRawEvaluateInExistingMainContext(expression).catch((e) => debugLogger.log("error", e));
      if (!data || !this._started)
        return;
      const snapshot = {
        callId,
        snapshotName,
        pageId: page.guid,
        frameId: frame.guid,
        frameUrl: data.url,
        doctype: data.doctype,
        html: data.html,
        viewport: data.viewport,
        timestamp: monotonicTime(),
        wallTime: data.wallTime,
        collectionTime: data.collectionTime,
        resourceOverrides: [],
        isMainFrame: page.mainFrame() === frame
      };
      for (const { url: url4, content, contentType } of data.resourceOverrides) {
        if (typeof content === "string") {
          const buffer2 = Buffer.from(content);
          const sha1 = calculateSha1(buffer2) + "." + (mime2.getExtension(contentType) || "dat");
          this._delegate.onSnapshotterBlob({ sha1, buffer: buffer2 });
          snapshot.resourceOverrides.push({ url: url4, sha1 });
        } else {
          snapshot.resourceOverrides.push({ url: url4, ref: content });
        }
      }
      this._delegate.onFrameSnapshot(snapshot);
    });
    await Promise.all(snapshots);
  }
  _onPage(page) {
    for (const frame of page.frames())
      this._annotateFrameHierarchy(frame);
    this._eventListeners.push(eventsHelper.addEventListener(page, Page.Events.FrameAttached, (frame) => this._annotateFrameHierarchy(frame)));
  }
  async _annotateFrameHierarchy(frame) {
    try {
      const frameElement = await frame.frameElement();
      const parent = frame.parentFrame();
      if (!parent)
        return;
      const context2 = await parent._mainContext();
      await context2?.evaluate(({ snapshotStreamer, frameElement: frameElement2, frameId }) => {
        window[snapshotStreamer].markIframe(frameElement2, frameId);
      }, { snapshotStreamer: this._snapshotStreamer, frameElement, frameId: frame.guid });
      frameElement.dispose();
    } catch (e) {
    }
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/trace/recorder/tracing.js
var version5 = 7;
var kScreencastOptions = { width: 800, height: 600, quality: 90 };
var Tracing = class extends SdkObject {
  static {
    __name(this, "Tracing");
  }
  constructor(context2, tracesDir) {
    super(context2, "tracing");
    this._fs = new SerializedFS();
    this._screencastListeners = [];
    this._eventListeners = [];
    this._isStopping = false;
    this._allResources = /* @__PURE__ */ new Set();
    this._pendingHarEntries = /* @__PURE__ */ new Set();
    this._context = context2;
    this._precreatedTracesDir = tracesDir;
    this._harTracer = new HarTracer(context2, null, this, {
      content: "attach",
      includeTraceInfo: true,
      recordRequestOverrides: false,
      waitForContentOnStop: false
    });
    const testIdAttributeName2 = "selectors" in context2 ? context2.selectors().testIdAttributeName() : void 0;
    this._contextCreatedEvent = {
      version: version5,
      type: "context-options",
      origin: "library",
      browserName: "",
      options: {},
      platform: process.platform,
      wallTime: 0,
      monotonicTime: 0,
      sdkLanguage: context2.attribution.playwright.options.sdkLanguage,
      testIdAttributeName: testIdAttributeName2,
      contextId: context2.guid
    };
    if (context2 instanceof BrowserContext) {
      this._snapshotter = new Snapshotter(context2, this);
      assert3(tracesDir, "tracesDir must be specified for BrowserContext");
      this._contextCreatedEvent.browserName = context2._browser.options.name;
      this._contextCreatedEvent.channel = context2._browser.options.channel;
      this._contextCreatedEvent.options = context2._options;
    }
  }
  async resetForReuse() {
    await this.stopChunk({ mode: "discard" }).catch(() => {
    });
    await this.stop();
    this._snapshotter?.resetForReuse();
  }
  async start(options2) {
    if (this._isStopping)
      throw new Error("Cannot start tracing while stopping");
    if (this._state)
      throw new Error("Tracing has been already started");
    this._contextCreatedEvent.sdkLanguage = this._context.attribution.playwright.options.sdkLanguage;
    const traceName = options2.name || createGuid();
    const tracesDir = this._createTracesDirIfNeeded();
    this._state = {
      options: options2,
      traceName,
      tracesDir,
      traceFile: path14.join(tracesDir, traceName + ".trace"),
      networkFile: path14.join(tracesDir, traceName + ".network"),
      resourcesDir: path14.join(tracesDir, "resources"),
      chunkOrdinal: 0,
      traceSha1s: /* @__PURE__ */ new Set(),
      networkSha1s: /* @__PURE__ */ new Set(),
      recording: false,
      callIds: /* @__PURE__ */ new Set(),
      groupStack: []
    };
    this._fs.mkdir(this._state.resourcesDir);
    this._fs.writeFile(this._state.networkFile, "");
    if (options2.snapshots)
      this._harTracer.start({ omitScripts: !options2.live });
  }
  async startChunk(options2 = {}) {
    if (this._state && this._state.recording)
      await this.stopChunk({ mode: "discard" });
    if (!this._state)
      throw new Error("Must start tracing before starting a new chunk");
    if (this._isStopping)
      throw new Error("Cannot start a trace chunk while stopping");
    this._state.recording = true;
    this._state.callIds.clear();
    const preserveNetworkResources = this._context instanceof BrowserContext;
    if (options2.name && options2.name !== this._state.traceName)
      this._changeTraceName(this._state, options2.name, preserveNetworkResources);
    else
      this._allocateNewTraceFile(this._state);
    if (!preserveNetworkResources)
      this._fs.writeFile(this._state.networkFile, "");
    this._fs.mkdir(path14.dirname(this._state.traceFile));
    const event = {
      ...this._contextCreatedEvent,
      title: options2.title,
      wallTime: Date.now(),
      monotonicTime: monotonicTime()
    };
    this._appendTraceEvent(event);
    this._context.instrumentation.addListener(this, this._context);
    this._eventListeners.push(
      eventsHelper.addEventListener(this._context, BrowserContext.Events.Console, this._onConsoleMessage.bind(this)),
      eventsHelper.addEventListener(this._context, BrowserContext.Events.PageError, this._onPageError.bind(this))
    );
    if (this._state.options.screenshots)
      this._startScreencast();
    if (this._state.options.snapshots)
      await this._snapshotter?.start();
    return { traceName: this._state.traceName };
  }
  _currentGroupId() {
    return this._state?.groupStack.length ? this._state.groupStack[this._state.groupStack.length - 1] : void 0;
  }
  async group(name, location2, metadata) {
    if (!this._state)
      return;
    const stackFrames = [];
    const { file, line, column } = location2 ?? metadata.location ?? {};
    if (file) {
      stackFrames.push({
        file,
        line: line ?? 0,
        column: column ?? 0
      });
    }
    const event = {
      type: "before",
      callId: metadata.id,
      startTime: metadata.startTime,
      apiName: name,
      class: "Tracing",
      method: "tracingGroup",
      params: {},
      stepId: metadata.stepId,
      stack: stackFrames
    };
    if (this._currentGroupId())
      event.parentId = this._currentGroupId();
    this._state.groupStack.push(event.callId);
    this._appendTraceEvent(event);
  }
  groupEnd() {
    if (!this._state)
      return;
    const callId = this._state.groupStack.pop();
    if (!callId)
      return;
    const event = {
      type: "after",
      callId,
      endTime: monotonicTime()
    };
    this._appendTraceEvent(event);
  }
  _startScreencast() {
    if (!(this._context instanceof BrowserContext))
      return;
    for (const page of this._context.pages())
      this._startScreencastInPage(page);
    this._screencastListeners.push(
      eventsHelper.addEventListener(this._context, BrowserContext.Events.Page, this._startScreencastInPage.bind(this))
    );
  }
  _stopScreencast() {
    eventsHelper.removeEventListeners(this._screencastListeners);
    if (!(this._context instanceof BrowserContext))
      return;
    for (const page of this._context.pages())
      page.setScreencastOptions(null);
  }
  _allocateNewTraceFile(state) {
    const suffix = state.chunkOrdinal ? `-chunk${state.chunkOrdinal}` : ``;
    state.chunkOrdinal++;
    state.traceFile = path14.join(state.tracesDir, `${state.traceName}${suffix}.trace`);
  }
  _changeTraceName(state, name, preserveNetworkResources) {
    state.traceName = name;
    state.chunkOrdinal = 0;
    this._allocateNewTraceFile(state);
    const newNetworkFile = path14.join(state.tracesDir, name + ".network");
    if (preserveNetworkResources)
      this._fs.copyFile(state.networkFile, newNetworkFile);
    state.networkFile = newNetworkFile;
  }
  async stop() {
    if (!this._state)
      return;
    if (this._isStopping)
      throw new Error(`Tracing is already stopping`);
    if (this._state.recording)
      throw new Error(`Must stop trace file before stopping tracing`);
    this._closeAllGroups();
    this._harTracer.stop();
    this.flushHarEntries();
    await this._fs.syncAndGetError();
    this._state = void 0;
  }
  async deleteTmpTracesDir() {
    if (this._tracesTmpDir)
      await removeFolders([this._tracesTmpDir]);
  }
  _createTracesDirIfNeeded() {
    if (this._precreatedTracesDir)
      return this._precreatedTracesDir;
    this._tracesTmpDir = fs.mkdtempSync(path14.join(os_default.tmpdir(), "playwright-tracing-"));
    return this._tracesTmpDir;
  }
  abort() {
    this._snapshotter?.dispose();
    this._harTracer.stop();
  }
  async flush() {
    this.abort();
    await this._fs.syncAndGetError();
  }
  _closeAllGroups() {
    while (this._currentGroupId())
      this.groupEnd();
  }
  async stopChunk(params) {
    if (this._isStopping)
      throw new Error(`Tracing is already stopping`);
    this._isStopping = true;
    if (!this._state || !this._state.recording) {
      this._isStopping = false;
      if (params.mode !== "discard")
        throw new Error(`Must start tracing before stopping`);
      return {};
    }
    this._closeAllGroups();
    this._context.instrumentation.removeListener(this);
    eventsHelper.removeEventListeners(this._eventListeners);
    if (this._state.options.screenshots)
      this._stopScreencast();
    if (this._state.options.snapshots)
      await this._snapshotter?.stop();
    this.flushHarEntries();
    const newNetworkFile = path14.join(this._state.tracesDir, this._state.traceName + `-pwnetcopy-${this._state.chunkOrdinal}.network`);
    const entries = [];
    entries.push({ name: "trace.trace", value: this._state.traceFile });
    entries.push({ name: "trace.network", value: newNetworkFile });
    for (const sha1 of /* @__PURE__ */ new Set([...this._state.traceSha1s, ...this._state.networkSha1s]))
      entries.push({ name: path14.join("resources", sha1), value: path14.join(this._state.resourcesDir, sha1) });
    this._state.traceSha1s = /* @__PURE__ */ new Set();
    if (params.mode === "discard") {
      this._isStopping = false;
      this._state.recording = false;
      return {};
    }
    this._fs.copyFile(this._state.networkFile, newNetworkFile);
    const zipFileName = this._state.traceFile + ".zip";
    if (params.mode === "archive")
      this._fs.zip(entries, zipFileName);
    const error4 = await this._fs.syncAndGetError();
    this._isStopping = false;
    if (this._state)
      this._state.recording = false;
    if (error4) {
      if (this._context instanceof BrowserContext && !this._context._browser.isConnected())
        return {};
      throw error4;
    }
    if (params.mode === "entries")
      return { entries };
    const artifact = new Artifact(this._context, zipFileName);
    artifact.reportFinished();
    return { artifact };
  }
  async _captureSnapshot(snapshotName, sdkObject, metadata) {
    if (!this._snapshotter)
      return;
    if (!sdkObject.attribution.page)
      return;
    if (!this._snapshotter.started())
      return;
    if (!shouldCaptureSnapshot(metadata))
      return;
    await this._snapshotter.captureSnapshot(sdkObject.attribution.page, metadata.id, snapshotName).catch(() => {
    });
  }
  onBeforeCall(sdkObject, metadata) {
    const event = createBeforeActionTraceEvent(metadata, this._currentGroupId());
    if (!event)
      return Promise.resolve();
    sdkObject.attribution.page?.temporarilyDisableTracingScreencastThrottling();
    event.beforeSnapshot = `before@${metadata.id}`;
    this._state?.callIds.add(metadata.id);
    this._appendTraceEvent(event);
    return this._captureSnapshot(event.beforeSnapshot, sdkObject, metadata);
  }
  onBeforeInputAction(sdkObject, metadata) {
    if (!this._state?.callIds.has(metadata.id))
      return Promise.resolve();
    const event = createInputActionTraceEvent(metadata);
    if (!event)
      return Promise.resolve();
    sdkObject.attribution.page?.temporarilyDisableTracingScreencastThrottling();
    event.inputSnapshot = `input@${metadata.id}`;
    this._appendTraceEvent(event);
    return this._captureSnapshot(event.inputSnapshot, sdkObject, metadata);
  }
  onCallLog(sdkObject, metadata, logName, message) {
    if (metadata.isServerSide || metadata.internal)
      return;
    if (logName !== "api")
      return;
    const event = createActionLogTraceEvent(metadata, message);
    if (event)
      this._appendTraceEvent(event);
  }
  async onAfterCall(sdkObject, metadata) {
    if (!this._state?.callIds.has(metadata.id))
      return;
    this._state?.callIds.delete(metadata.id);
    const event = createAfterActionTraceEvent(metadata);
    if (!event)
      return;
    sdkObject.attribution.page?.temporarilyDisableTracingScreencastThrottling();
    event.afterSnapshot = `after@${metadata.id}`;
    this._appendTraceEvent(event);
    return this._captureSnapshot(event.afterSnapshot, sdkObject, metadata);
  }
  onEntryStarted(entry) {
    this._pendingHarEntries.add(entry);
  }
  onEntryFinished(entry) {
    this._pendingHarEntries.delete(entry);
    const event = { type: "resource-snapshot", snapshot: entry };
    const visited = visitTraceEvent(event, this._state.networkSha1s);
    this._fs.appendFile(
      this._state.networkFile,
      JSON.stringify(visited) + "\n",
      true
      /* flush */
    );
  }
  flushHarEntries() {
    const harLines = [];
    for (const entry of this._pendingHarEntries) {
      const event = { type: "resource-snapshot", snapshot: entry };
      const visited = visitTraceEvent(event, this._state.networkSha1s);
      harLines.push(JSON.stringify(visited));
    }
    this._pendingHarEntries.clear();
    if (harLines.length)
      this._fs.appendFile(
        this._state.networkFile,
        harLines.join("\n") + "\n",
        true
        /* flush */
      );
  }
  onContentBlob(sha1, buffer2) {
    this._appendResource(sha1, buffer2);
  }
  onSnapshotterBlob(blob) {
    this._appendResource(blob.sha1, blob.buffer);
  }
  onFrameSnapshot(snapshot) {
    this._appendTraceEvent({ type: "frame-snapshot", snapshot });
  }
  _onConsoleMessage(message) {
    const event = {
      type: "console",
      messageType: message.type(),
      text: message.text(),
      args: message.args().map((a) => ({ preview: a.toString(), value: a.rawValue() })),
      location: message.location(),
      time: monotonicTime(),
      pageId: message.page()?.guid
    };
    this._appendTraceEvent(event);
  }
  onDialog(dialog) {
    const event = {
      type: "event",
      time: monotonicTime(),
      class: "BrowserContext",
      method: "dialog",
      params: { pageId: dialog.page().guid, type: dialog.type(), message: dialog.message(), defaultValue: dialog.defaultValue() }
    };
    this._appendTraceEvent(event);
  }
  onDownload(page, download) {
    const event = {
      type: "event",
      time: monotonicTime(),
      class: "BrowserContext",
      method: "download",
      params: { pageId: page.guid, url: download.url, suggestedFilename: download.suggestedFilename() }
    };
    this._appendTraceEvent(event);
  }
  onPageOpen(page) {
    const event = {
      type: "event",
      time: monotonicTime(),
      class: "BrowserContext",
      method: "page",
      params: { pageId: page.guid, openerPageId: page.opener()?.guid }
    };
    this._appendTraceEvent(event);
  }
  onPageClose(page) {
    const event = {
      type: "event",
      time: monotonicTime(),
      class: "BrowserContext",
      method: "pageClosed",
      params: { pageId: page.guid }
    };
    this._appendTraceEvent(event);
  }
  _onPageError(error4, page) {
    const event = {
      type: "event",
      time: monotonicTime(),
      class: "BrowserContext",
      method: "pageError",
      params: { error: serializeError(error4) },
      pageId: page.guid
    };
    this._appendTraceEvent(event);
  }
  _startScreencastInPage(page) {
    page.setScreencastOptions(kScreencastOptions);
    const prefix = page.guid;
    this._screencastListeners.push(
      eventsHelper.addEventListener(page, Page.Events.ScreencastFrame, (params) => {
        const suffix = params.timestamp || Date.now();
        const sha1 = `${prefix}-${suffix}.jpeg`;
        const event = {
          type: "screencast-frame",
          pageId: page.guid,
          sha1,
          width: params.width,
          height: params.height,
          timestamp: monotonicTime(),
          frameSwapWallTime: params.frameSwapWallTime
        };
        this._appendResource(sha1, params.buffer);
        this._appendTraceEvent(event);
      })
    );
  }
  _appendTraceEvent(event) {
    const visited = visitTraceEvent(event, this._state.traceSha1s);
    const flush = this._state.options.live || event.type !== "event" && event.type !== "console" && event.type !== "log";
    this._fs.appendFile(this._state.traceFile, JSON.stringify(visited) + "\n", flush);
  }
  _appendResource(sha1, buffer2) {
    if (this._allResources.has(sha1))
      return;
    this._allResources.add(sha1);
    const resourcePath = path14.join(this._state.resourcesDir, sha1);
    this._fs.writeFile(
      resourcePath,
      buffer2,
      true
      /* skipIfExists */
    );
  }
};
function visitTraceEvent(object, sha1s) {
  if (Array.isArray(object))
    return object.map((o) => visitTraceEvent(o, sha1s));
  if (object instanceof Dispatcher)
    return `<${object._type}>`;
  if (object instanceof Buffer)
    return `<Buffer>`;
  if (object instanceof Date)
    return object;
  if (typeof object === "object") {
    const result = {};
    for (const key in object) {
      if (key === "sha1" || key === "_sha1" || key.endsWith("Sha1")) {
        const sha1 = object[key];
        if (sha1)
          sha1s.add(sha1);
      }
      result[key] = visitTraceEvent(object[key], sha1s);
    }
    return result;
  }
  return object;
}
__name(visitTraceEvent, "visitTraceEvent");
function shouldCaptureSnapshot(metadata) {
  return commandsWithTracingSnapshots.has(metadata.type + "." + metadata.method);
}
__name(shouldCaptureSnapshot, "shouldCaptureSnapshot");
function createBeforeActionTraceEvent(metadata, parentId) {
  if (metadata.internal || metadata.method.startsWith("tracing"))
    return null;
  const event = {
    type: "before",
    callId: metadata.id,
    startTime: metadata.startTime,
    apiName: metadata.apiName || metadata.type + "." + metadata.method,
    class: metadata.type,
    method: metadata.method,
    params: metadata.params,
    stepId: metadata.stepId,
    pageId: metadata.pageId
  };
  if (parentId)
    event.parentId = parentId;
  return event;
}
__name(createBeforeActionTraceEvent, "createBeforeActionTraceEvent");
function createInputActionTraceEvent(metadata) {
  if (metadata.internal || metadata.method.startsWith("tracing"))
    return null;
  return {
    type: "input",
    callId: metadata.id,
    point: metadata.point
  };
}
__name(createInputActionTraceEvent, "createInputActionTraceEvent");
function createActionLogTraceEvent(metadata, message) {
  if (metadata.internal || metadata.method.startsWith("tracing"))
    return null;
  return {
    type: "log",
    callId: metadata.id,
    time: monotonicTime(),
    message
  };
}
__name(createActionLogTraceEvent, "createActionLogTraceEvent");
function createAfterActionTraceEvent(metadata) {
  if (metadata.internal || metadata.method.startsWith("tracing"))
    return null;
  return {
    type: "after",
    callId: metadata.id,
    endTime: metadata.endTime,
    error: metadata.error?.error,
    result: metadata.result,
    point: metadata.point
  };
}
__name(createAfterActionTraceEvent, "createAfterActionTraceEvent");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/browserContext.js
var BrowserContext = class _BrowserContext extends SdkObject {
  static {
    __name(this, "BrowserContext");
  }
  constructor(browser3, options2, browserContextId) {
    super(browser3, "browser-context");
    this._timeoutSettings = new TimeoutSettings();
    this._pageBindings = /* @__PURE__ */ new Map();
    this._activeProgressControllers = /* @__PURE__ */ new Set();
    this._closedStatus = "open";
    this._permissions = /* @__PURE__ */ new Map();
    this._downloads = /* @__PURE__ */ new Set();
    this._origins = /* @__PURE__ */ new Set();
    this._harRecorders = /* @__PURE__ */ new Map();
    this._tempDirs = [];
    this._settingStorageState = false;
    this.initScripts = [];
    this._routesInFlight = /* @__PURE__ */ new Set();
    this.attribution.context = this;
    this._browser = browser3;
    this._options = options2;
    this._browserContextId = browserContextId;
    this._isPersistentContext = !browserContextId;
    this._closePromise = new Promise((fulfill) => this._closePromiseFulfill = fulfill);
    this.fetchRequest = new BrowserContextAPIRequestContext(this);
    if (this._options.recordHar)
      this._harRecorders.set("", new HarRecorder(this, null, this._options.recordHar));
    this.tracing = new Tracing(this, browser3.options.tracesDir);
    this.clock = new Clock(this);
  }
  static {
    this.Events = {
      Console: "console",
      Close: "close",
      Dialog: "dialog",
      Page: "page",
      // Can't use just 'error' due to node.js special treatment of error events.
      // @see https://nodejs.org/api/events.html#events_error_events
      PageError: "pageerror",
      Request: "request",
      Response: "response",
      RequestFailed: "requestfailed",
      RequestFinished: "requestfinished",
      RequestAborted: "requestaborted",
      RequestFulfilled: "requestfulfilled",
      RequestContinued: "requestcontinued",
      BeforeClose: "beforeclose",
      VideoStarted: "videostarted"
    };
  }
  isPersistentContext() {
    return this._isPersistentContext;
  }
  setSelectors(selectors2) {
    this._selectors = selectors2;
  }
  selectors() {
    return this._selectors || this.attribution.playwright.selectors;
  }
  async _initialize() {
    if (this.attribution.playwright.options.isInternalPlaywright)
      return;
    this._debugger = new Debugger(this);
    if (debugMode() === "inspector")
      await Recorder.show(this, RecorderApp.factory(this), { pauseOnNextStatement: true });
    if (this._debugger.isPaused())
      Recorder.showInspectorNoReply(this, RecorderApp.factory(this));
    this._debugger.on(Debugger.Events.PausedStateChanged, () => {
      if (this._debugger.isPaused())
        Recorder.showInspectorNoReply(this, RecorderApp.factory(this));
    });
    if (debugMode() === "console")
      await this.extendInjectedScript("function Console(injectedScript) { injectedScript.consoleApi.install(); }");
    if (this._options.serviceWorkers === "block")
      await this.addInitScript(`
if (navigator.serviceWorker) navigator.serviceWorker.register = async () => { console.warn('Service Worker registration blocked by Playwright'); };
`);
    if (this._options.permissions)
      await this.grantPermissions(this._options.permissions);
  }
  debugger() {
    return this._debugger;
  }
  async _ensureVideosPath() {
    if (this._options.recordVideo)
      await mkdirIfNeeded(path15.join(this._options.recordVideo.dir, "dummy"));
  }
  canResetForReuse() {
    if (this._closedStatus !== "open")
      return false;
    return true;
  }
  async stopPendingOperations(reason) {
    for (const controller of this._activeProgressControllers)
      controller.abort(new Error(reason));
    await new Promise((f) => setTimeout(f, 0));
  }
  static reusableContextHash(params) {
    const paramsCopy = { ...params };
    for (const k of Object.keys(paramsCopy)) {
      const key = k;
      if (paramsCopy[key] === defaultNewContextParamValues[key])
        delete paramsCopy[key];
    }
    for (const key of paramsThatAllowContextReuse)
      delete paramsCopy[key];
    return JSON.stringify(paramsCopy);
  }
  async resetForReuse(metadata, params) {
    this.setDefaultNavigationTimeout(void 0);
    this.setDefaultTimeout(void 0);
    this.tracing.resetForReuse();
    if (params) {
      for (const key of paramsThatAllowContextReuse)
        this._options[key] = params[key];
    }
    await this._cancelAllRoutesInFlight();
    let page = this.pages()[0];
    const [, ...otherPages] = this.pages();
    for (const p of otherPages)
      await p.close(metadata);
    if (page && page.hasCrashed()) {
      await page.close(metadata);
      page = void 0;
    }
    page?._frameManager.setCloseAllOpeningDialogs(true);
    await page?._frameManager.closeOpenDialogs();
    await page?.mainFrame().goto(metadata, "about:blank", { timeout: 0 });
    page?._frameManager.setCloseAllOpeningDialogs(false);
    await this._resetStorage();
    await this._removeExposedBindings();
    await this._removeInitScripts();
    this.clock.markAsUninstalled();
    if (this._options.permissions)
      await this.grantPermissions(this._options.permissions);
    else
      await this.clearPermissions();
    await this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []);
    await this.setGeolocation(this._options.geolocation);
    await this.setOffline(!!this._options.offline);
    await this.setUserAgent(this._options.userAgent);
    await this.clearCache();
    await this._resetCookies();
    await page?.resetForReuse(metadata);
  }
  _browserClosed() {
    for (const page of this.pages())
      page._didClose();
    this._didCloseInternal();
  }
  _didCloseInternal() {
    if (this._closedStatus === "closed") {
      return;
    }
    this._clientCertificatesProxy?.close().catch(() => {
    });
    this.tracing.abort();
    if (this._isPersistentContext)
      this.onClosePersistent();
    this._closePromiseFulfill(new Error("Context closed"));
    this.emit(_BrowserContext.Events.Close);
  }
  pages() {
    return this.possiblyUninitializedPages().filter((page) => page.initializedOrUndefined());
  }
  async cookies(urls = []) {
    if (urls && !Array.isArray(urls))
      urls = [urls];
    return await this.doGetCookies(urls);
  }
  async clearCookies(options2) {
    const currentCookies = await this.cookies();
    await this.doClearCookies();
    const matches = /* @__PURE__ */ __name((cookie, prop, value) => {
      if (!value)
        return true;
      if (value instanceof RegExp) {
        value.lastIndex = 0;
        return value.test(cookie[prop]);
      }
      return cookie[prop] === value;
    }, "matches");
    const cookiesToReadd = currentCookies.filter((cookie) => {
      return !matches(cookie, "name", options2.name) || !matches(cookie, "domain", options2.domain) || !matches(cookie, "path", options2.path);
    });
    await this.addCookies(cookiesToReadd);
  }
  setHTTPCredentials(httpCredentials) {
    return this.doSetHTTPCredentials(httpCredentials);
  }
  hasBinding(name) {
    return this._pageBindings.has(name);
  }
  async exposeBinding(name, needsHandle, playwrightBinding) {
    if (this._pageBindings.has(name))
      throw new Error(`Function "${name}" has been already registered`);
    for (const page of this.pages()) {
      if (page.getBinding(name))
        throw new Error(`Function "${name}" has been already registered in one of the pages`);
    }
    const binding3 = new PageBinding(name, playwrightBinding, needsHandle);
    this._pageBindings.set(name, binding3);
    await this.doAddInitScript(binding3.initScript);
    const frames = this.pages().map((page) => page.frames()).flat();
    await Promise.all(frames.map((frame) => frame.evaluateExpression(binding3.initScript.source).catch((e) => {
    })));
  }
  async _removeExposedBindings() {
    for (const [key, binding3] of this._pageBindings) {
      if (!binding3.internal)
        this._pageBindings.delete(key);
    }
  }
  async grantPermissions(permissions, origin) {
    let resolvedOrigin = "*";
    if (origin) {
      const url4 = new URL(origin);
      resolvedOrigin = url4.origin;
    }
    const existing = new Set(this._permissions.get(resolvedOrigin) || []);
    permissions.forEach((p) => existing.add(p));
    const list = [...existing.values()];
    this._permissions.set(resolvedOrigin, list);
    await this.doGrantPermissions(resolvedOrigin, list);
  }
  async clearPermissions() {
    this._permissions.clear();
    await this.doClearPermissions();
  }
  setDefaultNavigationTimeout(timeout) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout);
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }
  async _loadDefaultContextAsIs(progress3) {
    if (!this.possiblyUninitializedPages().length) {
      const waitForEvent2 = helper.waitForEvent(progress3, this, _BrowserContext.Events.Page);
      progress3.cleanupWhenAborted(() => waitForEvent2.dispose);
      await Promise.race([waitForEvent2.promise, this._closePromise]);
    }
    const page = this.possiblyUninitializedPages()[0];
    if (!page)
      return;
    const pageOrError = await page.waitForInitializedOrError();
    if (pageOrError instanceof Error)
      throw pageOrError;
    await page.mainFrame()._waitForLoadState(progress3, "load");
    return page;
  }
  async _loadDefaultContext(progress3) {
    const defaultPage = await this._loadDefaultContextAsIs(progress3);
    if (!defaultPage)
      return;
    const browserName = this._browser.options.name;
    if (this._options.isMobile && browserName === "chromium" || this._options.locale && browserName === "webkit") {
      await this.newPage(progress3.metadata);
      await defaultPage.close(progress3.metadata);
    }
  }
  _authenticateProxyViaHeader() {
    const proxy = this._options.proxy || this._browser.options.proxy || { username: void 0, password: void 0 };
    const { username, password } = proxy;
    if (username) {
      this._options.httpCredentials = { username, password };
      const token = Buffer.from(`${username}:${password}`).toString("base64");
      this._options.extraHTTPHeaders = mergeHeaders([
        this._options.extraHTTPHeaders,
        singleHeader("Proxy-Authorization", `Basic ${token}`)
      ]);
    }
  }
  _authenticateProxyViaCredentials() {
    const proxy = this._options.proxy || this._browser.options.proxy;
    if (!proxy)
      return;
    const { username, password } = proxy;
    if (username)
      this._options.httpCredentials = { username, password: password || "" };
  }
  async addInitScript(source7, name) {
    const initScript = new InitScript(source7, false, name);
    this.initScripts.push(initScript);
    await this.doAddInitScript(initScript);
  }
  async _removeInitScripts() {
    this.initScripts = this.initScripts.filter((script) => script.internal);
    await this.doRemoveNonInternalInitScripts();
  }
  async setRequestInterceptor(handler) {
    this._requestInterceptor = handler;
    await this.doUpdateRequestInterception();
  }
  isClosingOrClosed() {
    return this._closedStatus !== "open";
  }
  async _deleteAllDownloads() {
    await Promise.all(Array.from(this._downloads).map((download) => download.artifact.deleteOnContextClose()));
  }
  async _deleteAllTempDirs() {
    await Promise.all(this._tempDirs.map(async (dir3) => await fs.promises.unlink(dir3).catch((e) => {
    })));
  }
  setCustomCloseHandler(handler) {
    this._customCloseHandler = handler;
  }
  async close(options2) {
    if (this._closedStatus === "open") {
      if (options2.reason)
        this._closeReason = options2.reason;
      this.emit(_BrowserContext.Events.BeforeClose);
      this._closedStatus = "closing";
      for (const harRecorder of this._harRecorders.values())
        await harRecorder.flush();
      await this.tracing.flush();
      const promises2 = [];
      for (const { context: context2, artifact } of this._browser._idToVideo.values()) {
        if (context2 === this)
          promises2.push(artifact.finishedPromise());
      }
      if (this._customCloseHandler) {
        await this._customCloseHandler();
      } else {
        await this.doClose(options2.reason);
      }
      promises2.push(this._deleteAllDownloads());
      promises2.push(this._deleteAllTempDirs());
      await Promise.all(promises2);
      if (!this._customCloseHandler)
        this._didCloseInternal();
    }
    await this._closePromise;
  }
  async newPage(metadata) {
    const page = await this.doCreateNewPage();
    if (metadata.isServerSide)
      page.markAsServerSideOnly();
    const pageOrError = await page.waitForInitializedOrError();
    if (pageOrError instanceof Page) {
      if (pageOrError.isClosed())
        throw new Error("Page has been closed.");
      return pageOrError;
    }
    throw pageOrError;
  }
  addVisitedOrigin(origin) {
    this._origins.add(origin);
  }
  async storageState(indexedDB2 = false) {
    const result = {
      cookies: await this.cookies(),
      origins: []
    };
    const originsToSave = new Set(this._origins);
    let collectScript = `(${collect})(${source3}, (${builtins})(), ${this._browser.options.name === "firefox"}, ${indexedDB2})`;
    collectScript = `((__name => (${collectScript}))(t => t))`;
    for (const page of this.pages()) {
      const origin = page.mainFrame().origin();
      if (!origin || !originsToSave.has(origin))
        continue;
      try {
        const storage = await page.mainFrame().nonStallingEvaluateInExistingContext(collectScript, "utility");
        if (storage.localStorage.length || storage.indexedDB?.length)
          result.origins.push({ origin, localStorage: storage.localStorage, indexedDB: storage.indexedDB });
        originsToSave.delete(origin);
      } catch {
      }
    }
    if (originsToSave.size) {
      const internalMetadata2 = serverSideCallMetadata();
      const page = await this.newPage(internalMetadata2);
      await page._setServerRequestInterceptor((handler) => {
        handler.fulfill({ body: "<html></html>" }).catch(() => {
        });
        return true;
      });
      for (const origin of originsToSave) {
        const frame = page.mainFrame();
        await frame.goto(internalMetadata2, origin);
        const storage = await frame.evaluateExpression(collectScript, { world: "utility" });
        if (storage.localStorage.length || storage.indexedDB?.length)
          result.origins.push({ origin, localStorage: storage.localStorage, indexedDB: storage.indexedDB });
      }
      await page.close(internalMetadata2);
    }
    return result;
  }
  async _resetStorage() {
    const oldOrigins = this._origins;
    const newOrigins = new Map(this._options.storageState?.origins?.map((p) => [p.origin, p]) || []);
    if (!oldOrigins.size && !newOrigins.size)
      return;
    let page = this.pages()[0];
    const internalMetadata2 = serverSideCallMetadata();
    page = page || await this.newPage({
      ...internalMetadata2,
      // Do not mark this page as internal, because we will leave it for later reuse
      // as a user-visible page.
      isServerSide: false
    });
    await page._setServerRequestInterceptor((handler) => {
      handler.fulfill({ body: "<html></html>" }).catch(() => {
      });
      return true;
    });
    for (const origin of /* @__PURE__ */ new Set([...oldOrigins, ...newOrigins.keys()])) {
      const frame = page.mainFrame();
      await frame.goto(internalMetadata2, origin);
      await frame.resetStorageForCurrentOriginBestEffort(newOrigins.get(origin));
    }
    await page._setServerRequestInterceptor(void 0);
    this._origins = /* @__PURE__ */ new Set([...newOrigins.keys()]);
  }
  async _resetCookies() {
    await this.doClearCookies();
    if (this._options.storageState?.cookies)
      await this.addCookies(this._options.storageState?.cookies);
  }
  isSettingStorageState() {
    return this._settingStorageState;
  }
  async setStorageState(metadata, state) {
    this._settingStorageState = true;
    try {
      if (state.cookies)
        await this.addCookies(state.cookies);
      if (state.origins && state.origins.length) {
        const internalMetadata2 = serverSideCallMetadata();
        const page = await this.newPage(internalMetadata2);
        await page._setServerRequestInterceptor((handler) => {
          handler.fulfill({ body: "<html></html>" }).catch(() => {
          });
          return true;
        });
        for (const originState of state.origins) {
          const frame = page.mainFrame();
          await frame.goto(metadata, originState.origin);
          const restoreScript = `((__name => (${restore}))(t => t))`;
          const utilityScriptSerializersScript = `((__name => (${source3}))(t => t))`;
          const builtinsScript = `((__name => (${builtins}))(t => t))`;
          await frame.evaluateExpression(`(${restoreScript})(${utilityScriptSerializersScript}, (${builtinsScript})(), ${JSON.stringify(originState)})`, { world: "utility" });
        }
        await page.close(internalMetadata2);
      }
    } finally {
      this._settingStorageState = false;
    }
  }
  async extendInjectedScript(source7, arg) {
    const installInFrame = /* @__PURE__ */ __name((frame) => frame.extendInjectedScript(source7, arg).catch(() => {
    }), "installInFrame");
    const installInPage = /* @__PURE__ */ __name((page) => {
      page.on(Page.Events.InternalFrameNavigatedToNewDocument, installInFrame);
      return Promise.all(page.frames().map(installInFrame));
    }, "installInPage");
    this.on(_BrowserContext.Events.Page, installInPage);
    return Promise.all(this.pages().map(installInPage));
  }
  async safeNonStallingEvaluateInAllFrames(expression, world, options2 = {}) {
    await Promise.all(this.pages().map((page) => page.safeNonStallingEvaluateInAllFrames(expression, world, options2)));
  }
  async _harStart(page, options2) {
    const harId = createGuid();
    this._harRecorders.set(harId, new HarRecorder(this, page, options2));
    return harId;
  }
  async _harExport(harId) {
    const recorder = this._harRecorders.get(harId || "");
    return recorder.export();
  }
  addRouteInFlight(route) {
    this._routesInFlight.add(route);
  }
  removeRouteInFlight(route) {
    this._routesInFlight.delete(route);
  }
  async _cancelAllRoutesInFlight() {
    await Promise.all([...this._routesInFlight].map((r) => r.abort())).catch(() => {
    });
    this._routesInFlight.clear();
  }
};
function assertBrowserContextIsNotOwned(context2) {
  for (const page of context2.pages()) {
    if (page._ownedContext)
      throw new Error("Please use browser.newContext() for multi-page scripts that share the context.");
  }
}
__name(assertBrowserContextIsNotOwned, "assertBrowserContextIsNotOwned");
function validateBrowserContextOptions(options2, browserOptions) {
  if (options2.noDefaultViewport && options2.deviceScaleFactor !== void 0)
    throw new Error(`"deviceScaleFactor" option is not supported with null "viewport"`);
  if (options2.noDefaultViewport && !!options2.isMobile)
    throw new Error(`"isMobile" option is not supported with null "viewport"`);
  if (options2.acceptDownloads === void 0 && browserOptions.name !== "electron")
    options2.acceptDownloads = "accept";
  else if (options2.acceptDownloads === void 0 && browserOptions.name === "electron")
    options2.acceptDownloads = "internal-browser-default";
  if (!options2.viewport && !options2.noDefaultViewport)
    options2.viewport = { width: 1280, height: 720 };
  if (options2.recordVideo) {
    if (!options2.recordVideo.size) {
      if (options2.noDefaultViewport) {
        options2.recordVideo.size = { width: 800, height: 600 };
      } else {
        const size = options2.viewport;
        const scale = Math.min(1, 800 / Math.max(size.width, size.height));
        options2.recordVideo.size = {
          width: Math.floor(size.width * scale),
          height: Math.floor(size.height * scale)
        };
      }
    }
    options2.recordVideo.size.width &= -2;
    options2.recordVideo.size.height &= -2;
  }
  if (options2.proxy)
    options2.proxy = normalizeProxySettings(options2.proxy);
  verifyGeolocation(options2.geolocation);
}
__name(validateBrowserContextOptions, "validateBrowserContextOptions");
function verifyGeolocation(geolocation) {
  if (!geolocation)
    return;
  geolocation.accuracy = geolocation.accuracy || 0;
  const { longitude, latitude, accuracy } = geolocation;
  if (longitude < -180 || longitude > 180)
    throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);
  if (latitude < -90 || latitude > 90)
    throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);
  if (accuracy < 0)
    throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);
}
__name(verifyGeolocation, "verifyGeolocation");
function verifyClientCertificates(clientCertificates) {
  if (!clientCertificates)
    return;
  for (const cert of clientCertificates) {
    if (!cert.origin)
      throw new Error(`clientCertificates.origin is required`);
    if (!cert.cert && !cert.key && !cert.passphrase && !cert.pfx)
      throw new Error("None of cert, key, passphrase or pfx is specified");
    if (cert.cert && !cert.key)
      throw new Error("cert is specified without key");
    if (!cert.cert && cert.key)
      throw new Error("key is specified without cert");
    if (cert.pfx && (cert.cert || cert.key))
      throw new Error("pfx is specified together with cert, key or passphrase");
  }
}
__name(verifyClientCertificates, "verifyClientCertificates");
function normalizeProxySettings(proxy) {
  let { server, bypass } = proxy;
  let url4;
  try {
    url4 = new URL(server);
    if (!url4.host || !url4.protocol)
      url4 = new URL("http://" + server);
  } catch (e) {
    url4 = new URL("http://" + server);
  }
  if (url4.protocol === "socks4:" && (proxy.username || proxy.password))
    throw new Error(`Socks4 proxy protocol does not support authentication`);
  if (url4.protocol === "socks5:" && (proxy.username || proxy.password))
    throw new Error(`Browser does not support socks5 proxy authentication`);
  server = url4.protocol + "//" + url4.host;
  if (bypass)
    bypass = bypass.split(",").map((t) => t.trim()).join(",");
  return { ...proxy, server, bypass };
}
__name(normalizeProxySettings, "normalizeProxySettings");
var paramsThatAllowContextReuse = [
  "colorScheme",
  "forcedColors",
  "reducedMotion",
  "contrast",
  "screen",
  "userAgent",
  "viewport"
];
var defaultNewContextParamValues = {
  noDefaultViewport: false,
  ignoreHTTPSErrors: false,
  javaScriptEnabled: true,
  bypassCSP: false,
  offline: false,
  isMobile: false,
  hasTouch: false,
  acceptDownloads: "accept",
  strictSelectors: false,
  serviceWorkers: "allow",
  locale: "en-US"
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/cookieStore.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Cookie = class {
  static {
    __name(this, "Cookie");
  }
  constructor(data) {
    this._raw = data;
  }
  name() {
    return this._raw.name;
  }
  // https://datatracker.ietf.org/doc/html/rfc6265#section-5.4
  matches(url4) {
    if (this._raw.secure && (url4.protocol !== "https:" && url4.hostname !== "localhost"))
      return false;
    if (!domainMatches(url4.hostname, this._raw.domain))
      return false;
    if (!pathMatches(url4.pathname, this._raw.path))
      return false;
    return true;
  }
  equals(other2) {
    return this._raw.name === other2._raw.name && this._raw.domain === other2._raw.domain && this._raw.path === other2._raw.path;
  }
  networkCookie() {
    return this._raw;
  }
  updateExpiresFrom(other2) {
    this._raw.expires = other2._raw.expires;
  }
  expired() {
    if (this._raw.expires === -1)
      return false;
    return this._raw.expires * 1e3 < Date.now();
  }
};
var CookieStore = class _CookieStore {
  static {
    __name(this, "CookieStore");
  }
  constructor() {
    this._nameToCookies = /* @__PURE__ */ new Map();
  }
  addCookies(cookies) {
    for (const cookie of cookies)
      this._addCookie(new Cookie(cookie));
  }
  cookies(url4) {
    const result = [];
    for (const cookie of this._cookiesIterator()) {
      if (cookie.matches(url4))
        result.push(cookie.networkCookie());
    }
    return result;
  }
  allCookies() {
    const result = [];
    for (const cookie of this._cookiesIterator())
      result.push(cookie.networkCookie());
    return result;
  }
  _addCookie(cookie) {
    let set2 = this._nameToCookies.get(cookie.name());
    if (!set2) {
      set2 = /* @__PURE__ */ new Set();
      this._nameToCookies.set(cookie.name(), set2);
    }
    for (const other2 of set2) {
      if (other2.equals(cookie))
        set2.delete(other2);
    }
    set2.add(cookie);
    _CookieStore.pruneExpired(set2);
  }
  *_cookiesIterator() {
    for (const [name, cookies] of this._nameToCookies) {
      _CookieStore.pruneExpired(cookies);
      for (const cookie of cookies)
        yield cookie;
      if (cookies.size === 0)
        this._nameToCookies.delete(name);
    }
  }
  static pruneExpired(cookies) {
    for (const cookie of cookies) {
      if (cookie.expired())
        cookies.delete(cookie);
    }
  }
};
function parseRawCookie(header) {
  const pairs2 = header.split(";").filter((s) => s.trim().length > 0).map((p) => {
    let key = "";
    let value2 = "";
    const separatorPos = p.indexOf("=");
    if (separatorPos === -1) {
      key = p.trim();
    } else {
      key = p.slice(0, separatorPos).trim();
      value2 = p.slice(separatorPos + 1).trim();
    }
    return [key, value2];
  });
  if (!pairs2.length)
    return null;
  const [name, value] = pairs2[0];
  const cookie = {
    name,
    value
  };
  for (let i = 1; i < pairs2.length; i++) {
    const [name2, value2] = pairs2[i];
    switch (name2.toLowerCase()) {
      case "expires":
        const expiresMs = +new Date(value2);
        if (isFinite(expiresMs)) {
          if (expiresMs <= 0)
            cookie.expires = 0;
          else
            cookie.expires = Math.min(expiresMs / 1e3, kMaxCookieExpiresDateInSeconds);
        }
        break;
      case "max-age":
        const maxAgeSec = parseInt(value2, 10);
        if (isFinite(maxAgeSec)) {
          if (maxAgeSec <= 0)
            cookie.expires = 0;
          else
            cookie.expires = Math.min(Date.now() / 1e3 + maxAgeSec, kMaxCookieExpiresDateInSeconds);
        }
        break;
      case "domain":
        cookie.domain = value2.toLocaleLowerCase() || "";
        if (cookie.domain && !cookie.domain.startsWith(".") && cookie.domain.includes("."))
          cookie.domain = "." + cookie.domain;
        break;
      case "path":
        cookie.path = value2 || "";
        break;
      case "secure":
        cookie.secure = true;
        break;
      case "httponly":
        cookie.httpOnly = true;
        break;
      case "samesite":
        switch (value2.toLowerCase()) {
          case "none":
            cookie.sameSite = "None";
            break;
          case "lax":
            cookie.sameSite = "Lax";
            break;
          case "strict":
            cookie.sameSite = "Strict";
            break;
        }
        break;
    }
  }
  return cookie;
}
__name(parseRawCookie, "parseRawCookie");
function domainMatches(value, domain2) {
  if (value === domain2)
    return true;
  if (!domain2.startsWith("."))
    return false;
  value = "." + value;
  return value.endsWith(domain2);
}
__name(domainMatches, "domainMatches");
function pathMatches(value, path31) {
  if (value === path31)
    return true;
  if (!value.endsWith("/"))
    value = value + "/";
  if (!path31.endsWith("/"))
    path31 = path31 + "/";
  return value.startsWith(path31);
}
__name(pathMatches, "pathMatches");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/formData.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MultipartFormData = class {
  static {
    __name(this, "MultipartFormData");
  }
  constructor() {
    this._chunks = [];
    this._boundary = generateUniqueBoundaryString();
  }
  contentTypeHeader() {
    return `multipart/form-data; boundary=${this._boundary}`;
  }
  addField(name, value) {
    this._beginMultiPartHeader(name);
    this._finishMultiPartHeader();
    this._chunks.push(Buffer.from(value));
    this._finishMultiPartField();
  }
  addFileField(name, value) {
    this._beginMultiPartHeader(name);
    this._chunks.push(Buffer.from(`; filename="${value.name}"`));
    this._chunks.push(Buffer.from(`\r
content-type: ${value.mimeType || mime2.getType(value.name) || "application/octet-stream"}`));
    this._finishMultiPartHeader();
    this._chunks.push(value.buffer);
    this._finishMultiPartField();
  }
  finish() {
    this._addBoundary(true);
    return Buffer.concat(this._chunks);
  }
  _beginMultiPartHeader(name) {
    this._addBoundary();
    this._chunks.push(Buffer.from(`content-disposition: form-data; name="${name}"`));
  }
  _finishMultiPartHeader() {
    this._chunks.push(Buffer.from(`\r
\r
`));
  }
  _finishMultiPartField() {
    this._chunks.push(Buffer.from(`\r
`));
  }
  _addBoundary(isLastBoundary) {
    this._chunks.push(Buffer.from("--" + this._boundary));
    if (isLastBoundary)
      this._chunks.push(Buffer.from("--"));
    this._chunks.push(Buffer.from("\r\n"));
  }
};
var alphaNumericEncodingMap = [
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  65,
  66
];
function generateUniqueBoundaryString() {
  const charCodes = [];
  for (let i = 0; i < 16; i++)
    charCodes.push(alphaNumericEncodingMap[Math.floor(Math.random() * alphaNumericEncodingMap.length)]);
  return "----WebKitFormBoundary" + String.fromCharCode(...charCodes);
}
__name(generateUniqueBoundaryString, "generateUniqueBoundaryString");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/socksClientCertificatesInterceptor.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter11 } from "node:events";
import net4 from "node:net";
import require$$65 from "node:stream";
import "node:path";
var dummyServerTlsOptions = void 0;
function loadDummyServerCertsIfNeeded() {
  if (dummyServerTlsOptions)
    return;
  const { cert, key } = generateSelfSignedCertificate();
  dummyServerTlsOptions = { key, cert };
}
__name(loadDummyServerCertsIfNeeded, "loadDummyServerCertsIfNeeded");
var ALPNCache = class {
  static {
    __name(this, "ALPNCache");
  }
  constructor() {
    this._cache = /* @__PURE__ */ new Map();
  }
  get(host, port, success) {
    const cacheKey = `${host}:${port}`;
    {
      const result2 = this._cache.get(cacheKey);
      if (result2) {
        result2.then(success);
        return;
      }
    }
    const result = new ManualPromise();
    this._cache.set(cacheKey, result);
    result.then(success);
    createTLSSocket({
      host,
      port,
      servername: net4.isIP(host) ? void 0 : host,
      ALPNProtocols: ["h2", "http/1.1"],
      rejectUnauthorized: false
    }).then((socket) => {
      result.resolve(socket.alpnProtocol || "http/1.1");
      socket.end();
    }).catch((error4) => {
      debugLogger.log("client-certificates", `ALPN error: ${error4.message}`);
      result.resolve("http/1.1");
    });
  }
};
var SocksProxyConnection = class {
  static {
    __name(this, "SocksProxyConnection");
  }
  constructor(socksProxy, uid, host, port) {
    this.firstPackageReceived = false;
    this._closed = false;
    this.socksProxy = socksProxy;
    this.uid = uid;
    this.host = host;
    this.port = port;
    this._targetCloseEventListener = () => {
      this.socksProxy._socksProxy.sendSocketEnd({ uid: this.uid });
      this.internalTLS?.destroy();
      this._dummyServer?.close();
    };
  }
  async connect() {
    if (this.socksProxy.proxyAgentFromOptions)
      this.target = await this.socksProxy.proxyAgentFromOptions.callback(new EventEmitter11(), { host: rewriteToLocalhostIfNeeded(this.host), port: this.port, secureEndpoint: false });
    else
      this.target = await createSocket(rewriteToLocalhostIfNeeded(this.host), this.port);
    this.target.once("close", this._targetCloseEventListener);
    this.target.once("error", (error4) => this.socksProxy._socksProxy.sendSocketError({ uid: this.uid, error: error4.message }));
    if (this._closed) {
      this.target.destroy();
      return;
    }
    this.socksProxy._socksProxy.socketConnected({
      uid: this.uid,
      host: this.target.localAddress,
      port: this.target.localPort
    });
  }
  onClose() {
    this.target.destroy();
    this.internalTLS?.destroy();
    this._dummyServer?.close();
    this._closed = true;
  }
  onData(data) {
    if (!this.firstPackageReceived) {
      this.firstPackageReceived = true;
      if (data[0] === 22)
        this._attachTLSListeners();
      else
        this.target.on("data", (data2) => this.socksProxy._socksProxy.sendSocketData({ uid: this.uid, data: data2 }));
    }
    if (this.internal)
      this.internal.push(data);
    else
      this.target.write(data);
  }
  _attachTLSListeners() {
    this.internal = new require$$65.Duplex({
      read: /* @__PURE__ */ __name(() => {
      }, "read"),
      write: /* @__PURE__ */ __name((data, encoding2, callback) => {
        this.socksProxy._socksProxy.sendSocketData({ uid: this.uid, data });
        callback();
      }, "write")
    });
    this.socksProxy.alpnCache.get(rewriteToLocalhostIfNeeded(this.host), this.port, (alpnProtocolChosenByServer) => {
      debugLogger.log("client-certificates", `Proxy->Target ${this.host}:${this.port} chooses ALPN ${alpnProtocolChosenByServer}`);
      if (this._closed)
        return;
      this._dummyServer = tls_default.createServer({
        ...dummyServerTlsOptions,
        ALPNProtocols: alpnProtocolChosenByServer === "h2" ? ["h2", "http/1.1"] : ["http/1.1"]
      });
      this._dummyServer.emit("connection", this.internal);
      this._dummyServer.once("secureConnection", (internalTLS) => {
        this.internalTLS = internalTLS;
        debugLogger.log("client-certificates", `Browser->Proxy ${this.host}:${this.port} chooses ALPN ${internalTLS.alpnProtocol}`);
        let targetTLS = void 0;
        const handleError = /* @__PURE__ */ __name((error4) => {
          debugLogger.log("client-certificates", `error when connecting to target: ${error4.message.replaceAll("\n", " ")}`);
          const responseBody = escapeHTML2("Playwright client-certificate error: " + error4.message).replaceAll("\n", " <br>");
          if (internalTLS?.alpnProtocol === "h2") {
            if ("performServerHandshake" in http2_default) {
              this.target.removeListener("close", this._targetCloseEventListener);
              const session2 = http2_default.performServerHandshake(internalTLS);
              session2.on("error", () => {
                this.target.destroy();
                this._targetCloseEventListener();
              });
              session2.once("stream", (stream2) => {
                stream2.respond({
                  "content-type": "text/html",
                  [http2_default.constants.HTTP2_HEADER_STATUS]: 503
                });
                const cleanup = /* @__PURE__ */ __name(() => {
                  session2.close();
                  this.target.destroy();
                  this._targetCloseEventListener();
                }, "cleanup");
                stream2.end(responseBody, cleanup);
                stream2.once("error", cleanup);
              });
            } else {
              this.target.destroy();
            }
          } else {
            internalTLS.end([
              "HTTP/1.1 503 Internal Server Error",
              "Content-Type: text/html; charset=utf-8",
              "Content-Length: " + Buffer.byteLength(responseBody),
              "",
              responseBody
            ].join("\r\n"));
            this.target.destroy();
          }
        }, "handleError");
        if (this._closed) {
          internalTLS.destroy();
          return;
        }
        targetTLS = tls_default.connect({
          socket: this.target,
          host: this.host,
          port: this.port,
          rejectUnauthorized: !this.socksProxy.ignoreHTTPSErrors,
          ALPNProtocols: [internalTLS.alpnProtocol || "http/1.1"],
          servername: !net4.isIP(this.host) ? this.host : void 0,
          secureContext: this.socksProxy.secureContextMap.get(new URL(`https://${this.host}:${this.port}`).origin)
        });
        targetTLS.once("secureConnect", () => {
          internalTLS.pipe(targetTLS);
          targetTLS.pipe(internalTLS);
        });
        internalTLS.once("error", () => this.target.destroy());
        targetTLS.once("error", handleError);
      });
    });
  }
};
var ClientCertificatesProxy = class {
  static {
    __name(this, "ClientCertificatesProxy");
  }
  constructor(contextOptions) {
    this._connections = /* @__PURE__ */ new Map();
    this.secureContextMap = /* @__PURE__ */ new Map();
    verifyClientCertificates(contextOptions.clientCertificates);
    this.alpnCache = new ALPNCache();
    this.ignoreHTTPSErrors = contextOptions.ignoreHTTPSErrors;
    this.proxyAgentFromOptions = createProxyAgent(contextOptions.proxy);
    this._initSecureContexts(contextOptions.clientCertificates);
    this._socksProxy = new SocksProxy();
    this._socksProxy.setPattern("*");
    this._socksProxy.addListener(SocksProxy.Events.SocksRequested, async (payload) => {
      try {
        const connection = new SocksProxyConnection(this, payload.uid, payload.host, payload.port);
        await connection.connect();
        this._connections.set(payload.uid, connection);
      } catch (error4) {
        this._socksProxy.socketFailed({ uid: payload.uid, errorCode: error4.code });
      }
    });
    this._socksProxy.addListener(SocksProxy.Events.SocksData, async (payload) => {
      this._connections.get(payload.uid)?.onData(payload.data);
    });
    this._socksProxy.addListener(SocksProxy.Events.SocksClosed, (payload) => {
      this._connections.get(payload.uid)?.onClose();
      this._connections.delete(payload.uid);
    });
    loadDummyServerCertsIfNeeded();
  }
  _initSecureContexts(clientCertificates) {
    const origin2certs = /* @__PURE__ */ new Map();
    for (const cert of clientCertificates || []) {
      const origin = normalizeOrigin(cert.origin);
      const certs = origin2certs.get(origin) || [];
      certs.push(cert);
      origin2certs.set(origin, certs);
    }
    for (const [origin, certs] of origin2certs) {
      try {
        this.secureContextMap.set(origin, tls_default.createSecureContext(convertClientCertificatesToTLSOptions(certs)));
      } catch (error4) {
        error4 = rewriteOpenSSLErrorIfNeeded(error4);
        throw rewriteErrorMessage(error4, `Failed to load client certificate: ${error4.message}`);
      }
    }
  }
  async listen() {
    const port = await this._socksProxy.listen(0, "127.0.0.1");
    return { server: `socks5://127.0.0.1:${port}` };
  }
  async close() {
    await this._socksProxy.close();
  }
};
function normalizeOrigin(origin) {
  try {
    return new URL(origin).origin;
  } catch (error4) {
    return origin;
  }
}
__name(normalizeOrigin, "normalizeOrigin");
function convertClientCertificatesToTLSOptions(clientCertificates) {
  if (!clientCertificates || !clientCertificates.length)
    return;
  const tlsOptions = {
    pfx: [],
    key: [],
    cert: []
  };
  for (const cert of clientCertificates) {
    if (cert.cert)
      tlsOptions.cert.push(cert.cert);
    if (cert.key)
      tlsOptions.key.push({ pem: cert.key, passphrase: cert.passphrase });
    if (cert.pfx)
      tlsOptions.pfx.push({ buf: cert.pfx, passphrase: cert.passphrase });
  }
  return tlsOptions;
}
__name(convertClientCertificatesToTLSOptions, "convertClientCertificatesToTLSOptions");
function getMatchingTLSOptionsForOrigin(clientCertificates, origin) {
  const matchingCerts = clientCertificates?.filter(
    (c) => normalizeOrigin(c.origin) === origin
  );
  return convertClientCertificatesToTLSOptions(matchingCerts);
}
__name(getMatchingTLSOptionsForOrigin, "getMatchingTLSOptionsForOrigin");
function rewriteToLocalhostIfNeeded(host) {
  return host === "local.playwright" ? "localhost" : host;
}
__name(rewriteToLocalhostIfNeeded, "rewriteToLocalhostIfNeeded");
function rewriteOpenSSLErrorIfNeeded(error4) {
  if (error4.message !== "unsupported" && error4.code !== "ERR_CRYPTO_UNSUPPORTED_OPERATION")
    return error4;
  return rewriteErrorMessage(error4, [
    "Unsupported TLS certificate.",
    "Most likely, the security algorithm of the given certificate was deprecated by OpenSSL.",
    "For more details, see https://github.com/openssl/openssl/blob/master/README-PROVIDERS.md#the-legacy-provider",
    "You could probably modernize the certificate by following the steps at https://github.com/nodejs/node/issues/40672#issuecomment-1243648223"
  ].join("\n"));
}
__name(rewriteOpenSSLErrorIfNeeded, "rewriteOpenSSLErrorIfNeeded");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/fetch.js
var APIRequestContext = class _APIRequestContext extends SdkObject {
  static {
    __name(this, "APIRequestContext");
  }
  constructor(parent) {
    super(parent, "request-context");
    this.fetchResponses = /* @__PURE__ */ new Map();
    this.fetchLog = /* @__PURE__ */ new Map();
    this._activeProgressControllers = /* @__PURE__ */ new Set();
    _APIRequestContext.allInstances.add(this);
  }
  static {
    this.Events = {
      Dispose: "dispose",
      Request: "request",
      RequestFinished: "requestfinished"
    };
  }
  static {
    this.allInstances = /* @__PURE__ */ new Set();
  }
  static findResponseBody(guid) {
    for (const request4 of _APIRequestContext.allInstances) {
      const body = request4.fetchResponses.get(guid);
      if (body)
        return body;
    }
    return void 0;
  }
  _disposeImpl() {
    _APIRequestContext.allInstances.delete(this);
    this.fetchResponses.clear();
    this.fetchLog.clear();
    this.emit(_APIRequestContext.Events.Dispose);
  }
  disposeResponse(fetchUid) {
    this.fetchResponses.delete(fetchUid);
    this.fetchLog.delete(fetchUid);
  }
  _storeResponseBody(body) {
    const uid = createGuid();
    this.fetchResponses.set(uid, body);
    return uid;
  }
  async fetch(params, metadata) {
    const defaults = this._defaultOptions();
    const headers = {
      "user-agent": defaults.userAgent,
      "accept": "*/*",
      "accept-encoding": "gzip,deflate,br"
    };
    if (defaults.extraHTTPHeaders) {
      for (const { name, value } of defaults.extraHTTPHeaders)
        setHeader(headers, name, value);
    }
    if (params.headers) {
      for (const { name, value } of params.headers)
        setHeader(headers, name, value);
    }
    const requestUrl = new URL(constructURLBasedOnBaseURL(defaults.baseURL, params.url));
    if (params.encodedParams) {
      requestUrl.search = params.encodedParams;
    } else if (params.params) {
      for (const { name, value } of params.params)
        requestUrl.searchParams.append(name, value);
    }
    const credentials = this._getHttpCredentials(requestUrl);
    if (credentials?.send === "always")
      setBasicAuthorizationHeader(headers, credentials);
    const method = params.method?.toUpperCase() || "GET";
    const proxy = defaults.proxy;
    let agent2;
    if (proxy?.server !== "per-context")
      agent2 = createProxyAgent(proxy, requestUrl);
    let maxRedirects = params.maxRedirects ?? (defaults.maxRedirects ?? 20);
    maxRedirects = maxRedirects === 0 ? -1 : maxRedirects;
    const timeout = defaults.timeoutSettings.timeout(params);
    const deadline = timeout && monotonicTime() + timeout;
    const options2 = {
      method,
      headers,
      agent: agent2,
      maxRedirects,
      timeout,
      deadline,
      ...getMatchingTLSOptionsForOrigin(this._defaultOptions().clientCertificates, requestUrl.origin),
      __testHookLookup: params.__testHookLookup
    };
    if (params.ignoreHTTPSErrors || defaults.ignoreHTTPSErrors)
      options2.rejectUnauthorized = false;
    const postData = serializePostData(params, headers);
    if (postData)
      setHeader(headers, "content-length", String(postData.byteLength));
    const controller = new ProgressController(metadata, this);
    const fetchResponse = await controller.run((progress3) => {
      return this._sendRequestWithRetries(progress3, requestUrl, options2, postData, params.maxRetries);
    });
    const fetchUid = this._storeResponseBody(fetchResponse.body);
    this.fetchLog.set(fetchUid, controller.metadata.log);
    const failOnStatusCode = params.failOnStatusCode !== void 0 ? params.failOnStatusCode : !!defaults.failOnStatusCode;
    if (failOnStatusCode && (fetchResponse.status < 200 || fetchResponse.status >= 400)) {
      let responseText = "";
      if (fetchResponse.body.byteLength) {
        let text = fetchResponse.body.toString("utf8");
        if (text.length > 1e3)
          text = text.substring(0, 997) + "...";
        responseText = `
Response text:
${text}`;
      }
      throw new Error(`${fetchResponse.status} ${fetchResponse.statusText}${responseText}`);
    }
    return { ...fetchResponse, fetchUid };
  }
  _parseSetCookieHeader(responseUrl, setCookie) {
    if (!setCookie)
      return [];
    const url4 = new URL(responseUrl);
    const defaultPath = "/" + url4.pathname.substr(1).split("/").slice(0, -1).join("/");
    const cookies = [];
    for (const header of setCookie) {
      const cookie = parseCookie2(header);
      if (!cookie)
        continue;
      if (!cookie.domain)
        cookie.domain = url4.hostname;
      else
        assert3(cookie.domain.startsWith(".") || !cookie.domain.includes("."));
      if (!domainMatches(url4.hostname, cookie.domain))
        continue;
      if (!cookie.path || !cookie.path.startsWith("/"))
        cookie.path = defaultPath;
      cookies.push(cookie);
    }
    return cookies;
  }
  async _updateRequestCookieHeader(url4, headers) {
    if (getHeader(headers, "cookie") !== void 0)
      return;
    const cookies = await this._cookies(url4);
    if (cookies.length) {
      const valueArray = cookies.map((c) => `${c.name}=${c.value}`);
      setHeader(headers, "cookie", valueArray.join("; "));
    }
  }
  async _sendRequestWithRetries(progress3, url4, options2, postData, maxRetries) {
    maxRetries ??= 0;
    let backoff = 250;
    for (let i = 0; i <= maxRetries; i++) {
      try {
        return await this._sendRequest(progress3, url4, options2, postData);
      } catch (e) {
        e = rewriteOpenSSLErrorIfNeeded(e);
        if (maxRetries === 0)
          throw e;
        if (i === maxRetries || options2.deadline && monotonicTime() + backoff > options2.deadline)
          throw new Error(`Failed after ${i + 1} attempt(s): ${e}`);
        if (e.code !== "ECONNRESET")
          throw e;
        progress3.log(`  Received ECONNRESET, will retry after ${backoff}ms.`);
        await new Promise((f) => setTimeout(f, backoff));
        backoff *= 2;
      }
    }
    throw new Error("Unreachable");
  }
  async _sendRequest(progress3, url4, options2, postData) {
    await this._updateRequestCookieHeader(url4, options2.headers);
    const requestCookies = getHeader(options2.headers, "cookie")?.split(";").map((p) => {
      const [name, value] = p.split("=").map((v) => v.trim());
      return { name, value };
    }) || [];
    const requestEvent = {
      url: url4,
      method: options2.method,
      headers: options2.headers,
      cookies: requestCookies,
      postData
    };
    this.emit(_APIRequestContext.Events.Request, requestEvent);
    return new Promise((fulfill, reject) => {
      const requestConstructor = (url4.protocol === "https:" ? https_default : http_default).request;
      const agent2 = options2.agent || (url4.protocol === "https:" ? httpsHappyEyeballsAgent : httpHappyEyeballsAgent);
      const requestOptions = { ...options2, agent: agent2 };
      const startAt = monotonicTime();
      let reusedSocketAt;
      let dnsLookupAt;
      let tcpConnectionAt;
      let tlsHandshakeAt;
      let requestFinishAt;
      let serverIPAddress;
      let serverPort;
      let securityDetails;
      const listeners2 = [];
      const request4 = requestConstructor(url4, requestOptions, async (response) => {
        const responseAt = monotonicTime();
        const notifyRequestFinished = /* @__PURE__ */ __name((body2) => {
          const endAt = monotonicTime();
          const connectEnd = tlsHandshakeAt ?? tcpConnectionAt;
          const timings = {
            send: requestFinishAt - startAt,
            wait: responseAt - requestFinishAt,
            receive: endAt - responseAt,
            dns: dnsLookupAt ? dnsLookupAt - startAt : -1,
            connect: connectEnd ? connectEnd - startAt : -1,
            // "If [ssl] is defined then the time is also included in the connect field "
            ssl: tlsHandshakeAt ? tlsHandshakeAt - tcpConnectionAt : -1,
            blocked: reusedSocketAt ? reusedSocketAt - startAt : -1
          };
          const requestFinishedEvent = {
            requestEvent,
            httpVersion: response.httpVersion,
            statusCode: response.statusCode || 0,
            statusMessage: response.statusMessage || "",
            headers: response.headers,
            rawHeaders: response.rawHeaders,
            cookies,
            body: body2,
            timings,
            serverIPAddress,
            serverPort,
            securityDetails
          };
          this.emit(_APIRequestContext.Events.RequestFinished, requestFinishedEvent);
        }, "notifyRequestFinished");
        progress3.log(`\u2190 ${response.statusCode} ${response.statusMessage}`);
        for (const [name, value] of Object.entries(response.headers))
          progress3.log(`  ${name}: ${value}`);
        const cookies = this._parseSetCookieHeader(response.url || url4.toString(), response.headers["set-cookie"]);
        if (cookies.length) {
          try {
            await this._addCookies(cookies);
          } catch (e) {
            await Promise.all(cookies.map((c) => this._addCookies([c]).catch(() => {
            })));
          }
        }
        if (redirectStatus.includes(response.statusCode) && options2.maxRedirects >= 0) {
          if (options2.maxRedirects === 0) {
            reject(new Error("Max redirect count exceeded"));
            request4.destroy();
            return;
          }
          const headers = { ...options2.headers };
          removeHeader(headers, `cookie`);
          const status = response.statusCode;
          let method = options2.method;
          if ((status === 301 || status === 302) && method === "POST" || status === 303 && !["GET", "HEAD"].includes(method)) {
            method = "GET";
            postData = void 0;
            removeHeader(headers, `content-encoding`);
            removeHeader(headers, `content-language`);
            removeHeader(headers, `content-length`);
            removeHeader(headers, `content-location`);
            removeHeader(headers, `content-type`);
          }
          const redirectOptions = {
            method,
            headers,
            agent: options2.agent,
            maxRedirects: options2.maxRedirects - 1,
            timeout: options2.timeout,
            deadline: options2.deadline,
            ...getMatchingTLSOptionsForOrigin(this._defaultOptions().clientCertificates, url4.origin),
            __testHookLookup: options2.__testHookLookup
          };
          if (options2.rejectUnauthorized === false)
            redirectOptions.rejectUnauthorized = false;
          const locationHeaderValue = Buffer.from(response.headers.location ?? "", "latin1").toString("utf8");
          if (locationHeaderValue) {
            let locationURL;
            try {
              locationURL = new URL(locationHeaderValue, url4);
            } catch (error4) {
              reject(new Error(`uri requested responds with an invalid redirect URL: ${locationHeaderValue}`));
              request4.destroy();
              return;
            }
            if (headers["host"])
              headers["host"] = locationURL.host;
            notifyRequestFinished();
            fulfill(this._sendRequest(progress3, locationURL, redirectOptions, postData));
            request4.destroy();
            return;
          }
        }
        if (response.statusCode === 401 && !getHeader(options2.headers, "authorization")) {
          const auth = response.headers["www-authenticate"];
          const credentials = this._getHttpCredentials(url4);
          if (auth?.trim().startsWith("Basic") && credentials) {
            setBasicAuthorizationHeader(options2.headers, credentials);
            notifyRequestFinished();
            fulfill(this._sendRequest(progress3, url4, options2, postData));
            request4.destroy();
            return;
          }
        }
        response.on("aborted", () => reject(new Error("aborted")));
        const chunks = [];
        const notifyBodyFinished = /* @__PURE__ */ __name(() => {
          const body2 = Buffer.concat(chunks);
          notifyRequestFinished(body2);
          fulfill({
            url: response.url || url4.toString(),
            status: response.statusCode || 0,
            statusText: response.statusMessage || "",
            headers: toHeadersArray(response.rawHeaders),
            body: body2
          });
        }, "notifyBodyFinished");
        let body = response;
        let transform2;
        const encoding2 = response.headers["content-encoding"];
        if (encoding2 === "gzip" || encoding2 === "x-gzip") {
          transform2 = zlib.createGunzip({
            flush: zlib.constants.Z_SYNC_FLUSH,
            finishFlush: zlib.constants.Z_SYNC_FLUSH
          });
        } else if (encoding2 === "br") {
          transform2 = zlib.createBrotliDecompress({
            flush: zlib.constants.BROTLI_OPERATION_FLUSH,
            finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
          });
        } else if (encoding2 === "deflate") {
          transform2 = zlib.createInflate();
        }
        if (transform2) {
          const emptyStreamTransform = new SafeEmptyStreamTransform(notifyBodyFinished);
          body = pipeline2(response, emptyStreamTransform, transform2, (e) => {
            if (e)
              reject(new Error(`failed to decompress '${encoding2}' encoding: ${e.message}`));
          });
          body.on("error", (e) => reject(new Error(`failed to decompress '${encoding2}' encoding: ${e}`)));
        } else {
          body.on("error", reject);
        }
        body.on("data", (chunk) => chunks.push(chunk));
        body.on("end", notifyBodyFinished);
      });
      request4.on("error", reject);
      listeners2.push(
        eventsHelper.addEventListener(this, _APIRequestContext.Events.Dispose, () => {
          reject(new Error("Request context disposed."));
          request4.destroy();
        })
      );
      request4.on("close", () => eventsHelper.removeEventListeners(listeners2));
      request4.on("socket", (socket) => {
        if (request4.reusedSocket) {
          reusedSocketAt = monotonicTime();
          return;
        }
        const happyEyeBallsTimings = timingForSocket(socket);
        dnsLookupAt = happyEyeBallsTimings.dnsLookupAt;
        tcpConnectionAt = happyEyeBallsTimings.tcpConnectionAt;
        listeners2.push(
          eventsHelper.addEventListener(socket, "lookup", () => {
            dnsLookupAt = monotonicTime();
          }),
          eventsHelper.addEventListener(socket, "connect", () => {
            tcpConnectionAt = monotonicTime();
          }),
          eventsHelper.addEventListener(socket, "secureConnect", () => {
            tlsHandshakeAt = monotonicTime();
            if (socket instanceof TLSSocket) {
              const peerCertificate = socket.getPeerCertificate();
              securityDetails = {
                protocol: socket.getProtocol() ?? void 0,
                subjectName: peerCertificate.subject.CN,
                validFrom: new Date(peerCertificate.valid_from).getTime() / 1e3,
                validTo: new Date(peerCertificate.valid_to).getTime() / 1e3,
                issuer: peerCertificate.issuer.CN
              };
            }
          })
        );
        serverIPAddress = socket.remoteAddress;
        serverPort = socket.remotePort;
      });
      request4.on("finish", () => {
        requestFinishAt = monotonicTime();
      });
      progress3.log(`\u2192 ${options2.method} ${url4.toString()}`);
      if (options2.headers) {
        for (const [name, value] of Object.entries(options2.headers))
          progress3.log(`  ${name}: ${value}`);
      }
      if (options2.deadline) {
        const rejectOnTimeout = /* @__PURE__ */ __name(() => {
          reject(new Error(`Request timed out after ${options2.timeout}ms`));
          request4.destroy();
        }, "rejectOnTimeout");
        const remaining = options2.deadline - monotonicTime();
        if (remaining <= 0) {
          rejectOnTimeout();
          return;
        }
        request4.setTimeout(remaining, rejectOnTimeout);
      }
      if (postData)
        request4.write(postData);
      request4.end();
    });
  }
  _getHttpCredentials(url4) {
    if (!this._defaultOptions().httpCredentials?.origin || url4.origin.toLowerCase() === this._defaultOptions().httpCredentials?.origin?.toLowerCase())
      return this._defaultOptions().httpCredentials;
    return void 0;
  }
};
var SafeEmptyStreamTransform = class extends Transform {
  static {
    __name(this, "SafeEmptyStreamTransform");
  }
  constructor(onEmptyStreamCallback) {
    super();
    this._receivedSomeData = false;
    this._onEmptyStreamCallback = onEmptyStreamCallback;
  }
  _transform(chunk, encoding2, callback) {
    this._receivedSomeData = true;
    callback(null, chunk);
  }
  _flush(callback) {
    if (this._receivedSomeData)
      callback(null);
    else
      this._onEmptyStreamCallback();
  }
};
var BrowserContextAPIRequestContext = class extends APIRequestContext {
  static {
    __name(this, "BrowserContextAPIRequestContext");
  }
  constructor(context2) {
    super(context2);
    this._context = context2;
    context2.once(BrowserContext.Events.Close, () => this._disposeImpl());
  }
  tracing() {
    return this._context.tracing;
  }
  async dispose(options2) {
    this._closeReason = options2.reason;
    this.fetchResponses.clear();
  }
  _defaultOptions() {
    return {
      userAgent: this._context._options.userAgent || this._context._browser.userAgent(),
      extraHTTPHeaders: this._context._options.extraHTTPHeaders,
      failOnStatusCode: void 0,
      httpCredentials: this._context._options.httpCredentials,
      proxy: this._context._options.proxy || this._context._browser.options.proxy,
      timeoutSettings: this._context._timeoutSettings,
      ignoreHTTPSErrors: this._context._options.ignoreHTTPSErrors,
      baseURL: this._context._options.baseURL,
      clientCertificates: this._context._options.clientCertificates
    };
  }
  async _addCookies(cookies) {
    await this._context.addCookies(cookies);
  }
  async _cookies(url4) {
    return await this._context.cookies(url4.toString());
  }
  async storageState(indexedDB2) {
    return this._context.storageState(indexedDB2);
  }
};
var GlobalAPIRequestContext = class extends APIRequestContext {
  static {
    __name(this, "GlobalAPIRequestContext");
  }
  constructor(playwright2, options2) {
    super(playwright2);
    this._cookieStore = new CookieStore();
    this.attribution.context = this;
    const timeoutSettings = new TimeoutSettings();
    if (options2.timeout !== void 0)
      timeoutSettings.setDefaultTimeout(options2.timeout);
    if (options2.storageState) {
      this._origins = options2.storageState.origins?.map((origin) => ({ indexedDB: [], ...origin }));
      this._cookieStore.addCookies(options2.storageState.cookies || []);
    }
    verifyClientCertificates(options2.clientCertificates);
    this._options = {
      baseURL: options2.baseURL,
      userAgent: options2.userAgent || getUserAgent(),
      extraHTTPHeaders: options2.extraHTTPHeaders,
      failOnStatusCode: !!options2.failOnStatusCode,
      ignoreHTTPSErrors: !!options2.ignoreHTTPSErrors,
      maxRedirects: options2.maxRedirects,
      httpCredentials: options2.httpCredentials,
      clientCertificates: options2.clientCertificates,
      proxy: options2.proxy,
      timeoutSettings
    };
    this._tracing = new Tracing(this, options2.tracesDir);
  }
  tracing() {
    return this._tracing;
  }
  async dispose(options2) {
    this._closeReason = options2.reason;
    await this._tracing.flush();
    await this._tracing.deleteTmpTracesDir();
    this._disposeImpl();
  }
  _defaultOptions() {
    return this._options;
  }
  async _addCookies(cookies) {
    this._cookieStore.addCookies(cookies);
  }
  async _cookies(url4) {
    return this._cookieStore.cookies(url4);
  }
  async storageState(indexedDB2 = false) {
    return {
      cookies: this._cookieStore.allCookies(),
      origins: (this._origins || []).map((origin) => ({ ...origin, indexedDB: indexedDB2 ? origin.indexedDB : [] }))
    };
  }
};
function toHeadersArray(rawHeaders2) {
  const result = [];
  for (let i = 0; i < rawHeaders2.length; i += 2)
    result.push({ name: rawHeaders2[i], value: rawHeaders2[i + 1] });
  return result;
}
__name(toHeadersArray, "toHeadersArray");
var redirectStatus = [301, 302, 303, 307, 308];
function parseCookie2(header) {
  const raw = parseRawCookie(header);
  if (!raw)
    return null;
  const cookie = {
    domain: "",
    path: "",
    expires: -1,
    httpOnly: false,
    secure: false,
    // From https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
    // The cookie-sending behavior if SameSite is not specified is SameSite=Lax.
    sameSite: "Lax",
    ...raw
  };
  return cookie;
}
__name(parseCookie2, "parseCookie");
function serializePostData(params, headers) {
  assert3((params.postData ? 1 : 0) + (params.jsonData ? 1 : 0) + (params.formData ? 1 : 0) + (params.multipartData ? 1 : 0) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
  if (params.jsonData !== void 0) {
    setHeader(headers, "content-type", "application/json", true);
    return Buffer.from(params.jsonData, "utf8");
  } else if (params.formData) {
    const searchParams = new URLSearchParams();
    for (const { name, value } of params.formData)
      searchParams.append(name, value);
    setHeader(headers, "content-type", "application/x-www-form-urlencoded", true);
    return Buffer.from(searchParams.toString(), "utf8");
  } else if (params.multipartData) {
    const formData = new MultipartFormData();
    for (const field of params.multipartData) {
      if (field.file)
        formData.addFileField(field.name, field.file);
      else if (field.value)
        formData.addField(field.name, field.value);
    }
    setHeader(headers, "content-type", formData.contentTypeHeader(), true);
    return formData.finish();
  } else if (params.postData !== void 0) {
    setHeader(headers, "content-type", "application/octet-stream", true);
    return params.postData;
  }
  return void 0;
}
__name(serializePostData, "serializePostData");
function setHeader(headers, name, value, keepExisting = false) {
  const existing = Object.entries(headers).find((pair) => pair[0].toLowerCase() === name.toLowerCase());
  if (!existing)
    headers[name] = value;
  else if (!keepExisting)
    headers[existing[0]] = value;
}
__name(setHeader, "setHeader");
function getHeader(headers, name) {
  const existing = Object.entries(headers).find((pair) => pair[0].toLowerCase() === name.toLowerCase());
  return existing ? existing[1] : void 0;
}
__name(getHeader, "getHeader");
function removeHeader(headers, name) {
  delete headers[name];
}
__name(removeHeader, "removeHeader");
function setBasicAuthorizationHeader(headers, credentials) {
  const { username, password } = credentials;
  const encoded = Buffer.from(`${username || ""}:${password || ""}`).toString("base64");
  setHeader(headers, "authorization", `Basic ${encoded}`);
}
__name(setBasicAuthorizationHeader, "setBasicAuthorizationHeader");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/androidDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/browserContextDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path19 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/artifactDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/streamDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var StreamDispatcher = class extends Dispatcher {
  static {
    __name(this, "StreamDispatcher");
  }
  constructor(scope, stream) {
    super(scope, { guid: "stream@" + createGuid(), stream }, "Stream", {});
    this._type_Stream = true;
    this._ended = false;
    stream.once("end", () => this._ended = true);
    stream.once("error", () => this._ended = true);
  }
  async read(params) {
    const stream = this._object.stream;
    if (this._ended)
      return { binary: Buffer.from("") };
    if (!stream.readableLength) {
      const readyPromise = new ManualPromise();
      const done = /* @__PURE__ */ __name(() => readyPromise.resolve(), "done");
      stream.on("readable", done);
      stream.on("end", done);
      stream.on("error", done);
      await readyPromise;
      stream.off("readable", done);
      stream.off("end", done);
      stream.off("error", done);
    }
    const buffer2 = stream.read(Math.min(stream.readableLength, params.size || stream.readableLength));
    return { binary: buffer2 || Buffer.from("") };
  }
  async close() {
    this._object.stream.destroy();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/artifactDispatcher.js
var ArtifactDispatcher = class _ArtifactDispatcher extends Dispatcher {
  static {
    __name(this, "ArtifactDispatcher");
  }
  constructor(scope, artifact) {
    super(scope, artifact, "Artifact", {
      absolutePath: artifact.localPath()
    });
    this._type_Artifact = true;
  }
  static from(parentScope, artifact) {
    return _ArtifactDispatcher.fromNullable(parentScope, artifact);
  }
  static fromNullable(parentScope, artifact) {
    if (!artifact)
      return void 0;
    const result = existingDispatcher(artifact);
    return result || new _ArtifactDispatcher(parentScope, artifact);
  }
  async pathAfterFinished() {
    const path31 = await this._object.localPathAfterFinished();
    return { value: path31 };
  }
  async saveAs(params) {
    return await new Promise((resolve, reject) => {
      this._object.saveAs(async (localPath, error4) => {
        if (error4) {
          reject(error4);
          return;
        }
        try {
          await mkdirIfNeeded(params.path);
          await fs.promises.copyFile(localPath, params.path);
          resolve();
        } catch (e) {
          reject(e);
        }
      });
    });
  }
  async saveAsStream() {
    return await new Promise((resolve, reject) => {
      this._object.saveAs(async (localPath, error4) => {
        if (error4) {
          reject(error4);
          return;
        }
        try {
          const readable = fs.createReadStream(localPath, { highWaterMark: 1024 * 1024 });
          const stream = new StreamDispatcher(this, readable);
          resolve({ stream });
          await new Promise((resolve2) => {
            readable.on("close", resolve2);
            readable.on("end", resolve2);
            readable.on("error", resolve2);
          });
        } catch (e) {
          reject(e);
        }
      });
    });
  }
  async stream() {
    const fileName = await this._object.localPathAfterFinished();
    const readable = fs.createReadStream(fileName, { highWaterMark: 1024 * 1024 });
    return { stream: new StreamDispatcher(this, readable) };
  }
  async failure() {
    const error4 = await this._object.failureError();
    return { error: error4 || void 0 };
  }
  async cancel() {
    await this._object.cancel();
  }
  async delete(_, metadata) {
    metadata.potentiallyClosesScope = true;
    await this._object.delete();
    this._dispose();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/cdpSessionDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crConnection.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter12 } from "node:events";
import "node:path";
import "node:url";
var ConnectionEvents = {
  Disconnected: Symbol("ConnectionEvents.Disconnected")
};
var kBrowserCloseMessageId = -9999;
var CRConnection = class extends EventEmitter12 {
  static {
    __name(this, "CRConnection");
  }
  constructor(transport, protocolLogger, browserLogsCollector) {
    super();
    this._lastId = 0;
    this._sessions = /* @__PURE__ */ new Map();
    this._closed = false;
    this.setMaxListeners(0);
    this._transport = transport;
    this._protocolLogger = protocolLogger;
    this._browserLogsCollector = browserLogsCollector;
    this.rootSession = new CRSession(this, null, "");
    this._sessions.set("", this.rootSession);
    this._transport.onmessage = this._onMessage.bind(this);
    this._transport.onclose = this._onClose.bind(this);
  }
  _rawSend(sessionId, method, params) {
    const id = ++this._lastId;
    const message = { id, method, params };
    if (sessionId)
      message.sessionId = sessionId;
    this._protocolLogger("send", message);
    this._transport.send(message);
    return id;
  }
  async _onMessage(message) {
    this._protocolLogger("receive", message);
    if (message.id === kBrowserCloseMessageId)
      return;
    const session2 = this._sessions.get(message.sessionId || "");
    if (session2)
      session2._onMessage(message);
  }
  _onClose(reason) {
    this._closed = true;
    this._transport.onmessage = void 0;
    this._transport.onclose = void 0;
    this._browserDisconnectedLogs = helper.formatBrowserLogs(this._browserLogsCollector.recentLogs(), reason);
    this.rootSession.dispose();
    Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));
  }
  close() {
    if (!this._closed)
      this._transport.close();
  }
  async createBrowserSession() {
    const { sessionId } = await this.rootSession.send("Target.attachToBrowserTarget");
    return new CDPSession(this.rootSession, sessionId);
  }
};
var CRSession = class _CRSession extends EventEmitter12 {
  static {
    __name(this, "CRSession");
  }
  constructor(connection, parentSession, sessionId, eventListener) {
    super();
    this._callbacks = /* @__PURE__ */ new Map();
    this._crashed = false;
    this._closed = false;
    this.setMaxListeners(0);
    this._connection = connection;
    this._parentSession = parentSession;
    this._sessionId = sessionId;
    this._eventListener = eventListener;
    this.on = super.on;
    this.addListener = super.addListener;
    this.off = super.removeListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }
  _markAsCrashed() {
    this._crashed = true;
  }
  createChildSession(sessionId, eventListener) {
    const session2 = new _CRSession(this._connection, this, sessionId, eventListener);
    this._connection._sessions.set(sessionId, session2);
    return session2;
  }
  async send(method, params) {
    if (this._crashed || this._closed || this._connection._closed || this._connection._browserDisconnectedLogs)
      throw new ProtocolError(this._crashed ? "crashed" : "closed", void 0, this._connection._browserDisconnectedLogs);
    const id = this._connection._rawSend(this._sessionId, method, params);
    return new Promise((resolve, reject) => {
      this._callbacks.set(id, { resolve, reject, error: new ProtocolError("error", method) });
    });
  }
  _sendMayFail(method, params) {
    return this.send(method, params).catch((error4) => debugLogger.log("error", error4));
  }
  _onMessage(object) {
    if (object.id && this._callbacks.has(object.id)) {
      const callback = this._callbacks.get(object.id);
      this._callbacks.delete(object.id);
      if (object.error) {
        callback.error.setMessage(object.error.message);
        callback.reject(callback.error);
      } else {
        callback.resolve(object.result);
      }
    } else if (object.id && object.error?.code === -32001) ;
    else {
      assert3(!object.id, object?.error?.message || void 0);
      Promise.resolve().then(() => {
        if (this._eventListener)
          this._eventListener(object.method, object.params);
        this.emit(object.method, object.params);
      });
    }
  }
  async detach() {
    if (this._closed)
      throw new Error(`Session already detached. Most likely the page has been closed.`);
    if (!this._parentSession)
      throw new Error("Root session cannot be closed");
    await this._sendMayFail("Runtime.runIfWaitingForDebugger");
    await this._parentSession.send("Target.detachFromTarget", { sessionId: this._sessionId });
    this.dispose();
  }
  dispose() {
    this._closed = true;
    this._connection._sessions.delete(this._sessionId);
    for (const callback of this._callbacks.values()) {
      callback.error.setMessage(`Internal server error, session closed.`);
      callback.error.type = this._crashed ? "crashed" : "closed";
      callback.error.logs = this._connection._browserDisconnectedLogs;
      callback.reject(callback.error);
    }
    this._callbacks.clear();
  }
};
var CDPSession = class _CDPSession extends EventEmitter12 {
  static {
    __name(this, "CDPSession");
  }
  constructor(parentSession, sessionId) {
    super();
    this._listeners = [];
    this.guid = `cdp-session@${sessionId}`;
    this._session = parentSession.createChildSession(sessionId, (method, params) => this.emit(_CDPSession.Events.Event, { method, params }));
    this._listeners = [eventsHelper.addEventListener(parentSession, "Target.detachedFromTarget", (event) => {
      if (event.sessionId === sessionId)
        this._onClose();
    })];
  }
  static {
    this.Events = {
      Event: "event",
      Closed: "close"
    };
  }
  async send(method, params) {
    return await this._session.send(method, params);
  }
  async detach() {
    return await this._session.detach();
  }
  async attachToTarget(targetId) {
    const { sessionId } = await this.send("Target.attachToTarget", { targetId, flatten: true });
    return new _CDPSession(this._session, sessionId);
  }
  _onClose() {
    eventsHelper.removeEventListeners(this._listeners);
    this._session.dispose();
    this.emit(_CDPSession.Events.Closed);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/cdpSessionDispatcher.js
var CDPSessionDispatcher = class extends Dispatcher {
  static {
    __name(this, "CDPSessionDispatcher");
  }
  constructor(scope, cdpSession) {
    super(scope, cdpSession, "CDPSession", {});
    this._type_CDPSession = true;
    this.addObjectListener(CDPSession.Events.Event, ({ method, params }) => this._dispatchEvent("event", { method, params }));
    this.addObjectListener(CDPSession.Events.Closed, () => this._dispose());
  }
  async send(params) {
    return { result: await this._object.send(params.method, params.params) };
  }
  async detach(_, metadata) {
    metadata.potentiallyClosesScope = true;
    await this._object.detach();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/dialogDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/pageDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/elementHandlerDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/frameDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/jsHandleDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JSHandleDispatcher = class extends Dispatcher {
  static {
    __name(this, "JSHandleDispatcher");
  }
  constructor(scope, jsHandle) {
    super(scope, jsHandle, jsHandle.asElement() ? "ElementHandle" : "JSHandle", {
      preview: jsHandle.toString()
    });
    this._type_JSHandle = true;
    jsHandle._setPreviewCallback((preview) => this._dispatchEvent("previewUpdated", { preview }));
  }
  async evaluateExpression(params) {
    return { value: serializeResult(await this._object.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg))) };
  }
  async evaluateExpressionHandle(params) {
    const jsHandle = await this._object.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg));
    return { handle: ElementHandleDispatcher.fromJSHandle(this.parentScope(), jsHandle) };
  }
  async getProperty(params) {
    const jsHandle = await this._object.getProperty(params.name);
    return { handle: ElementHandleDispatcher.fromJSHandle(this.parentScope(), jsHandle) };
  }
  async getPropertyList() {
    const map2 = await this._object.getProperties();
    const properties = [];
    for (const [name, value] of map2)
      properties.push({ name, value: ElementHandleDispatcher.fromJSHandle(this.parentScope(), value) });
    return { properties };
  }
  async jsonValue() {
    return { value: serializeResult(await this._object.jsonValue()) };
  }
  async dispose(_, metadata) {
    metadata.potentiallyClosesScope = true;
    this._object.dispose();
    this._dispose();
  }
};
function parseArgument(arg) {
  return parseSerializedValue(arg.value, arg.handles.map((a) => a._object));
}
__name(parseArgument, "parseArgument");
function serializeResult(arg) {
  return serializeValue(arg, (value) => ({ fallThrough: value }));
}
__name(serializeResult, "serializeResult");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/networkDispatchers.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/tracingDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TracingDispatcher = class _TracingDispatcher extends Dispatcher {
  static {
    __name(this, "TracingDispatcher");
  }
  constructor(scope, tracing) {
    super(scope, tracing, "Tracing", {});
    this._type_Tracing = true;
  }
  static from(scope, tracing) {
    const result = existingDispatcher(tracing);
    return result || new _TracingDispatcher(scope, tracing);
  }
  async tracingStart(params) {
    await this._object.start(params);
  }
  async tracingStartChunk(params) {
    return await this._object.startChunk(params);
  }
  async tracingGroup(params, metadata) {
    const { name, location: location2 } = params;
    await this._object.group(name, location2, metadata);
  }
  async tracingGroupEnd(params) {
    await this._object.groupEnd();
  }
  async tracingStopChunk(params) {
    const { artifact, entries } = await this._object.stopChunk(params);
    return { artifact: artifact ? ArtifactDispatcher.from(this, artifact) : void 0, entries };
  }
  async tracingStop(params) {
    await this._object.stop();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/networkDispatchers.js
var RequestDispatcher = class _RequestDispatcher extends Dispatcher {
  static {
    __name(this, "RequestDispatcher");
  }
  static from(scope, request4) {
    const result = existingDispatcher(request4);
    return result || new _RequestDispatcher(scope, request4);
  }
  static fromNullable(scope, request4) {
    return request4 ? _RequestDispatcher.from(scope, request4) : void 0;
  }
  constructor(scope, request4) {
    const postData = request4.postDataBuffer();
    const frame = request4.frame();
    const page = request4.frame()?._page;
    const pageDispatcher = page ? existingDispatcher(page) : null;
    const frameDispatcher = frame ? FrameDispatcher.from(scope, frame) : null;
    super(pageDispatcher || frameDispatcher || scope, request4, "Request", {
      frame: FrameDispatcher.fromNullable(scope, request4.frame()),
      serviceWorker: WorkerDispatcher.fromNullable(scope, request4.serviceWorker()),
      url: request4.url(),
      resourceType: request4.resourceType(),
      method: request4.method(),
      postData: postData === null ? void 0 : postData,
      headers: request4.headers(),
      isNavigationRequest: request4.isNavigationRequest(),
      redirectedFrom: _RequestDispatcher.fromNullable(scope, request4.redirectedFrom())
    });
    this._type_Request = true;
    this._browserContextDispatcher = scope;
  }
  async rawRequestHeaders(params) {
    return { headers: await this._object.rawRequestHeaders() };
  }
  async response() {
    return { response: ResponseDispatcher.fromNullable(this._browserContextDispatcher, await this._object.response()) };
  }
};
var ResponseDispatcher = class _ResponseDispatcher extends Dispatcher {
  static {
    __name(this, "ResponseDispatcher");
  }
  constructor(scope, response) {
    super(scope, response, "Response", {
      // TODO: responses in popups can point to non-reported requests.
      request: scope,
      url: response.url(),
      status: response.status(),
      statusText: response.statusText(),
      headers: response.headers(),
      timing: response.timing(),
      fromServiceWorker: response.fromServiceWorker()
    });
    this._type_Response = true;
  }
  static from(scope, response) {
    const result = existingDispatcher(response);
    const requestDispatcher = RequestDispatcher.from(scope, response.request());
    return result || new _ResponseDispatcher(requestDispatcher, response);
  }
  static fromNullable(scope, response) {
    return response ? _ResponseDispatcher.from(scope, response) : void 0;
  }
  async body() {
    return { binary: await this._object.body() };
  }
  async securityDetails() {
    return { value: await this._object.securityDetails() || void 0 };
  }
  async serverAddr() {
    return { value: await this._object.serverAddr() || void 0 };
  }
  async rawResponseHeaders(params) {
    return { headers: await this._object.rawResponseHeaders() };
  }
  async sizes(params) {
    return { sizes: await this._object.sizes() };
  }
};
var RouteDispatcher = class _RouteDispatcher extends Dispatcher {
  static {
    __name(this, "RouteDispatcher");
  }
  constructor(scope, route) {
    super(scope, route, "Route", {
      // Context route can point to a non-reported request, so we send the request in the initializer.
      request: scope
    });
    this._type_Route = true;
  }
  static from(scope, route) {
    const result = existingDispatcher(route);
    return result || new _RouteDispatcher(scope, route);
  }
  async continue(params, metadata) {
    await this._object.continue({
      url: params.url,
      method: params.method,
      headers: params.headers,
      postData: params.postData,
      isFallback: params.isFallback
    });
  }
  async fulfill(params, metadata) {
    await this._object.fulfill(params);
  }
  async abort(params, metadata) {
    await this._object.abort(params.errorCode || "failed");
  }
  async redirectNavigationRequest(params) {
    await this._object.redirectNavigationRequest(params.url);
  }
};
var WebSocketDispatcher = class extends Dispatcher {
  static {
    __name(this, "WebSocketDispatcher");
  }
  constructor(scope, webSocket) {
    super(scope, webSocket, "WebSocket", {
      url: webSocket.url()
    });
    this._type_EventTarget = true;
    this._type_WebSocket = true;
    this.addObjectListener(WebSocket3.Events.FrameSent, (event) => this._dispatchEvent("frameSent", event));
    this.addObjectListener(WebSocket3.Events.FrameReceived, (event) => this._dispatchEvent("frameReceived", event));
    this.addObjectListener(WebSocket3.Events.SocketError, (error4) => this._dispatchEvent("socketError", { error: error4 }));
    this.addObjectListener(WebSocket3.Events.Close, () => this._dispatchEvent("close", {}));
  }
};
var APIRequestContextDispatcher = class _APIRequestContextDispatcher extends Dispatcher {
  static {
    __name(this, "APIRequestContextDispatcher");
  }
  constructor(parentScope, request4) {
    const tracing = TracingDispatcher.from(parentScope, request4.tracing());
    super(parentScope, request4, "APIRequestContext", {
      tracing
    });
    this._type_APIRequestContext = true;
    this.adopt(tracing);
  }
  static from(scope, request4) {
    const result = existingDispatcher(request4);
    return result || new _APIRequestContextDispatcher(scope, request4);
  }
  static fromNullable(scope, request4) {
    return request4 ? _APIRequestContextDispatcher.from(scope, request4) : void 0;
  }
  async storageState(params) {
    return this._object.storageState(params.indexedDB);
  }
  async dispose(params, metadata) {
    metadata.potentiallyClosesScope = true;
    await this._object.dispose(params);
    this._dispose();
  }
  async fetch(params, metadata) {
    const fetchResponse = await this._object.fetch(params, metadata);
    return {
      response: {
        url: fetchResponse.url,
        status: fetchResponse.status,
        statusText: fetchResponse.statusText,
        headers: fetchResponse.headers,
        fetchUid: fetchResponse.fetchUid
      }
    };
  }
  async fetchResponseBody(params) {
    return { binary: this._object.fetchResponses.get(params.fetchUid) };
  }
  async fetchLog(params) {
    const log4 = this._object.fetchLog.get(params.fetchUid) || [];
    return { log: log4 };
  }
  async disposeAPIResponse(params) {
    this._object.disposeResponse(params.fetchUid);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/ariaSnapshot.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseAriaSnapshotUnsafe(yaml3, text) {
  const result = parseAriaSnapshot(yaml3, text);
  if (result.errors.length)
    throw new Error(result.errors[0].message);
  return result.fragment;
}
__name(parseAriaSnapshotUnsafe, "parseAriaSnapshotUnsafe");
function parseAriaSnapshot(yaml3, text, options2 = {}) {
  const lineCounter = new yaml3.LineCounter();
  const parseOptions2 = {
    keepSourceTokens: true,
    lineCounter,
    ...options2
  };
  const yamlDoc = yaml3.parseDocument(text, parseOptions2);
  const errors3 = [];
  const convertRange = /* @__PURE__ */ __name((range) => {
    return [lineCounter.linePos(range[0]), lineCounter.linePos(range[1])];
  }, "convertRange");
  const addError = /* @__PURE__ */ __name((error4) => {
    errors3.push({
      message: error4.message,
      range: [lineCounter.linePos(error4.pos[0]), lineCounter.linePos(error4.pos[1])]
    });
  }, "addError");
  const convertSeq = /* @__PURE__ */ __name((container, seq2) => {
    for (const item of seq2.items) {
      const itemIsString = item instanceof yaml3.Scalar && typeof item.value === "string";
      if (itemIsString) {
        const childNode = KeyParser.parse(item, parseOptions2, errors3);
        if (childNode) {
          container.children = container.children || [];
          container.children.push(childNode);
        }
        continue;
      }
      const itemIsMap = item instanceof yaml3.YAMLMap;
      if (itemIsMap) {
        convertMap(container, item);
        continue;
      }
      errors3.push({
        message: "Sequence items should be strings or maps",
        range: convertRange(item.range || seq2.range)
      });
    }
  }, "convertSeq");
  const convertMap = /* @__PURE__ */ __name((container, map2) => {
    for (const entry of map2.items) {
      container.children = container.children || [];
      const keyIsString = entry.key instanceof yaml3.Scalar && typeof entry.key.value === "string";
      if (!keyIsString) {
        errors3.push({
          message: "Only string keys are supported",
          range: convertRange(entry.key.range || map2.range)
        });
        continue;
      }
      const key = entry.key;
      const value = entry.value;
      if (key.value === "text") {
        const valueIsString = value instanceof yaml3.Scalar && typeof value.value === "string";
        if (!valueIsString) {
          errors3.push({
            message: "Text value should be a string",
            range: convertRange(entry.value.range || map2.range)
          });
          continue;
        }
        container.children.push({
          kind: "text",
          text: valueOrRegex(value.value)
        });
        continue;
      }
      if (key.value === "/children") {
        const valueIsString = value instanceof yaml3.Scalar && typeof value.value === "string";
        if (!valueIsString || value.value !== "contain" && value.value !== "equal" && value.value !== "deep-equal") {
          errors3.push({
            message: 'Strict value should be "contain", "equal" or "deep-equal"',
            range: convertRange(entry.value.range || map2.range)
          });
          continue;
        }
        container.containerMode = value.value;
        continue;
      }
      if (key.value.startsWith("/")) {
        const valueIsString = value instanceof yaml3.Scalar && typeof value.value === "string";
        if (!valueIsString) {
          errors3.push({
            message: "Property value should be a string",
            range: convertRange(entry.value.range || map2.range)
          });
          continue;
        }
        container.props = container.props ?? {};
        container.props[key.value.slice(1)] = valueOrRegex(value.value);
        continue;
      }
      const childNode = KeyParser.parse(key, parseOptions2, errors3);
      if (!childNode)
        continue;
      const valueIsScalar = value instanceof yaml3.Scalar;
      if (valueIsScalar) {
        const type2 = typeof value.value;
        if (type2 !== "string" && type2 !== "number" && type2 !== "boolean") {
          errors3.push({
            message: "Node value should be a string or a sequence",
            range: convertRange(entry.value.range || map2.range)
          });
          continue;
        }
        container.children.push({
          ...childNode,
          children: [{
            kind: "text",
            text: valueOrRegex(String(value.value))
          }]
        });
        continue;
      }
      const valueIsSequence = value instanceof yaml3.YAMLSeq;
      if (valueIsSequence) {
        container.children.push(childNode);
        convertSeq(childNode, value);
        continue;
      }
      errors3.push({
        message: "Map values should be strings or sequences",
        range: convertRange(entry.value.range || map2.range)
      });
    }
  }, "convertMap");
  const fragment = { kind: "role", role: "fragment" };
  yamlDoc.errors.forEach(addError);
  if (errors3.length)
    return { errors: errors3, fragment };
  if (!(yamlDoc.contents instanceof yaml3.YAMLSeq)) {
    errors3.push({
      message: 'Aria snapshot must be a YAML sequence, elements starting with " -"',
      range: yamlDoc.contents ? convertRange(yamlDoc.contents.range) : [{ line: 0, col: 0 }, { line: 0, col: 0 }]
    });
  }
  if (errors3.length)
    return { errors: errors3, fragment };
  convertSeq(fragment, yamlDoc.contents);
  if (errors3.length)
    return { errors: errors3, fragment: emptyFragment };
  if (fragment.children?.length === 1)
    return { fragment: fragment.children[0], errors: errors3 };
  return { fragment, errors: errors3 };
}
__name(parseAriaSnapshot, "parseAriaSnapshot");
var emptyFragment = { kind: "role", role: "fragment" };
function normalizeWhitespace(text) {
  return text.replace(/[\u200b\u00ad]/g, "").replace(/[\r\n\s\t]+/g, " ").trim();
}
__name(normalizeWhitespace, "normalizeWhitespace");
function valueOrRegex(value) {
  return value.startsWith("/") && value.endsWith("/") && value.length > 1 ? { pattern: value.slice(1, -1) } : normalizeWhitespace(value);
}
__name(valueOrRegex, "valueOrRegex");
var KeyParser = class _KeyParser {
  static {
    __name(this, "KeyParser");
  }
  static parse(text, options2, errors3) {
    try {
      return new _KeyParser(text.value)._parse();
    } catch (e) {
      if (e instanceof ParserError) {
        const message = options2.prettyErrors === false ? e.message : e.message + ":\n\n" + text.value + "\n" + " ".repeat(e.pos) + "^\n";
        errors3.push({
          message,
          range: [options2.lineCounter.linePos(text.range[0]), options2.lineCounter.linePos(text.range[0] + e.pos)]
        });
        return null;
      }
      throw e;
    }
  }
  constructor(input) {
    this._input = input;
    this._pos = 0;
    this._length = input.length;
  }
  _peek() {
    return this._input[this._pos] || "";
  }
  _next() {
    if (this._pos < this._length)
      return this._input[this._pos++];
    return null;
  }
  _eof() {
    return this._pos >= this._length;
  }
  _isWhitespace() {
    return !this._eof() && /\s/.test(this._peek());
  }
  _skipWhitespace() {
    while (this._isWhitespace())
      this._pos++;
  }
  _readIdentifier(type2) {
    if (this._eof())
      this._throwError(`Unexpected end of input when expecting ${type2}`);
    const start = this._pos;
    while (!this._eof() && /[a-zA-Z]/.test(this._peek()))
      this._pos++;
    return this._input.slice(start, this._pos);
  }
  _readString() {
    let result = "";
    let escaped2 = false;
    while (!this._eof()) {
      const ch = this._next();
      if (escaped2) {
        result += ch;
        escaped2 = false;
      } else if (ch === "\\") {
        escaped2 = true;
      } else if (ch === '"') {
        return result;
      } else {
        result += ch;
      }
    }
    this._throwError("Unterminated string");
  }
  _throwError(message, offset = 0) {
    throw new ParserError(message, offset || this._pos);
  }
  _readRegex() {
    let result = "";
    let escaped2 = false;
    let insideClass = false;
    while (!this._eof()) {
      const ch = this._next();
      if (escaped2) {
        result += ch;
        escaped2 = false;
      } else if (ch === "\\") {
        escaped2 = true;
        result += ch;
      } else if (ch === "/" && !insideClass) {
        return { pattern: result };
      } else if (ch === "[") {
        insideClass = true;
        result += ch;
      } else if (ch === "]" && insideClass) {
        result += ch;
        insideClass = false;
      } else {
        result += ch;
      }
    }
    this._throwError("Unterminated regex");
  }
  _readStringOrRegex() {
    const ch = this._peek();
    if (ch === '"') {
      this._next();
      return normalizeWhitespace(this._readString());
    }
    if (ch === "/") {
      this._next();
      return this._readRegex();
    }
    return null;
  }
  _readAttributes(result) {
    let errorPos = this._pos;
    while (true) {
      this._skipWhitespace();
      if (this._peek() === "[") {
        this._next();
        this._skipWhitespace();
        errorPos = this._pos;
        const flagName = this._readIdentifier("attribute");
        this._skipWhitespace();
        let flagValue = "";
        if (this._peek() === "=") {
          this._next();
          this._skipWhitespace();
          errorPos = this._pos;
          while (this._peek() !== "]" && !this._isWhitespace() && !this._eof())
            flagValue += this._next();
        }
        this._skipWhitespace();
        if (this._peek() !== "]")
          this._throwError("Expected ]");
        this._next();
        this._applyAttribute(result, flagName, flagValue || "true", errorPos);
      } else {
        break;
      }
    }
  }
  _parse() {
    this._skipWhitespace();
    const role = this._readIdentifier("role");
    this._skipWhitespace();
    const name = this._readStringOrRegex() || "";
    const result = { kind: "role", role, name };
    this._readAttributes(result);
    this._skipWhitespace();
    if (!this._eof())
      this._throwError("Unexpected input");
    return result;
  }
  _applyAttribute(node2, key, value, errorPos) {
    if (key === "checked") {
      this._assert(value === "true" || value === "false" || value === "mixed", 'Value of "checked" attribute must be a boolean or "mixed"', errorPos);
      node2.checked = value === "true" ? true : value === "false" ? false : "mixed";
      return;
    }
    if (key === "disabled") {
      this._assert(value === "true" || value === "false", 'Value of "disabled" attribute must be a boolean', errorPos);
      node2.disabled = value === "true";
      return;
    }
    if (key === "expanded") {
      this._assert(value === "true" || value === "false", 'Value of "expanded" attribute must be a boolean', errorPos);
      node2.expanded = value === "true";
      return;
    }
    if (key === "level") {
      this._assert(!isNaN(Number(value)), 'Value of "level" attribute must be a number', errorPos);
      node2.level = Number(value);
      return;
    }
    if (key === "pressed") {
      this._assert(value === "true" || value === "false" || value === "mixed", 'Value of "pressed" attribute must be a boolean or "mixed"', errorPos);
      node2.pressed = value === "true" ? true : value === "false" ? false : "mixed";
      return;
    }
    if (key === "selected") {
      this._assert(value === "true" || value === "false", 'Value of "selected" attribute must be a boolean', errorPos);
      node2.selected = value === "true";
      return;
    }
    this._assert(false, `Unsupported attribute [${key}]`, errorPos);
  }
  _assert(value, message, valuePos) {
    if (!value)
      this._throwError(message || "Assertion error", valuePos);
  }
};
var ParserError = class extends Error {
  static {
    __name(this, "ParserError");
  }
  constructor(message, pos) {
    super(message);
    this.pos = pos;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/frameDispatcher.js
var FrameDispatcher = class _FrameDispatcher extends Dispatcher {
  static {
    __name(this, "FrameDispatcher");
  }
  constructor(scope, frame) {
    const gcBucket = frame._page.mainFrame() === frame ? "MainFrame" : "Frame";
    const pageDispatcher = existingDispatcher(frame._page);
    super(pageDispatcher || scope, frame, "Frame", {
      url: frame.url(),
      name: frame.name(),
      parentFrame: _FrameDispatcher.fromNullable(scope, frame.parentFrame()),
      loadStates: Array.from(frame._firedLifecycleEvents)
    }, gcBucket);
    this._type_Frame = true;
    this._browserContextDispatcher = scope;
    this._frame = frame;
    this.addObjectListener(Frame.Events.AddLifecycle, (lifecycleEvent) => {
      this._dispatchEvent("loadstate", { add: lifecycleEvent });
    });
    this.addObjectListener(Frame.Events.RemoveLifecycle, (lifecycleEvent) => {
      this._dispatchEvent("loadstate", { remove: lifecycleEvent });
    });
    this.addObjectListener(Frame.Events.InternalNavigation, (event) => {
      if (!event.isPublic)
        return;
      const params = { url: event.url, name: event.name, error: event.error ? event.error.message : void 0 };
      if (event.newDocument)
        params.newDocument = { request: RequestDispatcher.fromNullable(this._browserContextDispatcher, event.newDocument.request || null) };
      this._dispatchEvent("navigated", params);
    });
  }
  static from(scope, frame) {
    const result = existingDispatcher(frame);
    return result || new _FrameDispatcher(scope, frame);
  }
  static fromNullable(scope, frame) {
    if (!frame)
      return;
    return _FrameDispatcher.from(scope, frame);
  }
  async goto(params, metadata) {
    return { response: ResponseDispatcher.fromNullable(this._browserContextDispatcher, await this._frame.goto(metadata, params.url, params)) };
  }
  async frameElement() {
    return { element: ElementHandleDispatcher.from(this, await this._frame.frameElement()) };
  }
  async evaluateExpression(params, metadata) {
    return { value: serializeResult(await this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg))) };
  }
  async evaluateExpressionHandle(params, metadata) {
    return { handle: ElementHandleDispatcher.fromJSHandle(this, await this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg))) };
  }
  async waitForSelector(params, metadata) {
    return { element: ElementHandleDispatcher.fromNullable(this, await this._frame.waitForSelector(metadata, params.selector, params)) };
  }
  async dispatchEvent(params, metadata) {
    return this._frame.dispatchEvent(metadata, params.selector, params.type, parseArgument(params.eventInit), params);
  }
  async evalOnSelector(params, metadata) {
    return { value: serializeResult(await this._frame.evalOnSelector(params.selector, !!params.strict, params.expression, params.isFunction, parseArgument(params.arg))) };
  }
  async evalOnSelectorAll(params, metadata) {
    return { value: serializeResult(await this._frame.evalOnSelectorAll(params.selector, params.expression, params.isFunction, parseArgument(params.arg))) };
  }
  async querySelector(params, metadata) {
    return { element: ElementHandleDispatcher.fromNullable(this, await this._frame.querySelector(params.selector, params)) };
  }
  async querySelectorAll(params, metadata) {
    const elements = await this._frame.querySelectorAll(params.selector);
    return { elements: elements.map((e) => ElementHandleDispatcher.from(this, e)) };
  }
  async queryCount(params) {
    return { value: await this._frame.queryCount(params.selector) };
  }
  async content() {
    return { value: await this._frame.content() };
  }
  async setContent(params, metadata) {
    return await this._frame.setContent(metadata, params.html, params);
  }
  async addScriptTag(params, metadata) {
    return { element: ElementHandleDispatcher.from(this, await this._frame.addScriptTag(params)) };
  }
  async addStyleTag(params, metadata) {
    return { element: ElementHandleDispatcher.from(this, await this._frame.addStyleTag(params)) };
  }
  async click(params, metadata) {
    metadata.potentiallyClosesScope = true;
    return await this._frame.click(metadata, params.selector, params);
  }
  async dblclick(params, metadata) {
    return await this._frame.dblclick(metadata, params.selector, params);
  }
  async dragAndDrop(params, metadata) {
    return await this._frame.dragAndDrop(metadata, params.source, params.target, params);
  }
  async tap(params, metadata) {
    return await this._frame.tap(metadata, params.selector, params);
  }
  async fill(params, metadata) {
    return await this._frame.fill(metadata, params.selector, params.value, params);
  }
  async focus(params, metadata) {
    await this._frame.focus(metadata, params.selector, params);
  }
  async blur(params, metadata) {
    await this._frame.blur(metadata, params.selector, params);
  }
  async textContent(params, metadata) {
    const value = await this._frame.textContent(metadata, params.selector, params);
    return { value: value === null ? void 0 : value };
  }
  async innerText(params, metadata) {
    return { value: await this._frame.innerText(metadata, params.selector, params) };
  }
  async innerHTML(params, metadata) {
    return { value: await this._frame.innerHTML(metadata, params.selector, params) };
  }
  async getAttribute(params, metadata) {
    const value = await this._frame.getAttribute(metadata, params.selector, params.name, params);
    return { value: value === null ? void 0 : value };
  }
  async inputValue(params, metadata) {
    const value = await this._frame.inputValue(metadata, params.selector, params);
    return { value };
  }
  async isChecked(params, metadata) {
    return { value: await this._frame.isChecked(metadata, params.selector, params) };
  }
  async isDisabled(params, metadata) {
    return { value: await this._frame.isDisabled(metadata, params.selector, params) };
  }
  async isEditable(params, metadata) {
    return { value: await this._frame.isEditable(metadata, params.selector, params) };
  }
  async isEnabled(params, metadata) {
    return { value: await this._frame.isEnabled(metadata, params.selector, params) };
  }
  async isHidden(params, metadata) {
    return { value: await this._frame.isHidden(metadata, params.selector, params) };
  }
  async isVisible(params, metadata) {
    return { value: await this._frame.isVisible(metadata, params.selector, params) };
  }
  async hover(params, metadata) {
    return await this._frame.hover(metadata, params.selector, params);
  }
  async selectOption(params, metadata) {
    const elements = (params.elements || []).map((e) => e._elementHandle);
    return { values: await this._frame.selectOption(metadata, params.selector, elements, params.options || [], params) };
  }
  async setInputFiles(params, metadata) {
    return await this._frame.setInputFiles(metadata, params.selector, params);
  }
  async type(params, metadata) {
    return await this._frame.type(metadata, params.selector, params.text, params);
  }
  async press(params, metadata) {
    return await this._frame.press(metadata, params.selector, params.key, params);
  }
  async check(params, metadata) {
    return await this._frame.check(metadata, params.selector, params);
  }
  async uncheck(params, metadata) {
    return await this._frame.uncheck(metadata, params.selector, params);
  }
  async waitForTimeout(params, metadata) {
    return await this._frame.waitForTimeout(metadata, params.timeout);
  }
  async waitForFunction(params, metadata) {
    return { handle: ElementHandleDispatcher.fromJSHandle(this, await this._frame._waitForFunctionExpression(metadata, params.expression, params.isFunction, parseArgument(params.arg), params)) };
  }
  async title(params, metadata) {
    return { value: await this._frame.title() };
  }
  async highlight(params, metadata) {
    return await this._frame.highlight(params.selector);
  }
  async expect(params, metadata) {
    metadata.potentiallyClosesScope = true;
    let expectedValue = params.expectedValue ? parseArgument(params.expectedValue) : void 0;
    if (params.expression === "to.match.aria" && expectedValue)
      expectedValue = parseAriaSnapshotUnsafe(yaml2, expectedValue);
    const result = await this._frame.expect(metadata, params.selector, { ...params, expectedValue });
    if (result.received !== void 0)
      result.received = serializeResult(result.received);
    return result;
  }
  async ariaSnapshot(params, metadata) {
    return { snapshot: await this._frame.ariaSnapshot(metadata, params.selector, params) };
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/elementHandlerDispatcher.js
var ElementHandleDispatcher = class _ElementHandleDispatcher extends JSHandleDispatcher {
  static {
    __name(this, "ElementHandleDispatcher");
  }
  constructor(scope, elementHandle) {
    super(scope, elementHandle);
    this._type_ElementHandle = true;
    this._elementHandle = elementHandle;
  }
  static from(scope, handle) {
    return existingDispatcher(handle) || new _ElementHandleDispatcher(scope, handle);
  }
  static fromNullable(scope, handle) {
    if (!handle)
      return void 0;
    return existingDispatcher(handle) || new _ElementHandleDispatcher(scope, handle);
  }
  static fromJSHandle(scope, handle) {
    const result = existingDispatcher(handle);
    if (result)
      return result;
    return handle.asElement() ? new _ElementHandleDispatcher(scope, handle.asElement()) : new JSHandleDispatcher(scope, handle);
  }
  async ownerFrame(params, metadata) {
    const frame = await this._elementHandle.ownerFrame();
    return { frame: frame ? FrameDispatcher.from(this._browserContextDispatcher(), frame) : void 0 };
  }
  async contentFrame(params, metadata) {
    const frame = await this._elementHandle.contentFrame();
    return { frame: frame ? FrameDispatcher.from(this._browserContextDispatcher(), frame) : void 0 };
  }
  async generateLocatorString(params, metadata) {
    return { value: await this._elementHandle.generateLocatorString() };
  }
  async getAttribute(params, metadata) {
    const value = await this._elementHandle.getAttribute(metadata, params.name);
    return { value: value === null ? void 0 : value };
  }
  async inputValue(params, metadata) {
    const value = await this._elementHandle.inputValue(metadata);
    return { value };
  }
  async textContent(params, metadata) {
    const value = await this._elementHandle.textContent(metadata);
    return { value: value === null ? void 0 : value };
  }
  async innerText(params, metadata) {
    return { value: await this._elementHandle.innerText(metadata) };
  }
  async innerHTML(params, metadata) {
    return { value: await this._elementHandle.innerHTML(metadata) };
  }
  async isChecked(params, metadata) {
    return { value: await this._elementHandle.isChecked(metadata) };
  }
  async isDisabled(params, metadata) {
    return { value: await this._elementHandle.isDisabled(metadata) };
  }
  async isEditable(params, metadata) {
    return { value: await this._elementHandle.isEditable(metadata) };
  }
  async isEnabled(params, metadata) {
    return { value: await this._elementHandle.isEnabled(metadata) };
  }
  async isHidden(params, metadata) {
    return { value: await this._elementHandle.isHidden(metadata) };
  }
  async isVisible(params, metadata) {
    return { value: await this._elementHandle.isVisible(metadata) };
  }
  async dispatchEvent(params, metadata) {
    await this._elementHandle.dispatchEvent(metadata, params.type, parseArgument(params.eventInit));
  }
  async scrollIntoViewIfNeeded(params, metadata) {
    await this._elementHandle.scrollIntoViewIfNeeded(metadata, params);
  }
  async hover(params, metadata) {
    return await this._elementHandle.hover(metadata, params);
  }
  async click(params, metadata) {
    return await this._elementHandle.click(metadata, params);
  }
  async dblclick(params, metadata) {
    return await this._elementHandle.dblclick(metadata, params);
  }
  async tap(params, metadata) {
    return await this._elementHandle.tap(metadata, params);
  }
  async selectOption(params, metadata) {
    const elements = (params.elements || []).map((e) => e._elementHandle);
    return { values: await this._elementHandle.selectOption(metadata, elements, params.options || [], params) };
  }
  async fill(params, metadata) {
    return await this._elementHandle.fill(metadata, params.value, params);
  }
  async selectText(params, metadata) {
    await this._elementHandle.selectText(metadata, params);
  }
  async setInputFiles(params, metadata) {
    return await this._elementHandle.setInputFiles(metadata, params);
  }
  async focus(params, metadata) {
    await this._elementHandle.focus(metadata);
  }
  async type(params, metadata) {
    return await this._elementHandle.type(metadata, params.text, params);
  }
  async press(params, metadata) {
    return await this._elementHandle.press(metadata, params.key, params);
  }
  async check(params, metadata) {
    return await this._elementHandle.check(metadata, params);
  }
  async uncheck(params, metadata) {
    return await this._elementHandle.uncheck(metadata, params);
  }
  async boundingBox(params, metadata) {
    const value = await this._elementHandle.boundingBox();
    return { value: value || void 0 };
  }
  async screenshot(params, metadata) {
    const mask = (params.mask || []).map(({ frame, selector }) => ({
      frame: frame._object,
      selector
    }));
    return { binary: await this._elementHandle.screenshot(metadata, { ...params, mask }) };
  }
  async querySelector(params, metadata) {
    const handle = await this._elementHandle.querySelector(params.selector, params);
    return { element: _ElementHandleDispatcher.fromNullable(this.parentScope(), handle) };
  }
  async querySelectorAll(params, metadata) {
    const elements = await this._elementHandle.querySelectorAll(params.selector);
    return { elements: elements.map((e) => _ElementHandleDispatcher.from(this.parentScope(), e)) };
  }
  async evalOnSelector(params, metadata) {
    return { value: serializeResult(await this._elementHandle.evalOnSelector(params.selector, !!params.strict, params.expression, params.isFunction, parseArgument(params.arg))) };
  }
  async evalOnSelectorAll(params, metadata) {
    return { value: serializeResult(await this._elementHandle.evalOnSelectorAll(params.selector, params.expression, params.isFunction, parseArgument(params.arg))) };
  }
  async waitForElementState(params, metadata) {
    await this._elementHandle.waitForElementState(metadata, params.state, params);
  }
  async waitForSelector(params, metadata) {
    return { element: _ElementHandleDispatcher.fromNullable(this.parentScope(), await this._elementHandle.waitForSelector(metadata, params.selector, params)) };
  }
  _browserContextDispatcher() {
    const scope = this.parentScope();
    if (scope instanceof BrowserContextDispatcher)
      return scope;
    if (scope instanceof PageDispatcher)
      return scope.parentScope();
    if (scope instanceof WorkerDispatcher || scope instanceof FrameDispatcher) {
      const parentScope = scope.parentScope();
      if (parentScope instanceof BrowserContextDispatcher)
        return parentScope;
      return parentScope.parentScope();
    }
    throw new Error("ElementHandle belongs to unexpected scope");
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/webSocketRouteDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/generated/webSocketMockSource.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source6 = `
var __commonJS = obj => {
  let required = false;
  let result;
  return function __require() {
    if (!required) {
      required = true;
      let fn;
      for (const name in obj) { fn = obj[name]; break; }
      const module = { exports: {} };
      fn(module.exports, module);
      result = module.exports;
    }
    return result;
  }
};
var __export = (target, all) => {for (var name in all) target[name] = all[name];};
var __toESM = mod => ({ ...mod, 'default': mod });
var __toCommonJS = mod => ({ ...mod, __esModule: true });


// packages/injected/src/webSocketMock.ts
var webSocketMock_exports = {};
__export(webSocketMock_exports, {
  inject: () => inject
});
module.exports = __toCommonJS(webSocketMock_exports);

// packages/playwright-core/src/utils/isomorphic/builtins.ts
function builtins(global) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  global = global != null ? global : globalThis;
  if (!global["__playwright_builtins__"]) {
    const builtins2 = {
      setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),
      clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),
      setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),
      clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),
      requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),
      cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),
      requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),
      cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),
      performance: global.performance,
      eval: (_i = global.eval) == null ? void 0 : _i.bind(global),
      Intl: global.Intl,
      Date: global.Date,
      Map: global.Map,
      Set: global.Set
    };
    Object.defineProperty(global, "__playwright_builtins__", { value: builtins2, configurable: false, enumerable: false, writable: false });
  }
  return global["__playwright_builtins__"];
}
var instance = builtins();
var setTimeout = instance.setTimeout;
var clearTimeout = instance.clearTimeout;
var setInterval = instance.setInterval;
var clearInterval = instance.clearInterval;
var requestAnimationFrame = instance.requestAnimationFrame;
var cancelAnimationFrame = instance.cancelAnimationFrame;
var requestIdleCallback = instance.requestIdleCallback;
var cancelIdleCallback = instance.cancelIdleCallback;
var performance = instance.performance;
var Intl = instance.Intl;
var Date = instance.Date;
var Map = instance.Map;
var Set = instance.Set;

// packages/injected/src/webSocketMock.ts
function inject(globalThis2) {
  if (globalThis2.__pwWebSocketDispatch)
    return;
  function generateId() {
    const bytes = new Uint8Array(32);
    globalThis2.crypto.getRandomValues(bytes);
    const hex = "0123456789abcdef";
    return [...bytes].map((value) => {
      const high = Math.floor(value / 16);
      const low = value % 16;
      return hex[high] + hex[low];
    }).join("");
  }
  function bufferToData(b) {
    let s = "";
    for (let i = 0; i < b.length; i++)
      s += String.fromCharCode(b[i]);
    return { data: globalThis2.btoa(s), isBase64: true };
  }
  function stringToBuffer(s) {
    s = globalThis2.atob(s);
    const b = new Uint8Array(s.length);
    for (let i = 0; i < s.length; i++)
      b[i] = s.charCodeAt(i);
    return b.buffer;
  }
  function messageToData(message, cb) {
    if (message instanceof globalThis2.Blob)
      return message.arrayBuffer().then((buffer) => cb(bufferToData(new Uint8Array(buffer))));
    if (typeof message === "string")
      return cb({ data: message, isBase64: false });
    if (ArrayBuffer.isView(message))
      return cb(bufferToData(new Uint8Array(message.buffer, message.byteOffset, message.byteLength)));
    return cb(bufferToData(new Uint8Array(message)));
  }
  function dataToMessage(data, binaryType) {
    if (!data.isBase64)
      return data.data;
    const buffer = stringToBuffer(data.data);
    return binaryType === "arraybuffer" ? buffer : new Blob([buffer]);
  }
  const binding = globalThis2.__pwWebSocketBinding;
  const NativeWebSocket = globalThis2.WebSocket;
  const idToWebSocket = new Map();
  globalThis2.__pwWebSocketDispatch = (request) => {
    const ws = idToWebSocket.get(request.id);
    if (!ws)
      return;
    if (request.type === "connect")
      ws._apiConnect();
    if (request.type === "passthrough")
      ws._apiPassThrough();
    if (request.type === "ensureOpened")
      ws._apiEnsureOpened();
    if (request.type === "sendToPage")
      ws._apiSendToPage(dataToMessage(request.data, ws.binaryType));
    if (request.type === "closePage")
      ws._apiClosePage(request.code, request.reason, request.wasClean);
    if (request.type === "sendToServer")
      ws._apiSendToServer(dataToMessage(request.data, ws.binaryType));
    if (request.type === "closeServer")
      ws._apiCloseServer(request.code, request.reason, request.wasClean);
  };
  const _WebSocketMock = class _WebSocketMock extends EventTarget {
    constructor(url, protocols) {
      var _a, _b;
      super();
      // WebSocket.CLOSED
      this.CONNECTING = 0;
      // WebSocket.CONNECTING
      this.OPEN = 1;
      // WebSocket.OPEN
      this.CLOSING = 2;
      // WebSocket.CLOSING
      this.CLOSED = 3;
      // WebSocket.CLOSED
      this._oncloseListener = null;
      this._onerrorListener = null;
      this._onmessageListener = null;
      this._onopenListener = null;
      this.bufferedAmount = 0;
      this.extensions = "";
      this.protocol = "";
      this.readyState = 0;
      this._origin = "";
      this._passthrough = false;
      this._wsBufferedMessages = [];
      this._binaryType = "blob";
      this.url = new URL(url, globalThis2.window.document.baseURI).href.replace(/^http/, "ws");
      this._origin = (_b = (_a = URL.parse(this.url)) == null ? void 0 : _a.origin) != null ? _b : "";
      this._protocols = protocols;
      this._id = generateId();
      idToWebSocket.set(this._id, this);
      binding({ type: "onCreate", id: this._id, url: this.url });
    }
    // --- native WebSocket implementation ---
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      this._binaryType = type;
      if (this._ws)
        this._ws.binaryType = type;
    }
    get onclose() {
      return this._oncloseListener;
    }
    set onclose(listener) {
      if (this._oncloseListener)
        this.removeEventListener("close", this._oncloseListener);
      this._oncloseListener = listener;
      if (this._oncloseListener)
        this.addEventListener("close", this._oncloseListener);
    }
    get onerror() {
      return this._onerrorListener;
    }
    set onerror(listener) {
      if (this._onerrorListener)
        this.removeEventListener("error", this._onerrorListener);
      this._onerrorListener = listener;
      if (this._onerrorListener)
        this.addEventListener("error", this._onerrorListener);
    }
    get onopen() {
      return this._onopenListener;
    }
    set onopen(listener) {
      if (this._onopenListener)
        this.removeEventListener("open", this._onopenListener);
      this._onopenListener = listener;
      if (this._onopenListener)
        this.addEventListener("open", this._onopenListener);
    }
    get onmessage() {
      return this._onmessageListener;
    }
    set onmessage(listener) {
      if (this._onmessageListener)
        this.removeEventListener("message", this._onmessageListener);
      this._onmessageListener = listener;
      if (this._onmessageListener)
        this.addEventListener("message", this._onmessageListener);
    }
    send(message) {
      if (this.readyState === _WebSocketMock.CONNECTING)
        throw new DOMException(\`Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.\`);
      if (this.readyState !== _WebSocketMock.OPEN)
        throw new DOMException(\`WebSocket is already in CLOSING or CLOSED state.\`);
      if (this._passthrough) {
        if (this._ws)
          this._apiSendToServer(message);
      } else {
        messageToData(message, (data) => binding({ type: "onMessageFromPage", id: this._id, data }));
      }
    }
    close(code, reason) {
      if (code !== void 0 && code !== 1e3 && (code < 3e3 || code > 4999))
        throw new DOMException(\`Failed to execute 'close' on 'WebSocket': The close code must be either 1000, or between 3000 and 4999. \${code} is neither.\`);
      if (this.readyState === _WebSocketMock.OPEN || this.readyState === _WebSocketMock.CONNECTING)
        this.readyState = _WebSocketMock.CLOSING;
      if (this._passthrough)
        this._apiCloseServer(code, reason, true);
      else
        binding({ type: "onClosePage", id: this._id, code, reason, wasClean: true });
    }
    // --- methods called from the routing API ---
    _apiEnsureOpened() {
      if (!this._ws)
        this._ensureOpened();
    }
    _apiSendToPage(message) {
      this._ensureOpened();
      if (this.readyState !== _WebSocketMock.OPEN)
        throw new DOMException(\`WebSocket is already in CLOSING or CLOSED state.\`);
      this.dispatchEvent(new MessageEvent("message", { data: message, origin: this._origin, cancelable: true }));
    }
    _apiSendToServer(message) {
      if (!this._ws)
        throw new Error("Cannot send a message before connecting to the server");
      if (this._ws.readyState === _WebSocketMock.CONNECTING)
        this._wsBufferedMessages.push(message);
      else
        this._ws.send(message);
    }
    _apiConnect() {
      if (this._ws)
        throw new Error("Can only connect to the server once");
      this._ws = new NativeWebSocket(this.url, this._protocols);
      this._ws.binaryType = this._binaryType;
      this._ws.onopen = () => {
        for (const message of this._wsBufferedMessages)
          this._ws.send(message);
        this._wsBufferedMessages = [];
        this._ensureOpened();
      };
      this._ws.onclose = (event) => {
        this._onWSClose(event.code, event.reason, event.wasClean);
      };
      this._ws.onmessage = (event) => {
        if (this._passthrough)
          this._apiSendToPage(event.data);
        else
          messageToData(event.data, (data) => binding({ type: "onMessageFromServer", id: this._id, data }));
      };
      this._ws.onerror = () => {
        const event = new Event("error", { cancelable: true });
        this.dispatchEvent(event);
      };
    }
    // This method connects to the server, and passes all messages through,
    // as if WebSocketMock was not engaged.
    _apiPassThrough() {
      this._passthrough = true;
      this._apiConnect();
    }
    _apiCloseServer(code, reason, wasClean) {
      if (!this._ws) {
        this._onWSClose(code, reason, wasClean);
        return;
      }
      if (this._ws.readyState === _WebSocketMock.CONNECTING || this._ws.readyState === _WebSocketMock.OPEN)
        this._ws.close(code, reason);
    }
    _apiClosePage(code, reason, wasClean) {
      if (this.readyState === _WebSocketMock.CLOSED)
        return;
      this.readyState = _WebSocketMock.CLOSED;
      this.dispatchEvent(new CloseEvent("close", { code, reason, wasClean, cancelable: true }));
      this._maybeCleanup();
      if (this._passthrough)
        this._apiCloseServer(code, reason, wasClean);
      else
        binding({ type: "onClosePage", id: this._id, code, reason, wasClean });
    }
    // --- internals ---
    _ensureOpened() {
      var _a;
      if (this.readyState !== _WebSocketMock.CONNECTING)
        return;
      this.extensions = ((_a = this._ws) == null ? void 0 : _a.extensions) || "";
      if (this._ws)
        this.protocol = this._ws.protocol;
      else if (Array.isArray(this._protocols))
        this.protocol = this._protocols[0] || "";
      else
        this.protocol = this._protocols || "";
      this.readyState = _WebSocketMock.OPEN;
      this.dispatchEvent(new Event("open", { cancelable: true }));
    }
    _onWSClose(code, reason, wasClean) {
      if (this._passthrough)
        this._apiClosePage(code, reason, wasClean);
      else
        binding({ type: "onCloseServer", id: this._id, code, reason, wasClean });
      if (this._ws) {
        this._ws.onopen = null;
        this._ws.onclose = null;
        this._ws.onmessage = null;
        this._ws.onerror = null;
        this._ws = void 0;
        this._wsBufferedMessages = [];
      }
      this._maybeCleanup();
    }
    _maybeCleanup() {
      if (this.readyState === _WebSocketMock.CLOSED && !this._ws)
        idToWebSocket.delete(this._id);
    }
  };
  _WebSocketMock.CONNECTING = 0;
  // WebSocket.CONNECTING
  _WebSocketMock.OPEN = 1;
  // WebSocket.OPEN
  _WebSocketMock.CLOSING = 2;
  // WebSocket.CLOSING
  _WebSocketMock.CLOSED = 3;
  let WebSocketMock = _WebSocketMock;
  globalThis2.WebSocket = class WebSocket extends WebSocketMock {
  };
}
`;

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/webSocketRouteDispatcher.js
var WebSocketRouteDispatcher = class _WebSocketRouteDispatcher extends Dispatcher {
  static {
    __name(this, "WebSocketRouteDispatcher");
  }
  constructor(scope, id, url4, frame) {
    super(scope, { guid: "webSocketRoute@" + createGuid() }, "WebSocketRoute", { url: url4 });
    this._type_WebSocketRoute = true;
    this._id = id;
    this._frame = frame;
    this._eventListeners.push(
      // When the frame navigates or detaches, there will be no more communication
      // from the mock websocket, so pretend like it was closed.
      eventsHelper.addEventListener(frame._page, Page.Events.InternalFrameNavigatedToNewDocument, (frame2) => {
        if (frame2 === this._frame)
          this._executionContextGone();
      }),
      eventsHelper.addEventListener(frame._page, Page.Events.FrameDetached, (frame2) => {
        if (frame2 === this._frame)
          this._executionContextGone();
      }),
      eventsHelper.addEventListener(frame._page, Page.Events.Close, () => this._executionContextGone()),
      eventsHelper.addEventListener(frame._page, Page.Events.Crash, () => this._executionContextGone())
    );
    _WebSocketRouteDispatcher._idToDispatcher.set(this._id, this);
    scope._dispatchEvent("webSocketRoute", { webSocketRoute: this });
  }
  static {
    this._idToDispatcher = /* @__PURE__ */ new Map();
  }
  static async installIfNeeded(target) {
    const kBindingName2 = "__pwWebSocketBinding";
    const context2 = target instanceof Page ? target.context() : target;
    if (!context2.hasBinding(kBindingName2)) {
      await context2.exposeBinding(kBindingName2, false, (source7, payload) => {
        if (payload.type === "onCreate") {
          const contextDispatcher = existingDispatcher(context2);
          const pageDispatcher = contextDispatcher ? PageDispatcher.fromNullable(contextDispatcher, source7.page) : void 0;
          let scope;
          if (pageDispatcher && matchesPattern(pageDispatcher, context2._options.baseURL, payload.url))
            scope = pageDispatcher;
          else if (contextDispatcher && matchesPattern(contextDispatcher, context2._options.baseURL, payload.url))
            scope = contextDispatcher;
          if (scope) {
            new _WebSocketRouteDispatcher(scope, payload.id, payload.url, source7.frame);
          } else {
            const request4 = { id: payload.id, type: "passthrough" };
            source7.frame.evaluateExpression(`globalThis.__pwWebSocketDispatch(${JSON.stringify(request4)})`).catch(() => {
            });
          }
          return;
        }
        const dispatcher = _WebSocketRouteDispatcher._idToDispatcher.get(payload.id);
        if (payload.type === "onMessageFromPage")
          dispatcher?._dispatchEvent("messageFromPage", { message: payload.data.data, isBase64: payload.data.isBase64 });
        if (payload.type === "onMessageFromServer")
          dispatcher?._dispatchEvent("messageFromServer", { message: payload.data.data, isBase64: payload.data.isBase64 });
        if (payload.type === "onClosePage")
          dispatcher?._dispatchEvent("closePage", { code: payload.code, reason: payload.reason, wasClean: payload.wasClean });
        if (payload.type === "onCloseServer")
          dispatcher?._dispatchEvent("closeServer", { code: payload.code, reason: payload.reason, wasClean: payload.wasClean });
      });
    }
    const kInitScriptName = "webSocketMockSource";
    if (!target.initScripts.find((s) => s.name === kInitScriptName)) {
      await target.addInitScript(`
        (() => {
          const module = {};
          ${source6}
          (module.exports.inject())(globalThis);
        })();
      `, kInitScriptName);
    }
  }
  async connect(params) {
    await this._evaluateAPIRequest({ id: this._id, type: "connect" });
  }
  async ensureOpened(params) {
    await this._evaluateAPIRequest({ id: this._id, type: "ensureOpened" });
  }
  async sendToPage(params) {
    await this._evaluateAPIRequest({ id: this._id, type: "sendToPage", data: { data: params.message, isBase64: params.isBase64 } });
  }
  async sendToServer(params) {
    await this._evaluateAPIRequest({ id: this._id, type: "sendToServer", data: { data: params.message, isBase64: params.isBase64 } });
  }
  async closePage(params) {
    await this._evaluateAPIRequest({ id: this._id, type: "closePage", code: params.code, reason: params.reason, wasClean: params.wasClean });
  }
  async closeServer(params) {
    await this._evaluateAPIRequest({ id: this._id, type: "closeServer", code: params.code, reason: params.reason, wasClean: params.wasClean });
  }
  async _evaluateAPIRequest(request4) {
    await this._frame.evaluateExpression(`globalThis.__pwWebSocketDispatch(${JSON.stringify(request4)})`).catch(() => {
    });
  }
  _onDispose() {
    _WebSocketRouteDispatcher._idToDispatcher.delete(this._id);
  }
  _executionContextGone() {
    if (!this._disposed) {
      this._dispatchEvent("closePage", { wasClean: true });
      this._dispatchEvent("closeServer", { wasClean: true });
    }
  }
};
function matchesPattern(dispatcher, baseURL, url4) {
  for (const pattern of dispatcher._webSocketInterceptionPatterns || []) {
    const urlMatch = pattern.regexSource ? new RegExp(pattern.regexSource, pattern.regexFlags) : pattern.glob;
    if (urlMatches(baseURL, url4, urlMatch, true))
      return true;
  }
  return false;
}
__name(matchesPattern, "matchesPattern");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/pageDispatcher.js
var PageDispatcher = class _PageDispatcher extends Dispatcher {
  static {
    __name(this, "PageDispatcher");
  }
  constructor(parentScope, page) {
    const mainFrame = FrameDispatcher.from(parentScope, page.mainFrame());
    super(parentScope, page, "Page", {
      mainFrame,
      viewportSize: page.viewportSize() || void 0,
      isClosed: page.isClosed(),
      opener: _PageDispatcher.fromNullable(parentScope, page.opener())
    });
    this._type_EventTarget = true;
    this._type_Page = true;
    this._subscriptions = /* @__PURE__ */ new Set();
    this._webSocketInterceptionPatterns = [];
    this.adopt(mainFrame);
    this._page = page;
    this.addObjectListener(Page.Events.Close, () => {
      this._dispatchEvent("close");
      this._dispose();
    });
    this.addObjectListener(Page.Events.Crash, () => this._dispatchEvent("crash"));
    this.addObjectListener(Page.Events.Download, (download) => {
      this._dispatchEvent("download", { url: download.url, suggestedFilename: download.suggestedFilename(), artifact: ArtifactDispatcher.from(parentScope, download.artifact) });
    });
    this.addObjectListener(Page.Events.FileChooser, (fileChooser) => this._dispatchEvent("fileChooser", {
      element: ElementHandleDispatcher.from(mainFrame, fileChooser.element()),
      isMultiple: fileChooser.isMultiple()
    }));
    this.addObjectListener(Page.Events.FrameAttached, (frame) => this._onFrameAttached(frame));
    this.addObjectListener(Page.Events.FrameDetached, (frame) => this._onFrameDetached(frame));
    this.addObjectListener(Page.Events.LocatorHandlerTriggered, (uid) => this._dispatchEvent("locatorHandlerTriggered", { uid }));
    this.addObjectListener(Page.Events.WebSocket, (webSocket) => this._dispatchEvent("webSocket", { webSocket: new WebSocketDispatcher(this, webSocket) }));
    this.addObjectListener(Page.Events.Worker, (worker) => this._dispatchEvent("worker", { worker: new WorkerDispatcher(this, worker) }));
    this.addObjectListener(Page.Events.Video, (artifact) => this._dispatchEvent("video", { artifact: ArtifactDispatcher.from(parentScope, artifact) }));
    if (page._video)
      this._dispatchEvent("video", { artifact: ArtifactDispatcher.from(this.parentScope(), page._video) });
    const frames = page._frameManager.frames();
    for (let i = 1; i < frames.length; i++)
      this._onFrameAttached(frames[i]);
  }
  static from(parentScope, page) {
    return _PageDispatcher.fromNullable(parentScope, page);
  }
  static fromNullable(parentScope, page) {
    if (!page)
      return void 0;
    const result = existingDispatcher(page);
    return result || new _PageDispatcher(parentScope, page);
  }
  page() {
    return this._page;
  }
  async setDefaultNavigationTimeoutNoReply(params, metadata) {
    this._page.setDefaultNavigationTimeout(params.timeout);
  }
  async setDefaultTimeoutNoReply(params, metadata) {
    this._page.setDefaultTimeout(params.timeout);
  }
  async exposeBinding(params, metadata) {
    await this._page.exposeBinding(params.name, !!params.needsHandle, (source7, ...args) => {
      if (this._disposed)
        return;
      const binding3 = new BindingCallDispatcher(this, params.name, !!params.needsHandle, source7, args);
      this._dispatchEvent("bindingCall", { binding: binding3 });
      return binding3.promise();
    });
  }
  async setExtraHTTPHeaders(params, metadata) {
    await this._page.setExtraHTTPHeaders(params.headers);
  }
  async reload(params, metadata) {
    return { response: ResponseDispatcher.fromNullable(this.parentScope(), await this._page.reload(metadata, params)) };
  }
  async goBack(params, metadata) {
    return { response: ResponseDispatcher.fromNullable(this.parentScope(), await this._page.goBack(metadata, params)) };
  }
  async goForward(params, metadata) {
    return { response: ResponseDispatcher.fromNullable(this.parentScope(), await this._page.goForward(metadata, params)) };
  }
  async requestGC(params, metadata) {
    await this._page.requestGC();
  }
  async registerLocatorHandler(params, metadata) {
    const uid = this._page.registerLocatorHandler(params.selector, params.noWaitAfter);
    return { uid };
  }
  async resolveLocatorHandlerNoReply(params, metadata) {
    this._page.resolveLocatorHandler(params.uid, params.remove);
  }
  async unregisterLocatorHandler(params, metadata) {
    this._page.unregisterLocatorHandler(params.uid);
  }
  async emulateMedia(params, metadata) {
    await this._page.emulateMedia({
      media: params.media,
      colorScheme: params.colorScheme,
      reducedMotion: params.reducedMotion,
      forcedColors: params.forcedColors,
      contrast: params.contrast
    });
  }
  async setViewportSize(params, metadata) {
    await this._page.setViewportSize(params.viewportSize);
  }
  async addInitScript(params, metadata) {
    await this._page.addInitScript(params.source);
  }
  async setNetworkInterceptionPatterns(params, metadata) {
    if (!params.patterns.length) {
      await this._page.setClientRequestInterceptor(void 0);
      return;
    }
    const urlMatchers = params.patterns.map((pattern) => pattern.regexSource ? new RegExp(pattern.regexSource, pattern.regexFlags) : pattern.glob);
    await this._page.setClientRequestInterceptor((route, request4) => {
      const matchesSome = urlMatchers.some((urlMatch) => urlMatches(this._page._browserContext._options.baseURL, request4.url(), urlMatch));
      if (!matchesSome)
        return false;
      this._dispatchEvent("route", { route: RouteDispatcher.from(RequestDispatcher.from(this.parentScope(), request4), route) });
      return true;
    });
  }
  async setWebSocketInterceptionPatterns(params, metadata) {
    this._webSocketInterceptionPatterns = params.patterns;
    if (params.patterns.length)
      await WebSocketRouteDispatcher.installIfNeeded(this._page);
  }
  async expectScreenshot(params, metadata) {
    const mask = (params.mask || []).map(({ frame, selector }) => ({
      frame: frame._object,
      selector
    }));
    const locator = params.locator ? {
      frame: params.locator.frame._object,
      selector: params.locator.selector
    } : void 0;
    return await this._page.expectScreenshot(metadata, {
      ...params,
      locator,
      mask
    });
  }
  async screenshot(params, metadata) {
    const mask = (params.mask || []).map(({ frame, selector }) => ({
      frame: frame._object,
      selector
    }));
    return { binary: await this._page.screenshot(metadata, { ...params, mask }) };
  }
  async close(params, metadata) {
    if (!params.runBeforeUnload)
      metadata.potentiallyClosesScope = true;
    await this._page.close(metadata, params);
  }
  async updateSubscription(params) {
    if (params.event === "fileChooser")
      await this._page.setFileChooserIntercepted(params.enabled);
    if (params.enabled)
      this._subscriptions.add(params.event);
    else
      this._subscriptions.delete(params.event);
  }
  async keyboardDown(params, metadata) {
    await this._page.keyboard.down(params.key);
  }
  async keyboardUp(params, metadata) {
    await this._page.keyboard.up(params.key);
  }
  async keyboardInsertText(params, metadata) {
    await this._page.keyboard.insertText(params.text);
  }
  async keyboardType(params, metadata) {
    await this._page.keyboard.type(params.text, params);
  }
  async keyboardPress(params, metadata) {
    await this._page.keyboard.press(params.key, params);
  }
  async mouseMove(params, metadata) {
    await this._page.mouse.move(params.x, params.y, params, metadata);
  }
  async mouseDown(params, metadata) {
    await this._page.mouse.down(params, metadata);
  }
  async mouseUp(params, metadata) {
    await this._page.mouse.up(params, metadata);
  }
  async mouseClick(params, metadata) {
    await this._page.mouse.click(params.x, params.y, params, metadata);
  }
  async mouseWheel(params, metadata) {
    await this._page.mouse.wheel(params.deltaX, params.deltaY);
  }
  async touchscreenTap(params, metadata) {
    await this._page.touchscreen.tap(params.x, params.y, metadata);
  }
  async accessibilitySnapshot(params, metadata) {
    const rootAXNode = await this._page.accessibility.snapshot({
      interestingOnly: params.interestingOnly,
      root: params.root ? params.root._elementHandle : void 0
    });
    return { rootAXNode: rootAXNode || void 0 };
  }
  async pdf(params, metadata) {
    if (!this._page.pdf)
      throw new Error("PDF generation is only supported for Headless Chromium");
    const buffer2 = await this._page.pdf(params);
    return { pdf: buffer2 };
  }
  async bringToFront(params, metadata) {
    await this._page.bringToFront();
  }
  async startJSCoverage(params, metadata) {
    const coverage = this._page.coverage;
    await coverage.startJSCoverage(params);
  }
  async stopJSCoverage(params, metadata) {
    const coverage = this._page.coverage;
    return await coverage.stopJSCoverage();
  }
  async startCSSCoverage(params, metadata) {
    const coverage = this._page.coverage;
    await coverage.startCSSCoverage(params);
  }
  async stopCSSCoverage(params, metadata) {
    const coverage = this._page.coverage;
    return await coverage.stopCSSCoverage();
  }
  _onFrameAttached(frame) {
    this._dispatchEvent("frameAttached", { frame: FrameDispatcher.from(this.parentScope(), frame) });
  }
  _onFrameDetached(frame) {
    this._dispatchEvent("frameDetached", { frame: FrameDispatcher.from(this.parentScope(), frame) });
  }
  _onDispose() {
    if (!this._page.isClosedOrClosingOrCrashed())
      this._page.setClientRequestInterceptor(void 0).catch(() => {
      });
  }
};
var WorkerDispatcher = class _WorkerDispatcher extends Dispatcher {
  static {
    __name(this, "WorkerDispatcher");
  }
  constructor(scope, worker) {
    super(scope, worker, "Worker", {
      url: worker.url()
    });
    this._type_Worker = true;
    this.addObjectListener(Worker.Events.Close, () => this._dispatchEvent("close"));
  }
  static fromNullable(scope, worker) {
    if (!worker)
      return void 0;
    const result = existingDispatcher(worker);
    return result || new _WorkerDispatcher(scope, worker);
  }
  async evaluateExpression(params, metadata) {
    return { value: serializeResult(await this._object.evaluateExpression(params.expression, params.isFunction, parseArgument(params.arg))) };
  }
  async evaluateExpressionHandle(params, metadata) {
    return { handle: ElementHandleDispatcher.fromJSHandle(this, await this._object.evaluateExpressionHandle(params.expression, params.isFunction, parseArgument(params.arg))) };
  }
};
var BindingCallDispatcher = class extends Dispatcher {
  static {
    __name(this, "BindingCallDispatcher");
  }
  constructor(scope, name, needsHandle, source7, args) {
    super(scope, { guid: "bindingCall@" + createGuid() }, "BindingCall", {
      frame: FrameDispatcher.from(scope.parentScope(), source7.frame),
      name,
      args: needsHandle ? void 0 : args.map(serializeResult),
      handle: needsHandle ? ElementHandleDispatcher.fromJSHandle(scope, args[0]) : void 0
    });
    this._type_BindingCall = true;
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  promise() {
    return this._promise;
  }
  async resolve(params, metadata) {
    this._resolve(parseArgument(params.result));
    this._dispose();
  }
  async reject(params, metadata) {
    this._reject(parseError(params.error));
    this._dispose();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/dialogDispatcher.js
var DialogDispatcher = class extends Dispatcher {
  static {
    __name(this, "DialogDispatcher");
  }
  constructor(scope, dialog) {
    const page = PageDispatcher.fromNullable(scope, dialog.page().initializedOrUndefined());
    super(page || scope, dialog, "Dialog", {
      page,
      type: dialog.type(),
      message: dialog.message(),
      defaultValue: dialog.defaultValue()
    });
    this._type_Dialog = true;
  }
  async accept(params) {
    await this._object.accept(params.promptText);
  }
  async dismiss() {
    await this._object.dismiss();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crBrowser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path18 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/browser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/download.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path16 from "node:path";
import "node:url";
var Download = class {
  static {
    __name(this, "Download");
  }
  constructor(page, downloadsPath, uuid, url4, suggestedFilename) {
    const unaccessibleErrorMessage = page._browserContext._options.acceptDownloads === "deny" ? "Pass { acceptDownloads: true } when you are creating your browser context." : void 0;
    this.artifact = new Artifact(page, path16.join(downloadsPath, uuid), unaccessibleErrorMessage, () => {
      return this._page._browserContext.cancelDownload(uuid);
    });
    this._page = page;
    this.url = url4;
    this._suggestedFilename = suggestedFilename;
    page._browserContext._downloads.add(this);
    if (suggestedFilename !== void 0)
      this._fireDownloadEvent();
  }
  page() {
    return this._page;
  }
  _filenameSuggested(suggestedFilename) {
    assert3(this._suggestedFilename === void 0);
    this._suggestedFilename = suggestedFilename;
    this._fireDownloadEvent();
  }
  suggestedFilename() {
    return this._suggestedFilename;
  }
  _fireDownloadEvent() {
    this._page.instrumentation.onDownload(this._page, this);
    this._page.emit(Page.Events.Download, this);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/browser.js
var Browser = class _Browser extends SdkObject {
  static {
    __name(this, "Browser");
  }
  constructor(parent, options2) {
    super(parent, "browser");
    this._downloads = /* @__PURE__ */ new Map();
    this._defaultContext = null;
    this._startedClosing = false;
    this._idToVideo = /* @__PURE__ */ new Map();
    this._isCollocatedWithServer = true;
    this.attribution.browser = this;
    this.options = options2;
    this.instrumentation.onBrowserOpen(this);
  }
  static {
    this.Events = {
      Disconnected: "disconnected"
    };
  }
  async newContext(metadata, options2) {
    validateBrowserContextOptions(options2, this.options);
    let clientCertificatesProxy;
    if (options2.clientCertificates?.length) {
      clientCertificatesProxy = new ClientCertificatesProxy(options2);
      options2 = { ...options2 };
      options2.proxyOverride = await clientCertificatesProxy.listen();
      options2.internalIgnoreHTTPSErrors = true;
    }
    let context2;
    try {
      context2 = await this.doCreateNewContext(options2);
    } catch (error4) {
      await clientCertificatesProxy?.close();
      throw error4;
    }
    context2._clientCertificatesProxy = clientCertificatesProxy;
    if (options2.storageState)
      await context2.setStorageState(metadata, options2.storageState);
    return context2;
  }
  async newContextForReuse(params, metadata) {
    const hash2 = BrowserContext.reusableContextHash(params);
    if (!this._contextForReuse || hash2 !== this._contextForReuse.hash || !this._contextForReuse.context.canResetForReuse()) {
      if (this._contextForReuse)
        await this._contextForReuse.context.close({ reason: "Context reused" });
      this._contextForReuse = { context: await this.newContext(metadata, params), hash: hash2 };
      return { context: this._contextForReuse.context, needsReset: false };
    }
    await this._contextForReuse.context.stopPendingOperations("Context recreated");
    return { context: this._contextForReuse.context, needsReset: true };
  }
  async stopPendingOperations(reason) {
    await this._contextForReuse?.context?.stopPendingOperations(reason);
  }
  _downloadCreated(page, uuid, url4, suggestedFilename) {
    const download = new Download(page, this.options.downloadsPath || "", uuid, url4, suggestedFilename);
    this._downloads.set(uuid, download);
  }
  _downloadFilenameSuggested(uuid, suggestedFilename) {
    const download = this._downloads.get(uuid);
    if (!download)
      return;
    download._filenameSuggested(suggestedFilename);
  }
  _downloadFinished(uuid, error4) {
    const download = this._downloads.get(uuid);
    if (!download)
      return;
    download.artifact.reportFinished(error4 ? new Error(error4) : void 0);
    this._downloads.delete(uuid);
  }
  _videoStarted(context2, videoId, path31, pageOrError) {
    const artifact = new Artifact(context2, path31);
    this._idToVideo.set(videoId, { context: context2, artifact });
    pageOrError.then((page) => {
      if (page instanceof Page) {
        page._video = artifact;
        page.emitOnContext(BrowserContext.Events.VideoStarted, artifact);
        page.emit(Page.Events.Video, artifact);
      }
    });
  }
  _takeVideo(videoId) {
    const video = this._idToVideo.get(videoId);
    this._idToVideo.delete(videoId);
    return video?.artifact;
  }
  _didClose() {
    for (const context2 of this.contexts())
      context2._browserClosed();
    if (this._defaultContext)
      this._defaultContext._browserClosed();
    this.emit(_Browser.Events.Disconnected);
    this.instrumentation.onBrowserClose(this);
  }
  async close(options2) {
    if (!this._startedClosing) {
      if (options2.reason)
        this._closeReason = options2.reason;
      this._startedClosing = true;
      await this.options.browserProcess.close();
    }
    if (this.isConnected())
      await new Promise((x) => this.once(_Browser.Events.Disconnected, x));
  }
  async killForTests() {
    await this.options.browserProcess.kill();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crPage.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path17 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dialog.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var Dialog = class extends SdkObject {
  static {
    __name(this, "Dialog");
  }
  constructor(page, type2, message, onHandle, defaultValue) {
    super(page, "dialog");
    this._handled = false;
    this._page = page;
    this._type = type2;
    this._message = message;
    this._onHandle = onHandle;
    this._defaultValue = defaultValue || "";
    this._page._frameManager.dialogDidOpen(this);
    this.instrumentation.onDialog(this);
  }
  page() {
    return this._page;
  }
  type() {
    return this._type;
  }
  message() {
    return this._message;
  }
  defaultValue() {
    return this._defaultValue;
  }
  async accept(promptText) {
    assert3(!this._handled, "Cannot accept dialog which is already handled!");
    this._handled = true;
    this._page._frameManager.dialogWillClose(this);
    await this._onHandle(true, promptText);
  }
  async dismiss() {
    assert3(!this._handled, "Cannot dismiss dialog which is already handled!");
    this._handled = true;
    this._page._frameManager.dialogWillClose(this);
    await this._onHandle(false);
  }
  async close() {
    if (this._type === "beforeunload")
      await this.accept();
    else
      await this.dismiss();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crAccessibility.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function getAccessibilityTree(client, needle) {
  const { nodes } = await client.send("Accessibility.getFullAXTree");
  const tree = CRAXNode.createTree(client, nodes);
  return {
    tree,
    needle: needle ? await tree._findElement(needle) : null
  };
}
__name(getAccessibilityTree, "getAccessibilityTree");
var CRAXNode = class _CRAXNode {
  static {
    __name(this, "CRAXNode");
  }
  constructor(client, payload) {
    this._children = [];
    this._richlyEditable = false;
    this._editable = false;
    this._focusable = false;
    this._expanded = false;
    this._hidden = false;
    this._client = client;
    this._payload = payload;
    this._name = this._payload.name ? this._payload.name.value : "";
    this._role = this._payload.role ? this._payload.role.value : "Unknown";
    for (const property of this._payload.properties || []) {
      if (property.name === "editable") {
        this._richlyEditable = property.value.value === "richtext";
        this._editable = true;
      }
      if (property.name === "focusable")
        this._focusable = property.value.value;
      if (property.name === "expanded")
        this._expanded = property.value.value;
      if (property.name === "hidden")
        this._hidden = property.value.value;
    }
  }
  _isPlainTextField() {
    if (this._richlyEditable)
      return false;
    if (this._editable)
      return true;
    return this._role === "textbox" || this._role === "ComboBox" || this._role === "searchbox";
  }
  _isTextOnlyObject() {
    const role = this._role;
    return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
  }
  _hasFocusableChild() {
    if (this._cachedHasFocusableChild === void 0) {
      this._cachedHasFocusableChild = false;
      for (const child of this._children) {
        if (child._focusable || child._hasFocusableChild()) {
          this._cachedHasFocusableChild = true;
          break;
        }
      }
    }
    return this._cachedHasFocusableChild;
  }
  children() {
    return this._children;
  }
  async _findElement(element) {
    const objectId = element._objectId;
    const { node: { backendNodeId } } = await this._client.send("DOM.describeNode", { objectId });
    const needle = this.find((node2) => node2._payload.backendDOMNodeId === backendNodeId);
    return needle || null;
  }
  find(predicate) {
    if (predicate(this))
      return this;
    for (const child of this._children) {
      const result = child.find(predicate);
      if (result)
        return result;
    }
    return null;
  }
  isLeafNode() {
    if (!this._children.length)
      return true;
    if (this._isPlainTextField() || this._isTextOnlyObject())
      return true;
    switch (this._role) {
      case "doc-cover":
      case "graphics-symbol":
      case "img":
      case "Meter":
      case "scrollbar":
      case "slider":
      case "separator":
      case "progressbar":
        return true;
    }
    if (this._hasFocusableChild())
      return false;
    if (this._focusable && this._role !== "WebArea" && this._role !== "RootWebArea" && this._name)
      return true;
    if (this._role === "heading" && this._name)
      return true;
    return false;
  }
  isControl() {
    switch (this._role) {
      case "button":
      case "checkbox":
      case "ColorWell":
      case "combobox":
      case "DisclosureTriangle":
      case "listbox":
      case "menu":
      case "menubar":
      case "menuitem":
      case "menuitemcheckbox":
      case "menuitemradio":
      case "radio":
      case "scrollbar":
      case "searchbox":
      case "slider":
      case "spinbutton":
      case "switch":
      case "tab":
      case "textbox":
      case "tree":
        return true;
      default:
        return false;
    }
  }
  isInteresting(insideControl) {
    const role = this._role;
    if (role === "Ignored" || this._hidden)
      return false;
    if (this._focusable || this._richlyEditable)
      return true;
    if (this.isControl())
      return true;
    if (insideControl)
      return false;
    return this.isLeafNode() && !!this._name;
  }
  normalizedRole() {
    switch (this._role) {
      case "RootWebArea":
        return "WebArea";
      case "StaticText":
        return "text";
      default:
        return this._role;
    }
  }
  serialize() {
    const properties = /* @__PURE__ */ new Map();
    for (const property of this._payload.properties || [])
      properties.set(property.name.toLowerCase(), property.value.value);
    if (this._payload.description)
      properties.set("description", this._payload.description.value);
    const node2 = {
      role: this.normalizedRole(),
      name: this._payload.name ? this._payload.name.value || "" : ""
    };
    const userStringProperties = [
      "description",
      "keyshortcuts",
      "roledescription",
      "valuetext"
    ];
    for (const userStringProperty of userStringProperties) {
      if (!properties.has(userStringProperty))
        continue;
      node2[userStringProperty] = properties.get(userStringProperty);
    }
    const booleanProperties = [
      "disabled",
      "expanded",
      "focused",
      "modal",
      "multiline",
      "multiselectable",
      "readonly",
      "required",
      "selected"
    ];
    for (const booleanProperty of booleanProperties) {
      if (booleanProperty === "focused" && (this._role === "WebArea" || this._role === "RootWebArea"))
        continue;
      const value = properties.get(booleanProperty);
      if (!value)
        continue;
      node2[booleanProperty] = value;
    }
    const numericalProperties = [
      "level",
      "valuemax",
      "valuemin"
    ];
    for (const numericalProperty of numericalProperties) {
      if (!properties.has(numericalProperty))
        continue;
      node2[numericalProperty] = properties.get(numericalProperty);
    }
    const tokenProperties = [
      "autocomplete",
      "haspopup",
      "invalid",
      "orientation"
    ];
    for (const tokenProperty of tokenProperties) {
      const value = properties.get(tokenProperty);
      if (!value || value === "false")
        continue;
      node2[tokenProperty] = value;
    }
    const axNode = node2;
    if (this._payload.value) {
      if (typeof this._payload.value.value === "string")
        axNode.valueString = this._payload.value.value;
      if (typeof this._payload.value.value === "number")
        axNode.valueNumber = this._payload.value.value;
    }
    if (properties.has("checked"))
      axNode.checked = properties.get("checked") === "true" ? "checked" : properties.get("checked") === "false" ? "unchecked" : "mixed";
    if (properties.has("pressed"))
      axNode.pressed = properties.get("pressed") === "true" ? "pressed" : properties.get("pressed") === "false" ? "released" : "mixed";
    return axNode;
  }
  static createTree(client, payloads) {
    const nodeById = /* @__PURE__ */ new Map();
    for (const payload of payloads)
      nodeById.set(payload.nodeId, new _CRAXNode(client, payload));
    for (const node2 of nodeById.values()) {
      for (const childId of node2._payload.childIds || [])
        node2._children.push(nodeById.get(childId));
    }
    return nodeById.values().next().value;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crCoverage.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var CRCoverage = class {
  static {
    __name(this, "CRCoverage");
  }
  constructor(client) {
    this._jsCoverage = new JSCoverage(client);
    this._cssCoverage = new CSSCoverage(client);
  }
  async startJSCoverage(options2) {
    return await this._jsCoverage.start(options2);
  }
  async stopJSCoverage() {
    return await this._jsCoverage.stop();
  }
  async startCSSCoverage(options2) {
    return await this._cssCoverage.start(options2);
  }
  async stopCSSCoverage() {
    return await this._cssCoverage.stop();
  }
};
var JSCoverage = class {
  static {
    __name(this, "JSCoverage");
  }
  constructor(client) {
    this._reportAnonymousScripts = false;
    this._client = client;
    this._enabled = false;
    this._scriptIds = /* @__PURE__ */ new Set();
    this._scriptSources = /* @__PURE__ */ new Map();
    this._eventListeners = [];
    this._resetOnNavigation = false;
  }
  async start(options2) {
    assert3(!this._enabled, "JSCoverage is already enabled");
    const {
      resetOnNavigation = true,
      reportAnonymousScripts = false
    } = options2;
    this._resetOnNavigation = resetOnNavigation;
    this._reportAnonymousScripts = reportAnonymousScripts;
    this._enabled = true;
    this._scriptIds.clear();
    this._scriptSources.clear();
    this._eventListeners = [
      eventsHelper.addEventListener(this._client, "Debugger.scriptParsed", this._onScriptParsed.bind(this)),
      eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this)),
      eventsHelper.addEventListener(this._client, "Debugger.paused", this._onDebuggerPaused.bind(this))
    ];
    await Promise.all([
      this._client.send("Profiler.enable"),
      this._client.send("Profiler.startPreciseCoverage", { callCount: true, detailed: true }),
      this._client.send("Debugger.enable"),
      this._client.send("Debugger.setSkipAllPauses", { skip: true })
    ]);
  }
  _onDebuggerPaused() {
    this._client.send("Debugger.resume");
  }
  _onExecutionContextsCleared() {
    if (!this._resetOnNavigation)
      return;
    this._scriptIds.clear();
    this._scriptSources.clear();
  }
  async _onScriptParsed(event) {
    this._scriptIds.add(event.scriptId);
    if (!event.url && !this._reportAnonymousScripts)
      return;
    const response = await this._client._sendMayFail("Debugger.getScriptSource", { scriptId: event.scriptId });
    if (response)
      this._scriptSources.set(event.scriptId, response.scriptSource);
  }
  async stop() {
    assert3(this._enabled, "JSCoverage is not enabled");
    this._enabled = false;
    const [profileResponse] = await Promise.all([
      this._client.send("Profiler.takePreciseCoverage"),
      this._client.send("Profiler.stopPreciseCoverage"),
      this._client.send("Profiler.disable"),
      this._client.send("Debugger.disable")
    ]);
    eventsHelper.removeEventListeners(this._eventListeners);
    const coverage = { entries: [] };
    for (const entry of profileResponse.result) {
      if (!this._scriptIds.has(entry.scriptId))
        continue;
      if (!entry.url && !this._reportAnonymousScripts)
        continue;
      const source7 = this._scriptSources.get(entry.scriptId);
      if (source7)
        coverage.entries.push({ ...entry, source: source7 });
      else
        coverage.entries.push(entry);
    }
    return coverage;
  }
};
var CSSCoverage = class {
  static {
    __name(this, "CSSCoverage");
  }
  constructor(client) {
    this._client = client;
    this._enabled = false;
    this._stylesheetURLs = /* @__PURE__ */ new Map();
    this._stylesheetSources = /* @__PURE__ */ new Map();
    this._eventListeners = [];
    this._resetOnNavigation = false;
  }
  async start(options2) {
    assert3(!this._enabled, "CSSCoverage is already enabled");
    const { resetOnNavigation = true } = options2;
    this._resetOnNavigation = resetOnNavigation;
    this._enabled = true;
    this._stylesheetURLs.clear();
    this._stylesheetSources.clear();
    this._eventListeners = [
      eventsHelper.addEventListener(this._client, "CSS.styleSheetAdded", this._onStyleSheet.bind(this)),
      eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this))
    ];
    await Promise.all([
      this._client.send("DOM.enable"),
      this._client.send("CSS.enable"),
      this._client.send("CSS.startRuleUsageTracking")
    ]);
  }
  _onExecutionContextsCleared() {
    if (!this._resetOnNavigation)
      return;
    this._stylesheetURLs.clear();
    this._stylesheetSources.clear();
  }
  async _onStyleSheet(event) {
    const header = event.header;
    if (!header.sourceURL)
      return;
    const response = await this._client._sendMayFail("CSS.getStyleSheetText", { styleSheetId: header.styleSheetId });
    if (response) {
      this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
      this._stylesheetSources.set(header.styleSheetId, response.text);
    }
  }
  async stop() {
    assert3(this._enabled, "CSSCoverage is not enabled");
    this._enabled = false;
    const ruleTrackingResponse = await this._client.send("CSS.stopRuleUsageTracking");
    await Promise.all([
      this._client.send("CSS.disable"),
      this._client.send("DOM.disable")
    ]);
    eventsHelper.removeEventListeners(this._eventListeners);
    const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
    for (const entry of ruleTrackingResponse.ruleUsage) {
      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
      if (!ranges) {
        ranges = [];
        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
      }
      ranges.push({
        startOffset: entry.startOffset,
        endOffset: entry.endOffset,
        count: entry.used ? 1 : 0
      });
    }
    const coverage = { entries: [] };
    for (const styleSheetId of this._stylesheetURLs.keys()) {
      const url4 = this._stylesheetURLs.get(styleSheetId);
      const text = this._stylesheetSources.get(styleSheetId);
      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
      coverage.entries.push({ url: url4, ranges, text });
    }
    return coverage;
  }
};
function convertToDisjointRanges(nestedRanges) {
  const points = [];
  for (const range of nestedRanges) {
    points.push({ offset: range.startOffset, type: 0, range });
    points.push({ offset: range.endOffset, type: 1, range });
  }
  points.sort((a, b) => {
    if (a.offset !== b.offset)
      return a.offset - b.offset;
    if (a.type !== b.type)
      return b.type - a.type;
    const aLength = a.range.endOffset - a.range.startOffset;
    const bLength = b.range.endOffset - b.range.startOffset;
    if (a.type === 0)
      return bLength - aLength;
    return aLength - bLength;
  });
  const hitCountStack = [];
  const results = [];
  let lastOffset = 0;
  for (const point of points) {
    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
      const lastResult = results.length ? results[results.length - 1] : null;
      if (lastResult && lastResult.end === lastOffset)
        lastResult.end = point.offset;
      else
        results.push({ start: lastOffset, end: point.offset });
    }
    lastOffset = point.offset;
    if (point.type === 0)
      hitCountStack.push(point.range.count);
    else
      hitCountStack.pop();
  }
  return results.filter((range) => range.end - range.start > 1);
}
__name(convertToDisjointRanges, "convertToDisjointRanges");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crDragDrop.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crProtocolHelper.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getExceptionMessage(exceptionDetails) {
  if (exceptionDetails.exception)
    return exceptionDetails.exception.description || String(exceptionDetails.exception.value);
  let message = exceptionDetails.text;
  if (exceptionDetails.stackTrace) {
    for (const callframe of exceptionDetails.stackTrace.callFrames) {
      const location2 = callframe.url + ":" + callframe.lineNumber + ":" + callframe.columnNumber;
      const functionName = callframe.functionName || "<anonymous>";
      message += `
    at ${functionName} (${location2})`;
    }
  }
  return message;
}
__name(getExceptionMessage, "getExceptionMessage");
async function releaseObject(client, objectId) {
  await client.send("Runtime.releaseObject", { objectId }).catch((error4) => {
  });
}
__name(releaseObject, "releaseObject");
async function saveProtocolStream(client, handle, path31) {
  let eof = false;
  await mkdirIfNeeded(path31);
  const fd = await fs.promises.open(path31, "w");
  while (!eof) {
    const response = await client.send("IO.read", { handle });
    eof = response.eof;
    const buf = Buffer.from(response.data, response.base64Encoded ? "base64" : void 0);
    await fd.write(buf);
  }
  await fd.close();
  await client.send("IO.close", { handle });
}
__name(saveProtocolStream, "saveProtocolStream");
async function readProtocolStream(client, handle) {
  let eof = false;
  const chunks = [];
  while (!eof) {
    const response = await client.send("IO.read", { handle });
    eof = response.eof;
    const buf = Buffer.from(response.data, response.base64Encoded ? "base64" : void 0);
    chunks.push(buf);
  }
  await client.send("IO.close", { handle });
  return Buffer.concat(chunks);
}
__name(readProtocolStream, "readProtocolStream");
function toConsoleMessageLocation(stackTrace) {
  return stackTrace && stackTrace.callFrames.length ? {
    url: stackTrace.callFrames[0].url,
    lineNumber: stackTrace.callFrames[0].lineNumber,
    columnNumber: stackTrace.callFrames[0].columnNumber
  } : { url: "", lineNumber: 0, columnNumber: 0 };
}
__name(toConsoleMessageLocation, "toConsoleMessageLocation");
function exceptionToError(exceptionDetails) {
  const messageWithStack = getExceptionMessage(exceptionDetails);
  const lines = messageWithStack.split("\n");
  const firstStackTraceLine = lines.findIndex((line) => line.startsWith("    at"));
  let messageWithName = "";
  let stack = "";
  if (firstStackTraceLine === -1) {
    messageWithName = messageWithStack;
  } else {
    messageWithName = lines.slice(0, firstStackTraceLine).join("\n");
    stack = messageWithStack;
  }
  const { name, message } = splitErrorMessage(messageWithName);
  const err = new Error(message);
  err.stack = stack;
  const nameOverride = exceptionDetails.exception?.preview?.properties.find((o) => o.name === "name");
  err.name = nameOverride ? nameOverride.value ?? "Error" : name;
  return err;
}
__name(exceptionToError, "exceptionToError");
function toModifiersMask(modifiers) {
  let mask = 0;
  if (modifiers.has("Alt"))
    mask |= 1;
  if (modifiers.has("Control"))
    mask |= 2;
  if (modifiers.has("Meta"))
    mask |= 4;
  if (modifiers.has("Shift"))
    mask |= 8;
  return mask;
}
__name(toModifiersMask, "toModifiersMask");
function toButtonsMask(buttons) {
  let mask = 0;
  if (buttons.has("left"))
    mask |= 1;
  if (buttons.has("right"))
    mask |= 2;
  if (buttons.has("middle"))
    mask |= 4;
  return mask;
}
__name(toButtonsMask, "toButtonsMask");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crDragDrop.js
import "node:path";
import "node:url";
var DragManager = class {
  static {
    __name(this, "DragManager");
  }
  constructor(page) {
    this._dragState = null;
    this._lastPosition = { x: 0, y: 0 };
    this._crPage = page;
  }
  async cancelDrag() {
    if (!this._dragState)
      return false;
    await this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
      type: "dragCancel",
      x: this._lastPosition.x,
      y: this._lastPosition.y,
      data: {
        items: [],
        dragOperationsMask: 65535
      }
    });
    this._dragState = null;
    return true;
  }
  async interceptDragCausedByMove(x, y, button, buttons, modifiers, moveCallback) {
    this._lastPosition = { x, y };
    if (this._dragState) {
      await this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
        type: "dragOver",
        x,
        y,
        data: this._dragState,
        modifiers: toModifiersMask(modifiers)
      });
      return;
    }
    if (button !== "left")
      return moveCallback();
    const client = this._crPage._mainFrameSession._client;
    let onDragIntercepted;
    const dragInterceptedPromise = new Promise((x2) => onDragIntercepted = x2);
    function setupDragListeners() {
      let didStartDrag = Promise.resolve(false);
      let dragEvent = null;
      const dragListener = /* @__PURE__ */ __name((event) => dragEvent = event, "dragListener");
      const mouseListener = /* @__PURE__ */ __name(() => {
        didStartDrag = new Promise((callback) => {
          window.addEventListener("dragstart", dragListener, { once: true, capture: true });
          setTimeout(() => callback(dragEvent ? !dragEvent.defaultPrevented : false), 0);
        });
      }, "mouseListener");
      window.addEventListener("mousemove", mouseListener, { once: true, capture: true });
      window.__cleanupDrag = async () => {
        const val = await didStartDrag;
        window.removeEventListener("mousemove", mouseListener, { capture: true });
        window.removeEventListener("dragstart", dragListener, { capture: true });
        delete window.__cleanupDrag;
        return val;
      };
    }
    __name(setupDragListeners, "setupDragListeners");
    const script = `((__name => (${setupDragListeners.toString()}))(t => t))`;
    await this._crPage._page.safeNonStallingEvaluateInAllFrames(`(${script})()`, "utility");
    client.on("Input.dragIntercepted", onDragIntercepted);
    try {
      await client.send("Input.setInterceptDrags", { enabled: true });
    } catch {
      client.off("Input.dragIntercepted", onDragIntercepted);
      return moveCallback();
    }
    await moveCallback();
    const expectingDrag = (await Promise.all(this._crPage._page.frames().map(async (frame) => {
      return frame.nonStallingEvaluateInExistingContext("window.__cleanupDrag && window.__cleanupDrag()", "utility").catch(() => false);
    }))).some((x2) => x2);
    this._dragState = expectingDrag ? (await dragInterceptedPromise).data : null;
    client.off("Input.dragIntercepted", onDragIntercepted);
    await client.send("Input.setInterceptDrags", { enabled: false });
    if (this._dragState) {
      await this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
        type: "dragEnter",
        x,
        y,
        data: this._dragState,
        modifiers: toModifiersMask(modifiers)
      });
    }
  }
  isDragging() {
    return !!this._dragState;
  }
  async drop(x, y, modifiers) {
    assert3(this._dragState, "missing drag state");
    await this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
      type: "drop",
      x,
      y,
      data: this._dragState,
      modifiers: toModifiersMask(modifiers)
    });
    this._dragState = null;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crExecutionContext.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CRExecutionContext = class {
  static {
    __name(this, "CRExecutionContext");
  }
  constructor(client, contextPayload) {
    this._client = client;
    this._contextId = contextPayload.id;
  }
  async rawEvaluateJSON(expression) {
    const { exceptionDetails, result: remoteObject } = await this._client.send("Runtime.evaluate", {
      expression,
      contextId: this._contextId,
      returnByValue: true
    }).catch(rewriteError);
    if (exceptionDetails)
      throw new JavaScriptErrorInEvaluate(getExceptionMessage(exceptionDetails));
    return remoteObject.value;
  }
  async rawEvaluateHandle(context2, expression) {
    const { exceptionDetails, result: remoteObject } = await this._client.send("Runtime.evaluate", {
      expression,
      contextId: this._contextId
    }).catch(rewriteError);
    if (exceptionDetails)
      throw new JavaScriptErrorInEvaluate(getExceptionMessage(exceptionDetails));
    return createHandle(context2, remoteObject);
  }
  async evaluateWithArguments(expression, returnByValue, utilityScript, values, handles) {
    const { exceptionDetails, result: remoteObject } = await this._client.send("Runtime.callFunctionOn", {
      functionDeclaration: expression,
      objectId: utilityScript._objectId,
      arguments: [
        { objectId: utilityScript._objectId },
        ...values.map((value) => ({ value })),
        ...handles.map((handle) => ({ objectId: handle._objectId }))
      ],
      returnByValue,
      awaitPromise: true,
      userGesture: true
    }).catch(rewriteError);
    if (exceptionDetails)
      throw new JavaScriptErrorInEvaluate(getExceptionMessage(exceptionDetails));
    return returnByValue ? parseEvaluationResultValue(remoteObject.value) : createHandle(utilityScript._context, remoteObject);
  }
  async getProperties(object) {
    const response = await this._client.send("Runtime.getProperties", {
      objectId: object._objectId,
      ownProperties: true
    });
    const result = /* @__PURE__ */ new Map();
    for (const property of response.result) {
      if (!property.enumerable || !property.value)
        continue;
      result.set(property.name, createHandle(object._context, property.value));
    }
    return result;
  }
  async releaseHandle(handle) {
    if (!handle._objectId)
      return;
    await releaseObject(this._client, handle._objectId);
  }
};
function rewriteError(error4) {
  if (error4.message.includes("Object reference chain is too long"))
    throw new Error("Cannot serialize result: object reference chain is too long.");
  if (error4.message.includes("Object couldn't be returned by value"))
    return { result: { type: "undefined" } };
  if (error4 instanceof TypeError && error4.message.startsWith("Converting circular structure to JSON"))
    rewriteErrorMessage(error4, error4.message + " Are you passing a nested JSHandle?");
  if (!isJavaScriptErrorInEvaluate(error4) && !isSessionClosedError(error4))
    throw new Error("Execution context was destroyed, most likely because of a navigation.");
  throw error4;
}
__name(rewriteError, "rewriteError");
function potentiallyUnserializableValue(remoteObject) {
  const value = remoteObject.value;
  const unserializableValue = remoteObject.unserializableValue;
  return unserializableValue ? parseUnserializableValue(unserializableValue) : value;
}
__name(potentiallyUnserializableValue, "potentiallyUnserializableValue");
function renderPreview(object) {
  if (object.type === "undefined")
    return "undefined";
  if ("value" in object)
    return String(object.value);
  if (object.unserializableValue)
    return String(object.unserializableValue);
  if (object.description === "Object" && object.preview) {
    const tokens = [];
    for (const { name, value } of object.preview.properties)
      tokens.push(`${name}: ${value}`);
    return `{${tokens.join(", ")}}`;
  }
  if (object.subtype === "array" && object.preview)
    return sparseArrayToString(object.preview.properties);
  return object.description;
}
__name(renderPreview, "renderPreview");
function createHandle(context2, remoteObject) {
  if (remoteObject.subtype === "node") {
    assert3(context2 instanceof FrameExecutionContext);
    return new ElementHandle(context2, remoteObject.objectId);
  }
  return new JSHandle(context2, remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
}
__name(createHandle, "createHandle");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crInput.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/macEditingCommands.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var macEditingCommands = {
  "Backspace": "deleteBackward:",
  "Enter": "insertNewline:",
  "NumpadEnter": "insertNewline:",
  "Escape": "cancelOperation:",
  "ArrowUp": "moveUp:",
  "ArrowDown": "moveDown:",
  "ArrowLeft": "moveLeft:",
  "ArrowRight": "moveRight:",
  "F5": "complete:",
  "Delete": "deleteForward:",
  "Home": "scrollToBeginningOfDocument:",
  "End": "scrollToEndOfDocument:",
  "PageUp": "scrollPageUp:",
  "PageDown": "scrollPageDown:",
  "Shift+Backspace": "deleteBackward:",
  "Shift+Enter": "insertNewline:",
  "Shift+NumpadEnter": "insertNewline:",
  "Shift+Escape": "cancelOperation:",
  "Shift+ArrowUp": "moveUpAndModifySelection:",
  "Shift+ArrowDown": "moveDownAndModifySelection:",
  "Shift+ArrowLeft": "moveLeftAndModifySelection:",
  "Shift+ArrowRight": "moveRightAndModifySelection:",
  "Shift+F5": "complete:",
  "Shift+Delete": "deleteForward:",
  "Shift+Home": "moveToBeginningOfDocumentAndModifySelection:",
  "Shift+End": "moveToEndOfDocumentAndModifySelection:",
  "Shift+PageUp": "pageUpAndModifySelection:",
  "Shift+PageDown": "pageDownAndModifySelection:",
  "Shift+Numpad5": "delete:",
  "Control+Tab": "selectNextKeyView:",
  "Control+Enter": "insertLineBreak:",
  "Control+NumpadEnter": "insertLineBreak:",
  "Control+Quote": "insertSingleQuoteIgnoringSubstitution:",
  "Control+KeyA": "moveToBeginningOfParagraph:",
  "Control+KeyB": "moveBackward:",
  "Control+KeyD": "deleteForward:",
  "Control+KeyE": "moveToEndOfParagraph:",
  "Control+KeyF": "moveForward:",
  "Control+KeyH": "deleteBackward:",
  "Control+KeyK": "deleteToEndOfParagraph:",
  "Control+KeyL": "centerSelectionInVisibleArea:",
  "Control+KeyN": "moveDown:",
  "Control+KeyO": ["insertNewlineIgnoringFieldEditor:", "moveBackward:"],
  "Control+KeyP": "moveUp:",
  "Control+KeyT": "transpose:",
  "Control+KeyV": "pageDown:",
  "Control+KeyY": "yank:",
  "Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
  "Control+ArrowUp": "scrollPageUp:",
  "Control+ArrowDown": "scrollPageDown:",
  "Control+ArrowLeft": "moveToLeftEndOfLine:",
  "Control+ArrowRight": "moveToRightEndOfLine:",
  "Shift+Control+Enter": "insertLineBreak:",
  "Shift+Control+NumpadEnter": "insertLineBreak:",
  "Shift+Control+Tab": "selectPreviousKeyView:",
  "Shift+Control+Quote": "insertDoubleQuoteIgnoringSubstitution:",
  "Shift+Control+KeyA": "moveToBeginningOfParagraphAndModifySelection:",
  "Shift+Control+KeyB": "moveBackwardAndModifySelection:",
  "Shift+Control+KeyE": "moveToEndOfParagraphAndModifySelection:",
  "Shift+Control+KeyF": "moveForwardAndModifySelection:",
  "Shift+Control+KeyN": "moveDownAndModifySelection:",
  "Shift+Control+KeyP": "moveUpAndModifySelection:",
  "Shift+Control+KeyV": "pageDownAndModifySelection:",
  "Shift+Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
  "Shift+Control+ArrowUp": "scrollPageUp:",
  "Shift+Control+ArrowDown": "scrollPageDown:",
  "Shift+Control+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
  "Shift+Control+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
  "Alt+Backspace": "deleteWordBackward:",
  "Alt+Enter": "insertNewlineIgnoringFieldEditor:",
  "Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
  "Alt+Escape": "complete:",
  "Alt+ArrowUp": ["moveBackward:", "moveToBeginningOfParagraph:"],
  "Alt+ArrowDown": ["moveForward:", "moveToEndOfParagraph:"],
  "Alt+ArrowLeft": "moveWordLeft:",
  "Alt+ArrowRight": "moveWordRight:",
  "Alt+Delete": "deleteWordForward:",
  "Alt+PageUp": "pageUp:",
  "Alt+PageDown": "pageDown:",
  "Shift+Alt+Backspace": "deleteWordBackward:",
  "Shift+Alt+Enter": "insertNewlineIgnoringFieldEditor:",
  "Shift+Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
  "Shift+Alt+Escape": "complete:",
  "Shift+Alt+ArrowUp": "moveParagraphBackwardAndModifySelection:",
  "Shift+Alt+ArrowDown": "moveParagraphForwardAndModifySelection:",
  "Shift+Alt+ArrowLeft": "moveWordLeftAndModifySelection:",
  "Shift+Alt+ArrowRight": "moveWordRightAndModifySelection:",
  "Shift+Alt+Delete": "deleteWordForward:",
  "Shift+Alt+PageUp": "pageUp:",
  "Shift+Alt+PageDown": "pageDown:",
  "Control+Alt+KeyB": "moveWordBackward:",
  "Control+Alt+KeyF": "moveWordForward:",
  "Control+Alt+Backspace": "deleteWordBackward:",
  "Shift+Control+Alt+KeyB": "moveWordBackwardAndModifySelection:",
  "Shift+Control+Alt+KeyF": "moveWordForwardAndModifySelection:",
  "Shift+Control+Alt+Backspace": "deleteWordBackward:",
  "Meta+NumpadSubtract": "cancel:",
  "Meta+Backspace": "deleteToBeginningOfLine:",
  "Meta+ArrowUp": "moveToBeginningOfDocument:",
  "Meta+ArrowDown": "moveToEndOfDocument:",
  "Meta+ArrowLeft": "moveToLeftEndOfLine:",
  "Meta+ArrowRight": "moveToRightEndOfLine:",
  "Shift+Meta+NumpadSubtract": "cancel:",
  "Shift+Meta+Backspace": "deleteToBeginningOfLine:",
  "Shift+Meta+ArrowUp": "moveToBeginningOfDocumentAndModifySelection:",
  "Shift+Meta+ArrowDown": "moveToEndOfDocumentAndModifySelection:",
  "Shift+Meta+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
  "Shift+Meta+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
  "Meta+KeyA": "selectAll:",
  "Meta+KeyC": "copy:",
  "Meta+KeyX": "cut:",
  "Meta+KeyV": "paste:",
  "Meta+KeyZ": "undo:",
  "Shift+Meta+KeyZ": "redo:"
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crInput.js
var RawKeyboardImpl = class {
  static {
    __name(this, "RawKeyboardImpl");
  }
  constructor(_client, _isMac, _dragManger) {
    this._client = _client;
    this._isMac = _isMac;
    this._dragManger = _dragManger;
  }
  _commandsForCode(code, modifiers) {
    if (!this._isMac)
      return [];
    const parts = [];
    for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
      if (modifiers.has(modifier))
        parts.push(modifier);
    }
    parts.push(code);
    const shortcut = parts.join("+");
    let commands = macEditingCommands[shortcut] || [];
    if (isString2(commands))
      commands = [commands];
    commands = commands.filter((x) => !x.startsWith("insert"));
    return commands.map((c) => c.substring(0, c.length - 1));
  }
  async keydown(modifiers, keyName, description, autoRepeat) {
    const { code, key, location: location2, text } = description;
    if (code === "Escape" && await this._dragManger.cancelDrag())
      return;
    const commands = this._commandsForCode(code, modifiers);
    await this._client.send("Input.dispatchKeyEvent", {
      type: text ? "keyDown" : "rawKeyDown",
      modifiers: toModifiersMask(modifiers),
      windowsVirtualKeyCode: description.keyCodeWithoutLocation,
      code,
      commands,
      key,
      text,
      unmodifiedText: text,
      autoRepeat,
      location: location2,
      isKeypad: location2 === keypadLocation2
    });
  }
  async keyup(modifiers, keyName, description) {
    const { code, key, location: location2 } = description;
    await this._client.send("Input.dispatchKeyEvent", {
      type: "keyUp",
      modifiers: toModifiersMask(modifiers),
      key,
      windowsVirtualKeyCode: description.keyCodeWithoutLocation,
      code,
      location: location2
    });
  }
  async sendText(text) {
    await this._client.send("Input.insertText", { text });
  }
};
var RawMouseImpl = class {
  static {
    __name(this, "RawMouseImpl");
  }
  constructor(page, client, dragManager) {
    this._page = page;
    this._client = client;
    this._dragManager = dragManager;
  }
  async move(x, y, button, buttons, modifiers, forClick) {
    const actualMove = /* @__PURE__ */ __name(async () => {
      await this._client.send("Input.dispatchMouseEvent", {
        type: "mouseMoved",
        button,
        buttons: toButtonsMask(buttons),
        x,
        y,
        modifiers: toModifiersMask(modifiers)
      });
    }, "actualMove");
    if (forClick) {
      return actualMove();
    }
    await this._dragManager.interceptDragCausedByMove(x, y, button, buttons, modifiers, actualMove);
  }
  async down(x, y, button, buttons, modifiers, clickCount) {
    if (this._dragManager.isDragging())
      return;
    await this._client.send("Input.dispatchMouseEvent", {
      type: "mousePressed",
      button,
      buttons: toButtonsMask(buttons),
      x,
      y,
      modifiers: toModifiersMask(modifiers),
      clickCount
    });
  }
  async up(x, y, button, buttons, modifiers, clickCount) {
    if (this._dragManager.isDragging()) {
      await this._dragManager.drop(x, y, modifiers);
      return;
    }
    await this._client.send("Input.dispatchMouseEvent", {
      type: "mouseReleased",
      button,
      buttons: toButtonsMask(buttons),
      x,
      y,
      modifiers: toModifiersMask(modifiers),
      clickCount
    });
  }
  async wheel(x, y, buttons, modifiers, deltaX, deltaY) {
    await this._client.send("Input.dispatchMouseEvent", {
      type: "mouseWheel",
      x,
      y,
      modifiers: toModifiersMask(modifiers),
      deltaX,
      deltaY
    });
  }
};
var RawTouchscreenImpl = class {
  static {
    __name(this, "RawTouchscreenImpl");
  }
  constructor(client) {
    this._client = client;
  }
  async tap(x, y, modifiers) {
    await Promise.all([
      this._client.send("Input.dispatchTouchEvent", {
        type: "touchStart",
        modifiers: toModifiersMask(modifiers),
        touchPoints: [{
          x,
          y
        }]
      }),
      this._client.send("Input.dispatchTouchEvent", {
        type: "touchEnd",
        modifiers: toModifiersMask(modifiers),
        touchPoints: []
      })
    ]);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crNetworkManager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/headers.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function headersObjectToArray(headers, separator, setCookieSeparator) {
  if (!setCookieSeparator)
    setCookieSeparator = separator;
  const result = [];
  for (const name in headers) {
    const values = headers[name];
    if (values === void 0)
      continue;
    if (separator) {
      const sep = name.toLowerCase() === "set-cookie" ? setCookieSeparator : separator;
      for (const value of values.split(sep))
        result.push({ name, value: value.trim() });
    } else {
      result.push({ name, value: values });
    }
  }
  return result;
}
__name(headersObjectToArray, "headersObjectToArray");
function headersArrayToObject(headers, lowerCase) {
  const result = {};
  for (const { name, value } of headers)
    result[lowerCase ? name.toLowerCase() : name] = value;
  return result;
}
__name(headersArrayToObject, "headersArrayToObject");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crNetworkManager.js
import "node:path";
import "node:url";
var CRNetworkManager = class {
  static {
    __name(this, "CRNetworkManager");
  }
  constructor(page, serviceWorker) {
    this._requestIdToRequest = /* @__PURE__ */ new Map();
    this._requestIdToRequestWillBeSentEvent = /* @__PURE__ */ new Map();
    this._credentials = null;
    this._attemptedAuthentications = /* @__PURE__ */ new Set();
    this._userRequestInterceptionEnabled = false;
    this._protocolRequestInterceptionEnabled = false;
    this._offline = false;
    this._extraHTTPHeaders = [];
    this._requestIdToRequestPausedEvent = /* @__PURE__ */ new Map();
    this._responseExtraInfoTracker = new ResponseExtraInfoTracker();
    this._sessions = /* @__PURE__ */ new Map();
    this._page = page;
    this._serviceWorker = serviceWorker;
  }
  async addSession(session2, workerFrame, isMain) {
    const sessionInfo = { session: session2, isMain, workerFrame, eventListeners: [] };
    sessionInfo.eventListeners = [
      eventsHelper.addEventListener(session2, "Fetch.requestPaused", this._onRequestPaused.bind(this, sessionInfo)),
      eventsHelper.addEventListener(session2, "Fetch.authRequired", this._onAuthRequired.bind(this, sessionInfo)),
      eventsHelper.addEventListener(session2, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this, sessionInfo)),
      eventsHelper.addEventListener(session2, "Network.requestWillBeSentExtraInfo", this._onRequestWillBeSentExtraInfo.bind(this)),
      eventsHelper.addEventListener(session2, "Network.requestServedFromCache", this._onRequestServedFromCache.bind(this)),
      eventsHelper.addEventListener(session2, "Network.responseReceived", this._onResponseReceived.bind(this, sessionInfo)),
      eventsHelper.addEventListener(session2, "Network.responseReceivedExtraInfo", this._onResponseReceivedExtraInfo.bind(this)),
      eventsHelper.addEventListener(session2, "Network.loadingFinished", this._onLoadingFinished.bind(this, sessionInfo)),
      eventsHelper.addEventListener(session2, "Network.loadingFailed", this._onLoadingFailed.bind(this, sessionInfo))
    ];
    if (this._page) {
      sessionInfo.eventListeners.push(...[
        eventsHelper.addEventListener(session2, "Network.webSocketCreated", (e) => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)),
        eventsHelper.addEventListener(session2, "Network.webSocketWillSendHandshakeRequest", (e) => this._page._frameManager.onWebSocketRequest(e.requestId)),
        eventsHelper.addEventListener(session2, "Network.webSocketHandshakeResponseReceived", (e) => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)),
        eventsHelper.addEventListener(session2, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)),
        eventsHelper.addEventListener(session2, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)),
        eventsHelper.addEventListener(session2, "Network.webSocketClosed", (e) => this._page._frameManager.webSocketClosed(e.requestId)),
        eventsHelper.addEventListener(session2, "Network.webSocketFrameError", (e) => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))
      ]);
    }
    this._sessions.set(session2, sessionInfo);
    await Promise.all([
      session2.send("Network.enable"),
      this._updateProtocolRequestInterceptionForSession(
        sessionInfo,
        true
        /* initial */
      ),
      this._setOfflineForSession(
        sessionInfo,
        true
        /* initial */
      ),
      this._setExtraHTTPHeadersForSession(
        sessionInfo,
        true
        /* initial */
      )
    ]);
  }
  removeSession(session2) {
    const info3 = this._sessions.get(session2);
    if (info3)
      eventsHelper.removeEventListeners(info3.eventListeners);
    this._sessions.delete(session2);
  }
  async _forEachSession(cb) {
    await Promise.all([...this._sessions.values()].map((info3) => {
      if (info3.isMain)
        return cb(info3);
      return cb(info3).catch((e) => {
        if (isSessionClosedError(e))
          return;
        throw e;
      });
    }));
  }
  async authenticate(credentials) {
    this._credentials = credentials;
    await this._updateProtocolRequestInterception();
  }
  async setOffline(offline) {
    if (offline === this._offline)
      return;
    this._offline = offline;
    await this._forEachSession((info3) => this._setOfflineForSession(info3));
  }
  async _setOfflineForSession(info3, initial) {
    if (initial && !this._offline)
      return;
    if (info3.workerFrame)
      return;
    await info3.session.send("Network.emulateNetworkConditions", {
      offline: this._offline,
      // values of 0 remove any active throttling. crbug.com/456324#c9
      latency: 0,
      downloadThroughput: -1,
      uploadThroughput: -1
    });
  }
  async setRequestInterception(value) {
    this._userRequestInterceptionEnabled = value;
    await this._updateProtocolRequestInterception();
  }
  async _updateProtocolRequestInterception() {
    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
    if (enabled === this._protocolRequestInterceptionEnabled)
      return;
    this._protocolRequestInterceptionEnabled = enabled;
    await this._forEachSession((info3) => this._updateProtocolRequestInterceptionForSession(info3));
  }
  async _updateProtocolRequestInterceptionForSession(info3, initial) {
    const enabled = this._protocolRequestInterceptionEnabled;
    if (initial && !enabled)
      return;
    const cachePromise = info3.session.send("Network.setCacheDisabled", { cacheDisabled: enabled });
    let fetchPromise = Promise.resolve(void 0);
    if (!info3.workerFrame) {
      if (enabled)
        fetchPromise = info3.session.send("Fetch.enable", { handleAuthRequests: true, patterns: [{ urlPattern: "*", requestStage: "Request" }] });
      else
        fetchPromise = info3.session.send("Fetch.disable");
    }
    await Promise.all([cachePromise, fetchPromise]);
  }
  async setExtraHTTPHeaders(extraHTTPHeaders) {
    if (!this._extraHTTPHeaders.length && !extraHTTPHeaders.length)
      return;
    this._extraHTTPHeaders = extraHTTPHeaders;
    await this._forEachSession((info3) => this._setExtraHTTPHeadersForSession(info3));
  }
  async _setExtraHTTPHeadersForSession(info3, initial) {
    if (initial && !this._extraHTTPHeaders.length)
      return;
    await info3.session.send("Network.setExtraHTTPHeaders", { headers: headersArrayToObject(
      this._extraHTTPHeaders,
      false
      /* lowerCase */
    ) });
  }
  async clearCache() {
    await this._forEachSession(async (info3) => {
      await info3.session.send("Network.setCacheDisabled", { cacheDisabled: true });
      if (!this._protocolRequestInterceptionEnabled)
        await info3.session.send("Network.setCacheDisabled", { cacheDisabled: false });
      if (!info3.workerFrame)
        await info3.session.send("Network.clearBrowserCache");
    });
  }
  _onRequestWillBeSent(sessionInfo, event) {
    if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
      const requestId = event.requestId;
      const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);
      if (requestPausedEvent) {
        this._onRequest(sessionInfo, event, requestPausedEvent.sessionInfo, requestPausedEvent.event);
        this._requestIdToRequestPausedEvent.delete(requestId);
      } else {
        this._requestIdToRequestWillBeSentEvent.set(event.requestId, { sessionInfo, event });
      }
    } else {
      this._onRequest(sessionInfo, event, void 0, void 0);
    }
  }
  _onRequestServedFromCache(event) {
    this._responseExtraInfoTracker.requestServedFromCache(event);
  }
  _onRequestWillBeSentExtraInfo(event) {
    this._responseExtraInfoTracker.requestWillBeSentExtraInfo(event);
  }
  _onAuthRequired(sessionInfo, event) {
    let response = "Default";
    const shouldProvideCredentials = this._shouldProvideCredentials(event.request.url);
    if (this._attemptedAuthentications.has(event.requestId)) {
      response = "CancelAuth";
    } else if (shouldProvideCredentials) {
      response = "ProvideCredentials";
      this._attemptedAuthentications.add(event.requestId);
    }
    const { username, password } = shouldProvideCredentials && this._credentials ? this._credentials : { username: void 0, password: void 0 };
    sessionInfo.session._sendMayFail("Fetch.continueWithAuth", {
      requestId: event.requestId,
      authChallengeResponse: { response, username, password }
    });
  }
  _shouldProvideCredentials(url4) {
    if (!this._credentials)
      return false;
    return !this._credentials.origin || new URL(url4).origin.toLowerCase() === this._credentials.origin.toLowerCase();
  }
  _onRequestPaused(sessionInfo, event) {
    if (!event.networkId) {
      sessionInfo.session._sendMayFail("Fetch.continueRequest", { requestId: event.requestId });
      return;
    }
    if (event.request.url.startsWith("data:"))
      return;
    const requestId = event.networkId;
    const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
    if (requestWillBeSentEvent) {
      this._onRequest(requestWillBeSentEvent.sessionInfo, requestWillBeSentEvent.event, sessionInfo, event);
      this._requestIdToRequestWillBeSentEvent.delete(requestId);
    } else {
      const existingRequest = this._requestIdToRequest.get(requestId);
      const alreadyContinuedParams = existingRequest?._route?._alreadyContinuedParams;
      if (alreadyContinuedParams && !event.redirectedRequestId) {
        sessionInfo.session._sendMayFail("Fetch.continueRequest", {
          ...alreadyContinuedParams,
          requestId: event.requestId
        });
        return;
      }
      this._requestIdToRequestPausedEvent.set(requestId, { sessionInfo, event });
    }
  }
  _onRequest(requestWillBeSentSessionInfo, requestWillBeSentEvent, requestPausedSessionInfo, requestPausedEvent) {
    if (requestWillBeSentEvent.request.url.startsWith("data:"))
      return;
    let redirectedFrom = null;
    if (requestWillBeSentEvent.redirectResponse) {
      const request22 = this._requestIdToRequest.get(requestWillBeSentEvent.requestId);
      if (request22) {
        this._handleRequestRedirect(request22, requestWillBeSentEvent.redirectResponse, requestWillBeSentEvent.timestamp, requestWillBeSentEvent.redirectHasExtraInfo);
        redirectedFrom = request22;
      }
    }
    let frame = requestWillBeSentEvent.frameId ? this._page?._frameManager.frame(requestWillBeSentEvent.frameId) : requestWillBeSentSessionInfo.workerFrame;
    if (!frame && this._page && requestPausedEvent && requestPausedEvent.frameId)
      frame = this._page._frameManager.frame(requestPausedEvent.frameId);
    if (!frame && this._page && requestWillBeSentEvent.frameId === (this._page?._delegate)._targetId) {
      frame = this._page._frameManager.frameAttached(requestWillBeSentEvent.frameId, null);
    }
    const isInterceptedOptionsPreflight = !!requestPausedEvent && requestPausedEvent.request.method === "OPTIONS" && requestWillBeSentEvent.initiator.type === "preflight";
    if (isInterceptedOptionsPreflight && (this._page || this._serviceWorker).needsRequestInterception()) {
      const requestHeaders = requestPausedEvent.request.headers;
      const responseHeaders = [
        { name: "Access-Control-Allow-Origin", value: requestHeaders["Origin"] || "*" },
        { name: "Access-Control-Allow-Methods", value: requestHeaders["Access-Control-Request-Method"] || "GET, POST, OPTIONS, DELETE" },
        { name: "Access-Control-Allow-Credentials", value: "true" }
      ];
      if (requestHeaders["Access-Control-Request-Headers"])
        responseHeaders.push({ name: "Access-Control-Allow-Headers", value: requestHeaders["Access-Control-Request-Headers"] });
      requestPausedSessionInfo.session._sendMayFail("Fetch.fulfillRequest", {
        requestId: requestPausedEvent.requestId,
        responseCode: 204,
        responsePhrase: statusText(204),
        responseHeaders,
        body: ""
      });
      return;
    }
    if (!frame && !this._serviceWorker) {
      if (requestPausedEvent)
        requestPausedSessionInfo.session._sendMayFail("Fetch.continueRequest", { requestId: requestPausedEvent.requestId });
      return;
    }
    let route = null;
    let headersOverride;
    if (requestPausedEvent) {
      if (redirectedFrom || !this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {
        headersOverride = redirectedFrom?._originalRequestRoute?._alreadyContinuedParams?.headers;
        requestPausedSessionInfo.session._sendMayFail("Fetch.continueRequest", { requestId: requestPausedEvent.requestId, headers: headersOverride });
      } else {
        route = new RouteImpl(requestPausedSessionInfo.session, requestPausedEvent.requestId);
      }
    }
    const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === "Document";
    const documentId = isNavigationRequest ? requestWillBeSentEvent.loaderId : void 0;
    const request4 = new InterceptableRequest({
      session: requestWillBeSentSessionInfo.session,
      context: (this._page || this._serviceWorker)._browserContext,
      frame: frame || null,
      serviceWorker: this._serviceWorker || null,
      documentId,
      route,
      requestWillBeSentEvent,
      requestPausedEvent,
      redirectedFrom,
      headersOverride: headersOverride || null
    });
    this._requestIdToRequest.set(requestWillBeSentEvent.requestId, request4);
    if (route) {
      request4.request.setRawRequestHeaders(headersObjectToArray(requestPausedEvent.request.headers, "\n"));
    }
    (this._page?._frameManager || this._serviceWorker).requestStarted(request4.request, route || void 0);
  }
  _createResponse(request4, responsePayload, hasExtraInfo) {
    const getResponseBody = /* @__PURE__ */ __name(async () => {
      const contentLengthHeader = Object.entries(responsePayload.headers).find((header) => header[0].toLowerCase() === "content-length");
      const expectedLength = contentLengthHeader ? +contentLengthHeader[1] : void 0;
      const session2 = request4.session;
      const response2 = await session2.send("Network.getResponseBody", { requestId: request4._requestId });
      if (response2.body || !expectedLength)
        return Buffer.from(response2.body, response2.base64Encoded ? "base64" : "utf8");
      if (request4._route?._fulfilled)
        return Buffer.from("");
      const resource = await session2.send("Network.loadNetworkResource", { url: request4.request.url(), frameId: this._serviceWorker ? void 0 : request4.request.frame()._id, options: { disableCache: false, includeCredentials: true } });
      const chunks = [];
      while (resource.resource.stream) {
        const chunk = await session2.send("IO.read", { handle: resource.resource.stream });
        chunks.push(Buffer.from(chunk.data, chunk.base64Encoded ? "base64" : "utf-8"));
        if (chunk.eof) {
          await session2.send("IO.close", { handle: resource.resource.stream });
          break;
        }
      }
      return Buffer.concat(chunks);
    }, "getResponseBody");
    const timingPayload = responsePayload.timing;
    let timing;
    if (timingPayload && !this._responseExtraInfoTracker.servedFromCache(request4._requestId)) {
      timing = {
        startTime: (timingPayload.requestTime - request4._timestamp + request4._wallTime) * 1e3,
        domainLookupStart: timingPayload.dnsStart,
        domainLookupEnd: timingPayload.dnsEnd,
        connectStart: timingPayload.connectStart,
        secureConnectionStart: timingPayload.sslStart,
        connectEnd: timingPayload.connectEnd,
        requestStart: timingPayload.sendStart,
        responseStart: timingPayload.receiveHeadersEnd
      };
    } else {
      timing = {
        startTime: request4._wallTime * 1e3,
        domainLookupStart: -1,
        domainLookupEnd: -1,
        connectStart: -1,
        secureConnectionStart: -1,
        connectEnd: -1,
        requestStart: -1,
        responseStart: -1
      };
    }
    const response = new Response2(request4.request, responsePayload.status, responsePayload.statusText, headersObjectToArray(responsePayload.headers), timing, getResponseBody, !!responsePayload.fromServiceWorker, responsePayload.protocol);
    if (responsePayload?.remoteIPAddress && typeof responsePayload?.remotePort === "number") {
      response._serverAddrFinished({
        ipAddress: responsePayload.remoteIPAddress,
        port: responsePayload.remotePort
      });
    } else {
      response._serverAddrFinished();
    }
    response._securityDetailsFinished({
      protocol: responsePayload?.securityDetails?.protocol,
      subjectName: responsePayload?.securityDetails?.subjectName,
      issuer: responsePayload?.securityDetails?.issuer,
      validFrom: responsePayload?.securityDetails?.validFrom,
      validTo: responsePayload?.securityDetails?.validTo
    });
    this._responseExtraInfoTracker.processResponse(request4._requestId, response, hasExtraInfo);
    return response;
  }
  _deleteRequest(request4) {
    this._requestIdToRequest.delete(request4._requestId);
    if (request4._interceptionId)
      this._attemptedAuthentications.delete(request4._interceptionId);
  }
  _handleRequestRedirect(request4, responsePayload, timestamp2, hasExtraInfo) {
    const response = this._createResponse(request4, responsePayload, hasExtraInfo);
    response.setTransferSize(null);
    response.setEncodedBodySize(null);
    response._requestFinished((timestamp2 - request4._timestamp) * 1e3);
    this._deleteRequest(request4);
    (this._page?._frameManager || this._serviceWorker).requestReceivedResponse(response);
    (this._page?._frameManager || this._serviceWorker).reportRequestFinished(request4.request, response);
  }
  _onResponseReceivedExtraInfo(event) {
    this._responseExtraInfoTracker.responseReceivedExtraInfo(event);
  }
  _onResponseReceived(sessionInfo, event) {
    let request4 = this._requestIdToRequest.get(event.requestId);
    if (!request4 && event.response.fromServiceWorker) {
      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
      if (requestWillBeSentEvent) {
        this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
        this._onRequest(sessionInfo, requestWillBeSentEvent.event, void 0, void 0);
        request4 = this._requestIdToRequest.get(event.requestId);
      }
    }
    if (!request4)
      return;
    const response = this._createResponse(request4, event.response, event.hasExtraInfo);
    (this._page?._frameManager || this._serviceWorker).requestReceivedResponse(response);
  }
  _onLoadingFinished(sessionInfo, event) {
    this._responseExtraInfoTracker.loadingFinished(event);
    const request4 = this._requestIdToRequest.get(event.requestId);
    if (!request4)
      return;
    this._maybeUpdateRequestSession(sessionInfo, request4);
    const response = request4.request._existingResponse();
    if (response) {
      response.setTransferSize(event.encodedDataLength);
      response.responseHeadersSize().then((size) => response.setEncodedBodySize(event.encodedDataLength - size));
      response._requestFinished(helper.secondsToRoundishMillis(event.timestamp - request4._timestamp));
    }
    this._deleteRequest(request4);
    (this._page?._frameManager || this._serviceWorker).reportRequestFinished(request4.request, response);
  }
  _onLoadingFailed(sessionInfo, event) {
    this._responseExtraInfoTracker.loadingFailed(event);
    let request4 = this._requestIdToRequest.get(event.requestId);
    if (!request4) {
      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
      if (requestWillBeSentEvent) {
        this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
        this._onRequest(sessionInfo, requestWillBeSentEvent.event, void 0, void 0);
        request4 = this._requestIdToRequest.get(event.requestId);
      }
    }
    if (!request4)
      return;
    this._maybeUpdateRequestSession(sessionInfo, request4);
    const response = request4.request._existingResponse();
    if (response) {
      response.setTransferSize(null);
      response.setEncodedBodySize(null);
      response._requestFinished(helper.secondsToRoundishMillis(event.timestamp - request4._timestamp));
    } else {
      request4.request.setRawRequestHeaders(null);
    }
    this._deleteRequest(request4);
    request4.request._setFailureText(event.errorText || event.blockedReason || "");
    (this._page?._frameManager || this._serviceWorker).requestFailed(request4.request, !!event.canceled);
  }
  _maybeUpdateRequestSession(sessionInfo, request4) {
    if (request4.session !== sessionInfo.session && !sessionInfo.isMain && (request4._documentId === request4._requestId || sessionInfo.workerFrame))
      request4.session = sessionInfo.session;
  }
};
var InterceptableRequest = class {
  static {
    __name(this, "InterceptableRequest");
  }
  constructor(options2) {
    const { session: session2, context: context2, frame, documentId, route, requestWillBeSentEvent, requestPausedEvent, redirectedFrom, serviceWorker, headersOverride } = options2;
    this.session = session2;
    this._timestamp = requestWillBeSentEvent.timestamp;
    this._wallTime = requestWillBeSentEvent.wallTime;
    this._requestId = requestWillBeSentEvent.requestId;
    this._interceptionId = requestPausedEvent && requestPausedEvent.requestId;
    this._documentId = documentId;
    this._route = route;
    this._originalRequestRoute = route ?? redirectedFrom?._originalRequestRoute;
    const {
      headers,
      method,
      url: url4,
      postDataEntries = null
    } = requestPausedEvent ? requestPausedEvent.request : requestWillBeSentEvent.request;
    const type2 = (requestWillBeSentEvent.type || "").toLowerCase();
    let postDataBuffer = null;
    const entries = postDataEntries?.filter((entry) => entry.bytes);
    if (entries && entries.length)
      postDataBuffer = Buffer.concat(entries.map((entry) => Buffer.from(entry.bytes, "base64")));
    this.request = new Request(context2, frame, serviceWorker, redirectedFrom?.request || null, documentId, url4, type2, method, postDataBuffer, headersOverride || headersObjectToArray(headers));
  }
};
var RouteImpl = class {
  static {
    __name(this, "RouteImpl");
  }
  constructor(session2, interceptionId) {
    this._fulfilled = false;
    this._session = session2;
    this._interceptionId = interceptionId;
  }
  async continue(overrides) {
    this._alreadyContinuedParams = {
      requestId: this._interceptionId,
      url: overrides.url,
      headers: overrides.headers,
      method: overrides.method,
      postData: overrides.postData ? overrides.postData.toString("base64") : void 0
    };
    await catchDisallowedErrors(async () => {
      await this._session.send("Fetch.continueRequest", this._alreadyContinuedParams);
    });
  }
  async fulfill(response) {
    this._fulfilled = true;
    const body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
    const responseHeaders = splitSetCookieHeader(response.headers);
    await catchDisallowedErrors(async () => {
      await this._session.send("Fetch.fulfillRequest", {
        requestId: this._interceptionId,
        responseCode: response.status,
        responsePhrase: statusText(response.status),
        responseHeaders,
        body
      });
    });
  }
  async abort(errorCode = "failed") {
    const errorReason = errorReasons[errorCode];
    assert3(errorReason, "Unknown error code: " + errorCode);
    await catchDisallowedErrors(async () => {
      await this._session.send("Fetch.failRequest", {
        requestId: this._interceptionId,
        errorReason
      });
    });
  }
};
async function catchDisallowedErrors(callback) {
  try {
    return await callback();
  } catch (e) {
    if (isProtocolError(e) && e.message.includes("Invalid http status code or phrase"))
      throw e;
    if (isProtocolError(e) && e.message.includes("Unsafe header"))
      throw e;
  }
}
__name(catchDisallowedErrors, "catchDisallowedErrors");
function splitSetCookieHeader(headers) {
  const index2 = headers.findIndex(({ name }) => name.toLowerCase() === "set-cookie");
  if (index2 === -1)
    return headers;
  const header = headers[index2];
  const values = header.value.split("\n");
  if (values.length === 1)
    return headers;
  const result = headers.slice();
  result.splice(index2, 1, ...values.map((value) => ({ name: header.name, value })));
  return result;
}
__name(splitSetCookieHeader, "splitSetCookieHeader");
var errorReasons = {
  "aborted": "Aborted",
  "accessdenied": "AccessDenied",
  "addressunreachable": "AddressUnreachable",
  "blockedbyclient": "BlockedByClient",
  "blockedbyresponse": "BlockedByResponse",
  "connectionaborted": "ConnectionAborted",
  "connectionclosed": "ConnectionClosed",
  "connectionfailed": "ConnectionFailed",
  "connectionrefused": "ConnectionRefused",
  "connectionreset": "ConnectionReset",
  "internetdisconnected": "InternetDisconnected",
  "namenotresolved": "NameNotResolved",
  "timedout": "TimedOut",
  "failed": "Failed"
};
var ResponseExtraInfoTracker = class {
  static {
    __name(this, "ResponseExtraInfoTracker");
  }
  constructor() {
    this._requests = /* @__PURE__ */ new Map();
  }
  requestWillBeSentExtraInfo(event) {
    const info3 = this._getOrCreateEntry(event.requestId);
    info3.requestWillBeSentExtraInfo.push(event);
    this._patchHeaders(info3, info3.requestWillBeSentExtraInfo.length - 1);
    this._checkFinished(info3);
  }
  requestServedFromCache(event) {
    const info3 = this._getOrCreateEntry(event.requestId);
    info3.servedFromCache = true;
  }
  servedFromCache(requestId) {
    const info3 = this._requests.get(requestId);
    return !!info3?.servedFromCache;
  }
  responseReceivedExtraInfo(event) {
    const info3 = this._getOrCreateEntry(event.requestId);
    info3.responseReceivedExtraInfo.push(event);
    this._patchHeaders(info3, info3.responseReceivedExtraInfo.length - 1);
    this._checkFinished(info3);
  }
  processResponse(requestId, response, hasExtraInfo) {
    let info3 = this._requests.get(requestId);
    if (!hasExtraInfo || info3?.servedFromCache) {
      response.request().setRawRequestHeaders(null);
      response.setResponseHeadersSize(null);
      response.setRawResponseHeaders(null);
      return;
    }
    info3 = this._getOrCreateEntry(requestId);
    info3.responses.push(response);
    this._patchHeaders(info3, info3.responses.length - 1);
  }
  loadingFinished(event) {
    const info3 = this._requests.get(event.requestId);
    if (!info3)
      return;
    info3.loadingFinished = event;
    this._checkFinished(info3);
  }
  loadingFailed(event) {
    const info3 = this._requests.get(event.requestId);
    if (!info3)
      return;
    info3.loadingFailed = event;
    this._checkFinished(info3);
  }
  _getOrCreateEntry(requestId) {
    let info3 = this._requests.get(requestId);
    if (!info3) {
      info3 = {
        requestId,
        requestWillBeSentExtraInfo: [],
        responseReceivedExtraInfo: [],
        responses: []
      };
      this._requests.set(requestId, info3);
    }
    return info3;
  }
  _patchHeaders(info3, index2) {
    const response = info3.responses[index2];
    const requestExtraInfo = info3.requestWillBeSentExtraInfo[index2];
    if (response && requestExtraInfo) {
      response.request().setRawRequestHeaders(headersObjectToArray(requestExtraInfo.headers, "\n"));
      info3.requestWillBeSentExtraInfo[index2] = void 0;
    }
    const responseExtraInfo = info3.responseReceivedExtraInfo[index2];
    if (response && responseExtraInfo) {
      response.setResponseHeadersSize(responseExtraInfo.headersText?.length || 0);
      response.setRawResponseHeaders(headersObjectToArray(responseExtraInfo.headers, "\n"));
      info3.responseReceivedExtraInfo[index2] = void 0;
    }
  }
  _checkFinished(info3) {
    if (!info3.loadingFinished && !info3.loadingFailed)
      return;
    if (info3.responses.length <= info3.responseReceivedExtraInfo.length) {
      this._stopTracking(info3.requestId);
      return;
    }
  }
  _stopTracking(requestId) {
    this._requests.delete(requestId);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crPdf.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var PagePaperFormats = {
  letter: { width: 8.5, height: 11 },
  legal: { width: 8.5, height: 14 },
  tabloid: { width: 11, height: 17 },
  ledger: { width: 17, height: 11 },
  a0: { width: 33.1, height: 46.8 },
  a1: { width: 23.4, height: 33.1 },
  a2: { width: 16.54, height: 23.4 },
  a3: { width: 11.7, height: 16.54 },
  a4: { width: 8.27, height: 11.7 },
  a5: { width: 5.83, height: 8.27 },
  a6: { width: 4.13, height: 5.83 }
};
var unitToPixels = {
  "px": 1,
  "in": 96,
  "cm": 37.8,
  "mm": 3.78
};
function convertPrintParameterToInches(text) {
  if (text === void 0)
    return void 0;
  let unit = text.substring(text.length - 2).toLowerCase();
  let valueText = "";
  if (unitToPixels.hasOwnProperty(unit)) {
    valueText = text.substring(0, text.length - 2);
  } else {
    unit = "px";
    valueText = text;
  }
  const value = Number(valueText);
  assert3(!isNaN(value), "Failed to parse parameter value: " + text);
  const pixels = value * unitToPixels[unit];
  return pixels / 96;
}
__name(convertPrintParameterToInches, "convertPrintParameterToInches");
var CRPDF = class {
  static {
    __name(this, "CRPDF");
  }
  constructor(client) {
    this._client = client;
  }
  async generate(options2) {
    const {
      scale = 1,
      displayHeaderFooter = false,
      headerTemplate = "",
      footerTemplate = "",
      printBackground = false,
      landscape = false,
      pageRanges = "",
      preferCSSPageSize = false,
      margin = {},
      tagged = false,
      outline = false
    } = options2;
    let paperWidth = 8.5;
    let paperHeight = 11;
    if (options2.format) {
      const format2 = PagePaperFormats[options2.format.toLowerCase()];
      assert3(format2, "Unknown paper format: " + options2.format);
      paperWidth = format2.width;
      paperHeight = format2.height;
    } else {
      paperWidth = convertPrintParameterToInches(options2.width) || paperWidth;
      paperHeight = convertPrintParameterToInches(options2.height) || paperHeight;
    }
    const marginTop = convertPrintParameterToInches(margin.top) || 0;
    const marginLeft = convertPrintParameterToInches(margin.left) || 0;
    const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
    const marginRight = convertPrintParameterToInches(margin.right) || 0;
    const generateDocumentOutline = outline;
    const generateTaggedPDF = tagged;
    const result = await this._client.send("Page.printToPDF", {
      transferMode: "ReturnAsStream",
      landscape,
      displayHeaderFooter,
      headerTemplate,
      footerTemplate,
      printBackground,
      scale,
      paperWidth,
      paperHeight,
      marginTop,
      marginBottom,
      marginLeft,
      marginRight,
      pageRanges,
      preferCSSPageSize,
      generateTaggedPDF,
      generateDocumentOutline
    });
    return await readProtocolStream(this._client, result.stream);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/defaultFontFamilies.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var platformToFontFamilies = {
  "linux": {
    "fontFamilies": {
      "standard": "Times New Roman",
      "fixed": "Monospace",
      "serif": "Times New Roman",
      "sansSerif": "Arial",
      "cursive": "Comic Sans MS",
      "fantasy": "Impact"
    }
  },
  "mac": {
    "fontFamilies": {
      "standard": "Times",
      "fixed": "Courier",
      "serif": "Times",
      "sansSerif": "Helvetica",
      "cursive": "Apple Chancery",
      "fantasy": "Papyrus"
    },
    "forScripts": [
      {
        "script": "jpan",
        "fontFamilies": {
          "standard": "Hiragino Kaku Gothic ProN",
          "fixed": "Osaka-Mono",
          "serif": "Hiragino Mincho ProN",
          "sansSerif": "Hiragino Kaku Gothic ProN"
        }
      },
      {
        "script": "hang",
        "fontFamilies": {
          "standard": "Apple SD Gothic Neo",
          "serif": "AppleMyungjo",
          "sansSerif": "Apple SD Gothic Neo"
        }
      },
      {
        "script": "hans",
        "fontFamilies": {
          "standard": ",PingFang SC,STHeiti",
          "serif": "Songti SC",
          "sansSerif": ",PingFang SC,STHeiti",
          "cursive": "Kaiti SC"
        }
      },
      {
        "script": "hant",
        "fontFamilies": {
          "standard": ",PingFang TC,Heiti TC",
          "serif": "Songti TC",
          "sansSerif": ",PingFang TC,Heiti TC",
          "cursive": "Kaiti TC"
        }
      }
    ]
  },
  "win": {
    "fontFamilies": {
      "standard": "Times New Roman",
      "fixed": "Consolas",
      "serif": "Times New Roman",
      "sansSerif": "Arial",
      "cursive": "Comic Sans MS",
      "fantasy": "Impact"
    },
    "forScripts": [
      {
        "script": "cyrl",
        "fontFamilies": {
          "standard": "Times New Roman",
          "fixed": "Courier New",
          "serif": "Times New Roman",
          "sansSerif": "Arial"
        }
      },
      {
        "script": "arab",
        "fontFamilies": {
          "fixed": "Courier New",
          "sansSerif": "Segoe UI"
        }
      },
      {
        "script": "grek",
        "fontFamilies": {
          "standard": "Times New Roman",
          "fixed": "Courier New",
          "serif": "Times New Roman",
          "sansSerif": "Arial"
        }
      },
      {
        "script": "jpan",
        "fontFamilies": {
          "standard": ",Meiryo,Yu Gothic",
          "fixed": "MS Gothic",
          "serif": ",Yu Mincho,MS PMincho",
          "sansSerif": ",Meiryo,Yu Gothic"
        }
      },
      {
        "script": "hang",
        "fontFamilies": {
          "standard": "Malgun Gothic",
          "fixed": "Gulimche",
          "serif": "Batang",
          "sansSerif": "Malgun Gothic",
          "cursive": "Gungsuh"
        }
      },
      {
        "script": "hans",
        "fontFamilies": {
          "standard": "Microsoft YaHei",
          "fixed": "NSimsun",
          "serif": "Simsun",
          "sansSerif": "Microsoft YaHei",
          "cursive": "KaiTi"
        }
      },
      {
        "script": "hant",
        "fontFamilies": {
          "standard": "Microsoft JhengHei",
          "fixed": "MingLiU",
          "serif": "PMingLiU",
          "sansSerif": "Microsoft JhengHei",
          "cursive": "DFKai-SB"
        }
      }
    ]
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/videoRecorder.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/processLauncher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var gracefullyCloseSet = /* @__PURE__ */ new Set();
var killSet = /* @__PURE__ */ new Set();
async function gracefullyCloseAll() {
  await Promise.all(Array.from(gracefullyCloseSet).map((gracefullyClose) => gracefullyClose().catch((e) => {
  })));
}
__name(gracefullyCloseAll, "gracefullyCloseAll");
function gracefullyProcessExitDoNotHang(code) {
  setTimeout(() => process.exit(code), 3e4);
  gracefullyCloseAll().then(() => {
    process.exit(code);
  });
}
__name(gracefullyProcessExitDoNotHang, "gracefullyProcessExitDoNotHang");
function exitHandler() {
  for (const kill2 of killSet)
    kill2();
}
__name(exitHandler, "exitHandler");
var sigintHandlerCalled = false;
function sigintHandler() {
  const exitWithCode130 = /* @__PURE__ */ __name(() => {
    if (isUnderTest()) {
      setTimeout(() => process.exit(130), 1e3);
    } else {
      process.exit(130);
    }
  }, "exitWithCode130");
  if (sigintHandlerCalled) {
    process.off("SIGINT", sigintHandler);
    for (const kill2 of killSet)
      kill2();
    exitWithCode130();
  } else {
    sigintHandlerCalled = true;
    gracefullyCloseAll().then(() => exitWithCode130());
  }
}
__name(sigintHandler, "sigintHandler");
function sigtermHandler() {
  gracefullyCloseAll();
}
__name(sigtermHandler, "sigtermHandler");
function sighupHandler() {
  gracefullyCloseAll();
}
__name(sighupHandler, "sighupHandler");
var installedHandlers = /* @__PURE__ */ new Set();
var processHandlers = {
  exit: exitHandler,
  SIGINT: sigintHandler,
  SIGTERM: sigtermHandler,
  SIGHUP: sighupHandler
};
function addProcessHandlerIfNeeded(name) {
  if (!installedHandlers.has(name)) {
    installedHandlers.add(name);
    process.on(name, processHandlers[name]);
  }
}
__name(addProcessHandlerIfNeeded, "addProcessHandlerIfNeeded");
function removeProcessHandlersIfNeeded() {
  if (killSet.size)
    return;
  for (const handler of installedHandlers)
    process.off(handler, processHandlers[handler]);
  installedHandlers.clear();
}
__name(removeProcessHandlersIfNeeded, "removeProcessHandlersIfNeeded");
async function launchProcess(options2) {
  const stdio = options2.stdio === "pipe" ? ["ignore", "pipe", "pipe", "pipe", "pipe"] : ["pipe", "pipe", "pipe"];
  options2.log(`<launching> ${options2.command} ${options2.args ? options2.args.join(" ") : ""}`);
  const spawnOptions = {
    // On non-windows platforms, `detached: true` makes child process a leader of a new
    // process group, making it possible to kill child process tree with `.kill(-pid)` command.
    // @see https://nodejs.org/api/child_process.html#child_process_options_detached
    detached: process.platform !== "win32",
    env: options2.env,
    cwd: options2.cwd,
    shell: options2.shell,
    stdio
  };
  const spawnedProcess = spawn(options2.command, options2.args || [], spawnOptions);
  const cleanup = /* @__PURE__ */ __name(async () => {
    options2.log(`[pid=${spawnedProcess.pid || "N/A"}] starting temporary directories cleanup`);
    const errors3 = await removeFolders(options2.tempDirectories);
    for (let i = 0; i < options2.tempDirectories.length; ++i) {
      if (errors3[i])
        options2.log(`[pid=${spawnedProcess.pid || "N/A"}] exception while removing ${options2.tempDirectories[i]}: ${errors3[i]}`);
    }
    options2.log(`[pid=${spawnedProcess.pid || "N/A"}] finished temporary directories cleanup`);
  }, "cleanup");
  spawnedProcess.on("error", () => {
  });
  if (!spawnedProcess.pid) {
    let failed;
    const failedPromise = new Promise((f, r) => failed = f);
    spawnedProcess.once("error", (error4) => {
      failed(new Error("Failed to launch: " + error4));
    });
    return cleanup().then(() => failedPromise).then((e) => Promise.reject(e));
  }
  options2.log(`<launched> pid=${spawnedProcess.pid}`);
  const stdout2 = createInterface({ input: spawnedProcess.stdout });
  stdout2.on("line", (data) => {
    options2.log(`[pid=${spawnedProcess.pid}][out] ` + data);
  });
  const stderr2 = createInterface({ input: spawnedProcess.stderr });
  stderr2.on("line", (data) => {
    options2.log(`[pid=${spawnedProcess.pid}][err] ` + data);
  });
  let processClosed = false;
  let fulfillCleanup = /* @__PURE__ */ __name(() => {
  }, "fulfillCleanup");
  const waitForCleanup = new Promise((f) => fulfillCleanup = f);
  spawnedProcess.once("close", (exitCode2, signal) => {
    options2.log(`[pid=${spawnedProcess.pid}] <process did exit: exitCode=${exitCode2}, signal=${signal}>`);
    processClosed = true;
    gracefullyCloseSet.delete(gracefullyClose);
    killSet.delete(killProcessAndCleanup);
    removeProcessHandlersIfNeeded();
    options2.onExit(exitCode2, signal);
    cleanup().then(fulfillCleanup);
  });
  addProcessHandlerIfNeeded("exit");
  if (options2.handleSIGINT)
    addProcessHandlerIfNeeded("SIGINT");
  if (options2.handleSIGTERM)
    addProcessHandlerIfNeeded("SIGTERM");
  if (options2.handleSIGHUP)
    addProcessHandlerIfNeeded("SIGHUP");
  gracefullyCloseSet.add(gracefullyClose);
  killSet.add(killProcessAndCleanup);
  let gracefullyClosing = false;
  async function gracefullyClose() {
    if (gracefullyClosing) {
      options2.log(`[pid=${spawnedProcess.pid}] <forcefully close>`);
      killProcess();
      await waitForCleanup;
      return;
    }
    gracefullyClosing = true;
    options2.log(`[pid=${spawnedProcess.pid}] <gracefully close start>`);
    await options2.attemptToGracefullyClose().catch(() => killProcess());
    await waitForCleanup;
    options2.log(`[pid=${spawnedProcess.pid}] <gracefully close end>`);
  }
  __name(gracefullyClose, "gracefullyClose");
  function killProcess() {
    gracefullyCloseSet.delete(gracefullyClose);
    killSet.delete(killProcessAndCleanup);
    removeProcessHandlersIfNeeded();
    options2.log(`[pid=${spawnedProcess.pid}] <kill>`);
    if (spawnedProcess.pid && !spawnedProcess.killed && !processClosed) {
      options2.log(`[pid=${spawnedProcess.pid}] <will force kill>`);
      try {
        if (process.platform === "win32") {
          const taskkillProcess = spawnSync(`taskkill /pid ${spawnedProcess.pid} /T /F`, { shell: true });
          const [stdout22, stderr22] = [taskkillProcess.stdout.toString(), taskkillProcess.stderr.toString()];
          if (stdout22)
            options2.log(`[pid=${spawnedProcess.pid}] taskkill stdout: ${stdout22}`);
          if (stderr22)
            options2.log(`[pid=${spawnedProcess.pid}] taskkill stderr: ${stderr22}`);
        } else {
          process.kill(-spawnedProcess.pid, "SIGKILL");
        }
      } catch (e) {
        options2.log(`[pid=${spawnedProcess.pid}] exception while trying to kill process: ${e}`);
      }
    } else {
      options2.log(`[pid=${spawnedProcess.pid}] <skipped force kill spawnedProcess.killed=${spawnedProcess.killed} processClosed=${processClosed}>`);
    }
  }
  __name(killProcess, "killProcess");
  function killProcessAndCleanup() {
    killProcess();
    options2.log(`[pid=${spawnedProcess.pid || "N/A"}] starting temporary directories cleanup`);
    for (const dir3 of options2.tempDirectories) {
      try {
        fs.rmSync(dir3, { force: true, recursive: true, maxRetries: 5 });
      } catch (e) {
        options2.log(`[pid=${spawnedProcess.pid || "N/A"}] exception while removing ${dir3}: ${e}`);
      }
    }
    options2.log(`[pid=${spawnedProcess.pid || "N/A"}] finished temporary directories cleanup`);
  }
  __name(killProcessAndCleanup, "killProcessAndCleanup");
  function killAndWait() {
    killProcess();
    return waitForCleanup;
  }
  __name(killAndWait, "killAndWait");
  return { launchedProcess: spawnedProcess, gracefullyClose, kill: killAndWait };
}
__name(launchProcess, "launchProcess");
function envArrayToObject(env3) {
  const result = {};
  for (const { name, value } of env3)
    result[name] = value;
  return result;
}
__name(envArrayToObject, "envArrayToObject");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/videoRecorder.js
var fps = 25;
var VideoRecorder = class _VideoRecorder {
  static {
    __name(this, "VideoRecorder");
  }
  constructor(page, ffmpegPath, progress3) {
    this._process = null;
    this._gracefullyClose = null;
    this._lastWritePromise = Promise.resolve();
    this._lastFrameTimestamp = 0;
    this._lastFrameBuffer = null;
    this._lastWriteTimestamp = 0;
    this._frameQueue = [];
    this._isStopped = false;
    this._progress = progress3;
    this._ffmpegPath = ffmpegPath;
    page.on(Page.Events.ScreencastFrame, (frame) => this.writeFrame(frame.buffer, frame.frameSwapWallTime / 1e3));
  }
  static async launch(page, ffmpegPath, options2) {
    if (!options2.outputFile.endsWith(".webm"))
      throw new Error("File must have .webm extension");
    const controller = new ProgressController(serverSideCallMetadata(), page);
    controller.setLogName("browser");
    return await controller.run(async (progress3) => {
      const recorder = new _VideoRecorder(page, ffmpegPath, progress3);
      await recorder._launch(options2);
      return recorder;
    });
  }
  async _launch(options2) {
    const w = options2.width;
    const h = options2.height;
    const args = `-loglevel error -f image2pipe -avioflags direct -fpsprobesize 0 -probesize 32 -analyzeduration 0 -c:v mjpeg -i pipe:0 -y -an -r ${fps} -c:v vp8 -qmin 0 -qmax 50 -crf 8 -deadline realtime -speed 8 -b:v 1M -threads 1 -vf pad=${w}:${h}:0:0:gray,crop=${w}:${h}:0:0`.split(" ");
    args.push(options2.outputFile);
    const progress3 = this._progress;
    const { launchedProcess, gracefullyClose } = await launchProcess({
      command: this._ffmpegPath,
      args,
      stdio: "stdin",
      log: /* @__PURE__ */ __name((message) => progress3.log(message), "log"),
      tempDirectories: [],
      attemptToGracefullyClose: /* @__PURE__ */ __name(async () => {
        progress3.log("Closing stdin...");
        launchedProcess.stdin.end();
      }, "attemptToGracefullyClose"),
      onExit: /* @__PURE__ */ __name((exitCode2, signal) => {
        progress3.log(`ffmpeg onkill exitCode=${exitCode2} signal=${signal}`);
      }, "onExit")
    });
    launchedProcess.stdin.on("finish", () => {
      progress3.log("ffmpeg finished input.");
    });
    launchedProcess.stdin.on("error", () => {
      progress3.log("ffmpeg error.");
    });
    this._process = launchedProcess;
    this._gracefullyClose = gracefullyClose;
  }
  writeFrame(frame, timestamp2) {
    assert3(this._process);
    if (this._isStopped)
      return;
    if (this._lastFrameBuffer) {
      const durationSec = timestamp2 - this._lastFrameTimestamp;
      const repeatCount = Math.max(1, Math.round(fps * durationSec));
      for (let i = 0; i < repeatCount; ++i)
        this._frameQueue.push(this._lastFrameBuffer);
      this._lastWritePromise = this._lastWritePromise.then(() => this._sendFrames());
    }
    this._lastFrameBuffer = frame;
    this._lastFrameTimestamp = timestamp2;
    this._lastWriteTimestamp = monotonicTime();
  }
  async _sendFrames() {
    while (this._frameQueue.length)
      await this._sendFrame(this._frameQueue.shift());
  }
  async _sendFrame(frame) {
    return new Promise((f) => this._process.stdin.write(frame, f)).then((error4) => {
      if (error4)
        this._progress.log(`ffmpeg failed to write: ${String(error4)}`);
    });
  }
  async stop() {
    if (this._isStopped)
      return;
    this.writeFrame(Buffer.from([]), this._lastFrameTimestamp + (monotonicTime() - this._lastWriteTimestamp) / 1e3);
    this._isStopped = true;
    await this._lastWritePromise;
    await this._gracefullyClose();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crPage.js
var UTILITY_WORLD_NAME = "__playwright_utility_world__";
var CRPage = class {
  static {
    __name(this, "CRPage");
  }
  constructor(client, targetId, browserContext, opener, bits) {
    this._sessions = /* @__PURE__ */ new Map();
    this._nextWindowOpenPopupFeatures = [];
    this._targetId = targetId;
    this._opener = opener;
    this._isBackgroundPage = bits.isBackgroundPage;
    const dragManager = new DragManager(this);
    this.rawKeyboard = new RawKeyboardImpl(client, browserContext._browser._platform() === "mac", dragManager);
    this.rawMouse = new RawMouseImpl(this, client, dragManager);
    this.rawTouchscreen = new RawTouchscreenImpl(client);
    this._pdf = new CRPDF(client);
    this._coverage = new CRCoverage(client);
    this._browserContext = browserContext;
    this._page = new Page(this, browserContext);
    this._networkManager = new CRNetworkManager(this._page, null);
    this.updateOffline();
    this.updateExtraHTTPHeaders();
    this.updateHttpCredentials();
    this.updateRequestInterception();
    this._mainFrameSession = new FrameSession(this, client, targetId, null);
    this._sessions.set(targetId, this._mainFrameSession);
    if (opener && !browserContext._options.noDefaultViewport) {
      const features2 = opener._nextWindowOpenPopupFeatures.shift() || [];
      const viewportSize = helper.getViewportSizeFromWindowFeatures(features2);
      if (viewportSize)
        this._page._emulatedSize = { viewport: viewportSize, screen: viewportSize };
    }
    const createdEvent = this._isBackgroundPage ? CRBrowserContext.CREvents.BackgroundPage : BrowserContext.Events.Page;
    this._mainFrameSession._initialize(bits.hasUIWindow).then(
      () => this._page.reportAsNew(this._opener?._page, void 0, createdEvent),
      (error4) => this._page.reportAsNew(this._opener?._page, error4, createdEvent)
    );
  }
  static mainFrameSession(page) {
    const crPage = page._delegate;
    return crPage._mainFrameSession;
  }
  async _forAllFrameSessions(cb) {
    const frameSessions = Array.from(this._sessions.values());
    await Promise.all(frameSessions.map((frameSession) => {
      if (frameSession._isMainFrame())
        return cb(frameSession);
      return cb(frameSession).catch((e) => {
        if (isSessionClosedError(e))
          return;
        throw e;
      });
    }));
  }
  _sessionForFrame(frame) {
    while (!this._sessions.has(frame._id)) {
      const parent = frame.parentFrame();
      if (!parent)
        throw new Error(`Frame has been detached.`);
      frame = parent;
    }
    return this._sessions.get(frame._id);
  }
  _sessionForHandle(handle) {
    const frame = handle._context.frame;
    return this._sessionForFrame(frame);
  }
  willBeginDownload() {
    this._mainFrameSession._willBeginDownload();
  }
  didClose() {
    for (const session2 of this._sessions.values())
      session2.dispose();
    this._page._didClose();
  }
  async navigateFrame(frame, url4, referrer) {
    return this._sessionForFrame(frame)._navigate(frame, url4, referrer);
  }
  async updateExtraHTTPHeaders() {
    const headers = mergeHeaders([
      this._browserContext._options.extraHTTPHeaders,
      this._page.extraHTTPHeaders()
    ]);
    await this._networkManager.setExtraHTTPHeaders(headers);
  }
  async updateGeolocation() {
    await this._forAllFrameSessions((frame) => frame._updateGeolocation(false));
  }
  async updateOffline() {
    await this._networkManager.setOffline(!!this._browserContext._options.offline);
  }
  async updateHttpCredentials() {
    await this._networkManager.authenticate(this._browserContext._options.httpCredentials || null);
  }
  async updateEmulatedViewportSize(preserveWindowBoundaries) {
    await this._mainFrameSession._updateViewport(preserveWindowBoundaries);
  }
  async bringToFront() {
    await this._mainFrameSession._client.send("Page.bringToFront");
  }
  async updateEmulateMedia() {
    await this._forAllFrameSessions((frame) => frame._updateEmulateMedia());
  }
  async updateUserAgent() {
    await this._forAllFrameSessions((frame) => frame._updateUserAgent());
  }
  async updateRequestInterception() {
    await this._networkManager.setRequestInterception(this._page.needsRequestInterception());
  }
  async updateFileChooserInterception() {
    await this._forAllFrameSessions((frame) => frame._updateFileChooserInterception(false));
  }
  async reload() {
    await this._mainFrameSession._client.send("Page.reload");
  }
  async _go(delta) {
    const history = await this._mainFrameSession._client.send("Page.getNavigationHistory");
    const entry = history.entries[history.currentIndex + delta];
    if (!entry)
      return false;
    await this._mainFrameSession._client.send("Page.navigateToHistoryEntry", { entryId: entry.id });
    return true;
  }
  goBack() {
    return this._go(-1);
  }
  goForward() {
    return this._go(1);
  }
  async requestGC() {
    await this._mainFrameSession._client.send("HeapProfiler.collectGarbage");
  }
  async addInitScript(initScript, world = "main") {
    await this._forAllFrameSessions((frame) => frame._evaluateOnNewDocument(initScript, world));
  }
  async removeNonInternalInitScripts() {
    await this._forAllFrameSessions((frame) => frame._removeEvaluatesOnNewDocument());
  }
  async closePage(runBeforeUnload) {
    if (runBeforeUnload)
      await this._mainFrameSession._client.send("Page.close");
    else
      await this._browserContext._browser._closePage(this);
  }
  async setBackgroundColor(color) {
    await this._mainFrameSession._client.send("Emulation.setDefaultBackgroundColorOverride", { color });
  }
  async takeScreenshot(progress3, format2, documentRect, viewportRect, quality, fitsViewport, scale) {
    const { visualViewport } = await this._mainFrameSession._client.send("Page.getLayoutMetrics");
    if (!documentRect) {
      documentRect = {
        x: visualViewport.pageX + viewportRect.x,
        y: visualViewport.pageY + viewportRect.y,
        ...helper.enclosingIntSize({
          width: viewportRect.width / visualViewport.scale,
          height: viewportRect.height / visualViewport.scale
        })
      };
    }
    const clip = { ...documentRect, scale: viewportRect ? visualViewport.scale : 1 };
    if (scale === "css") {
      const deviceScaleFactor = this._browserContext._options.deviceScaleFactor || 1;
      clip.scale /= deviceScaleFactor;
    }
    progress3.throwIfAborted();
    const result = await this._mainFrameSession._client.send("Page.captureScreenshot", { format: format2, quality, clip, captureBeyondViewport: !fitsViewport });
    return Buffer.from(result.data, "base64");
  }
  async getContentFrame(handle) {
    return this._sessionForHandle(handle)._getContentFrame(handle);
  }
  async getOwnerFrame(handle) {
    return this._sessionForHandle(handle)._getOwnerFrame(handle);
  }
  async getBoundingBox(handle) {
    return this._sessionForHandle(handle)._getBoundingBox(handle);
  }
  async scrollRectIntoViewIfNeeded(handle, rect) {
    return this._sessionForHandle(handle)._scrollRectIntoViewIfNeeded(handle, rect);
  }
  async setScreencastOptions(options2) {
    if (options2) {
      await this._mainFrameSession._startScreencast(this, {
        format: "jpeg",
        quality: options2.quality,
        maxWidth: options2.width,
        maxHeight: options2.height
      });
    } else {
      await this._mainFrameSession._stopScreencast(this);
    }
  }
  rafCountForStablePosition() {
    return 1;
  }
  async getContentQuads(handle) {
    return this._sessionForHandle(handle)._getContentQuads(handle);
  }
  async setInputFilePaths(handle, files) {
    const frame = await handle.ownerFrame();
    if (!frame)
      throw new Error("Cannot set input files to detached input element");
    const parentSession = this._sessionForFrame(frame);
    await parentSession._client.send("DOM.setFileInputFiles", {
      objectId: handle._objectId,
      files
    });
  }
  async adoptElementHandle(handle, to) {
    return this._sessionForHandle(handle)._adoptElementHandle(handle, to);
  }
  async getAccessibilityTree(needle) {
    return getAccessibilityTree(this._mainFrameSession._client, needle);
  }
  async inputActionEpilogue() {
    await this._mainFrameSession._client.send("Page.enable").catch((e) => {
    });
  }
  async resetForReuse() {
    await this.rawMouse.move(-1, -1, "none", /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), true);
  }
  async pdf(options2) {
    return this._pdf.generate(options2);
  }
  coverage() {
    return this._coverage;
  }
  async getFrameElement(frame) {
    let parent = frame.parentFrame();
    if (!parent)
      throw new Error("Frame has been detached.");
    const parentSession = this._sessionForFrame(parent);
    const { backendNodeId } = await parentSession._client.send("DOM.getFrameOwner", { frameId: frame._id }).catch((e) => {
      if (e instanceof Error && e.message.includes("Frame with the given id was not found."))
        rewriteErrorMessage(e, "Frame has been detached.");
      throw e;
    });
    parent = frame.parentFrame();
    if (!parent)
      throw new Error("Frame has been detached.");
    return parentSession._adoptBackendNodeId(backendNodeId, await parent._mainContext());
  }
  shouldToggleStyleSheetToSyncAnimations() {
    return false;
  }
};
var FrameSession = class _FrameSession {
  static {
    __name(this, "FrameSession");
  }
  constructor(crPage, client, targetId, parentSession) {
    this._childSessions = /* @__PURE__ */ new Set();
    this._contextIdToContext = /* @__PURE__ */ new Map();
    this._eventListeners = [];
    this._firstNonInitialNavigationCommittedFulfill = () => {
    };
    this._firstNonInitialNavigationCommittedReject = (e) => {
    };
    this._swappedIn = false;
    this._videoRecorder = null;
    this._screencastId = null;
    this._screencastClients = /* @__PURE__ */ new Set();
    this._evaluateOnNewDocumentIdentifiers = [];
    this._workerSessions = /* @__PURE__ */ new Map();
    this._client = client;
    this._crPage = crPage;
    this._page = crPage._page;
    this._targetId = targetId;
    this._parentSession = parentSession;
    if (parentSession)
      parentSession._childSessions.add(this);
    this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
      this._firstNonInitialNavigationCommittedFulfill = f;
      this._firstNonInitialNavigationCommittedReject = r;
    });
    this._firstNonInitialNavigationCommittedPromise.catch(() => {
    });
  }
  _isMainFrame() {
    return this._targetId === this._crPage._targetId;
  }
  _addRendererListeners() {
    this._eventListeners.push(...[
      eventsHelper.addEventListener(this._client, "Log.entryAdded", (event) => this._onLogEntryAdded(event)),
      eventsHelper.addEventListener(this._client, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)),
      eventsHelper.addEventListener(this._client, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)),
      eventsHelper.addEventListener(this._client, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId, event.reason)),
      eventsHelper.addEventListener(this._client, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)),
      eventsHelper.addEventListener(this._client, "Page.frameRequestedNavigation", (event) => this._onFrameRequestedNavigation(event)),
      eventsHelper.addEventListener(this._client, "Page.javascriptDialogOpening", (event) => this._onDialog(event)),
      eventsHelper.addEventListener(this._client, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)),
      eventsHelper.addEventListener(this._client, "Runtime.bindingCalled", (event) => this._onBindingCalled(event)),
      eventsHelper.addEventListener(this._client, "Runtime.consoleAPICalled", (event) => this._onConsoleAPI(event)),
      eventsHelper.addEventListener(this._client, "Runtime.exceptionThrown", (exception) => this._handleException(exception.exceptionDetails)),
      eventsHelper.addEventListener(this._client, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)),
      eventsHelper.addEventListener(this._client, "Runtime.executionContextDestroyed", (event) => this._onExecutionContextDestroyed(event.executionContextId)),
      eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", (event) => this._onExecutionContextsCleared()),
      eventsHelper.addEventListener(this._client, "Target.attachedToTarget", (event) => this._onAttachedToTarget(event)),
      eventsHelper.addEventListener(this._client, "Target.detachedFromTarget", (event) => this._onDetachedFromTarget(event))
    ]);
  }
  _addBrowserListeners() {
    this._eventListeners.push(...[
      eventsHelper.addEventListener(this._client, "Inspector.targetCrashed", (event) => this._onTargetCrashed()),
      eventsHelper.addEventListener(this._client, "Page.screencastFrame", (event) => this._onScreencastFrame(event)),
      eventsHelper.addEventListener(this._client, "Page.windowOpen", (event) => this._onWindowOpen(event))
    ]);
  }
  async _initialize(hasUIWindow) {
    const isSettingStorageState = this._page._browserContext.isSettingStorageState();
    if (!isSettingStorageState && hasUIWindow && !this._crPage._browserContext._browser.isClank() && !this._crPage._browserContext._options.noDefaultViewport) {
      const { windowId } = await this._client.send("Browser.getWindowForTarget");
      this._windowId = windowId;
    }
    let screencastOptions;
    if (!isSettingStorageState && this._isMainFrame() && this._crPage._browserContext._options.recordVideo && hasUIWindow) {
      const screencastId = createGuid();
      const outputFile = path17.join(this._crPage._browserContext._options.recordVideo.dir, screencastId + ".webm");
      screencastOptions = {
        // validateBrowserContextOptions ensures correct video size.
        ...this._crPage._browserContext._options.recordVideo.size,
        outputFile
      };
      await this._crPage._browserContext._ensureVideosPath();
      await this._createVideoRecorder(screencastId, screencastOptions);
      this._crPage._page.waitForInitializedOrError().then((p) => {
        if (p instanceof Error)
          this._stopVideoRecording().catch(() => {
          });
      });
    }
    let lifecycleEventsEnabled;
    if (!this._isMainFrame())
      this._addRendererListeners();
    this._addBrowserListeners();
    const promises2 = [
      this._client.send("Page.enable"),
      this._client.send("Page.getFrameTree").then(({ frameTree }) => {
        if (this._isMainFrame()) {
          this._handleFrameTree(frameTree);
          this._addRendererListeners();
        }
        const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)];
        for (const frame of localFrames) {
          this._client._sendMayFail("Page.createIsolatedWorld", {
            frameId: frame._id,
            grantUniveralAccess: true,
            worldName: UTILITY_WORLD_NAME
          });
          for (const initScript of this._crPage._page.allInitScripts())
            frame.evaluateExpression(initScript.source).catch((e) => {
            });
        }
        const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ":";
        if (isInitialEmptyPage) {
          lifecycleEventsEnabled.catch((e) => {
          }).then(() => {
            this._eventListeners.push(eventsHelper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
          });
        } else {
          this._firstNonInitialNavigationCommittedFulfill();
          this._eventListeners.push(eventsHelper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
        }
      }),
      this._client.send("Log.enable", {}),
      lifecycleEventsEnabled = this._client.send("Page.setLifecycleEventsEnabled", { enabled: true }),
      this._client.send("Runtime.enable", {}),
      this._client.send("Runtime.addBinding", { name: PageBinding.kPlaywrightBinding }),
      this._client.send("Page.addScriptToEvaluateOnNewDocument", {
        source: "",
        worldName: UTILITY_WORLD_NAME
      }),
      this._crPage._networkManager.addSession(this._client, void 0, this._isMainFrame()),
      this._client.send("Target.setAutoAttach", { autoAttach: true, waitForDebuggerOnStart: true, flatten: true })
    ];
    if (!isSettingStorageState) {
      if (this._isMainFrame())
        promises2.push(this._client.send("Emulation.setFocusEmulationEnabled", { enabled: true }));
      const options2 = this._crPage._browserContext._options;
      if (options2.bypassCSP)
        promises2.push(this._client.send("Page.setBypassCSP", { enabled: true }));
      if (options2.ignoreHTTPSErrors || options2.internalIgnoreHTTPSErrors)
        promises2.push(this._client.send("Security.setIgnoreCertificateErrors", { ignore: true }));
      if (this._isMainFrame())
        promises2.push(this._updateViewport());
      if (options2.hasTouch)
        promises2.push(this._client.send("Emulation.setTouchEmulationEnabled", { enabled: true }));
      if (options2.javaScriptEnabled === false)
        promises2.push(this._client.send("Emulation.setScriptExecutionDisabled", { value: true }));
      if (options2.userAgent || options2.locale)
        promises2.push(this._updateUserAgent());
      if (options2.locale)
        promises2.push(emulateLocale(this._client, options2.locale));
      if (options2.timezoneId)
        promises2.push(emulateTimezone(this._client, options2.timezoneId));
      if (!this._crPage._browserContext._browser.options.headful)
        promises2.push(this._setDefaultFontFamilies(this._client));
      promises2.push(this._updateGeolocation(true));
      promises2.push(this._updateEmulateMedia());
      promises2.push(this._updateFileChooserInterception(true));
      for (const initScript of this._crPage._page.allInitScripts())
        promises2.push(this._evaluateOnNewDocument(initScript, "main"));
      if (screencastOptions)
        promises2.push(this._startVideoRecording(screencastOptions));
    }
    promises2.push(this._client.send("Runtime.runIfWaitingForDebugger"));
    promises2.push(this._firstNonInitialNavigationCommittedPromise);
    await Promise.all(promises2);
  }
  dispose() {
    this._firstNonInitialNavigationCommittedReject(new TargetClosedError());
    for (const childSession of this._childSessions)
      childSession.dispose();
    if (this._parentSession)
      this._parentSession._childSessions.delete(this);
    eventsHelper.removeEventListeners(this._eventListeners);
    this._crPage._networkManager.removeSession(this._client);
    this._crPage._sessions.delete(this._targetId);
    this._client.dispose();
  }
  async _navigate(frame, url4, referrer) {
    const response = await this._client.send("Page.navigate", { url: url4, referrer, frameId: frame._id, referrerPolicy: "unsafeUrl" });
    if (response.errorText)
      throw new NavigationAbortedError(response.loaderId, `${response.errorText} at ${url4}`);
    return { newDocumentId: response.loaderId };
  }
  _onLifecycleEvent(event) {
    if (this._eventBelongsToStaleFrame(event.frameId))
      return;
    if (event.name === "load")
      this._page._frameManager.frameLifecycleEvent(event.frameId, "load");
    else if (event.name === "DOMContentLoaded")
      this._page._frameManager.frameLifecycleEvent(event.frameId, "domcontentloaded");
  }
  _handleFrameTree(frameTree) {
    this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
    this._onFrameNavigated(frameTree.frame, true);
    if (!frameTree.childFrames)
      return;
    for (const child of frameTree.childFrames)
      this._handleFrameTree(child);
  }
  _eventBelongsToStaleFrame(frameId) {
    const frame = this._page._frameManager.frame(frameId);
    if (!frame)
      return true;
    const session2 = this._crPage._sessionForFrame(frame);
    return session2 && session2 !== this && !session2._swappedIn;
  }
  _onFrameAttached(frameId, parentFrameId) {
    const frameSession = this._crPage._sessions.get(frameId);
    if (frameSession && frameId !== this._targetId) {
      frameSession._swappedIn = true;
      const frame = this._page._frameManager.frame(frameId);
      if (frame)
        this._page._frameManager.removeChildFramesRecursively(frame);
      return;
    }
    if (parentFrameId && !this._page._frameManager.frame(parentFrameId)) {
      return;
    }
    this._page._frameManager.frameAttached(frameId, parentFrameId);
  }
  _onFrameNavigated(framePayload, initial) {
    if (this._eventBelongsToStaleFrame(framePayload.id))
      return;
    this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ""), framePayload.name || "", framePayload.loaderId, initial);
    if (!initial)
      this._firstNonInitialNavigationCommittedFulfill();
  }
  _onFrameRequestedNavigation(payload) {
    if (this._eventBelongsToStaleFrame(payload.frameId))
      return;
    if (payload.disposition === "currentTab")
      this._page._frameManager.frameRequestedNavigation(payload.frameId);
  }
  _onFrameNavigatedWithinDocument(frameId, url4) {
    if (this._eventBelongsToStaleFrame(frameId))
      return;
    this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url4);
  }
  _onFrameDetached(frameId, reason) {
    if (this._crPage._sessions.has(frameId)) {
      return;
    }
    if (reason === "swap") {
      const frame = this._page._frameManager.frame(frameId);
      if (frame)
        this._page._frameManager.removeChildFramesRecursively(frame);
      return;
    }
    this._page._frameManager.frameDetached(frameId);
  }
  _onExecutionContextCreated(contextPayload) {
    const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;
    if (!frame || this._eventBelongsToStaleFrame(frame._id))
      return;
    const delegate = new CRExecutionContext(this._client, contextPayload);
    let worldName = null;
    if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
      worldName = "main";
    else if (contextPayload.name === UTILITY_WORLD_NAME)
      worldName = "utility";
    const context2 = new FrameExecutionContext(delegate, frame, worldName);
    if (worldName)
      frame._contextCreated(worldName, context2);
    this._contextIdToContext.set(contextPayload.id, context2);
  }
  _onExecutionContextDestroyed(executionContextId) {
    const context2 = this._contextIdToContext.get(executionContextId);
    if (!context2)
      return;
    this._contextIdToContext.delete(executionContextId);
    context2.frame._contextDestroyed(context2);
  }
  _onExecutionContextsCleared() {
    for (const contextId of Array.from(this._contextIdToContext.keys()))
      this._onExecutionContextDestroyed(contextId);
  }
  _onAttachedToTarget(event) {
    const session2 = this._client.createChildSession(event.sessionId);
    if (event.targetInfo.type === "iframe") {
      const targetId = event.targetInfo.targetId;
      const frame = this._page._frameManager.frame(targetId);
      if (!frame)
        return;
      this._page._frameManager.removeChildFramesRecursively(frame);
      for (const [contextId, context2] of this._contextIdToContext) {
        if (context2.frame === frame)
          this._onExecutionContextDestroyed(contextId);
      }
      const frameSession = new _FrameSession(this._crPage, session2, targetId, this);
      this._crPage._sessions.set(targetId, frameSession);
      frameSession._initialize(false).catch((e) => e);
      return;
    }
    if (event.targetInfo.type !== "worker") {
      session2.detach().catch(() => {
      });
      return;
    }
    const url4 = event.targetInfo.url;
    const worker = new Worker(this._page, url4);
    this._page._addWorker(event.sessionId, worker);
    this._workerSessions.set(event.sessionId, session2);
    session2.once("Runtime.executionContextCreated", async (event2) => {
      worker._createExecutionContext(new CRExecutionContext(session2, event2.context));
    });
    session2._sendMayFail("Runtime.enable");
    this._crPage._networkManager.addSession(session2, this._page._frameManager.frame(this._targetId) ?? void 0).catch(() => {
    });
    session2._sendMayFail("Runtime.runIfWaitingForDebugger");
    session2._sendMayFail("Target.setAutoAttach", { autoAttach: true, waitForDebuggerOnStart: true, flatten: true });
    session2.on("Target.attachedToTarget", (event2) => this._onAttachedToTarget(event2));
    session2.on("Target.detachedFromTarget", (event2) => this._onDetachedFromTarget(event2));
    session2.on("Runtime.consoleAPICalled", (event2) => {
      const args = event2.args.map((o) => createHandle(worker._existingExecutionContext, o));
      this._page._addConsoleMessage(event2.type, args, toConsoleMessageLocation(event2.stackTrace));
    });
    session2.on("Runtime.exceptionThrown", (exception) => this._page.emitOnContextOnceInitialized(BrowserContext.Events.PageError, exceptionToError(exception.exceptionDetails), this._page));
  }
  _onDetachedFromTarget(event) {
    const workerSession = this._workerSessions.get(event.sessionId);
    if (workerSession) {
      workerSession.dispose();
      this._page._removeWorker(event.sessionId);
      return;
    }
    const childFrameSession = this._crPage._sessions.get(event.targetId);
    if (!childFrameSession)
      return;
    if (childFrameSession._swappedIn) {
      childFrameSession.dispose();
      return;
    }
    this._client.send("Page.enable").catch((e) => null).then(() => {
      if (!childFrameSession._swappedIn)
        this._page._frameManager.frameDetached(event.targetId);
      childFrameSession.dispose();
    });
  }
  _onWindowOpen(event) {
    this._crPage._nextWindowOpenPopupFeatures.push(event.windowFeatures);
  }
  async _onConsoleAPI(event) {
    if (event.executionContextId === 0) {
      return;
    }
    const context2 = this._contextIdToContext.get(event.executionContextId);
    if (!context2)
      return;
    const values = event.args.map((arg) => createHandle(context2, arg));
    this._page._addConsoleMessage(event.type, values, toConsoleMessageLocation(event.stackTrace));
  }
  async _onBindingCalled(event) {
    const pageOrError = await this._crPage._page.waitForInitializedOrError();
    if (!(pageOrError instanceof Error)) {
      const context2 = this._contextIdToContext.get(event.executionContextId);
      if (context2)
        await this._page._onBindingCalled(event.payload, context2);
    }
  }
  _onDialog(event) {
    if (!this._page._frameManager.frame(this._targetId))
      return;
    this._page.emitOnContext(BrowserContext.Events.Dialog, new Dialog(
      this._page,
      event.type,
      event.message,
      async (accept, promptText) => {
        if (this._isMainFrame() && event.type === "beforeunload" && !accept)
          this._page._frameManager.frameAbortedNavigation(this._page.mainFrame()._id, "navigation cancelled by beforeunload dialog");
        await this._client.send("Page.handleJavaScriptDialog", { accept, promptText });
      },
      event.defaultPrompt
    ));
  }
  _handleException(exceptionDetails) {
    this._page.emitOnContextOnceInitialized(BrowserContext.Events.PageError, exceptionToError(exceptionDetails), this._page);
  }
  async _onTargetCrashed() {
    this._client._markAsCrashed();
    this._page._didCrash();
  }
  _onLogEntryAdded(event) {
    const { level, text, args, source: source7, url: url4, lineNumber } = event.entry;
    if (args)
      args.map((arg) => releaseObject(this._client, arg.objectId));
    if (source7 !== "worker") {
      const location2 = {
        url: url4 || "",
        lineNumber: lineNumber || 0,
        columnNumber: 0
      };
      this._page._addConsoleMessage(level, [], location2, text);
    }
  }
  async _onFileChooserOpened(event) {
    if (!event.backendNodeId)
      return;
    const frame = this._page._frameManager.frame(event.frameId);
    if (!frame)
      return;
    let handle;
    try {
      const utilityContext = await frame._utilityContext();
      handle = await this._adoptBackendNodeId(event.backendNodeId, utilityContext);
    } catch (e) {
      return;
    }
    await this._page._onFileChooserOpened(handle);
  }
  _willBeginDownload() {
    if (!this._crPage._page.initializedOrUndefined()) {
      this._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
    }
  }
  _onScreencastFrame(payload) {
    this._page.throttleScreencastFrameAck(() => {
      this._client.send("Page.screencastFrameAck", { sessionId: payload.sessionId }).catch(() => {
      });
    });
    const buffer2 = Buffer.from(payload.data, "base64");
    this._page.emit(Page.Events.ScreencastFrame, {
      buffer: buffer2,
      frameSwapWallTime: payload.metadata.timestamp ? payload.metadata.timestamp * 1e3 : void 0,
      width: payload.metadata.deviceWidth,
      height: payload.metadata.deviceHeight
    });
  }
  async _createVideoRecorder(screencastId, options2) {
    assert3(!this._screencastId);
    const ffmpegPath = registry.findExecutable("ffmpeg").executablePathOrDie(this._page.attribution.playwright.options.sdkLanguage);
    this._videoRecorder = await VideoRecorder.launch(this._crPage._page, ffmpegPath, options2);
    this._screencastId = screencastId;
  }
  async _startVideoRecording(options2) {
    const screencastId = this._screencastId;
    assert3(screencastId);
    this._page.once(Page.Events.Close, () => this._stopVideoRecording().catch(() => {
    }));
    const gotFirstFrame = new Promise((f) => this._client.once("Page.screencastFrame", f));
    await this._startScreencast(this._videoRecorder, {
      format: "jpeg",
      quality: 90,
      maxWidth: options2.width,
      maxHeight: options2.height
    });
    gotFirstFrame.then(() => {
      this._crPage._browserContext._browser._videoStarted(this._crPage._browserContext, screencastId, options2.outputFile, this._crPage._page.waitForInitializedOrError());
    });
  }
  async _stopVideoRecording() {
    if (!this._screencastId)
      return;
    const screencastId = this._screencastId;
    this._screencastId = null;
    const recorder = this._videoRecorder;
    this._videoRecorder = null;
    await this._stopScreencast(recorder);
    await recorder.stop().catch(() => {
    });
    const video = this._crPage._browserContext._browser._takeVideo(screencastId);
    video?.reportFinished();
  }
  async _startScreencast(client, options2 = {}) {
    this._screencastClients.add(client);
    if (this._screencastClients.size === 1)
      await this._client.send("Page.startScreencast", options2);
  }
  async _stopScreencast(client) {
    this._screencastClients.delete(client);
    if (!this._screencastClients.size)
      await this._client._sendMayFail("Page.stopScreencast");
  }
  async _updateGeolocation(initial) {
    const geolocation = this._crPage._browserContext._options.geolocation;
    if (!initial || geolocation)
      await this._client.send("Emulation.setGeolocationOverride", geolocation || {});
  }
  async _updateViewport(preserveWindowBoundaries) {
    if (this._crPage._browserContext._browser.isClank())
      return;
    assert3(this._isMainFrame());
    const options2 = this._crPage._browserContext._options;
    const emulatedSize = this._page.emulatedSize();
    if (emulatedSize === null)
      return;
    const viewportSize = emulatedSize.viewport;
    const screenSize = emulatedSize.screen;
    const isLandscape = screenSize.width > screenSize.height;
    const metricsOverride = {
      mobile: !!options2.isMobile,
      width: viewportSize.width,
      height: viewportSize.height,
      screenWidth: screenSize.width,
      screenHeight: screenSize.height,
      deviceScaleFactor: options2.deviceScaleFactor || 1,
      screenOrientation: !!options2.isMobile ? isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" } : { angle: 0, type: "landscapePrimary" },
      dontSetVisibleSize: preserveWindowBoundaries
    };
    if (JSON.stringify(this._metricsOverride) === JSON.stringify(metricsOverride))
      return;
    const promises2 = [
      this._client.send("Emulation.setDeviceMetricsOverride", metricsOverride)
    ];
    if (!preserveWindowBoundaries && this._windowId) {
      let insets = { width: 0, height: 0 };
      if (this._crPage._browserContext._browser.options.headful) {
        insets = { width: 24, height: 88 };
        if (process.platform === "win32")
          insets = { width: 16, height: 88 };
        else if (process.platform === "linux")
          insets = { width: 8, height: 85 };
        else if (process.platform === "darwin")
          insets = { width: 2, height: 80 };
        if (this._crPage._browserContext.isPersistentContext()) {
          insets.height += 46;
        }
      }
      promises2.push(this.setWindowBounds({
        width: viewportSize.width + insets.width,
        height: viewportSize.height + insets.height
      }));
    }
    await Promise.all(promises2);
    this._metricsOverride = metricsOverride;
  }
  async windowBounds() {
    const { bounds } = await this._client.send("Browser.getWindowBounds", {
      windowId: this._windowId
    });
    return bounds;
  }
  async setWindowBounds(bounds) {
    return await this._client.send("Browser.setWindowBounds", {
      windowId: this._windowId,
      bounds
    });
  }
  async _updateEmulateMedia() {
    const emulatedMedia = this._page.emulatedMedia();
    const media = emulatedMedia.media === "no-override" ? "" : emulatedMedia.media;
    const colorScheme = emulatedMedia.colorScheme === "no-override" ? "" : emulatedMedia.colorScheme;
    const reducedMotion = emulatedMedia.reducedMotion === "no-override" ? "" : emulatedMedia.reducedMotion;
    const forcedColors = emulatedMedia.forcedColors === "no-override" ? "" : emulatedMedia.forcedColors;
    const contrast = emulatedMedia.contrast === "no-override" ? "" : emulatedMedia.contrast;
    const features2 = [
      { name: "prefers-color-scheme", value: colorScheme },
      { name: "prefers-reduced-motion", value: reducedMotion },
      { name: "forced-colors", value: forcedColors },
      { name: "prefers-contrast", value: contrast }
    ];
    await this._client.send("Emulation.setEmulatedMedia", { media, features: features2 });
  }
  async _updateUserAgent() {
    const options2 = this._crPage._browserContext._options;
    await this._client.send("Emulation.setUserAgentOverride", {
      userAgent: options2.userAgent || "",
      acceptLanguage: options2.locale,
      userAgentMetadata: calculateUserAgentMetadata(options2)
    });
  }
  async _setDefaultFontFamilies(session2) {
    const fontFamilies = platformToFontFamilies[this._crPage._browserContext._browser._platform()];
    await session2.send("Page.setFontFamilies", fontFamilies);
  }
  async _updateFileChooserInterception(initial) {
    const enabled = this._page.fileChooserIntercepted();
    if (initial && !enabled)
      return;
    await this._client.send("Page.setInterceptFileChooserDialog", { enabled }).catch(() => {
    });
  }
  async _evaluateOnNewDocument(initScript, world) {
    const worldName = world === "utility" ? UTILITY_WORLD_NAME : void 0;
    const { identifier } = await this._client.send("Page.addScriptToEvaluateOnNewDocument", { source: initScript.source, worldName });
    if (!initScript.internal)
      this._evaluateOnNewDocumentIdentifiers.push(identifier);
  }
  async _removeEvaluatesOnNewDocument() {
    const identifiers = this._evaluateOnNewDocumentIdentifiers;
    this._evaluateOnNewDocumentIdentifiers = [];
    await Promise.all(identifiers.map((identifier) => this._client.send("Page.removeScriptToEvaluateOnNewDocument", { identifier })));
  }
  async _getContentFrame(handle) {
    const nodeInfo = await this._client.send("DOM.describeNode", {
      objectId: handle._objectId
    });
    if (!nodeInfo || typeof nodeInfo.node.frameId !== "string")
      return null;
    return this._page._frameManager.frame(nodeInfo.node.frameId);
  }
  async _getOwnerFrame(handle) {
    const documentElement = await handle.evaluateHandle((node2) => {
      const doc = node2;
      if (doc.documentElement && doc.documentElement.ownerDocument === doc)
        return doc.documentElement;
      return node2.ownerDocument ? node2.ownerDocument.documentElement : null;
    });
    if (!documentElement)
      return null;
    if (!documentElement._objectId)
      return null;
    const nodeInfo = await this._client.send("DOM.describeNode", {
      objectId: documentElement._objectId
    });
    const frameId = nodeInfo && typeof nodeInfo.node.frameId === "string" ? nodeInfo.node.frameId : null;
    documentElement.dispose();
    return frameId;
  }
  async _getBoundingBox(handle) {
    const result = await this._client._sendMayFail("DOM.getBoxModel", {
      objectId: handle._objectId
    });
    if (!result)
      return null;
    const quad = result.model.border;
    const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
    const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
    const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
    const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
    const position = await this._framePosition();
    if (!position)
      return null;
    return { x: x + position.x, y: y + position.y, width, height };
  }
  async _framePosition() {
    const frame = this._page._frameManager.frame(this._targetId);
    if (!frame)
      return null;
    if (frame === this._page.mainFrame())
      return { x: 0, y: 0 };
    const element = await frame.frameElement();
    const box = await element.boundingBox();
    return box;
  }
  async _scrollRectIntoViewIfNeeded(handle, rect) {
    return await this._client.send("DOM.scrollIntoViewIfNeeded", {
      objectId: handle._objectId,
      rect
    }).then(() => "done").catch((e) => {
      if (e instanceof Error && e.message.includes("Node does not have a layout object"))
        return "error:notvisible";
      if (e instanceof Error && e.message.includes("Node is detached from document"))
        return "error:notconnected";
      throw e;
    });
  }
  async _getContentQuads(handle) {
    const result = await this._client._sendMayFail("DOM.getContentQuads", {
      objectId: handle._objectId
    });
    if (!result)
      return null;
    const position = await this._framePosition();
    if (!position)
      return null;
    return result.quads.map((quad) => [
      { x: quad[0] + position.x, y: quad[1] + position.y },
      { x: quad[2] + position.x, y: quad[3] + position.y },
      { x: quad[4] + position.x, y: quad[5] + position.y },
      { x: quad[6] + position.x, y: quad[7] + position.y }
    ]);
  }
  async _adoptElementHandle(handle, to) {
    const nodeInfo = await this._client.send("DOM.describeNode", {
      objectId: handle._objectId
    });
    return this._adoptBackendNodeId(nodeInfo.node.backendNodeId, to);
  }
  async _adoptBackendNodeId(backendNodeId, to) {
    const result = await this._client._sendMayFail("DOM.resolveNode", {
      backendNodeId,
      executionContextId: to.delegate._contextId
    });
    if (!result || result.object.subtype === "null")
      throw new Error(kUnableToAdoptErrorMessage);
    return createHandle(to, result.object).asElement();
  }
};
async function emulateLocale(session2, locale) {
  try {
    await session2.send("Emulation.setLocaleOverride", { locale });
  } catch (exception) {
    if (exception.message.includes("Another locale override is already in effect"))
      return;
    throw exception;
  }
}
__name(emulateLocale, "emulateLocale");
async function emulateTimezone(session2, timezoneId) {
  try {
    await session2.send("Emulation.setTimezoneOverride", { timezoneId });
  } catch (exception) {
    if (exception.message.includes("Timezone override is already in effect"))
      return;
    if (exception.message.includes("Invalid timezone"))
      throw new Error(`Invalid timezone ID: ${timezoneId}`);
    throw exception;
  }
}
__name(emulateTimezone, "emulateTimezone");
function calculateUserAgentMetadata(options2) {
  const ua = options2.userAgent;
  if (!ua)
    return void 0;
  const metadata = {
    mobile: !!options2.isMobile,
    model: "",
    architecture: "x64",
    platform: "Windows",
    platformVersion: ""
  };
  const androidMatch = ua.match(/Android (\d+(\.\d+)?(\.\d+)?)/);
  const iPhoneMatch = ua.match(/iPhone OS (\d+(_\d+)?)/);
  const iPadMatch = ua.match(/iPad; CPU OS (\d+(_\d+)?)/);
  const macOSMatch = ua.match(/Mac OS X (\d+(_\d+)?(_\d+)?)/);
  const windowsMatch = ua.match(/Windows\D+(\d+(\.\d+)?(\.\d+)?)/);
  if (androidMatch) {
    metadata.platform = "Android";
    metadata.platformVersion = androidMatch[1];
    metadata.architecture = "arm";
  } else if (iPhoneMatch) {
    metadata.platform = "iOS";
    metadata.platformVersion = iPhoneMatch[1];
    metadata.architecture = "arm";
  } else if (iPadMatch) {
    metadata.platform = "iOS";
    metadata.platformVersion = iPadMatch[1];
    metadata.architecture = "arm";
  } else if (macOSMatch) {
    metadata.platform = "macOS";
    metadata.platformVersion = macOSMatch[1];
    if (!ua.includes("Intel"))
      metadata.architecture = "arm";
  } else if (windowsMatch) {
    metadata.platform = "Windows";
    metadata.platformVersion = windowsMatch[1];
  } else if (ua.toLowerCase().includes("linux")) {
    metadata.platform = "Linux";
  }
  if (ua.includes("ARM"))
    metadata.architecture = "arm";
  return metadata;
}
__name(calculateUserAgentMetadata, "calculateUserAgentMetadata");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crServiceWorker.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CRServiceWorker = class extends Worker {
  static {
    __name(this, "CRServiceWorker");
  }
  constructor(browserContext, session2, url4) {
    super(browserContext, url4);
    this._session = session2;
    this._browserContext = browserContext;
    if (!!process.env.PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS)
      this._networkManager = new CRNetworkManager(null, this);
    session2.once("Runtime.executionContextCreated", (event) => {
      this._createExecutionContext(new CRExecutionContext(session2, event.context));
    });
    if (this._networkManager && this._isNetworkInspectionEnabled()) {
      this.updateRequestInterception();
      this.updateExtraHTTPHeaders();
      this.updateHttpCredentials();
      this.updateOffline();
      this._networkManager.addSession(
        session2,
        void 0,
        true
        /* isMain */
      ).catch(() => {
      });
    }
    session2.send("Runtime.enable", {}).catch((e) => {
    });
    session2.send("Runtime.runIfWaitingForDebugger").catch((e) => {
    });
    session2.on("Inspector.targetReloadedAfterCrash", () => {
      session2._sendMayFail("Runtime.runIfWaitingForDebugger", {});
    });
  }
  didClose() {
    this._networkManager?.removeSession(this._session);
    this._session.dispose();
    super.didClose();
  }
  async updateOffline() {
    if (!this._isNetworkInspectionEnabled())
      return;
    await this._networkManager?.setOffline(!!this._browserContext._options.offline).catch(() => {
    });
  }
  async updateHttpCredentials() {
    if (!this._isNetworkInspectionEnabled())
      return;
    await this._networkManager?.authenticate(this._browserContext._options.httpCredentials || null).catch(() => {
    });
  }
  async updateExtraHTTPHeaders() {
    if (!this._isNetworkInspectionEnabled())
      return;
    await this._networkManager?.setExtraHTTPHeaders(this._browserContext._options.extraHTTPHeaders || []).catch(() => {
    });
  }
  async updateRequestInterception() {
    if (!this._isNetworkInspectionEnabled())
      return;
    await this._networkManager?.setRequestInterception(this.needsRequestInterception()).catch(() => {
    });
  }
  needsRequestInterception() {
    return this._isNetworkInspectionEnabled() && !!this._browserContext._requestInterceptor;
  }
  reportRequestFinished(request4, response) {
    this._browserContext.emit(BrowserContext.Events.RequestFinished, { request: request4, response });
  }
  requestFailed(request4, _canceled) {
    this._browserContext.emit(BrowserContext.Events.RequestFailed, request4);
  }
  requestReceivedResponse(response) {
    this._browserContext.emit(BrowserContext.Events.Response, response);
  }
  requestStarted(request4, route) {
    this._browserContext.emit(BrowserContext.Events.Request, request4);
    if (route) {
      const r = new Route(request4, route);
      if (this._browserContext._requestInterceptor?.(r, request4))
        return;
      r.continue({ isFallback: true }).catch(() => {
      });
    }
  }
  _isNetworkInspectionEnabled() {
    return this._browserContext._options.serviceWorkers !== "block";
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crBrowser.js
var CRBrowser = class _CRBrowser extends Browser {
  static {
    __name(this, "CRBrowser");
  }
  constructor(parent, connection, options2) {
    super(parent, options2);
    this._clientRootSessionPromise = null;
    this._contexts = /* @__PURE__ */ new Map();
    this._crPages = /* @__PURE__ */ new Map();
    this._backgroundPages = /* @__PURE__ */ new Map();
    this._serviceWorkers = /* @__PURE__ */ new Map();
    this._version = "";
    this._tracingRecording = false;
    this._userAgent = "";
    this._connection = connection;
    this._session = this._connection.rootSession;
    this._connection.on(ConnectionEvents.Disconnected, () => this._didDisconnect());
    this._session.on("Target.attachedToTarget", this._onAttachedToTarget.bind(this));
    this._session.on("Target.detachedFromTarget", this._onDetachedFromTarget.bind(this));
    this._session.on("Browser.downloadWillBegin", this._onDownloadWillBegin.bind(this));
    this._session.on("Browser.downloadProgress", this._onDownloadProgress.bind(this));
  }
  static async connect(parent, transport, options2, devtools) {
    options2 = { ...options2 };
    const connection = new CRConnection(transport, options2.protocolLogger, options2.browserLogsCollector);
    const browser3 = new _CRBrowser(parent, connection, options2);
    browser3._devtools = devtools;
    if (browser3.isClank())
      browser3._isCollocatedWithServer = false;
    const session2 = connection.rootSession;
    if (options2.__testHookOnConnectToBrowser)
      await options2.__testHookOnConnectToBrowser();
    const version6 = await session2.send("Browser.getVersion");
    browser3._version = version6.product.substring(version6.product.indexOf("/") + 1);
    browser3._userAgent = version6.userAgent;
    browser3.options.headful = !version6.userAgent.includes("Headless");
    if (!options2.persistent) {
      await session2.send("Target.setAutoAttach", { autoAttach: true, waitForDebuggerOnStart: true, flatten: true });
      return browser3;
    }
    browser3._defaultContext = new CRBrowserContext(browser3, void 0, options2.persistent);
    await Promise.all([
      session2.send("Target.setAutoAttach", { autoAttach: true, waitForDebuggerOnStart: true, flatten: true }).then(async () => {
        await session2.send("Target.getTargetInfo");
      }),
      browser3._defaultContext._initialize()
    ]);
    await browser3._waitForAllPagesToBeInitialized();
    return browser3;
  }
  async doCreateNewContext(options2) {
    const proxy = options2.proxyOverride || options2.proxy;
    let proxyBypassList = void 0;
    if (proxy) {
      if (process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK)
        proxyBypassList = proxy.bypass;
      else
        proxyBypassList = "<-loopback>" + (proxy.bypass ? `,${proxy.bypass}` : "");
    }
    const { browserContextId } = await this._session.send("Target.createBrowserContext", {
      disposeOnDetach: true,
      proxyServer: proxy ? proxy.server : void 0,
      proxyBypassList
    });
    const context2 = new CRBrowserContext(this, browserContextId, options2);
    await context2._initialize();
    this._contexts.set(browserContextId, context2);
    return context2;
  }
  contexts() {
    return Array.from(this._contexts.values());
  }
  version() {
    return this._version;
  }
  userAgent() {
    return this._userAgent;
  }
  _platform() {
    if (this._userAgent.includes("Windows"))
      return "win";
    if (this._userAgent.includes("Macintosh"))
      return "mac";
    return "linux";
  }
  isClank() {
    return this.options.name === "clank";
  }
  async _waitForAllPagesToBeInitialized() {
    await Promise.all([...this._crPages.values()].map((crPage) => crPage._page.waitForInitializedOrError()));
  }
  _onAttachedToTarget({ targetInfo, sessionId, waitingForDebugger }) {
    if (targetInfo.type === "browser")
      return;
    const session2 = this._session.createChildSession(sessionId);
    assert3(targetInfo.browserContextId, "targetInfo: " + JSON.stringify(targetInfo, null, 2));
    let context2 = this._contexts.get(targetInfo.browserContextId) || null;
    if (!context2) {
      context2 = this._defaultContext;
    }
    if (targetInfo.type === "other" && targetInfo.url.startsWith("devtools://devtools") && this._devtools) {
      this._devtools.install(session2);
      return;
    }
    const treatOtherAsPage = targetInfo.type === "other" && process.env.PW_CHROMIUM_ATTACH_TO_OTHER;
    if (!context2 || targetInfo.type === "other" && !treatOtherAsPage) {
      session2.detach().catch(() => {
      });
      return;
    }
    assert3(!this._crPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
    assert3(!this._backgroundPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
    assert3(!this._serviceWorkers.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
    if (targetInfo.type === "background_page") {
      const backgroundPage = new CRPage(session2, targetInfo.targetId, context2, null, { hasUIWindow: false, isBackgroundPage: true });
      this._backgroundPages.set(targetInfo.targetId, backgroundPage);
      return;
    }
    if (targetInfo.type === "page" || treatOtherAsPage) {
      const opener = targetInfo.openerId ? this._crPages.get(targetInfo.openerId) || null : null;
      const crPage = new CRPage(session2, targetInfo.targetId, context2, opener, { hasUIWindow: targetInfo.type === "page", isBackgroundPage: false });
      this._crPages.set(targetInfo.targetId, crPage);
      return;
    }
    if (targetInfo.type === "service_worker") {
      const serviceWorker = new CRServiceWorker(context2, session2, targetInfo.url);
      this._serviceWorkers.set(targetInfo.targetId, serviceWorker);
      context2.emit(CRBrowserContext.CREvents.ServiceWorker, serviceWorker);
      return;
    }
    session2.detach().catch(() => {
    });
  }
  _onDetachedFromTarget(payload) {
    const targetId = payload.targetId;
    const crPage = this._crPages.get(targetId);
    if (crPage) {
      this._crPages.delete(targetId);
      crPage.didClose();
      return;
    }
    const backgroundPage = this._backgroundPages.get(targetId);
    if (backgroundPage) {
      this._backgroundPages.delete(targetId);
      backgroundPage.didClose();
      return;
    }
    const serviceWorker = this._serviceWorkers.get(targetId);
    if (serviceWorker) {
      this._serviceWorkers.delete(targetId);
      serviceWorker.didClose();
      return;
    }
  }
  _didDisconnect() {
    for (const crPage of this._crPages.values())
      crPage.didClose();
    this._crPages.clear();
    for (const backgroundPage of this._backgroundPages.values())
      backgroundPage.didClose();
    this._backgroundPages.clear();
    for (const serviceWorker of this._serviceWorkers.values())
      serviceWorker.didClose();
    this._serviceWorkers.clear();
    this._didClose();
  }
  _findOwningPage(frameId) {
    for (const crPage of this._crPages.values()) {
      const frame = crPage._page._frameManager.frame(frameId);
      if (frame)
        return crPage;
    }
    return null;
  }
  _onDownloadWillBegin(payload) {
    const page = this._findOwningPage(payload.frameId);
    if (!page) {
      return;
    }
    page.willBeginDownload();
    let originPage = page._page.initializedOrUndefined();
    if (!originPage && page._opener)
      originPage = page._opener._page.initializedOrUndefined();
    if (!originPage)
      return;
    this._downloadCreated(originPage, payload.guid, payload.url, payload.suggestedFilename);
  }
  _onDownloadProgress(payload) {
    if (payload.state === "completed")
      this._downloadFinished(payload.guid, "");
    if (payload.state === "canceled")
      this._downloadFinished(payload.guid, this._closeReason || "canceled");
  }
  async _closePage(crPage) {
    await this._session.send("Target.closeTarget", { targetId: crPage._targetId });
  }
  async newBrowserCDPSession() {
    return await this._connection.createBrowserSession();
  }
  async startTracing(page, options2 = {}) {
    assert3(!this._tracingRecording, "Cannot start recording trace while already recording trace.");
    this._tracingClient = page ? page._delegate._mainFrameSession._client : this._session;
    const defaultCategories = [
      "-*",
      "devtools.timeline",
      "v8.execute",
      "disabled-by-default-devtools.timeline",
      "disabled-by-default-devtools.timeline.frame",
      "toplevel",
      "blink.console",
      "blink.user_timing",
      "latencyInfo",
      "disabled-by-default-devtools.timeline.stack",
      "disabled-by-default-v8.cpu_profiler",
      "disabled-by-default-v8.cpu_profiler.hires"
    ];
    const {
      screenshots = false,
      categories = defaultCategories
    } = options2;
    if (screenshots)
      categories.push("disabled-by-default-devtools.screenshot");
    this._tracingRecording = true;
    await this._tracingClient.send("Tracing.start", {
      transferMode: "ReturnAsStream",
      categories: categories.join(",")
    });
  }
  async stopTracing() {
    assert3(this._tracingClient, "Tracing was not started.");
    const [event] = await Promise.all([
      new Promise((f) => this._tracingClient.once("Tracing.tracingComplete", f)),
      this._tracingClient.send("Tracing.end")
    ]);
    const tracingPath = path18.join(this.options.artifactsDir, createGuid() + ".crtrace");
    await saveProtocolStream(this._tracingClient, event.stream, tracingPath);
    this._tracingRecording = false;
    const artifact = new Artifact(this, tracingPath);
    artifact.reportFinished();
    return artifact;
  }
  isConnected() {
    return !this._connection._closed;
  }
  async _clientRootSession() {
    if (!this._clientRootSessionPromise)
      this._clientRootSessionPromise = this._connection.createBrowserSession();
    return this._clientRootSessionPromise;
  }
};
var CRBrowserContext = class extends BrowserContext {
  static {
    __name(this, "CRBrowserContext");
  }
  static {
    this.CREvents = {
      BackgroundPage: "backgroundpage",
      ServiceWorker: "serviceworker"
    };
  }
  constructor(browser3, browserContextId, options2) {
    super(browser3, options2, browserContextId);
    this._authenticateProxyViaCredentials();
  }
  async _initialize() {
    assert3(!Array.from(this._browser._crPages.values()).some((page) => page._browserContext === this));
    const promises2 = [super._initialize()];
    if (this._browser.options.name !== "clank" && this._options.acceptDownloads !== "internal-browser-default") {
      promises2.push(this._browser._session.send("Browser.setDownloadBehavior", {
        behavior: this._options.acceptDownloads === "accept" ? "allowAndName" : "deny",
        browserContextId: this._browserContextId,
        downloadPath: this._browser.options.downloadsPath,
        eventsEnabled: true
      }));
    }
    await Promise.all(promises2);
  }
  _crPages() {
    return [...this._browser._crPages.values()].filter((crPage) => crPage._browserContext === this);
  }
  possiblyUninitializedPages() {
    return this._crPages().map((crPage) => crPage._page);
  }
  async doCreateNewPage() {
    assertBrowserContextIsNotOwned(this);
    const { targetId } = await this._browser._session.send("Target.createTarget", { url: "about:blank", browserContextId: this._browserContextId });
    return this._browser._crPages.get(targetId)._page;
  }
  async doGetCookies(urls) {
    const { cookies } = await this._browser._session.send("Storage.getCookies", { browserContextId: this._browserContextId });
    return filterCookies(cookies.map((c) => {
      const copy = { sameSite: "Lax", ...c };
      delete copy.size;
      delete copy.priority;
      delete copy.session;
      delete copy.sameParty;
      delete copy.sourceScheme;
      delete copy.sourcePort;
      return copy;
    }), urls);
  }
  async addCookies(cookies) {
    await this._browser._session.send("Storage.setCookies", { cookies: rewriteCookies(cookies), browserContextId: this._browserContextId });
  }
  async doClearCookies() {
    await this._browser._session.send("Storage.clearCookies", { browserContextId: this._browserContextId });
  }
  async doGrantPermissions(origin, permissions) {
    const webPermissionToProtocol = /* @__PURE__ */ new Map([
      ["geolocation", "geolocation"],
      ["midi", "midi"],
      ["notifications", "notifications"],
      ["camera", "videoCapture"],
      ["microphone", "audioCapture"],
      ["background-sync", "backgroundSync"],
      ["ambient-light-sensor", "sensors"],
      ["accelerometer", "sensors"],
      ["gyroscope", "sensors"],
      ["magnetometer", "sensors"],
      ["clipboard-read", "clipboardReadWrite"],
      ["clipboard-write", "clipboardSanitizedWrite"],
      ["payment-handler", "paymentHandler"],
      // chrome-specific permissions we have.
      ["midi-sysex", "midiSysex"],
      ["storage-access", "storageAccess"]
    ]);
    const filtered = permissions.map((permission2) => {
      const protocolPermission = webPermissionToProtocol.get(permission2);
      if (!protocolPermission)
        throw new Error("Unknown permission: " + permission2);
      return protocolPermission;
    });
    await this._browser._session.send("Browser.grantPermissions", { origin: origin === "*" ? void 0 : origin, browserContextId: this._browserContextId, permissions: filtered });
  }
  async doClearPermissions() {
    await this._browser._session.send("Browser.resetPermissions", { browserContextId: this._browserContextId });
  }
  async setGeolocation(geolocation) {
    verifyGeolocation(geolocation);
    this._options.geolocation = geolocation;
    for (const page of this.pages())
      await page._delegate.updateGeolocation();
  }
  async setExtraHTTPHeaders(headers) {
    this._options.extraHTTPHeaders = headers;
    for (const page of this.pages())
      await page._delegate.updateExtraHTTPHeaders();
    for (const sw of this.serviceWorkers())
      await sw.updateExtraHTTPHeaders();
  }
  async setUserAgent(userAgent) {
    this._options.userAgent = userAgent;
    for (const page of this.pages())
      await page._delegate.updateUserAgent();
  }
  async setOffline(offline) {
    this._options.offline = offline;
    for (const page of this.pages())
      await page._delegate.updateOffline();
    for (const sw of this.serviceWorkers())
      await sw.updateOffline();
  }
  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;
    for (const page of this.pages())
      await page._delegate.updateHttpCredentials();
    for (const sw of this.serviceWorkers())
      await sw.updateHttpCredentials();
  }
  async doAddInitScript(initScript) {
    for (const page of this.pages())
      await page._delegate.addInitScript(initScript);
  }
  async doRemoveNonInternalInitScripts() {
    for (const page of this.pages())
      await page._delegate.removeNonInternalInitScripts();
  }
  async doUpdateRequestInterception() {
    for (const page of this.pages())
      await page._delegate.updateRequestInterception();
    for (const sw of this.serviceWorkers())
      await sw.updateRequestInterception();
  }
  async doClose(reason) {
    const openedBeforeUnloadDialogs = [];
    for (const crPage of this._crPages()) {
      const dialogs = [...crPage._page._frameManager._openedDialogs].filter((dialog) => dialog.type() === "beforeunload");
      openedBeforeUnloadDialogs.push(...dialogs);
    }
    await Promise.all(openedBeforeUnloadDialogs.map((dialog) => dialog.dismiss()));
    if (!this._browserContextId) {
      await this.stopVideoRecording();
      await this._browser.close({ reason });
      return;
    }
    await Promise.all(this._crPages().map((page) => page.closePage(true))).catch(() => {
    });
    await this._browser._session.send("Target.disposeBrowserContext", { browserContextId: this._browserContextId });
    this._browser._contexts.delete(this._browserContextId);
    for (const [targetId, serviceWorker] of this._browser._serviceWorkers) {
      if (serviceWorker._browserContext !== this)
        continue;
      serviceWorker.didClose();
      this._browser._serviceWorkers.delete(targetId);
    }
  }
  async stopVideoRecording() {
    await Promise.all(this._crPages().map((crPage) => crPage._mainFrameSession._stopVideoRecording()));
  }
  onClosePersistent() {
    for (const [targetId, backgroundPage] of this._browser._backgroundPages.entries()) {
      if (backgroundPage._browserContext === this && backgroundPage._page.initializedOrUndefined()) {
        backgroundPage.didClose();
        this._browser._backgroundPages.delete(targetId);
      }
    }
  }
  async clearCache() {
    for (const page of this._crPages())
      await page._networkManager.clearCache();
  }
  async cancelDownload(guid) {
    await this._browser._session.send("Browser.cancelDownload", {
      guid,
      browserContextId: this._browserContextId
    });
  }
  backgroundPages() {
    const result = [];
    for (const backgroundPage of this._browser._backgroundPages.values()) {
      if (backgroundPage._browserContext === this && backgroundPage._page.initializedOrUndefined())
        result.push(backgroundPage._page);
    }
    return result;
  }
  serviceWorkers() {
    return Array.from(this._browser._serviceWorkers.values()).filter((serviceWorker) => serviceWorker._browserContext === this);
  }
  async newCDPSession(page) {
    let targetId = null;
    if (page instanceof Page) {
      targetId = page._delegate._targetId;
    } else if (page instanceof Frame) {
      const session2 = page._page._delegate._sessions.get(page._id);
      if (!session2)
        throw new Error(`This frame does not have a separate CDP session, it is a part of the parent frame's session`);
      targetId = session2._targetId;
    } else {
      throw new Error("page: expected Page or Frame");
    }
    const rootSession = await this._browser._clientRootSession();
    return rootSession.attachToTarget(targetId);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/writableStreamDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WritableStreamDispatcher = class extends Dispatcher {
  static {
    __name(this, "WritableStreamDispatcher");
  }
  constructor(scope, streamOrDirectory, lastModifiedMs) {
    super(scope, { guid: "writableStream@" + createGuid(), streamOrDirectory }, "WritableStream", {});
    this._type_WritableStream = true;
    this._lastModifiedMs = lastModifiedMs;
  }
  async write(params) {
    if (typeof this._object.streamOrDirectory === "string")
      throw new Error("Cannot write to a directory");
    const stream = this._object.streamOrDirectory;
    await new Promise((fulfill, reject) => {
      stream.write(params.binary, (error4) => {
        if (error4)
          reject(error4);
        else
          fulfill();
      });
    });
  }
  async close() {
    if (typeof this._object.streamOrDirectory === "string")
      throw new Error("Cannot close a directory");
    const stream = this._object.streamOrDirectory;
    await new Promise((fulfill) => stream.end(fulfill));
    if (this._lastModifiedMs)
      await fs.promises.utimes(this.path(), new Date(this._lastModifiedMs), new Date(this._lastModifiedMs));
  }
  path() {
    if (typeof this._object.streamOrDirectory === "string")
      return this._object.streamOrDirectory;
    return this._object.streamOrDirectory.path;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/browserContextDispatcher.js
var BrowserContextDispatcher = class extends Dispatcher {
  static {
    __name(this, "BrowserContextDispatcher");
  }
  constructor(parentScope, context2) {
    const requestContext = APIRequestContextDispatcher.from(parentScope, context2.fetchRequest);
    const tracing = TracingDispatcher.from(parentScope, context2.tracing);
    super(parentScope, context2, "BrowserContext", {
      isChromium: context2._browser.options.isChromium,
      isLocalBrowserOnServer: context2._browser._isCollocatedWithServer,
      requestContext,
      tracing
    });
    this._type_EventTarget = true;
    this._type_BrowserContext = true;
    this._subscriptions = /* @__PURE__ */ new Set();
    this._webSocketInterceptionPatterns = [];
    this.adopt(requestContext);
    this.adopt(tracing);
    this._context = context2;
    const onVideo = /* @__PURE__ */ __name((artifact) => {
      const artifactDispatcher = ArtifactDispatcher.from(parentScope, artifact);
      this._dispatchEvent("video", { artifact: artifactDispatcher });
    }, "onVideo");
    this.addObjectListener(BrowserContext.Events.VideoStarted, onVideo);
    for (const video of context2._browser._idToVideo.values()) {
      if (video.context === context2)
        onVideo(video.artifact);
    }
    for (const page of context2.pages())
      this._dispatchEvent("page", { page: PageDispatcher.from(this, page) });
    this.addObjectListener(BrowserContext.Events.Page, (page) => {
      this._dispatchEvent("page", { page: PageDispatcher.from(this, page) });
    });
    this.addObjectListener(BrowserContext.Events.Close, () => {
      this._dispatchEvent("close");
      this._dispose();
    });
    this.addObjectListener(BrowserContext.Events.PageError, (error4, page) => {
      this._dispatchEvent("pageError", { error: serializeError(error4), page: PageDispatcher.from(this, page) });
    });
    this.addObjectListener(BrowserContext.Events.Console, (message) => {
      const page = message.page();
      if (this._shouldDispatchEvent(page, "console")) {
        const pageDispatcher = PageDispatcher.from(this, page);
        this._dispatchEvent("console", {
          page: pageDispatcher,
          type: message.type(),
          text: message.text(),
          args: message.args().map((a) => ElementHandleDispatcher.fromJSHandle(pageDispatcher, a)),
          location: message.location()
        });
      }
    });
    this.addObjectListener(BrowserContext.Events.Dialog, (dialog) => {
      if (this._shouldDispatchEvent(dialog.page(), "dialog"))
        this._dispatchEvent("dialog", { dialog: new DialogDispatcher(this, dialog) });
      else
        dialog.close().catch(() => {
        });
    });
    if (context2._browser.options.name === "chromium") {
      for (const page of context2.backgroundPages())
        this._dispatchEvent("backgroundPage", { page: PageDispatcher.from(this, page) });
      this.addObjectListener(CRBrowserContext.CREvents.BackgroundPage, (page) => this._dispatchEvent("backgroundPage", { page: PageDispatcher.from(this, page) }));
      for (const serviceWorker of context2.serviceWorkers())
        this._dispatchEvent("serviceWorker", { worker: new WorkerDispatcher(this, serviceWorker) });
      this.addObjectListener(CRBrowserContext.CREvents.ServiceWorker, (serviceWorker) => this._dispatchEvent("serviceWorker", { worker: new WorkerDispatcher(this, serviceWorker) }));
    }
    this.addObjectListener(BrowserContext.Events.Request, (request4) => {
      const redirectFromDispatcher = request4.redirectedFrom() && existingDispatcher(request4.redirectedFrom());
      if (!redirectFromDispatcher && !this._shouldDispatchNetworkEvent(request4, "request") && !request4.isNavigationRequest())
        return;
      const requestDispatcher = RequestDispatcher.from(this, request4);
      this._dispatchEvent("request", {
        request: requestDispatcher,
        page: PageDispatcher.fromNullable(this, request4.frame()?._page.initializedOrUndefined())
      });
    });
    this.addObjectListener(BrowserContext.Events.Response, (response) => {
      const requestDispatcher = existingDispatcher(response.request());
      if (!requestDispatcher && !this._shouldDispatchNetworkEvent(response.request(), "response"))
        return;
      this._dispatchEvent("response", {
        response: ResponseDispatcher.from(this, response),
        page: PageDispatcher.fromNullable(this, response.frame()?._page.initializedOrUndefined())
      });
    });
    this.addObjectListener(BrowserContext.Events.RequestFailed, (request4) => {
      const requestDispatcher = existingDispatcher(request4);
      if (!requestDispatcher && !this._shouldDispatchNetworkEvent(request4, "requestFailed"))
        return;
      this._dispatchEvent("requestFailed", {
        request: RequestDispatcher.from(this, request4),
        failureText: request4._failureText || void 0,
        responseEndTiming: request4._responseEndTiming,
        page: PageDispatcher.fromNullable(this, request4.frame()?._page.initializedOrUndefined())
      });
    });
    this.addObjectListener(BrowserContext.Events.RequestFinished, ({ request: request4, response }) => {
      const requestDispatcher = existingDispatcher(request4);
      if (!requestDispatcher && !this._shouldDispatchNetworkEvent(request4, "requestFinished"))
        return;
      this._dispatchEvent("requestFinished", {
        request: RequestDispatcher.from(this, request4),
        response: ResponseDispatcher.fromNullable(this, response),
        responseEndTiming: request4._responseEndTiming,
        page: PageDispatcher.fromNullable(this, request4.frame()?._page.initializedOrUndefined())
      });
    });
  }
  _shouldDispatchNetworkEvent(request4, event) {
    return this._shouldDispatchEvent(request4.frame()?._page?.initializedOrUndefined(), event);
  }
  _shouldDispatchEvent(page, event) {
    if (this._subscriptions.has(event))
      return true;
    const pageDispatcher = page ? existingDispatcher(page) : void 0;
    if (pageDispatcher?._subscriptions.has(event))
      return true;
    return false;
  }
  async createTempFiles(params) {
    const dir3 = this._context._browser.options.artifactsDir;
    const tmpDir = path19.join(dir3, "upload-" + createGuid());
    const tempDirWithRootName = params.rootDirName ? path19.join(tmpDir, path19.basename(params.rootDirName)) : tmpDir;
    await fs.promises.mkdir(tempDirWithRootName, { recursive: true });
    this._context._tempDirs.push(tmpDir);
    return {
      rootDir: params.rootDirName ? new WritableStreamDispatcher(this, tempDirWithRootName) : void 0,
      writableStreams: await Promise.all(params.items.map(async (item) => {
        await fs.promises.mkdir(path19.dirname(path19.join(tempDirWithRootName, item.name)), { recursive: true });
        const file = fs.createWriteStream(path19.join(tempDirWithRootName, item.name));
        return new WritableStreamDispatcher(this, file, item.lastModifiedMs);
      }))
    };
  }
  async setDefaultNavigationTimeoutNoReply(params) {
    this._context.setDefaultNavigationTimeout(params.timeout);
  }
  async setDefaultTimeoutNoReply(params) {
    this._context.setDefaultTimeout(params.timeout);
  }
  async exposeBinding(params) {
    await this._context.exposeBinding(params.name, !!params.needsHandle, (source7, ...args) => {
      if (this._disposed)
        return;
      const pageDispatcher = PageDispatcher.from(this, source7.page);
      const binding3 = new BindingCallDispatcher(pageDispatcher, params.name, !!params.needsHandle, source7, args);
      this._dispatchEvent("bindingCall", { binding: binding3 });
      return binding3.promise();
    });
  }
  async newPage(params, metadata) {
    return { page: PageDispatcher.from(this, await this._context.newPage(metadata)) };
  }
  async cookies(params) {
    return { cookies: await this._context.cookies(params.urls) };
  }
  async addCookies(params) {
    await this._context.addCookies(params.cookies);
  }
  async clearCookies(params) {
    const nameRe = params.nameRegexSource !== void 0 && params.nameRegexFlags !== void 0 ? new RegExp(params.nameRegexSource, params.nameRegexFlags) : void 0;
    const domainRe = params.domainRegexSource !== void 0 && params.domainRegexFlags !== void 0 ? new RegExp(params.domainRegexSource, params.domainRegexFlags) : void 0;
    const pathRe = params.pathRegexSource !== void 0 && params.pathRegexFlags !== void 0 ? new RegExp(params.pathRegexSource, params.pathRegexFlags) : void 0;
    await this._context.clearCookies({
      name: nameRe || params.name,
      domain: domainRe || params.domain,
      path: pathRe || params.path
    });
  }
  async grantPermissions(params) {
    await this._context.grantPermissions(params.permissions, params.origin);
  }
  async clearPermissions() {
    await this._context.clearPermissions();
  }
  async setGeolocation(params) {
    await this._context.setGeolocation(params.geolocation);
  }
  async setExtraHTTPHeaders(params) {
    await this._context.setExtraHTTPHeaders(params.headers);
  }
  async setOffline(params) {
    await this._context.setOffline(params.offline);
  }
  async setHTTPCredentials(params) {
    await this._context.setHTTPCredentials(params.httpCredentials);
  }
  async addInitScript(params) {
    await this._context.addInitScript(params.source);
  }
  async setNetworkInterceptionPatterns(params) {
    if (!params.patterns.length) {
      await this._context.setRequestInterceptor(void 0);
      return;
    }
    const urlMatchers = params.patterns.map((pattern) => pattern.regexSource ? new RegExp(pattern.regexSource, pattern.regexFlags) : pattern.glob);
    await this._context.setRequestInterceptor((route, request4) => {
      const matchesSome = urlMatchers.some((urlMatch) => urlMatches(this._context._options.baseURL, request4.url(), urlMatch));
      if (!matchesSome)
        return false;
      this._dispatchEvent("route", { route: RouteDispatcher.from(RequestDispatcher.from(this, request4), route) });
      return true;
    });
  }
  async setWebSocketInterceptionPatterns(params, metadata) {
    this._webSocketInterceptionPatterns = params.patterns;
    if (params.patterns.length)
      await WebSocketRouteDispatcher.installIfNeeded(this._context);
  }
  async storageState(params, metadata) {
    return await this._context.storageState(params.indexedDB);
  }
  async close(params, metadata) {
    metadata.potentiallyClosesScope = true;
    await this._context.close(params);
  }
  async enableRecorder(params) {
    await Recorder.show(this._context, RecorderApp.factory(this._context), params);
  }
  async pause(params, metadata) {
  }
  async newCDPSession(params) {
    if (!this._object._browser.options.isChromium)
      throw new Error(`CDP session is only available in Chromium`);
    if (!params.page && !params.frame || params.page && params.frame)
      throw new Error(`CDP session must be initiated with either Page or Frame, not none or both`);
    const crBrowserContext = this._object;
    return { session: new CDPSessionDispatcher(this, await crBrowserContext.newCDPSession((params.page ? params.page : params.frame)._object)) };
  }
  async harStart(params) {
    const harId = await this._context._harStart(params.page ? params.page._object : null, params.options);
    return { harId };
  }
  async harExport(params) {
    const artifact = await this._context._harExport(params.harId);
    if (!artifact)
      throw new Error("No HAR artifact. Ensure record.harPath is set.");
    return { artifact: ArtifactDispatcher.from(this, artifact) };
  }
  async clockFastForward(params, metadata) {
    await this._context.clock.fastForward(params.ticksString ?? params.ticksNumber ?? 0);
  }
  async clockInstall(params, metadata) {
    await this._context.clock.install(params.timeString ?? params.timeNumber ?? void 0);
  }
  async clockPauseAt(params, metadata) {
    await this._context.clock.pauseAt(params.timeString ?? params.timeNumber ?? 0);
  }
  async clockResume(params, metadata) {
    await this._context.clock.resume();
  }
  async clockRunFor(params, metadata) {
    await this._context.clock.runFor(params.ticksString ?? params.ticksNumber ?? 0);
  }
  async clockSetFixedTime(params, metadata) {
    await this._context.clock.setFixedTime(params.timeString ?? params.timeNumber ?? 0);
  }
  async clockSetSystemTime(params, metadata) {
    await this._context.clock.setSystemTime(params.timeString ?? params.timeNumber ?? 0);
  }
  async updateSubscription(params) {
    if (params.enabled)
      this._subscriptions.add(params.event);
    else
      this._subscriptions.delete(params.event);
  }
  _onDispose() {
    if (!this._context.isClosingOrClosed())
      this._context.setRequestInterceptor(void 0).catch(() => {
      });
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/android/android.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter13 } from "node:events";
import path20 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/pipeTransport.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PipeTransport = class {
  static {
    __name(this, "PipeTransport");
  }
  constructor(pipeWrite, pipeRead, closeable, endian = "le") {
    this._data = Buffer.from([]);
    this._waitForNextTask = makeWaitForNextTask();
    this._closed = false;
    this._bytesLeft = 0;
    this._pipeWrite = pipeWrite;
    this._endian = endian;
    this._closeableStream = closeable;
    pipeRead.on("data", (buffer2) => this._dispatch(buffer2));
    pipeRead.on("close", () => {
      this._closed = true;
      if (this.onclose)
        this.onclose();
    });
    this.onmessage = void 0;
    this.onclose = void 0;
  }
  send(message) {
    if (this._closed)
      throw new Error("Pipe has been closed");
    const data = Buffer.from(message, "utf-8");
    const dataLength = Buffer.alloc(4);
    if (this._endian === "be")
      dataLength.writeUInt32BE(data.length, 0);
    else
      dataLength.writeUInt32LE(data.length, 0);
    this._pipeWrite.write(dataLength);
    this._pipeWrite.write(data);
  }
  close() {
    this._closeableStream.close();
  }
  _dispatch(buffer2) {
    this._data = Buffer.concat([this._data, buffer2]);
    while (true) {
      if (!this._bytesLeft && this._data.length < 4) {
        break;
      }
      if (!this._bytesLeft) {
        this._bytesLeft = this._endian === "be" ? this._data.readUInt32BE(0) : this._data.readUInt32LE(0);
        this._data = this._data.slice(4);
      }
      if (!this._bytesLeft || this._data.length < this._bytesLeft) {
        break;
      }
      const message = this._data.slice(0, this._bytesLeft);
      this._data = this._data.slice(this._bytesLeft);
      this._bytesLeft = 0;
      this._waitForNextTask(() => {
        if (this.onmessage)
          this.onmessage(message.toString("utf-8"));
      });
    }
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/chromiumSwitches.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var disabledFeatures = [
  // See https://github.com/microsoft/playwright/pull/10380
  "AcceptCHFrame",
  // See https://github.com/microsoft/playwright/pull/10679
  "AutoExpandDetailsElement",
  // See https://github.com/microsoft/playwright/issues/14047
  "AvoidUnnecessaryBeforeUnloadCheckSync",
  // See https://github.com/microsoft/playwright/pull/12992
  "CertificateTransparencyComponentUpdater",
  "DestroyProfileOnBrowserClose",
  // See https://github.com/microsoft/playwright/pull/13854
  "DialMediaRouteProvider",
  // Chromium is disabling manifest version 2. Allow testing it as long as Chromium can actually run it.
  // Disabled in https://chromium-review.googlesource.com/c/chromium/src/+/6265903.
  "ExtensionManifestV2Disabled",
  "GlobalMediaControls",
  // See https://github.com/microsoft/playwright/pull/27605
  "HttpsUpgrades",
  "ImprovedCookieControls",
  "LazyFrameLoading",
  // Hides the Lens feature in the URL address bar. Its not working in unofficial builds.
  "LensOverlay",
  // See https://github.com/microsoft/playwright/pull/8162
  "MediaRouter",
  // See https://github.com/microsoft/playwright/issues/28023
  "PaintHolding",
  // See https://github.com/microsoft/playwright/issues/32230
  "ThirdPartyStoragePartitioning",
  // See https://github.com/microsoft/playwright/issues/16126
  "Translate"
];
var chromiumSwitches = [
  "--disable-field-trial-config",
  // https://source.chromium.org/chromium/chromium/src/+/main:testing/variations/README.md
  "--disable-background-networking",
  "--disable-background-timer-throttling",
  "--disable-backgrounding-occluded-windows",
  "--disable-back-forward-cache",
  // Avoids surprises like main request not being intercepted during page.goBack().
  "--disable-breakpad",
  "--disable-client-side-phishing-detection",
  "--disable-component-extensions-with-background-pages",
  "--disable-component-update",
  // Avoids unneeded network activity after startup.
  "--no-default-browser-check",
  "--disable-default-apps",
  "--disable-dev-shm-usage",
  "--disable-extensions",
  "--disable-features=" + disabledFeatures.join(","),
  "--allow-pre-commit-input",
  "--disable-hang-monitor",
  "--disable-ipc-flooding-protection",
  "--disable-popup-blocking",
  "--disable-prompt-on-repost",
  "--disable-renderer-backgrounding",
  "--force-color-profile=srgb",
  "--metrics-recording-only",
  "--no-first-run",
  "--enable-automation",
  "--password-store=basic",
  "--use-mock-keychain",
  // See https://chromium-review.googlesource.com/c/chromium/src/+/2436773
  "--no-service-autorun",
  "--export-tagged-pdf",
  // https://chromium-review.googlesource.com/c/chromium/src/+/4853540
  "--disable-search-engine-choice-screen",
  // https://issues.chromium.org/41491762
  "--unsafely-disable-devtools-self-xss-warnings"
];

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/android/android.js
var ARTIFACTS_FOLDER = path20.join(os_default.tmpdir(), "playwright-artifacts-");
var Android = class extends SdkObject {
  static {
    __name(this, "Android");
  }
  constructor(parent, backend) {
    super(parent, "android");
    this._devices = /* @__PURE__ */ new Map();
    this._backend = backend;
    this._timeoutSettings = new TimeoutSettings();
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }
  async devices(options2) {
    const devices2 = (await this._backend.devices(options2)).filter((d) => d.status === "device");
    const newSerials = /* @__PURE__ */ new Set();
    for (const d of devices2) {
      newSerials.add(d.serial);
      if (this._devices.has(d.serial))
        continue;
      const device = await AndroidDevice.create(this, d, options2);
      this._devices.set(d.serial, device);
    }
    for (const d of this._devices.keys()) {
      if (!newSerials.has(d))
        this._devices.delete(d);
    }
    return [...this._devices.values()];
  }
  _deviceClosed(device) {
    this._devices.delete(device.serial);
  }
};
var AndroidDevice = class _AndroidDevice extends SdkObject {
  static {
    __name(this, "AndroidDevice");
  }
  constructor(android, backend, model, options2) {
    super(android, "android-device");
    this._lastId = 0;
    this._callbacks = /* @__PURE__ */ new Map();
    this._webViews = /* @__PURE__ */ new Map();
    this._browserConnections = /* @__PURE__ */ new Set();
    this._isClosed = false;
    this._android = android;
    this._backend = backend;
    this.model = model;
    this.serial = backend.serial;
    this._options = options2;
    this._timeoutSettings = new TimeoutSettings(android._timeoutSettings);
  }
  static {
    this.Events = {
      WebViewAdded: "webViewAdded",
      WebViewRemoved: "webViewRemoved",
      Close: "close"
    };
  }
  static async create(android, backend, options2) {
    await backend.init();
    const model = await backend.runCommand("shell:getprop ro.product.model");
    const device = new _AndroidDevice(android, backend, model.toString().trim(), options2);
    await device._init();
    return device;
  }
  async _init() {
    await this._refreshWebViews();
    const poll = /* @__PURE__ */ __name(() => {
      this._pollingWebViews = setTimeout(() => this._refreshWebViews().then(poll).catch(() => {
        this.close().catch(() => {
        });
      }), 500);
    }, "poll");
    poll();
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }
  async shell(command2) {
    const result = await this._backend.runCommand(`shell:${command2}`);
    await this._refreshWebViews();
    return result;
  }
  async open(command2) {
    return await this._backend.open(`${command2}`);
  }
  async screenshot() {
    return await this._backend.runCommand(`shell:screencap -p`);
  }
  async _driver() {
    if (this._isClosed)
      return;
    if (!this._driverPromise)
      this._driverPromise = this._installDriver();
    return this._driverPromise;
  }
  async _installDriver() {
    debug5("pw:android")("Stopping the old driver");
    await this.shell(`am force-stop com.microsoft.playwright.androiddriver`);
    if (!this._options.omitDriverInstall) {
      debug5("pw:android")("Uninstalling the old driver");
      await this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver`);
      await this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver.test`);
      debug5("pw:android")("Installing the new driver");
      const executable = registry.findExecutable("android");
      const packageManagerCommand = getPackageManagerExecCommand();
      for (const file of ["android-driver.apk", "android-driver-target.apk"]) {
        const fullName = path20.join(executable.directory, file);
        if (!fs.existsSync(fullName))
          throw new Error(`Please install Android driver apk using '${packageManagerCommand} playwright install android'`);
        await this.installApk(await fs.promises.readFile(fullName));
      }
    } else {
      debug5("pw:android")("Skipping the driver installation");
    }
    debug5("pw:android")("Starting the new driver");
    this.shell("am instrument -w com.microsoft.playwright.androiddriver.test/androidx.test.runner.AndroidJUnitRunner").catch((e) => debug5("pw:android")(e));
    const socket = await this._waitForLocalAbstract("playwright_android_driver_socket");
    const transport = new PipeTransport(socket, socket, socket, "be");
    transport.onmessage = (message) => {
      const response = JSON.parse(message);
      const { id, result, error: error4 } = response;
      const callback = this._callbacks.get(id);
      if (!callback)
        return;
      if (error4)
        callback.reject(new Error(error4));
      else
        callback.fulfill(result);
      this._callbacks.delete(id);
    };
    return transport;
  }
  async _waitForLocalAbstract(socketName) {
    let socket;
    debug5("pw:android")(`Polling the socket localabstract:${socketName}`);
    while (!socket) {
      try {
        socket = await this._backend.open(`localabstract:${socketName}`);
      } catch (e) {
        await new Promise((f) => setTimeout(f, 250));
      }
    }
    debug5("pw:android")(`Connected to localabstract:${socketName}`);
    return socket;
  }
  async send(method, params = {}) {
    params.timeout = this._timeoutSettings.timeout(params);
    const driver = await this._driver();
    if (!driver)
      throw new Error("Device is closed");
    const id = ++this._lastId;
    const result = new Promise((fulfill, reject) => this._callbacks.set(id, { fulfill, reject }));
    driver.send(JSON.stringify({ id, method, params }));
    return result;
  }
  async close() {
    if (this._isClosed)
      return;
    this._isClosed = true;
    if (this._pollingWebViews)
      clearTimeout(this._pollingWebViews);
    for (const connection of this._browserConnections)
      await connection.close();
    if (this._driverPromise) {
      const driver = await this._driver();
      driver?.close();
    }
    await this._backend.close();
    this._android._deviceClosed(this);
    this.emit(_AndroidDevice.Events.Close);
  }
  async launchBrowser(pkg = "com.android.chrome", options2) {
    debug5("pw:android")("Force-stopping", pkg);
    await this._backend.runCommand(`shell:am force-stop ${pkg}`);
    const socketName = isUnderTest() ? "webview_devtools_remote_playwright_test" : "playwright_" + createGuid() + "_devtools_remote";
    const commandLine = this._defaultArgs(options2, socketName).join(" ");
    debug5("pw:android")("Starting", pkg, commandLine);
    await this._backend.runCommand(`shell:echo "${Buffer.from(commandLine).toString("base64")}" | base64 -d > /data/local/tmp/chrome-command-line`);
    await this._backend.runCommand(`shell:am start -a android.intent.action.VIEW -d about:blank ${pkg}`);
    const browserContext = await this._connectToBrowser(socketName, options2);
    await this._backend.runCommand(`shell:rm /data/local/tmp/chrome-command-line`);
    return browserContext;
  }
  _defaultArgs(options2, socketName) {
    const chromeArguments = [
      "_",
      "--disable-fre",
      "--no-default-browser-check",
      `--remote-debugging-socket-name=${socketName}`,
      ...chromiumSwitches,
      ...this._innerDefaultArgs(options2)
    ];
    return chromeArguments;
  }
  _innerDefaultArgs(options2) {
    const { args = [], proxy } = options2;
    const chromeArguments = [];
    if (proxy) {
      chromeArguments.push(`--proxy-server=${proxy.server}`);
      const proxyBypassRules = [];
      if (proxy.bypass)
        proxyBypassRules.push(...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t));
      if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes("<-loopback>"))
        proxyBypassRules.push("<-loopback>");
      if (proxyBypassRules.length > 0)
        chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
    }
    chromeArguments.push(...args);
    return chromeArguments;
  }
  async connectToWebView(socketName) {
    const webView = this._webViews.get(socketName);
    if (!webView)
      throw new Error("WebView has been closed");
    return await this._connectToBrowser(socketName);
  }
  async _connectToBrowser(socketName, options2 = {}) {
    const socket = await this._waitForLocalAbstract(socketName);
    const androidBrowser = new AndroidBrowser(this, socket);
    await androidBrowser._init();
    this._browserConnections.add(androidBrowser);
    const artifactsDir = await fs.promises.mkdtemp(ARTIFACTS_FOLDER);
    const cleanupArtifactsDir = /* @__PURE__ */ __name(async () => {
      const errors3 = (await removeFolders([artifactsDir])).filter(Boolean);
      for (let i = 0; i < (errors3 || []).length; ++i)
        debug5("pw:android")(`exception while removing ${artifactsDir}: ${errors3[i]}`);
    }, "cleanupArtifactsDir");
    gracefullyCloseSet.add(cleanupArtifactsDir);
    socket.on("close", async () => {
      gracefullyCloseSet.delete(cleanupArtifactsDir);
      cleanupArtifactsDir().catch((e) => debug5("pw:android")(`could not cleanup artifacts dir: ${e}`));
    });
    const browserOptions = {
      name: "clank",
      isChromium: true,
      slowMo: 0,
      persistent: { ...options2, noDefaultViewport: true },
      artifactsDir,
      downloadsPath: artifactsDir,
      tracesDir: artifactsDir,
      browserProcess: new ClankBrowserProcess(androidBrowser),
      proxy: options2.proxy,
      protocolLogger: helper.debugProtocolLogger(),
      browserLogsCollector: new RecentLogsCollector(),
      originalLaunchOptions: {}
    };
    validateBrowserContextOptions(options2, browserOptions);
    const browser3 = await CRBrowser.connect(this.attribution.playwright, androidBrowser, browserOptions);
    const controller = new ProgressController(serverSideCallMetadata(), this);
    const defaultContext = browser3._defaultContext;
    await controller.run(async (progress3) => {
      await defaultContext._loadDefaultContextAsIs(progress3);
    });
    return defaultContext;
  }
  webViews() {
    return [...this._webViews.values()];
  }
  async installApk(content, options2) {
    const args = options2 && options2.args ? options2.args : ["-r", "-t", "-S"];
    debug5("pw:android")("Opening install socket");
    const installSocket = await this._backend.open(`shell:cmd package install ${args.join(" ")} ${content.length}`);
    debug5("pw:android")("Writing driver bytes: " + content.length);
    await installSocket.write(content);
    const success = await new Promise((f) => installSocket.on("data", f));
    debug5("pw:android")("Written driver bytes: " + success);
    installSocket.close();
  }
  async push(content, path210, mode = 420) {
    const socket = await this._backend.open(`sync:`);
    const sendHeader = /* @__PURE__ */ __name(async (command2, length) => {
      const buffer2 = Buffer.alloc(command2.length + 4);
      buffer2.write(command2, 0);
      buffer2.writeUInt32LE(length, command2.length);
      await socket.write(buffer2);
    }, "sendHeader");
    const send2 = /* @__PURE__ */ __name(async (command2, data) => {
      await sendHeader(command2, data.length);
      await socket.write(data);
    }, "send");
    await send2("SEND", Buffer.from(`${path210},${mode}`));
    const maxChunk = 65535;
    for (let i = 0; i < content.length; i += maxChunk)
      await send2("DATA", content.slice(i, i + maxChunk));
    await sendHeader("DONE", Date.now() / 1e3 | 0);
    const result = await new Promise((f) => socket.once("data", f));
    const code = result.slice(0, 4).toString();
    if (code !== "OKAY")
      throw new Error("Could not push: " + code);
    socket.close();
  }
  async _refreshWebViews() {
    const sockets = (await this._backend.runCommand(`shell:cat /proc/net/unix | grep webview_devtools_remote`)).toString().split("\n");
    if (this._isClosed)
      return;
    const socketNames = /* @__PURE__ */ new Set();
    for (const line of sockets) {
      const matchSocketName = line.match(/[^@]+@(.*?webview_devtools_remote_?.*)/);
      if (!matchSocketName)
        continue;
      const socketName = matchSocketName[1];
      socketNames.add(socketName);
      if (this._webViews.has(socketName))
        continue;
      const match = line.match(/[^@]+@.*?webview_devtools_remote_?(\d*)/);
      let pid2 = -1;
      if (match && match[1])
        pid2 = +match[1];
      const pkg = await this._extractPkg(pid2);
      if (this._isClosed)
        return;
      const webView = { pid: pid2, pkg, socketName };
      this._webViews.set(socketName, webView);
      this.emit(_AndroidDevice.Events.WebViewAdded, webView);
    }
    for (const p of this._webViews.keys()) {
      if (!socketNames.has(p)) {
        this._webViews.delete(p);
        this.emit(_AndroidDevice.Events.WebViewRemoved, p);
      }
    }
  }
  async _extractPkg(pid2) {
    let pkg = "";
    if (pid2 === -1)
      return pkg;
    const procs = (await this._backend.runCommand(`shell:ps -A | grep ${pid2}`)).toString().split("\n");
    for (const proc of procs) {
      const match = proc.match(/[^\s]+\s+(\d+).*$/);
      if (!match)
        continue;
      pkg = proc.substring(proc.lastIndexOf(" ") + 1);
    }
    return pkg;
  }
};
var AndroidBrowser = class extends EventEmitter13 {
  static {
    __name(this, "AndroidBrowser");
  }
  constructor(device, socket) {
    super();
    this._waitForNextTask = makeWaitForNextTask();
    this.setMaxListeners(0);
    this.device = device;
    this._socket = socket;
    this._socket.on("close", () => {
      this._waitForNextTask(() => {
        if (this.onclose)
          this.onclose();
      });
    });
    this._receiver = new wsReceiver2();
    this._receiver.on("message", (message) => {
      this._waitForNextTask(() => {
        if (this.onmessage)
          this.onmessage(JSON.parse(message));
      });
    });
  }
  async _init() {
    await this._socket.write(Buffer.from(`GET /devtools/browser HTTP/1.1\r
Upgrade: WebSocket\r
Connection: Upgrade\r
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r
Sec-WebSocket-Version: 13\r
\r
`));
    await new Promise((f) => this._socket.once("data", f));
    this._socket.on("data", (data) => this._receiver._write(data, "binary", () => {
    }));
  }
  async send(s) {
    await this._socket.write(encodeWebFrame(JSON.stringify(s)));
  }
  async close() {
    this._socket.close();
  }
};
function encodeWebFrame(data) {
  return wsSender2.frame(Buffer.from(data), {
    opcode: 1,
    mask: true,
    fin: true,
    readOnly: true
  })[0];
}
__name(encodeWebFrame, "encodeWebFrame");
var ClankBrowserProcess = class {
  static {
    __name(this, "ClankBrowserProcess");
  }
  constructor(browser3) {
    this._browser = browser3;
  }
  async kill() {
  }
  async close() {
    await this._browser.close();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/androidDispatcher.js
var AndroidDispatcher = class extends Dispatcher {
  static {
    __name(this, "AndroidDispatcher");
  }
  constructor(scope, android) {
    super(scope, android, "Android", {});
    this._type_Android = true;
  }
  async devices(params) {
    const devices2 = await this._object.devices(params);
    return {
      devices: devices2.map((d) => AndroidDeviceDispatcher.from(this, d))
    };
  }
  async setDefaultTimeoutNoReply(params) {
    this._object.setDefaultTimeout(params.timeout);
  }
};
var AndroidDeviceDispatcher = class _AndroidDeviceDispatcher extends Dispatcher {
  static {
    __name(this, "AndroidDeviceDispatcher");
  }
  constructor(scope, device) {
    super(scope, device, "AndroidDevice", {
      model: device.model,
      serial: device.serial
    });
    this._type_EventTarget = true;
    this._type_AndroidDevice = true;
    for (const webView of device.webViews())
      this._dispatchEvent("webViewAdded", { webView });
    this.addObjectListener(AndroidDevice.Events.WebViewAdded, (webView) => this._dispatchEvent("webViewAdded", { webView }));
    this.addObjectListener(AndroidDevice.Events.WebViewRemoved, (socketName) => this._dispatchEvent("webViewRemoved", { socketName }));
    this.addObjectListener(AndroidDevice.Events.Close, (socketName) => this._dispatchEvent("close"));
  }
  static from(scope, device) {
    const result = existingDispatcher(device);
    return result || new _AndroidDeviceDispatcher(scope, device);
  }
  async wait(params) {
    await this._object.send("wait", params);
  }
  async fill(params) {
    await this._object.send("click", { selector: params.selector });
    await this._object.send("fill", params);
  }
  async tap(params) {
    await this._object.send("click", params);
  }
  async drag(params) {
    await this._object.send("drag", params);
  }
  async fling(params) {
    await this._object.send("fling", params);
  }
  async longTap(params) {
    await this._object.send("longClick", params);
  }
  async pinchClose(params) {
    await this._object.send("pinchClose", params);
  }
  async pinchOpen(params) {
    await this._object.send("pinchOpen", params);
  }
  async scroll(params) {
    await this._object.send("scroll", params);
  }
  async swipe(params) {
    await this._object.send("swipe", params);
  }
  async info(params) {
    const info3 = await this._object.send("info", params);
    fixupAndroidElementInfo(info3);
    return { info: info3 };
  }
  async inputType(params) {
    const text = params.text;
    const keyCodes = [];
    for (let i = 0; i < text.length; ++i) {
      const code = keyMap.get(text[i].toUpperCase());
      if (code === void 0)
        throw new Error("No mapping for " + text[i] + " found");
      keyCodes.push(code);
    }
    await Promise.all(keyCodes.map((keyCode) => this._object.send("inputPress", { keyCode })));
  }
  async inputPress(params) {
    if (!keyMap.has(params.key))
      throw new Error("Unknown key: " + params.key);
    await this._object.send("inputPress", { keyCode: keyMap.get(params.key) });
  }
  async inputTap(params) {
    await this._object.send("inputClick", params);
  }
  async inputSwipe(params) {
    await this._object.send("inputSwipe", params);
  }
  async inputDrag(params) {
    await this._object.send("inputDrag", params);
  }
  async screenshot(params) {
    return { binary: await this._object.screenshot() };
  }
  async shell(params) {
    return { result: await this._object.shell(params.command) };
  }
  async open(params, metadata) {
    const socket = await this._object.open(params.command);
    return { socket: new AndroidSocketDispatcher(this, socket) };
  }
  async installApk(params) {
    await this._object.installApk(params.file, { args: params.args });
  }
  async push(params) {
    await this._object.push(params.file, params.path, params.mode);
  }
  async launchBrowser(params) {
    const context2 = await this._object.launchBrowser(params.pkg, params);
    return { context: new BrowserContextDispatcher(this, context2) };
  }
  async close(params) {
    await this._object.close();
  }
  async setDefaultTimeoutNoReply(params) {
    this._object.setDefaultTimeout(params.timeout);
  }
  async connectToWebView(params) {
    return { context: new BrowserContextDispatcher(this, await this._object.connectToWebView(params.socketName)) };
  }
};
var AndroidSocketDispatcher = class extends Dispatcher {
  static {
    __name(this, "AndroidSocketDispatcher");
  }
  constructor(scope, socket) {
    super(scope, socket, "AndroidSocket", {});
    this._type_AndroidSocket = true;
    this.addObjectListener("data", (data) => this._dispatchEvent("data", { data }));
    this.addObjectListener("close", () => {
      this._dispatchEvent("close");
      this._dispose();
    });
  }
  async write(params, metadata) {
    await this._object.write(params.data);
  }
  async close(params, metadata) {
    this._object.close();
  }
};
var keyMap = /* @__PURE__ */ new Map([
  ["Unknown", 0],
  ["SoftLeft", 1],
  ["SoftRight", 2],
  ["Home", 3],
  ["Back", 4],
  ["Call", 5],
  ["EndCall", 6],
  ["0", 7],
  ["1", 8],
  ["2", 9],
  ["3", 10],
  ["4", 11],
  ["5", 12],
  ["6", 13],
  ["7", 14],
  ["8", 15],
  ["9", 16],
  ["Star", 17],
  ["*", 17],
  ["Pound", 18],
  ["#", 18],
  ["DialUp", 19],
  ["DialDown", 20],
  ["DialLeft", 21],
  ["DialRight", 22],
  ["DialCenter", 23],
  ["VolumeUp", 24],
  ["VolumeDown", 25],
  ["Power", 26],
  ["Camera", 27],
  ["Clear", 28],
  ["A", 29],
  ["B", 30],
  ["C", 31],
  ["D", 32],
  ["E", 33],
  ["F", 34],
  ["G", 35],
  ["H", 36],
  ["I", 37],
  ["J", 38],
  ["K", 39],
  ["L", 40],
  ["M", 41],
  ["N", 42],
  ["O", 43],
  ["P", 44],
  ["Q", 45],
  ["R", 46],
  ["S", 47],
  ["T", 48],
  ["U", 49],
  ["V", 50],
  ["W", 51],
  ["X", 52],
  ["Y", 53],
  ["Z", 54],
  ["Comma", 55],
  [",", 55],
  ["Period", 56],
  [".", 56],
  ["AltLeft", 57],
  ["AltRight", 58],
  ["ShiftLeft", 59],
  ["ShiftRight", 60],
  ["Tab", 61],
  ["	", 61],
  ["Space", 62],
  [" ", 62],
  ["Sym", 63],
  ["Explorer", 64],
  ["Envelop", 65],
  ["Enter", 66],
  ["Del", 67],
  ["Grave", 68],
  ["Minus", 69],
  ["-", 69],
  ["Equals", 70],
  ["=", 70],
  ["LeftBracket", 71],
  ["(", 71],
  ["RightBracket", 72],
  [")", 72],
  ["Backslash", 73],
  ["\\", 73],
  ["Semicolon", 74],
  [";", 74],
  ["Apostrophe", 75],
  ["`", 75],
  ["Slash", 76],
  ["/", 76],
  ["At", 77],
  ["@", 77],
  ["Num", 78],
  ["HeadsetHook", 79],
  ["Focus", 80],
  ["Plus", 81],
  ["Menu", 82],
  ["Notification", 83],
  ["Search", 84],
  ["ChannelUp", 166],
  ["ChannelDown", 167],
  ["AppSwitch", 187],
  ["Assist", 219],
  ["Cut", 277],
  ["Copy", 278],
  ["Paste", 279]
]);
function fixupAndroidElementInfo(info3) {
  info3.clazz = info3.clazz || "";
  info3.pkg = info3.pkg || "";
  info3.res = info3.res || "";
  info3.desc = info3.desc || "";
  info3.text = info3.text || "";
  for (const child of info3.children || [])
    fixupAndroidElementInfo(child);
}
__name(fixupAndroidElementInfo, "fixupAndroidElementInfo");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/browserDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/selectors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Selectors = class {
  static {
    __name(this, "Selectors");
  }
  constructor() {
    this.guid = `selectors@${createGuid()}`;
    this._testIdAttributeName = "data-testid";
    this._builtinEngines = /* @__PURE__ */ new Set([
      "css",
      "css:light",
      "xpath",
      "xpath:light",
      "_react",
      "_vue",
      "text",
      "text:light",
      "id",
      "id:light",
      "data-testid",
      "data-testid:light",
      "data-test-id",
      "data-test-id:light",
      "data-test",
      "data-test:light",
      "nth",
      "visible",
      "internal:control",
      "internal:has",
      "internal:has-not",
      "internal:has-text",
      "internal:has-not-text",
      "internal:and",
      "internal:or",
      "internal:chain",
      "role",
      "internal:attr",
      "internal:label",
      "internal:text",
      "internal:role",
      "internal:testid",
      "aria-ref"
    ]);
    this._builtinEnginesInMainWorld = /* @__PURE__ */ new Set([
      "_react",
      "_vue"
    ]);
    this._engines = /* @__PURE__ */ new Map();
  }
  async register(name, source7, contentScript = false) {
    if (!name.match(/^[a-zA-Z_0-9-]+$/))
      throw new Error("Selector engine name may only contain [a-zA-Z0-9_] characters");
    if (this._builtinEngines.has(name) || name === "zs" || name === "zs:light")
      throw new Error(`"${name}" is a predefined selector engine`);
    if (this._engines.has(name))
      throw new Error(`"${name}" selector engine has been already registered`);
    this._engines.set(name, { source: source7, contentScript });
  }
  testIdAttributeName() {
    return this._testIdAttributeName;
  }
  setTestIdAttributeName(testIdAttributeName2) {
    this._testIdAttributeName = testIdAttributeName2;
  }
  unregisterAll() {
    this._engines.clear();
  }
  parseSelector(selector, strict) {
    const parsed = typeof selector === "string" ? parseSelector(selector) : selector;
    let needsMainWorld = false;
    visitAllSelectorParts(parsed, (part) => {
      const name = part.name;
      const custom = this._engines.get(name);
      if (!custom && !this._builtinEngines.has(name))
        throw new InvalidSelectorError(`Unknown engine "${name}" while parsing selector ${stringifySelector(parsed)}`);
      if (custom && !custom.contentScript)
        needsMainWorld = true;
      if (this._builtinEnginesInMainWorld.has(name))
        needsMainWorld = true;
    });
    return {
      parsed,
      world: needsMainWorld ? "main" : "utility",
      strict
    };
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/browserDispatcher.js
var BrowserDispatcher = class extends Dispatcher {
  static {
    __name(this, "BrowserDispatcher");
  }
  constructor(scope, browser3) {
    super(scope, browser3, "Browser", { version: browser3.version(), name: browser3.options.name });
    this._type_Browser = true;
    this.addObjectListener(Browser.Events.Disconnected, () => this._didClose());
  }
  _didClose() {
    this._dispatchEvent("close");
    this._dispose();
  }
  async newContext(params, metadata) {
    const context2 = await this._object.newContext(metadata, params);
    return { context: new BrowserContextDispatcher(this, context2) };
  }
  async newContextForReuse(params, metadata) {
    return await newContextForReuse(this._object, this, params, null, metadata);
  }
  async stopPendingOperations(params, metadata) {
    await this._object.stopPendingOperations(params.reason);
  }
  async close(params, metadata) {
    metadata.potentiallyClosesScope = true;
    await this._object.close(params);
  }
  async killForTests(_, metadata) {
    metadata.potentiallyClosesScope = true;
    await this._object.killForTests();
  }
  async defaultUserAgentForTest() {
    return { userAgent: this._object.userAgent() };
  }
  async newBrowserCDPSession() {
    if (!this._object.options.isChromium)
      throw new Error(`CDP session is only available in Chromium`);
    const crBrowser = this._object;
    return { session: new CDPSessionDispatcher(this, await crBrowser.newBrowserCDPSession()) };
  }
  async startTracing(params) {
    if (!this._object.options.isChromium)
      throw new Error(`Tracing is only available in Chromium`);
    const crBrowser = this._object;
    await crBrowser.startTracing(params.page ? params.page._object : void 0, params);
  }
  async stopTracing() {
    if (!this._object.options.isChromium)
      throw new Error(`Tracing is only available in Chromium`);
    const crBrowser = this._object;
    return { artifact: ArtifactDispatcher.from(this, await crBrowser.stopTracing()) };
  }
};
var ConnectedBrowserDispatcher = class extends Dispatcher {
  static {
    __name(this, "ConnectedBrowserDispatcher");
  }
  constructor(scope, browser3) {
    super(scope, browser3, "Browser", { version: browser3.version(), name: browser3.options.name });
    this._type_Browser = true;
    this._contexts = /* @__PURE__ */ new Set();
    this.selectors = new Selectors();
  }
  async newContext(params, metadata) {
    if (params.recordVideo)
      params.recordVideo.dir = this._object.options.artifactsDir;
    const context2 = await this._object.newContext(metadata, params);
    this._contexts.add(context2);
    context2.setSelectors(this.selectors);
    context2.on(BrowserContext.Events.Close, () => this._contexts.delete(context2));
    return { context: new BrowserContextDispatcher(this, context2) };
  }
  async newContextForReuse(params, metadata) {
    return await newContextForReuse(this._object, this, params, this.selectors, metadata);
  }
  async stopPendingOperations(params, metadata) {
    await this._object.stopPendingOperations(params.reason);
  }
  async close() {
  }
  async killForTests() {
  }
  async defaultUserAgentForTest() {
    throw new Error("Client should not send us Browser.defaultUserAgentForTest");
  }
  async newBrowserCDPSession() {
    if (!this._object.options.isChromium)
      throw new Error(`CDP session is only available in Chromium`);
    const crBrowser = this._object;
    return { session: new CDPSessionDispatcher(this, await crBrowser.newBrowserCDPSession()) };
  }
  async startTracing(params) {
    if (!this._object.options.isChromium)
      throw new Error(`Tracing is only available in Chromium`);
    const crBrowser = this._object;
    await crBrowser.startTracing(params.page ? params.page._object : void 0, params);
  }
  async stopTracing() {
    if (!this._object.options.isChromium)
      throw new Error(`Tracing is only available in Chromium`);
    const crBrowser = this._object;
    return { artifact: ArtifactDispatcher.from(this, await crBrowser.stopTracing()) };
  }
  async cleanupContexts() {
    await Promise.all(Array.from(this._contexts).map((context2) => context2.close({ reason: "Global context cleanup (connection terminated)" })));
  }
};
async function newContextForReuse(browser3, scope, params, selectors2, metadata) {
  const { context: context2, needsReset } = await browser3.newContextForReuse(params, metadata);
  if (needsReset) {
    const oldContextDispatcher = existingDispatcher(context2);
    if (oldContextDispatcher)
      oldContextDispatcher._dispose();
    await context2.resetForReuse(metadata, params);
  }
  if (selectors2)
    context2.setSelectors(selectors2);
  const contextDispatcher = new BrowserContextDispatcher(scope, context2);
  return { context: contextDispatcher };
}
__name(newContextForReuse, "newContextForReuse");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/browserTypeDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BrowserTypeDispatcher = class extends Dispatcher {
  static {
    __name(this, "BrowserTypeDispatcher");
  }
  constructor(scope, browserType) {
    super(scope, browserType, "BrowserType", {
      executablePath: browserType.executablePath(),
      name: browserType.name()
    });
    this._type_BrowserType = true;
  }
  async launch(params, metadata) {
    const browser3 = await this._object.launch(metadata, params);
    return { browser: new BrowserDispatcher(this, browser3) };
  }
  async launchPersistentContext(params, metadata) {
    const browserContext = await this._object.launchPersistentContext(metadata, params.userDataDir, params);
    return { context: new BrowserContextDispatcher(this, browserContext) };
  }
  async connectOverCDP(params, metadata) {
    const browser3 = await this._object.connectOverCDP(metadata, params.endpointURL, params);
    const browserDispatcher = new BrowserDispatcher(this, browser3);
    return {
      browser: browserDispatcher,
      defaultContext: browser3._defaultContext ? new BrowserContextDispatcher(browserDispatcher, browser3._defaultContext) : void 0
    };
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/electronDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/electron/electron.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path21 from "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/cloudflare/webSocketTransport.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/cloudflare/chunking.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HEADER_SIZE = 4;
var MAX_MESSAGE_SIZE = 1048575;
var FIRST_CHUNK_DATA_SIZE = MAX_MESSAGE_SIZE - HEADER_SIZE;
var messageToChunks = /* @__PURE__ */ __name((data) => {
  const encoder2 = new TextEncoder();
  const encodedUint8Array = encoder2.encode(data);
  const firstChunk = new Uint8Array(
    Math.min(MAX_MESSAGE_SIZE, HEADER_SIZE + encodedUint8Array.length)
  );
  const view = new DataView(firstChunk.buffer);
  view.setUint32(0, encodedUint8Array.length, true);
  firstChunk.set(
    encodedUint8Array.slice(0, FIRST_CHUNK_DATA_SIZE),
    HEADER_SIZE
  );
  const chunks = [firstChunk];
  for (let i = FIRST_CHUNK_DATA_SIZE; i < data.length; i += MAX_MESSAGE_SIZE)
    chunks.push(encodedUint8Array.slice(i, i + MAX_MESSAGE_SIZE));
  return chunks;
}, "messageToChunks");
var chunksToMessage = /* @__PURE__ */ __name((chunks, sessionid) => {
  if (chunks.length === 0)
    return null;
  const emptyBuffer = new Uint8Array(0);
  const firstChunk = chunks[0] || emptyBuffer;
  const view = new DataView(firstChunk.buffer);
  const expectedBytes = view.getUint32(0, true);
  let totalBytes = -4;
  for (let i = 0; i < chunks.length; ++i) {
    const curChunk = chunks[i] || emptyBuffer;
    totalBytes += curChunk.length;
    if (totalBytes > expectedBytes) {
      throw new Error(
        `Should have gotten the exact number of bytes but we got more.  SessionID: ${sessionid}`
      );
    }
    if (totalBytes === expectedBytes) {
      const chunksToCombine = chunks.splice(0, i + 1);
      chunksToCombine[0] = firstChunk.subarray(HEADER_SIZE);
      const combined = new Uint8Array(expectedBytes);
      let offset = 0;
      for (let j = 0; j <= i; ++j) {
        const chunk = chunksToCombine[j] || emptyBuffer;
        combined.set(chunk, offset);
        offset += chunk.length;
      }
      const decoder2 = new TextDecoder();
      const message = decoder2.decode(combined);
      return message;
    }
  }
  return null;
}, "chunksToMessage");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/cloudflare/webSocketTransport.js
var transportZone = new AsyncLocalStorage();
var WebSocketTransport = class {
  static {
    __name(this, "WebSocketTransport");
  }
  constructor(ws3, sessionId) {
    this._chunks = [];
    this._pingInterval = setInterval(() => {
      return this._ws.send("ping");
    }, 1e3);
    this._ws = ws3;
    this.sessionId = sessionId;
    this._ws.addEventListener("message", (event) => {
      this._chunks.push(new Uint8Array(event.data));
      const message = chunksToMessage(this._chunks, sessionId);
      if (message && this.onmessage)
        this.onmessage(JSON.parse(message));
    });
    this._ws.addEventListener("close", () => {
      clearInterval(this._pingInterval);
      if (this.onclose)
        this.onclose();
    });
    this._ws.addEventListener("error", (e) => {
      console.error(`Websocket error: SessionID: ${sessionId}`, e);
      clearInterval(this._pingInterval);
    });
  }
  static async connect() {
    const transport = transportZone.getStore();
    if (!transport)
      throw new Error("Transport is not available in the current zone");
    return transport;
  }
  send(message) {
    for (const chunk of messageToChunks(JSON.stringify(message)))
      this._ws.send(chunk);
  }
  close() {
    clearInterval(this._pingInterval);
    this._ws.close();
    this.onclose?.();
  }
  async closeAndWait() {
    if (this._ws.readyState === WebSocket.CLOSED)
      return;
    this.close();
  }
  toString() {
    return this.sessionId;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/electron/electron.js
var ARTIFACTS_FOLDER2 = path21.join(os_default.tmpdir(), "playwright-artifacts-");
var ElectronApplication = class _ElectronApplication extends SdkObject {
  static {
    __name(this, "ElectronApplication");
  }
  constructor(parent, browser3, nodeConnection, process2) {
    super(parent, "electron-app");
    this._nodeElectronHandlePromise = new ManualPromise();
    this._timeoutSettings = new TimeoutSettings();
    this._process = process2;
    this._browserContext = browser3._defaultContext;
    this._nodeConnection = nodeConnection;
    this._nodeSession = nodeConnection.rootSession;
    this._nodeSession.on("Runtime.executionContextCreated", async (event) => {
      if (!event.context.auxData || !event.context.auxData.isDefault)
        return;
      const crExecutionContext = new CRExecutionContext(this._nodeSession, event.context);
      this._nodeExecutionContext = new ExecutionContext(this, crExecutionContext, "electron");
      const { result: remoteObject } = await crExecutionContext._client.send("Runtime.evaluate", {
        expression: `require('electron')`,
        contextId: event.context.id,
        // Needed after Electron 28 to get access to require: https://github.com/microsoft/playwright/issues/28048
        includeCommandLineAPI: true
      });
      this._nodeElectronHandlePromise.resolve(new JSHandle(this._nodeExecutionContext, "object", "ElectronModule", remoteObject.objectId));
    });
    this._nodeSession.on("Runtime.consoleAPICalled", (event) => this._onConsoleAPI(event));
    const appClosePromise = new Promise((f) => this.once(_ElectronApplication.Events.Close, f));
    this._browserContext.setCustomCloseHandler(async () => {
      await this._browserContext.stopVideoRecording();
      const electronHandle = await this._nodeElectronHandlePromise;
      await electronHandle.evaluate(({ app }) => app.quit()).catch(() => {
      });
      this._nodeConnection.close();
      await appClosePromise;
    });
  }
  static {
    this.Events = {
      Close: "close",
      Console: "console"
    };
  }
  async _onConsoleAPI(event) {
    if (event.executionContextId === 0) {
      return;
    }
    if (!this._nodeExecutionContext)
      return;
    const args = event.args.map((arg) => createHandle(this._nodeExecutionContext, arg));
    const message = new ConsoleMessage(null, event.type, void 0, args, toConsoleMessageLocation(event.stackTrace));
    this.emit(_ElectronApplication.Events.Console, message);
  }
  async initialize() {
    await this._nodeSession.send("Runtime.enable", {});
    await this._nodeSession.send("Runtime.evaluate", { expression: "__playwright_run()" });
  }
  process() {
    return this._process;
  }
  context() {
    return this._browserContext;
  }
  async close() {
    await this._browserContext.close({ reason: "Application exited" });
  }
  async browserWindow(page) {
    const targetId = page._delegate._targetId;
    const electronHandle = await this._nodeElectronHandlePromise;
    return await electronHandle.evaluateHandle(({ BrowserWindow, webContents }, targetId2) => {
      const wc = webContents.fromDevToolsTargetId(targetId2);
      return BrowserWindow.fromWebContents(wc);
    }, targetId);
  }
};
var Electron = class extends SdkObject {
  static {
    __name(this, "Electron");
  }
  constructor(playwright2) {
    super(playwright2, "electron");
  }
  async launch(options2) {
    const {
      args = []
    } = options2;
    const controller = new ProgressController(serverSideCallMetadata(), this);
    controller.setLogName("browser");
    return controller.run(async (progress3) => {
      let app = void 0;
      let electronArguments = ["--inspect=0", "--remote-debugging-port=0", ...args];
      if (os_default.platform() === "linux") {
        const runningAsRoot = process.geteuid && process.geteuid() === 0;
        if (runningAsRoot && electronArguments.indexOf("--no-sandbox") === -1)
          electronArguments.unshift("--no-sandbox");
      }
      const artifactsDir = await fs.promises.mkdtemp(ARTIFACTS_FOLDER2);
      const browserLogsCollector = new RecentLogsCollector();
      const env3 = options2.env ? envArrayToObject(options2.env) : process.env;
      let command2;
      if (options2.executablePath) {
        command2 = options2.executablePath;
      } else {
        try {
          command2 = require$$06;
        } catch (error4) {
          if (error4?.code === "MODULE_NOT_FOUND") {
            throw new Error("\n" + wrapInASCIIBox([
              "Electron executablePath not found!",
              "Please install it using `npm install -D electron` or set the executablePath to your Electron executable."
            ].join("\n"), 1));
          }
          throw error4;
        }
        electronArguments.unshift("-r", __require.resolve("./loader"));
      }
      let shell = false;
      if (process.platform === "win32") {
        shell = true;
        command2 = `"${command2}"`;
        electronArguments = electronArguments.map((arg) => `"${arg}"`);
      }
      delete env3.NODE_OPTIONS;
      const { launchedProcess, gracefullyClose, kill: kill2 } = await launchProcess({
        command: command2,
        args: electronArguments,
        env: env3,
        log: /* @__PURE__ */ __name((message) => {
          progress3.log(message);
          browserLogsCollector.log(message);
        }, "log"),
        shell,
        stdio: "pipe",
        cwd: options2.cwd,
        tempDirectories: [artifactsDir],
        attemptToGracefullyClose: /* @__PURE__ */ __name(() => app.close(), "attemptToGracefullyClose"),
        handleSIGINT: true,
        handleSIGTERM: true,
        handleSIGHUP: true,
        onExit: /* @__PURE__ */ __name(() => app?.emit(ElectronApplication.Events.Close), "onExit")
      });
      const waitForXserverError = new Promise(async (resolve, reject) => {
        waitForLine(progress3, launchedProcess, /Unable to open X display/).then(() => reject(new Error([
          "Unable to open X display!",
          `================================`,
          "Most likely this is because there is no X server available.",
          "Use 'xvfb-run' on Linux to launch your tests with an emulated display server.",
          "For example: 'xvfb-run npm run test:e2e'",
          `================================`,
          progress3.metadata.log
        ].join("\n")))).catch(() => {
        });
      });
      const nodeMatchPromise = waitForLine(progress3, launchedProcess, /^Debugger listening on (ws:\/\/.*)$/);
      const chromeMatchPromise = waitForLine(progress3, launchedProcess, /^DevTools listening on (ws:\/\/.*)$/);
      const debuggerDisconnectPromise = waitForLine(progress3, launchedProcess, /Waiting for the debugger to disconnect\.\.\./);
      const nodeMatch = await nodeMatchPromise;
      const nodeTransport = await WebSocketTransport.connect(progress3, nodeMatch[1]);
      const nodeConnection = new CRConnection(nodeTransport, helper.debugProtocolLogger(), browserLogsCollector);
      debuggerDisconnectPromise.then(() => {
        nodeTransport.close();
      }).catch(() => {
      });
      const chromeMatch = await Promise.race([
        chromeMatchPromise,
        waitForXserverError
      ]);
      const chromeTransport = await WebSocketTransport.connect(progress3, chromeMatch[1]);
      const browserProcess = {
        onclose: void 0,
        process: launchedProcess,
        close: gracefullyClose,
        kill: kill2
      };
      const contextOptions = {
        ...options2,
        noDefaultViewport: true
      };
      const browserOptions = {
        name: "electron",
        isChromium: true,
        headful: true,
        persistent: contextOptions,
        browserProcess,
        protocolLogger: helper.debugProtocolLogger(),
        browserLogsCollector,
        artifactsDir,
        downloadsPath: artifactsDir,
        tracesDir: options2.tracesDir || artifactsDir,
        originalLaunchOptions: {}
      };
      validateBrowserContextOptions(contextOptions, browserOptions);
      const browser3 = await CRBrowser.connect(this.attribution.playwright, chromeTransport, browserOptions);
      app = new ElectronApplication(this, browser3, nodeConnection, launchedProcess);
      await app.initialize();
      return app;
    }, TimeoutSettings.launchTimeout(options2));
  }
};
function waitForLine(progress3, process2, regex) {
  return new Promise((resolve, reject) => {
    const rl = createInterface({ input: process2.stderr });
    const failError = new Error("Process failed to launch!");
    const listeners2 = [
      eventsHelper.addEventListener(rl, "line", onLine),
      eventsHelper.addEventListener(rl, "close", reject.bind(null, failError)),
      eventsHelper.addEventListener(process2, "exit", reject.bind(null, failError)),
      // It is Ok to remove error handler because we did not create process and there is another listener.
      eventsHelper.addEventListener(process2, "error", reject.bind(null, failError))
    ];
    progress3.cleanupWhenAborted(cleanup);
    function onLine(line) {
      const match = line.match(regex);
      if (!match)
        return;
      cleanup();
      resolve(match);
    }
    __name(onLine, "onLine");
    function cleanup() {
      eventsHelper.removeEventListeners(listeners2);
    }
    __name(cleanup, "cleanup");
  });
}
__name(waitForLine, "waitForLine");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/electronDispatcher.js
var ElectronDispatcher = class extends Dispatcher {
  static {
    __name(this, "ElectronDispatcher");
  }
  constructor(scope, electron) {
    super(scope, electron, "Electron", {});
    this._type_Electron = true;
  }
  async launch(params) {
    const electronApplication = await this._object.launch(params);
    return { electronApplication: new ElectronApplicationDispatcher(this, electronApplication) };
  }
};
var ElectronApplicationDispatcher = class extends Dispatcher {
  static {
    __name(this, "ElectronApplicationDispatcher");
  }
  constructor(scope, electronApplication) {
    super(scope, electronApplication, "ElectronApplication", {
      context: new BrowserContextDispatcher(scope, electronApplication.context())
    });
    this._type_EventTarget = true;
    this._type_ElectronApplication = true;
    this._subscriptions = /* @__PURE__ */ new Set();
    this.addObjectListener(ElectronApplication.Events.Close, () => {
      this._dispatchEvent("close");
      this._dispose();
    });
    this.addObjectListener(ElectronApplication.Events.Console, (message) => {
      if (!this._subscriptions.has("console"))
        return;
      this._dispatchEvent("console", {
        type: message.type(),
        text: message.text(),
        args: message.args().map((a) => ElementHandleDispatcher.fromJSHandle(this, a)),
        location: message.location()
      });
    });
  }
  async browserWindow(params) {
    const handle = await this._object.browserWindow(params.page.page());
    return { handle: ElementHandleDispatcher.fromJSHandle(this, handle) };
  }
  async evaluateExpression(params) {
    const handle = await this._object._nodeElectronHandlePromise;
    return { value: serializeResult(await handle.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg))) };
  }
  async evaluateExpressionHandle(params) {
    const handle = await this._object._nodeElectronHandlePromise;
    const result = await handle.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg));
    return { handle: ElementHandleDispatcher.fromJSHandle(this, result) };
  }
  async updateSubscription(params) {
    if (params.enabled)
      this._subscriptions.add(params.event);
    else
      this._subscriptions.delete(params.event);
  }
  async close() {
    await this._object.close();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/localUtilsDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/localUtils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path23 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/harBackend.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path22 from "node:path";
var redirectStatus2 = [301, 302, 303, 307, 308];
var HarBackend = class {
  static {
    __name(this, "HarBackend");
  }
  constructor(harFile, baseDir, zipFile) {
    this.id = createGuid();
    this._harFile = harFile;
    this._baseDir = baseDir;
    this._zipFile = zipFile;
  }
  async lookup(url4, method, headers, postData, isNavigationRequest) {
    let entry;
    try {
      entry = await this._harFindResponse(url4, method, headers, postData);
    } catch (e) {
      return { action: "error", message: "HAR error: " + e.message };
    }
    if (!entry)
      return { action: "noentry" };
    if (entry.request.url !== url4 && isNavigationRequest)
      return { action: "redirect", redirectURL: entry.request.url };
    const response = entry.response;
    try {
      const buffer2 = await this._loadContent(response.content);
      return {
        action: "fulfill",
        status: response.status,
        headers: response.headers,
        body: buffer2
      };
    } catch (e) {
      return { action: "error", message: e.message };
    }
  }
  async _loadContent(content) {
    const file = content._file;
    let buffer2;
    if (file) {
      if (this._zipFile)
        buffer2 = await this._zipFile.read(file);
      else
        buffer2 = await fs.promises.readFile(path22.resolve(this._baseDir, file));
    } else {
      buffer2 = Buffer.from(content.text || "", content.encoding === "base64" ? "base64" : "utf-8");
    }
    return buffer2;
  }
  async _harFindResponse(url4, method, headers, postData) {
    const harLog = this._harFile.log;
    const visited = /* @__PURE__ */ new Set();
    while (true) {
      const entries = [];
      for (const candidate of harLog.entries) {
        if (candidate.request.url !== url4 || candidate.request.method !== method)
          continue;
        if (method === "POST" && postData && candidate.request.postData) {
          const buffer2 = await this._loadContent(candidate.request.postData);
          if (!buffer2.equals(postData)) {
            const boundary = multipartBoundary(headers);
            if (!boundary)
              continue;
            const candidataBoundary = multipartBoundary(candidate.request.headers);
            if (!candidataBoundary)
              continue;
            if (postData.toString().replaceAll(boundary, "") !== buffer2.toString().replaceAll(candidataBoundary, ""))
              continue;
          }
        }
        entries.push(candidate);
      }
      if (!entries.length)
        return;
      let entry = entries[0];
      if (entries.length > 1) {
        const list = [];
        for (const candidate of entries) {
          const matchingHeaders = countMatchingHeaders(candidate.request.headers, headers);
          list.push({ candidate, matchingHeaders });
        }
        list.sort((a, b) => b.matchingHeaders - a.matchingHeaders);
        entry = list[0].candidate;
      }
      if (visited.has(entry))
        throw new Error(`Found redirect cycle for ${url4}`);
      visited.add(entry);
      const locationHeader = entry.response.headers.find((h) => h.name.toLowerCase() === "location");
      if (redirectStatus2.includes(entry.response.status) && locationHeader) {
        const locationURL = new URL(locationHeader.value, url4);
        url4 = locationURL.toString();
        if ((entry.response.status === 301 || entry.response.status === 302) && method === "POST" || entry.response.status === 303 && !["GET", "HEAD"].includes(method)) {
          method = "GET";
        }
        continue;
      }
      return entry;
    }
  }
  dispose() {
    this._zipFile?.close();
  }
};
function countMatchingHeaders(harHeaders, headers) {
  const set2 = new Set(headers.map((h) => h.name.toLowerCase() + ":" + h.value));
  let matches = 0;
  for (const h of harHeaders) {
    if (set2.has(h.name.toLowerCase() + ":" + h.value))
      ++matches;
  }
  return matches;
}
__name(countMatchingHeaders, "countMatchingHeaders");
function multipartBoundary(headers) {
  const contentType = headers.find((h) => h.name.toLowerCase() === "content-type");
  if (!contentType?.value.includes("multipart/form-data"))
    return void 0;
  const boundary = contentType.value.match(/boundary=(\S+)/);
  if (boundary)
    return boundary[1];
  return void 0;
}
__name(multipartBoundary, "multipartBoundary");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/zipFile.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ZipFile = class {
  static {
    __name(this, "ZipFile");
  }
  constructor(fileName) {
    this._entries = /* @__PURE__ */ new Map();
    this._fileName = fileName;
    this._openedPromise = this._open();
  }
  async _open() {
    await new Promise((fulfill, reject) => {
      yauzl2.open(this._fileName, { autoClose: false }, (e, z) => {
        if (e) {
          reject(e);
          return;
        }
        this._zipFile = z;
        this._zipFile.on("entry", (entry) => {
          this._entries.set(entry.fileName, entry);
        });
        this._zipFile.on("end", fulfill);
      });
    });
  }
  async entries() {
    await this._openedPromise;
    return [...this._entries.keys()];
  }
  async read(entryPath) {
    await this._openedPromise;
    const entry = this._entries.get(entryPath);
    if (!entry)
      throw new Error(`${entryPath} not found in file ${this._fileName}`);
    return new Promise((resolve, reject) => {
      this._zipFile.openReadStream(entry, (error4, readStream) => {
        if (error4 || !readStream) {
          reject(error4 || "Entry not found");
          return;
        }
        const buffers = [];
        readStream.on("data", (data) => buffers.push(data));
        readStream.on("end", () => resolve(Buffer.concat(buffers)));
      });
    });
  }
  close() {
    this._zipFile?.close();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/traceUtils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function serializeClientSideCallMetadata(metadatas) {
  const fileNames = new Map2();
  const stacks = [];
  for (const m of metadatas) {
    if (!m.stack || !m.stack.length)
      continue;
    const stack = [];
    for (const frame of m.stack) {
      let ordinal = fileNames.get(frame.file);
      if (typeof ordinal !== "number") {
        ordinal = fileNames.size;
        fileNames.set(frame.file, ordinal);
      }
      const stackFrame = [ordinal, frame.line || 0, frame.column || 0, frame.function || ""];
      stack.push(stackFrame);
    }
    stacks.push([m.id, stack]);
  }
  return { files: [...fileNames.keys()], stacks };
}
__name(serializeClientSideCallMetadata, "serializeClientSideCallMetadata");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/localUtils.js
async function zip(stackSessions, params) {
  const promise = new ManualPromise();
  const zipFile = new yazl2.ZipFile();
  zipFile.on("error", (error4) => promise.reject(error4));
  const addFile = /* @__PURE__ */ __name((file, name) => {
    try {
      if (fs.statSync(file).isFile())
        zipFile.addFile(file, name);
    } catch (e) {
    }
  }, "addFile");
  for (const entry of params.entries)
    addFile(entry.value, entry.name);
  const stackSession = params.stacksId ? stackSessions.get(params.stacksId) : void 0;
  if (stackSession?.callStacks.length) {
    await stackSession.writer;
    if (process.env.PW_LIVE_TRACE_STACKS) {
      zipFile.addFile(stackSession.file, "trace.stacks");
    } else {
      const buffer2 = Buffer.from(JSON.stringify(serializeClientSideCallMetadata(stackSession.callStacks)));
      zipFile.addBuffer(buffer2, "trace.stacks");
    }
  }
  if (params.includeSources) {
    const sourceFiles = /* @__PURE__ */ new Set();
    for (const { stack } of stackSession?.callStacks || []) {
      if (!stack)
        continue;
      for (const { file } of stack)
        sourceFiles.add(file);
    }
    for (const sourceFile of sourceFiles)
      addFile(sourceFile, "resources/src@" + await calculateSha1(sourceFile) + ".txt");
  }
  if (params.mode === "write") {
    await fs.promises.mkdir(path23.dirname(params.zipFile), { recursive: true });
    zipFile.end(void 0, () => {
      zipFile.outputStream.pipe(fs.createWriteStream(params.zipFile)).on("close", () => promise.resolve()).on("error", (error4) => promise.reject(error4));
    });
    await promise;
    await deleteStackSession(stackSessions, params.stacksId);
    return;
  }
  const tempFile = params.zipFile + ".tmp";
  await fs.promises.rename(params.zipFile, tempFile);
  yauzl2.open(tempFile, (err, inZipFile) => {
    if (err) {
      promise.reject(err);
      return;
    }
    assert3(inZipFile);
    let pendingEntries = inZipFile.entryCount;
    inZipFile.on("entry", (entry) => {
      inZipFile.openReadStream(entry, (err2, readStream) => {
        if (err2) {
          promise.reject(err2);
          return;
        }
        zipFile.addReadStream(readStream, entry.fileName);
        if (--pendingEntries === 0) {
          zipFile.end(void 0, () => {
            zipFile.outputStream.pipe(fs.createWriteStream(params.zipFile)).on("close", () => {
              fs.promises.unlink(tempFile).then(() => {
                promise.resolve();
              }).catch((error4) => promise.reject(error4));
            });
          });
        }
      });
    });
  });
  await promise;
  await deleteStackSession(stackSessions, params.stacksId);
}
__name(zip, "zip");
async function deleteStackSession(stackSessions, stacksId) {
  const session2 = stacksId ? stackSessions.get(stacksId) : void 0;
  if (!session2)
    return;
  await session2.writer;
  if (session2.tmpDir)
    await removeFolders([session2.tmpDir]);
  stackSessions.delete(stacksId);
}
__name(deleteStackSession, "deleteStackSession");
async function harOpen(harBackends, params) {
  let harBackend;
  if (params.file.endsWith(".zip")) {
    const zipFile = new ZipFile(params.file);
    const entryNames = await zipFile.entries();
    const harEntryName = entryNames.find((e) => e.endsWith(".har"));
    if (!harEntryName)
      return { error: "Specified archive does not have a .har file" };
    const har = await zipFile.read(harEntryName);
    const harFile = JSON.parse(har.toString());
    harBackend = new HarBackend(harFile, null, zipFile);
  } else {
    const harFile = JSON.parse(await fs.promises.readFile(params.file, "utf-8"));
    harBackend = new HarBackend(harFile, path23.dirname(params.file), null);
  }
  harBackends.set(harBackend.id, harBackend);
  return { harId: harBackend.id };
}
__name(harOpen, "harOpen");
async function harLookup(harBackends, params) {
  const harBackend = harBackends.get(params.harId);
  if (!harBackend)
    return { action: "error", message: `Internal error: har was not opened` };
  return await harBackend.lookup(params.url, params.method, params.headers, params.postData, params.isNavigationRequest);
}
__name(harLookup, "harLookup");
async function harClose(harBackends, params) {
  const harBackend = harBackends.get(params.harId);
  if (harBackend) {
    harBackends.delete(harBackend.id);
    harBackend.dispose();
  }
}
__name(harClose, "harClose");
async function harUnzip(params) {
  const dir3 = path23.dirname(params.zipFile);
  const zipFile = new ZipFile(params.zipFile);
  for (const entry of await zipFile.entries()) {
    const buffer2 = await zipFile.read(entry);
    if (entry === "har.har")
      await fs.promises.writeFile(params.harFile, buffer2);
    else
      await fs.promises.writeFile(path23.join(dir3, entry), buffer2);
  }
  zipFile.close();
  await fs.promises.unlink(params.zipFile);
}
__name(harUnzip, "harUnzip");
async function tracingStarted(stackSessions, params) {
  let tmpDir = void 0;
  if (!params.tracesDir)
    tmpDir = await fs.promises.mkdtemp(path23.join(os_default.tmpdir(), "playwright-tracing-"));
  const traceStacksFile = path23.join(params.tracesDir || tmpDir, params.traceName + ".stacks");
  stackSessions.set(traceStacksFile, { callStacks: [], file: traceStacksFile, writer: Promise.resolve(), tmpDir });
  return { stacksId: traceStacksFile };
}
__name(tracingStarted, "tracingStarted");
async function traceDiscarded(stackSessions, params) {
  await deleteStackSession(stackSessions, params.stacksId);
}
__name(traceDiscarded, "traceDiscarded");
async function addStackToTracingNoReply(stackSessions, params) {
  for (const session2 of stackSessions.values()) {
    session2.callStacks.push(params.callData);
    if (process.env.PW_LIVE_TRACE_STACKS) {
      session2.writer = session2.writer.then(() => {
        const buffer2 = Buffer.from(JSON.stringify(serializeClientSideCallMetadata(session2.callStacks)));
        return fs.promises.writeFile(session2.file, buffer2);
      });
    }
  }
}
__name(addStackToTracingNoReply, "addStackToTracingNoReply");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/jsonPipeDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JsonPipeDispatcher = class extends Dispatcher {
  static {
    __name(this, "JsonPipeDispatcher");
  }
  constructor(scope) {
    super(scope, { guid: "jsonPipe@" + createGuid() }, "JsonPipe", {});
    this._type_JsonPipe = true;
  }
  async send(params) {
    this.emit("message", params.message);
  }
  async close() {
    this.emit("close");
    if (!this._disposed) {
      this._dispatchEvent("closed", {});
      this._dispose();
    }
  }
  dispatch(message) {
    if (!this._disposed)
      this._dispatchEvent("message", { message });
  }
  wasClosed(reason) {
    if (!this._disposed) {
      this._dispatchEvent("closed", { reason });
      this._dispose();
    }
  }
  dispose() {
    this._dispose();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/socksInterceptor.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import require$$0$35 from "node:events";
var SocksInterceptor = class {
  static {
    __name(this, "SocksInterceptor");
  }
  constructor(transport, pattern, redirectPortForTest) {
    this._ids = /* @__PURE__ */ new Set();
    this._handler = new SocksProxyHandler(pattern, redirectPortForTest);
    let lastId = -1;
    this._channel = new Proxy(new require$$0$35(), {
      get: /* @__PURE__ */ __name((obj, prop) => {
        if (prop in obj || obj[prop] !== void 0 || typeof prop !== "string")
          return obj[prop];
        return (params) => {
          try {
            const id = --lastId;
            this._ids.add(id);
            const validator = findValidator("SocksSupport", prop, "Params");
            params = validator(params, "", { tChannelImpl: tChannelForSocks, binary: "toBase64", isUnderTest });
            transport.send({ id, guid: this._socksSupportObjectGuid, method: prop, params, metadata: { stack: [], apiName: "", internal: true } });
          } catch (e) {
          }
        };
      }, "get")
    });
    this._handler.on(SocksProxyHandler.Events.SocksConnected, (payload) => this._channel.socksConnected(payload));
    this._handler.on(SocksProxyHandler.Events.SocksData, (payload) => this._channel.socksData(payload));
    this._handler.on(SocksProxyHandler.Events.SocksError, (payload) => this._channel.socksError(payload));
    this._handler.on(SocksProxyHandler.Events.SocksFailed, (payload) => this._channel.socksFailed(payload));
    this._handler.on(SocksProxyHandler.Events.SocksEnd, (payload) => this._channel.socksEnd(payload));
    this._channel.on("socksRequested", (payload) => this._handler.socketRequested(payload));
    this._channel.on("socksClosed", (payload) => this._handler.socketClosed(payload));
    this._channel.on("socksData", (payload) => this._handler.sendSocketData(payload));
  }
  cleanup() {
    this._handler.cleanup();
  }
  interceptMessage(message) {
    if (this._ids.has(message.id)) {
      this._ids.delete(message.id);
      return true;
    }
    if (message.method === "__create__" && message.params.type === "SocksSupport") {
      this._socksSupportObjectGuid = message.params.guid;
      return false;
    }
    if (this._socksSupportObjectGuid && message.guid === this._socksSupportObjectGuid) {
      const validator = findValidator("SocksSupport", message.method, "Event");
      const params = validator(message.params, "", { tChannelImpl: tChannelForSocks, binary: "fromBase64", isUnderTest });
      this._channel.emit(message.method, params);
      return true;
    }
    return false;
  }
};
function tChannelForSocks(names, arg, path31, context2) {
  throw new ValidationError(`${path31}: channels are not expected in SocksSupport`);
}
__name(tChannelForSocks, "tChannelForSocks");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/localUtilsDispatcher.js
var LocalUtilsDispatcher = class extends Dispatcher {
  static {
    __name(this, "LocalUtilsDispatcher");
  }
  constructor(scope, playwright2) {
    const localUtils2 = new SdkObject(playwright2, "localUtils", "localUtils");
    const deviceDescriptors$1 = Object.entries(deviceDescriptors).map(([name, descriptor]) => ({ name, descriptor }));
    super(scope, localUtils2, "LocalUtils", {
      deviceDescriptors: deviceDescriptors$1
    });
    this._harBackends = /* @__PURE__ */ new Map();
    this._stackSessions = /* @__PURE__ */ new Map();
    this._type_LocalUtils = true;
  }
  async zip(params) {
    return await zip(this._stackSessions, params);
  }
  async harOpen(params, metadata) {
    return await harOpen(this._harBackends, params);
  }
  async harLookup(params, metadata) {
    return await harLookup(this._harBackends, params);
  }
  async harClose(params, metadata) {
    return await harClose(this._harBackends, params);
  }
  async harUnzip(params, metadata) {
    return await harUnzip(params);
  }
  async tracingStarted(params, metadata) {
    return await tracingStarted(this._stackSessions, params);
  }
  async traceDiscarded(params, metadata) {
    return await traceDiscarded(this._stackSessions, params);
  }
  async addStackToTracingNoReply(params, metadata) {
    return await addStackToTracingNoReply(this._stackSessions, params);
  }
  async connect(params, metadata) {
    const controller = new ProgressController(metadata, this._object);
    controller.setLogName("browser");
    return await controller.run(async (progress3) => {
      const wsHeaders = {
        "User-Agent": getUserAgent(),
        "x-playwright-proxy": params.exposeNetwork ?? "",
        ...params.headers
      };
      const wsEndpoint = await urlToWSEndpoint(progress3, params.wsEndpoint);
      const transport = await WebSocketTransport.connect(progress3, wsEndpoint, { headers: wsHeaders, followRedirects: true, debugLogHeader: "x-playwright-debug-log" });
      const socksInterceptor = new SocksInterceptor(transport, params.exposeNetwork, params.socksProxyRedirectPortForTest);
      const pipe = new JsonPipeDispatcher(this);
      transport.onmessage = (json) => {
        if (socksInterceptor.interceptMessage(json))
          return;
        const cb = /* @__PURE__ */ __name(() => {
          try {
            pipe.dispatch(json);
          } catch (e) {
            transport.close();
          }
        }, "cb");
        if (params.slowMo)
          setTimeout(cb, params.slowMo);
        else
          cb();
      };
      pipe.on("message", (message) => {
        transport.send(message);
      });
      transport.onclose = (reason) => {
        socksInterceptor?.cleanup();
        pipe.wasClosed(reason);
      };
      pipe.on("close", () => transport.close());
      return { pipe, headers: transport.headers };
    }, params.timeout || 0);
  }
  async globToRegex(params, metadata) {
    const regex = resolveGlobToRegexPattern(params.baseURL, params.glob, params.webSocketUrl);
    return { regex };
  }
};
async function urlToWSEndpoint(progress3, endpointURL) {
  if (endpointURL.startsWith("ws"))
    return endpointURL;
  progress3?.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);
  const fetchUrl = new URL(endpointURL);
  if (!fetchUrl.pathname.endsWith("/"))
    fetchUrl.pathname += "/";
  fetchUrl.pathname += "json";
  const json = await fetchData({
    url: fetchUrl.toString(),
    method: "GET",
    timeout: progress3?.timeUntilDeadline() ?? 3e4,
    headers: { "User-Agent": getUserAgent() }
  }, async (params, response) => {
    return new Error(`Unexpected status ${response.statusCode} when connecting to ${fetchUrl.toString()}.
This does not look like a Playwright server, try connecting via ws://.`);
  });
  progress3?.throwIfAborted();
  const wsUrl = new URL(endpointURL);
  let wsEndpointPath = JSON.parse(json).wsEndpointPath;
  if (wsEndpointPath.startsWith("/"))
    wsEndpointPath = wsEndpointPath.substring(1);
  if (!wsUrl.pathname.endsWith("/"))
    wsUrl.pathname += "/";
  wsUrl.pathname += wsEndpointPath;
  wsUrl.protocol = wsUrl.protocol === "https:" ? "wss:" : "ws:";
  return wsUrl.toString();
}
__name(urlToWSEndpoint, "urlToWSEndpoint");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/selectorsDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SelectorsDispatcher = class extends Dispatcher {
  static {
    __name(this, "SelectorsDispatcher");
  }
  constructor(scope, selectors2) {
    super(scope, selectors2, "Selectors", {});
    this._type_Selectors = true;
  }
  async register(params) {
    await this._object.register(params.name, params.source, params.contentScript);
  }
  async setTestIdAttributeName(params) {
    this._object.setTestIdAttributeName(params.testIdAttributeName);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/playwrightDispatcher.js
var PlaywrightDispatcher = class extends Dispatcher {
  static {
    __name(this, "PlaywrightDispatcher");
  }
  constructor(scope, playwright2, socksProxy, preLaunchedBrowser, prelaunchedAndroidDevice) {
    const browserDispatcher = preLaunchedBrowser ? new ConnectedBrowserDispatcher(scope, preLaunchedBrowser) : void 0;
    const android = new AndroidDispatcher(scope, playwright2.android);
    const prelaunchedAndroidDeviceDispatcher = prelaunchedAndroidDevice ? new AndroidDeviceDispatcher(android, prelaunchedAndroidDevice) : void 0;
    super(scope, playwright2, "Playwright", {
      chromium: new BrowserTypeDispatcher(scope, playwright2.chromium),
      firefox: new BrowserTypeDispatcher(scope, playwright2.firefox),
      webkit: new BrowserTypeDispatcher(scope, playwright2.webkit),
      bidiChromium: new BrowserTypeDispatcher(scope, playwright2.bidiChromium),
      bidiFirefox: new BrowserTypeDispatcher(scope, playwright2.bidiFirefox),
      android,
      electron: new ElectronDispatcher(scope, playwright2.electron),
      utils: playwright2.options.isServer ? void 0 : new LocalUtilsDispatcher(scope, playwright2),
      selectors: new SelectorsDispatcher(scope, browserDispatcher?.selectors || playwright2.selectors),
      preLaunchedBrowser: browserDispatcher,
      preConnectedAndroidDevice: prelaunchedAndroidDeviceDispatcher,
      socksSupport: socksProxy ? new SocksSupportDispatcher(scope, socksProxy) : void 0
    });
    this._type_Playwright = true;
    this._browserDispatcher = browserDispatcher;
  }
  async newRequest(params) {
    const request4 = new GlobalAPIRequestContext(this._object, params);
    return { request: APIRequestContextDispatcher.from(this.parentScope(), request4) };
  }
  async cleanup() {
    await this._browserDispatcher?.cleanupContexts();
  }
};
var SocksSupportDispatcher = class extends Dispatcher {
  static {
    __name(this, "SocksSupportDispatcher");
  }
  constructor(scope, socksProxy) {
    super(scope, { guid: "socksSupport@" + createGuid() }, "SocksSupport", {});
    this._type_SocksSupport = true;
    this._socksProxy = socksProxy;
    this._socksListeners = [
      eventsHelper.addEventListener(socksProxy, SocksProxy.Events.SocksRequested, (payload) => this._dispatchEvent("socksRequested", payload)),
      eventsHelper.addEventListener(socksProxy, SocksProxy.Events.SocksData, (payload) => this._dispatchEvent("socksData", payload)),
      eventsHelper.addEventListener(socksProxy, SocksProxy.Events.SocksClosed, (payload) => this._dispatchEvent("socksClosed", payload))
    ];
  }
  async socksConnected(params) {
    this._socksProxy?.socketConnected(params);
  }
  async socksFailed(params) {
    this._socksProxy?.socketFailed(params);
  }
  async socksData(params) {
    this._socksProxy?.sendSocketData(params);
  }
  async socksError(params) {
    this._socksProxy?.sendSocketError(params);
  }
  async socksEnd(params) {
    this._socksProxy?.sendSocketEnd(params);
  }
  _onDispose() {
    eventsHelper.removeEventListeners(this._socksListeners);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/playwright.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/android/backendAdb.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter14 } from "node:events";
import net5 from "node:net";
var AdbBackend = class {
  static {
    __name(this, "AdbBackend");
  }
  async devices(options2 = {}) {
    const result = await runCommand("host:devices", options2.host, options2.port);
    const lines = result.toString().trim().split("\n");
    return lines.map((line) => {
      const [serial, status] = line.trim().split("	");
      return new AdbDevice(serial, status, options2.host, options2.port);
    });
  }
};
var AdbDevice = class {
  static {
    __name(this, "AdbDevice");
  }
  constructor(serial, status, host, port) {
    this._closed = false;
    this.serial = serial;
    this.status = status;
    this.host = host;
    this.port = port;
  }
  async init() {
  }
  async close() {
    this._closed = true;
  }
  runCommand(command2) {
    if (this._closed)
      throw new Error("Device is closed");
    return runCommand(command2, this.host, this.port, this.serial);
  }
  async open(command2) {
    if (this._closed)
      throw new Error("Device is closed");
    const result = await open5(command2, this.host, this.port, this.serial);
    result.becomeSocket();
    return result;
  }
};
async function runCommand(command2, host = "127.0.0.1", port = 5037, serial) {
  debug5("pw:adb:runCommand")(command2, serial);
  const socket = new BufferedSocketWrapper(command2, net5.createConnection({ host, port }));
  try {
    if (serial) {
      await socket.write(encodeMessage(`host:transport:${serial}`));
      const status2 = await socket.read(4);
      assert3(status2.toString() === "OKAY", status2.toString());
    }
    await socket.write(encodeMessage(command2));
    const status = await socket.read(4);
    assert3(status.toString() === "OKAY", status.toString());
    let commandOutput;
    if (!command2.startsWith("shell:")) {
      const remainingLength = parseInt((await socket.read(4)).toString(), 16);
      commandOutput = await socket.read(remainingLength);
    } else {
      commandOutput = await socket.readAll();
    }
    return commandOutput;
  } finally {
    socket.close();
  }
}
__name(runCommand, "runCommand");
async function open5(command2, host = "127.0.0.1", port = 5037, serial) {
  const socket = new BufferedSocketWrapper(command2, net5.createConnection({ host, port }));
  if (serial) {
    await socket.write(encodeMessage(`host:transport:${serial}`));
    const status2 = await socket.read(4);
    assert3(status2.toString() === "OKAY", status2.toString());
  }
  await socket.write(encodeMessage(command2));
  const status = await socket.read(4);
  assert3(status.toString() === "OKAY", status.toString());
  return socket;
}
__name(open5, "open");
function encodeMessage(message) {
  let lenHex = message.length.toString(16);
  lenHex = "0".repeat(4 - lenHex.length) + lenHex;
  return Buffer.from(lenHex + message);
}
__name(encodeMessage, "encodeMessage");
var BufferedSocketWrapper = class extends EventEmitter14 {
  static {
    __name(this, "BufferedSocketWrapper");
  }
  constructor(command2, socket) {
    super();
    this.guid = createGuid();
    this._buffer = Buffer.from([]);
    this._isSocket = false;
    this._isClosed = false;
    this._command = command2;
    this._socket = socket;
    this._connectPromise = new Promise((f) => this._socket.on("connect", f));
    this._socket.on("data", (data) => {
      debug5("pw:adb:data")(data.toString());
      if (this._isSocket) {
        this.emit("data", data);
        return;
      }
      this._buffer = Buffer.concat([this._buffer, data]);
      if (this._notifyReader)
        this._notifyReader();
    });
    this._socket.on("close", () => {
      this._isClosed = true;
      if (this._notifyReader)
        this._notifyReader();
      this.close();
      this.emit("close");
    });
    this._socket.on("error", (error4) => this.emit("error", error4));
  }
  async write(data) {
    debug5("pw:adb:send")(data.toString().substring(0, 100) + "...");
    await this._connectPromise;
    await new Promise((f) => this._socket.write(data, f));
  }
  close() {
    if (this._isClosed)
      return;
    debug5("pw:adb")("Close " + this._command);
    this._socket.destroy();
  }
  async read(length) {
    await this._connectPromise;
    assert3(!this._isSocket, "Can not read by length in socket mode");
    while (this._buffer.length < length)
      await new Promise((f) => this._notifyReader = f);
    const result = this._buffer.slice(0, length);
    this._buffer = this._buffer.slice(length);
    debug5("pw:adb:recv")(result.toString().substring(0, 100) + "...");
    return result;
  }
  async readAll() {
    while (!this._isClosed)
      await new Promise((f) => this._notifyReader = f);
    return this._buffer;
  }
  becomeSocket() {
    assert3(!this._buffer.length);
    this._isSocket = true;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiChromium.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/browserType.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path24 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/pipeTransport.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var PipeTransport2 = class {
  static {
    __name(this, "PipeTransport");
  }
  constructor(pipeWrite, pipeRead) {
    this._pendingBuffers = [];
    this._waitForNextTask = makeWaitForNextTask();
    this._closed = false;
    this._pipeRead = pipeRead;
    this._pipeWrite = pipeWrite;
    pipeRead.on("data", (buffer2) => this._dispatch(buffer2));
    pipeRead.on("close", () => {
      this._closed = true;
      if (this._onclose)
        this._onclose.call(null);
    });
    pipeRead.on("error", (e) => debugLogger.log("error", e));
    pipeWrite.on("error", (e) => debugLogger.log("error", e));
    this.onmessage = void 0;
  }
  get onclose() {
    return this._onclose;
  }
  set onclose(onclose) {
    this._onclose = onclose;
    if (onclose && !this._pipeRead.readable)
      onclose();
  }
  send(message) {
    if (this._closed)
      throw new Error("Pipe has been closed");
    this._pipeWrite.write(JSON.stringify(message));
    this._pipeWrite.write("\0");
  }
  close() {
    throw new Error("unimplemented");
  }
  _dispatch(buffer2) {
    let end = buffer2.indexOf("\0");
    if (end === -1) {
      this._pendingBuffers.push(buffer2);
      return;
    }
    this._pendingBuffers.push(buffer2.slice(0, end));
    const message = Buffer.concat(this._pendingBuffers).toString();
    this._waitForNextTask(() => {
      if (this.onmessage)
        this.onmessage.call(null, JSON.parse(message));
    });
    let start = end + 1;
    end = buffer2.indexOf("\0", start);
    while (end !== -1) {
      const message2 = buffer2.toString(void 0, start, end);
      this._waitForNextTask(() => {
        if (this.onmessage)
          this.onmessage.call(null, JSON.parse(message2));
      });
      start = end + 1;
      end = buffer2.indexOf("\0", start);
    }
    this._pendingBuffers = [buffer2.slice(start)];
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/browserType.js
var kNoXServerRunningError = "Looks like you launched a headed browser without having a XServer running.\nSet either 'headless: true' or use 'xvfb-run <your-playwright-app>' before running Playwright.\n\n<3 Playwright Team";
var BrowserReadyState = class {
  static {
    __name(this, "BrowserReadyState");
  }
  constructor() {
    this._wsEndpoint = new ManualPromise();
  }
  onBrowserExit() {
    this._wsEndpoint.resolve(void 0);
  }
  async waitUntilReady() {
    const wsEndpoint = await this._wsEndpoint;
    return { wsEndpoint };
  }
};
var BrowserType = class extends SdkObject {
  static {
    __name(this, "BrowserType");
  }
  constructor(parent, browserName) {
    super(parent, "browser-type");
    this._useBidi = false;
    this.attribution.browserType = this;
    this._name = browserName;
  }
  executablePath() {
    return registry.findExecutable(this._name).executablePath(this.attribution.playwright.options.sdkLanguage) || "";
  }
  name() {
    return this._name;
  }
  async launch(metadata, options2, protocolLogger) {
    options2 = this._validateLaunchOptions(options2);
    if (this._useBidi)
      options2.useWebSocket = true;
    const controller = new ProgressController(metadata, this);
    controller.setLogName("browser");
    const browser3 = await controller.run((progress3) => {
      const seleniumHubUrl = options2.__testHookSeleniumRemoteURL || process.env.SELENIUM_REMOTE_URL;
      if (seleniumHubUrl)
        return this._launchWithSeleniumHub(progress3, seleniumHubUrl, options2);
      return this._innerLaunchWithRetries(progress3, options2, void 0, helper.debugProtocolLogger(protocolLogger)).catch((e) => {
        throw this._rewriteStartupLog(e);
      });
    }, TimeoutSettings.launchTimeout(options2));
    return browser3;
  }
  async launchPersistentContext(metadata, userDataDir, options2) {
    const launchOptions = this._validateLaunchOptions(options2);
    if (this._useBidi)
      launchOptions.useWebSocket = true;
    const controller = new ProgressController(metadata, this);
    controller.setLogName("browser");
    const browser3 = await controller.run(async (progress3) => {
      let clientCertificatesProxy;
      if (options2.clientCertificates?.length) {
        clientCertificatesProxy = new ClientCertificatesProxy(options2);
        launchOptions.proxyOverride = await clientCertificatesProxy?.listen();
        options2 = { ...options2 };
        options2.internalIgnoreHTTPSErrors = true;
      }
      progress3.cleanupWhenAborted(() => clientCertificatesProxy?.close());
      const browser22 = await this._innerLaunchWithRetries(progress3, launchOptions, options2, helper.debugProtocolLogger(), userDataDir).catch((e) => {
        throw this._rewriteStartupLog(e);
      });
      browser22._defaultContext._clientCertificatesProxy = clientCertificatesProxy;
      return browser22;
    }, TimeoutSettings.launchTimeout(launchOptions));
    return browser3._defaultContext;
  }
  async _innerLaunchWithRetries(progress3, options2, persistent, protocolLogger, userDataDir) {
    try {
      return await this._innerLaunch(progress3, options2, persistent, protocolLogger, userDataDir);
    } catch (error4) {
      const errorMessage = typeof error4 === "object" && typeof error4.message === "string" ? error4.message : "";
      if (errorMessage.includes("Inconsistency detected by ld.so")) {
        progress3.log(`<restarting browser due to hitting race condition in glibc>`);
        return this._innerLaunch(progress3, options2, persistent, protocolLogger, userDataDir);
      }
      throw error4;
    }
  }
  async _innerLaunch(progress3, options2, persistent, protocolLogger, maybeUserDataDir) {
    options2.proxy = options2.proxy ? normalizeProxySettings(options2.proxy) : void 0;
    const browserLogsCollector = new RecentLogsCollector();
    const { browserProcess, userDataDir, artifactsDir, transport } = await this._launchProcess(progress3, options2, !!persistent, browserLogsCollector, maybeUserDataDir);
    if (options2.__testHookBeforeCreateBrowser)
      await options2.__testHookBeforeCreateBrowser();
    const browserOptions = {
      name: this._name,
      isChromium: this._name === "chromium",
      channel: options2.channel,
      slowMo: options2.slowMo,
      persistent,
      headful: !options2.headless,
      artifactsDir,
      downloadsPath: options2.downloadsPath || artifactsDir,
      tracesDir: options2.tracesDir || artifactsDir,
      browserProcess,
      customExecutablePath: options2.executablePath,
      proxy: options2.proxy,
      protocolLogger,
      browserLogsCollector,
      wsEndpoint: options2.useWebSocket ? transport.wsEndpoint : void 0,
      originalLaunchOptions: options2
    };
    if (persistent)
      validateBrowserContextOptions(persistent, browserOptions);
    copyTestHooks(options2, browserOptions);
    const browser3 = await this.connectToTransport(transport, browserOptions);
    browser3._userDataDirForTest = userDataDir;
    if (persistent && !options2.ignoreAllDefaultArgs)
      await browser3._defaultContext._loadDefaultContext(progress3);
    return browser3;
  }
  async _launchProcess(progress3, options2, isPersistent, browserLogsCollector, userDataDir) {
    const {
      ignoreDefaultArgs,
      ignoreAllDefaultArgs,
      args = [],
      executablePath = null,
      handleSIGINT = true,
      handleSIGTERM = true,
      handleSIGHUP = true
    } = options2;
    const env3 = options2.env ? envArrayToObject(options2.env) : process.env;
    await this._createArtifactDirs(options2);
    const tempDirectories = [];
    const artifactsDir = await fs.promises.mkdtemp(path24.join(os_default.tmpdir(), "playwright-artifacts-"));
    tempDirectories.push(artifactsDir);
    if (userDataDir) {
      assert3(path24.isAbsolute(userDataDir), "userDataDir must be an absolute path");
      if (!await existsAsync(userDataDir))
        await fs.promises.mkdir(userDataDir, { recursive: true, mode: 448 });
    } else {
      userDataDir = await fs.promises.mkdtemp(path24.join(os_default.tmpdir(), `playwright_${this._name}dev_profile-`));
      tempDirectories.push(userDataDir);
    }
    await this.prepareUserDataDir(options2, userDataDir);
    const browserArguments = [];
    if (ignoreAllDefaultArgs)
      browserArguments.push(...args);
    else if (ignoreDefaultArgs)
      browserArguments.push(...this.defaultArgs(options2, isPersistent, userDataDir).filter((arg) => ignoreDefaultArgs.indexOf(arg) === -1));
    else
      browserArguments.push(...this.defaultArgs(options2, isPersistent, userDataDir));
    let executable;
    if (executablePath) {
      if (!await existsAsync(executablePath))
        throw new Error(`Failed to launch ${this._name} because executable doesn't exist at ${executablePath}`);
      executable = executablePath;
    } else {
      const registryExecutable = registry.findExecutable(this.getExecutableName(options2));
      if (!registryExecutable || registryExecutable.browserName !== this._name)
        throw new Error(`Unsupported ${this._name} channel "${options2.channel}"`);
      executable = registryExecutable.executablePathOrDie(this.attribution.playwright.options.sdkLanguage);
      await registry.validateHostRequirementsForExecutablesIfNeeded([registryExecutable], this.attribution.playwright.options.sdkLanguage);
    }
    const readyState = this.readyState(options2);
    let transport = void 0;
    let browserProcess = void 0;
    const { launchedProcess, gracefullyClose, kill: kill2 } = await launchProcess({
      command: executable,
      args: browserArguments,
      env: this.amendEnvironment(env3, userDataDir, executable, browserArguments),
      handleSIGINT,
      handleSIGTERM,
      handleSIGHUP,
      log: /* @__PURE__ */ __name((message) => {
        readyState?.onBrowserOutput(message);
        progress3.log(message);
        browserLogsCollector.log(message);
      }, "log"),
      stdio: "pipe",
      tempDirectories,
      attemptToGracefullyClose: /* @__PURE__ */ __name(async () => {
        if (options2.__testHookGracefullyClose)
          await options2.__testHookGracefullyClose();
        this.attemptToGracefullyCloseBrowser(transport);
      }, "attemptToGracefullyClose"),
      onExit: /* @__PURE__ */ __name((exitCode2, signal) => {
        readyState?.onBrowserExit();
        if (browserProcess && browserProcess.onclose)
          browserProcess.onclose(exitCode2, signal);
      }, "onExit")
    });
    async function closeOrKill(timeout) {
      let timer;
      try {
        await Promise.race([
          gracefullyClose(),
          new Promise((resolve, reject) => timer = setTimeout(reject, timeout))
        ]);
      } catch (ignored) {
        await kill2().catch((ignored2) => {
        });
      } finally {
        clearTimeout(timer);
      }
    }
    __name(closeOrKill, "closeOrKill");
    browserProcess = {
      onclose: void 0,
      process: launchedProcess,
      close: /* @__PURE__ */ __name(() => closeOrKill(options2.__testHookBrowserCloseTimeout || DEFAULT_TIMEOUT), "close"),
      kill: kill2
    };
    progress3.cleanupWhenAborted(() => closeOrKill(progress3.timeUntilDeadline()));
    const wsEndpoint = (await readyState?.waitUntilReady())?.wsEndpoint;
    if (options2.useWebSocket) {
      transport = await WebSocketTransport.connect(progress3, wsEndpoint);
    } else {
      const stdio = launchedProcess.stdio;
      transport = new PipeTransport2(stdio[3], stdio[4]);
    }
    return { browserProcess, artifactsDir, userDataDir, transport };
  }
  async _createArtifactDirs(options2) {
    if (options2.downloadsPath)
      await fs.promises.mkdir(options2.downloadsPath, { recursive: true });
    if (options2.tracesDir)
      await fs.promises.mkdir(options2.tracesDir, { recursive: true });
  }
  async connectOverCDP(metadata, endpointURL, options2) {
    throw new Error("CDP connections are only supported by Chromium");
  }
  async _launchWithSeleniumHub(progress3, hubUrl, options2) {
    throw new Error("Connecting to SELENIUM_REMOTE_URL is only supported by Chromium");
  }
  _validateLaunchOptions(options2) {
    const { devtools = false } = options2;
    let { headless = !devtools, downloadsPath, proxy } = options2;
    if (debugMode())
      headless = false;
    if (downloadsPath && !path24.isAbsolute(downloadsPath))
      downloadsPath = path24.join(process.cwd(), downloadsPath);
    if (this.attribution.playwright.options.socksProxyPort)
      proxy = { server: `socks5://127.0.0.1:${this.attribution.playwright.options.socksProxyPort}` };
    return { ...options2, devtools, headless, downloadsPath, proxy };
  }
  _createUserDataDirArgMisuseError(userDataDirArg) {
    switch (this.attribution.playwright.options.sdkLanguage) {
      case "java":
        return new Error(`Pass userDataDir parameter to 'BrowserType.launchPersistentContext(userDataDir, options)' instead of specifying '${userDataDirArg}' argument`);
      case "python":
        return new Error(`Pass user_data_dir parameter to 'browser_type.launch_persistent_context(user_data_dir, **kwargs)' instead of specifying '${userDataDirArg}' argument`);
      case "csharp":
        return new Error(`Pass userDataDir parameter to 'BrowserType.LaunchPersistentContextAsync(userDataDir, options)' instead of specifying '${userDataDirArg}' argument`);
      default:
        return new Error(`Pass userDataDir parameter to 'browserType.launchPersistentContext(userDataDir, options)' instead of specifying '${userDataDirArg}' argument`);
    }
  }
  _rewriteStartupLog(error4) {
    if (!isProtocolError(error4))
      return error4;
    return this.doRewriteStartupLog(error4);
  }
  readyState(options2) {
    return void 0;
  }
  async prepareUserDataDir(options2, userDataDir) {
  }
  getExecutableName(options2) {
    return options2.channel || this._name;
  }
};
function copyTestHooks(from, to) {
  for (const [key, value] of Object.entries(from)) {
    if (key.startsWith("__testHook"))
      to[key] = value;
  }
}
__name(copyTestHooks, "copyTestHooks");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiBrowser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiConnection.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter15 } from "node:events";
var kBrowserCloseMessageId2 = 0;
var BidiConnection = class {
  static {
    __name(this, "BidiConnection");
  }
  constructor(transport, onDisconnect, protocolLogger, browserLogsCollector) {
    this._lastId = 0;
    this._closed = false;
    this._browsingContextToSession = /* @__PURE__ */ new Map();
    this._transport = transport;
    this._onDisconnect = onDisconnect;
    this._protocolLogger = protocolLogger;
    this._browserLogsCollector = browserLogsCollector;
    this.browserSession = new BidiSession(this, "", (message) => {
      this.rawSend(message);
    });
    this._transport.onmessage = this._dispatchMessage.bind(this);
    this._transport.onclose = this._onClose.bind(this);
  }
  nextMessageId() {
    return ++this._lastId;
  }
  rawSend(message) {
    this._protocolLogger("send", message);
    this._transport.send(message);
  }
  _dispatchMessage(message) {
    this._protocolLogger("receive", message);
    const object = message;
    if (object.type === "event") {
      let context2;
      if ("context" in object.params)
        context2 = object.params.context;
      else if (object.method === "log.entryAdded" || object.method === "script.message")
        context2 = object.params.source?.context;
      if (context2) {
        const session2 = this._browsingContextToSession.get(context2);
        if (session2) {
          session2.dispatchMessage(message);
          return;
        }
      }
    } else if (message.id) {
      for (const session2 of this._browsingContextToSession.values()) {
        if (session2.hasCallback(message.id)) {
          session2.dispatchMessage(message);
          return;
        }
      }
    }
    this.browserSession.dispatchMessage(message);
  }
  _onClose(reason) {
    this._closed = true;
    this._transport.onmessage = void 0;
    this._transport.onclose = void 0;
    this._browserDisconnectedLogs = helper.formatBrowserLogs(this._browserLogsCollector.recentLogs(), reason);
    this.browserSession.dispose();
    this._onDisconnect();
  }
  isClosed() {
    return this._closed;
  }
  close() {
    if (!this._closed)
      this._transport.close();
  }
  createMainFrameBrowsingContextSession(bowsingContextId) {
    const result = new BidiSession(this, bowsingContextId, (message) => this.rawSend(message));
    this._browsingContextToSession.set(bowsingContextId, result);
    return result;
  }
};
var BidiSession = class extends EventEmitter15 {
  static {
    __name(this, "BidiSession");
  }
  constructor(connection, sessionId, rawSend) {
    super();
    this._disposed = false;
    this._callbacks = /* @__PURE__ */ new Map();
    this._crashed = false;
    this._browsingContexts = /* @__PURE__ */ new Set();
    this.setMaxListeners(0);
    this.connection = connection;
    this.sessionId = sessionId;
    this._rawSend = rawSend;
    this.on = super.on;
    this.off = super.removeListener;
    this.addListener = super.addListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }
  addFrameBrowsingContext(context2) {
    this._browsingContexts.add(context2);
    this.connection._browsingContextToSession.set(context2, this);
  }
  removeFrameBrowsingContext(context2) {
    this._browsingContexts.delete(context2);
    this.connection._browsingContextToSession.delete(context2);
  }
  async send(method, params) {
    if (this._crashed || this._disposed || this.connection._browserDisconnectedLogs)
      throw new ProtocolError(this._crashed ? "crashed" : "closed", void 0, this.connection._browserDisconnectedLogs);
    const id = this.connection.nextMessageId();
    const messageObj = { id, method, params };
    this._rawSend(messageObj);
    return new Promise((resolve, reject) => {
      this._callbacks.set(id, { resolve, reject, error: new ProtocolError("error", method) });
    });
  }
  sendMayFail(method, params) {
    return this.send(method, params).catch((error4) => debugLogger.log("error", error4));
  }
  markAsCrashed() {
    this._crashed = true;
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed = true;
    this.connection._browsingContextToSession.delete(this.sessionId);
    for (const context2 of this._browsingContexts)
      this.connection._browsingContextToSession.delete(context2);
    this._browsingContexts.clear();
    for (const callback of this._callbacks.values()) {
      callback.error.type = this._crashed ? "crashed" : "closed";
      callback.error.logs = this.connection._browserDisconnectedLogs;
      callback.reject(callback.error);
    }
    this._callbacks.clear();
  }
  hasCallback(id) {
    return this._callbacks.has(id);
  }
  dispatchMessage(message) {
    const object = message;
    if (object.id === kBrowserCloseMessageId2)
      return;
    if (object.id && this._callbacks.has(object.id)) {
      const callback = this._callbacks.get(object.id);
      this._callbacks.delete(object.id);
      if (object.type === "error") {
        callback.error.setMessage(object.error + "\nMessage: " + object.message);
        callback.reject(callback.error);
      } else if (object.type === "success") {
        callback.resolve(object.result);
      } else {
        callback.error.setMessage("Internal error, unexpected response type: " + JSON.stringify(object));
        callback.reject(callback.error);
      }
    } else if (object.id) ;
    else {
      Promise.resolve().then(() => this.emit(object.method, object.params));
    }
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiNetworkManager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/third_party/bidiProtocolCore.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Session2;
((Session22) => {
  ((UserPromptHandlerType2) => {
    UserPromptHandlerType2["Accept"] = "accept";
    UserPromptHandlerType2["Dismiss"] = "dismiss";
    UserPromptHandlerType2["Ignore"] = "ignore";
  })(Session22.UserPromptHandlerType || (Session22.UserPromptHandlerType = {}));
})(Session2 || (Session2 = {}));
var BrowsingContext;
((BrowsingContext2) => {
  ((ReadinessState2) => {
    ReadinessState2["None"] = "none";
    ReadinessState2["Interactive"] = "interactive";
    ReadinessState2["Complete"] = "complete";
  })(BrowsingContext2.ReadinessState || (BrowsingContext2.ReadinessState = {}));
})(BrowsingContext || (BrowsingContext = {}));
((BrowsingContext2) => {
  ((UserPromptType2) => {
    UserPromptType2["Alert"] = "alert";
    UserPromptType2["Beforeunload"] = "beforeunload";
    UserPromptType2["Confirm"] = "confirm";
    UserPromptType2["Prompt"] = "prompt";
  })(BrowsingContext2.UserPromptType || (BrowsingContext2.UserPromptType = {}));
})(BrowsingContext || (BrowsingContext = {}));
((BrowsingContext2) => {
  ((CreateType2) => {
    CreateType2["Tab"] = "tab";
    CreateType2["Window"] = "window";
  })(BrowsingContext2.CreateType || (BrowsingContext2.CreateType = {}));
})(BrowsingContext || (BrowsingContext = {}));
var Network2;
((Network22) => {
  ((SameSite2) => {
    SameSite2["Strict"] = "strict";
    SameSite2["Lax"] = "lax";
    SameSite2["None"] = "none";
  })(Network22.SameSite || (Network22.SameSite = {}));
})(Network2 || (Network2 = {}));
((Network22) => {
  ((InterceptPhase2) => {
    InterceptPhase2["BeforeRequestSent"] = "beforeRequestSent";
    InterceptPhase2["ResponseStarted"] = "responseStarted";
    InterceptPhase2["AuthRequired"] = "authRequired";
  })(Network22.InterceptPhase || (Network22.InterceptPhase = {}));
})(Network2 || (Network2 = {}));
var Script;
((Script2) => {
  ((ResultOwnership2) => {
    ResultOwnership2["Root"] = "root";
    ResultOwnership2["None"] = "none";
  })(Script2.ResultOwnership || (Script2.ResultOwnership = {}));
})(Script || (Script = {}));
var Log;
((Log2) => {
  ((Level2) => {
    Level2["Debug"] = "debug";
    Level2["Info"] = "info";
    Level2["Warn"] = "warn";
    Level2["Error"] = "error";
  })(Log2.Level || (Log2.Level = {}));
})(Log || (Log = {}));
var Input;
((Input2) => {
  ((PointerType2) => {
    PointerType2["Mouse"] = "mouse";
    PointerType2["Pen"] = "pen";
    PointerType2["Touch"] = "touch";
  })(Input2.PointerType || (Input2.PointerType = {}));
})(Input || (Input = {}));

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/third_party/bidiProtocolPermissions.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Permissions;
((Permissions2) => {
  ((PermissionState2) => {
    PermissionState2["Granted"] = "granted";
    PermissionState2["Denied"] = "denied";
    PermissionState2["Prompt"] = "prompt";
  })(Permissions2.PermissionState || (Permissions2.PermissionState = {}));
})(Permissions || (Permissions = {}));

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiNetworkManager.js
var BidiNetworkManager = class {
  static {
    __name(this, "BidiNetworkManager");
  }
  constructor(bidiSession, page, onNavigationResponseStarted) {
    this._userRequestInterceptionEnabled = false;
    this._protocolRequestInterceptionEnabled = false;
    this._session = bidiSession;
    this._requests = /* @__PURE__ */ new Map();
    this._page = page;
    this._onNavigationResponseStarted = onNavigationResponseStarted;
    this._eventListeners = [
      eventsHelper.addEventListener(bidiSession, "network.beforeRequestSent", this._onBeforeRequestSent.bind(this)),
      eventsHelper.addEventListener(bidiSession, "network.responseStarted", this._onResponseStarted.bind(this)),
      eventsHelper.addEventListener(bidiSession, "network.responseCompleted", this._onResponseCompleted.bind(this)),
      eventsHelper.addEventListener(bidiSession, "network.fetchError", this._onFetchError.bind(this)),
      eventsHelper.addEventListener(bidiSession, "network.authRequired", this._onAuthRequired.bind(this))
    ];
  }
  dispose() {
    eventsHelper.removeEventListeners(this._eventListeners);
  }
  _onBeforeRequestSent(param) {
    if (param.request.url.startsWith("data:"))
      return;
    const redirectedFrom = param.redirectCount ? this._requests.get(param.request.request) || null : null;
    const frame = redirectedFrom ? redirectedFrom.request.frame() : param.context ? this._page._frameManager.frame(param.context) : null;
    if (!frame)
      return;
    if (redirectedFrom)
      this._requests.delete(redirectedFrom._id);
    let route;
    if (param.intercepts) {
      if (redirectedFrom) {
        let params = {};
        if (redirectedFrom._originalRequestRoute?._alreadyContinuedHeaders)
          params = toBidiRequestHeaders(redirectedFrom._originalRequestRoute._alreadyContinuedHeaders ?? []);
        this._session.sendMayFail("network.continueRequest", {
          request: param.request.request,
          ...params
        });
      } else {
        route = new BidiRouteImpl(this._session, param.request.request);
      }
    }
    const request4 = new BidiRequest(frame, redirectedFrom, param, route);
    this._requests.set(request4._id, request4);
    this._page._frameManager.requestStarted(request4.request, route);
  }
  _onResponseStarted(params) {
    const request4 = this._requests.get(params.request.request);
    if (!request4)
      return;
    const getResponseBody = /* @__PURE__ */ __name(async () => {
      throw new Error(`Response body is not available for requests in Bidi`);
    }, "getResponseBody");
    const timings = params.request.timings;
    const startTime = timings.requestTime;
    function relativeToStart(time3) {
      if (!time3)
        return -1;
      return time3 - startTime;
    }
    __name(relativeToStart, "relativeToStart");
    const timing = {
      startTime,
      requestStart: relativeToStart(timings.requestStart),
      responseStart: relativeToStart(timings.responseStart),
      domainLookupStart: relativeToStart(timings.dnsStart),
      domainLookupEnd: relativeToStart(timings.dnsEnd),
      connectStart: relativeToStart(timings.connectStart),
      secureConnectionStart: relativeToStart(timings.tlsStart),
      connectEnd: relativeToStart(timings.connectEnd)
    };
    const response = new Response2(request4.request, params.response.status, params.response.statusText, fromBidiHeaders(params.response.headers), timing, getResponseBody, false);
    response._serverAddrFinished();
    response._securityDetailsFinished();
    response.setRawResponseHeaders(null);
    response.setResponseHeadersSize(params.response.headersSize);
    this._page._frameManager.requestReceivedResponse(response);
    if (params.navigation)
      this._onNavigationResponseStarted(params);
  }
  _onResponseCompleted(params) {
    const request4 = this._requests.get(params.request.request);
    if (!request4)
      return;
    const response = request4.request._existingResponse();
    response.setTransferSize(params.response.bodySize);
    response.setEncodedBodySize(params.response.bodySize);
    const isRedirected = response.status() >= 300 && response.status() <= 399;
    const responseEndTime = params.request.timings.responseEnd - response.timing().startTime;
    if (isRedirected) {
      response._requestFinished(responseEndTime);
    } else {
      this._requests.delete(request4._id);
      response._requestFinished(responseEndTime);
    }
    response._setHttpVersion(params.response.protocol);
    this._page._frameManager.reportRequestFinished(request4.request, response);
  }
  _onFetchError(params) {
    const request4 = this._requests.get(params.request.request);
    if (!request4)
      return;
    this._requests.delete(request4._id);
    const response = request4.request._existingResponse();
    if (response) {
      response.setTransferSize(null);
      response.setEncodedBodySize(null);
      response._requestFinished(-1);
    }
    request4.request._setFailureText(params.errorText);
    this._page._frameManager.requestFailed(request4.request, params.errorText === "NS_BINDING_ABORTED");
  }
  _onAuthRequired(params) {
    const isBasic = params.response.authChallenges?.some((challenge) => challenge.scheme.startsWith("Basic"));
    const credentials = this._page._browserContext._options.httpCredentials;
    if (isBasic && credentials) {
      this._session.sendMayFail("network.continueWithAuth", {
        request: params.request.request,
        action: "provideCredentials",
        credentials: {
          type: "password",
          username: credentials.username,
          password: credentials.password
        }
      });
    } else {
      this._session.sendMayFail("network.continueWithAuth", {
        request: params.request.request,
        action: "default"
      });
    }
  }
  async setRequestInterception(value) {
    this._userRequestInterceptionEnabled = value;
    await this._updateProtocolRequestInterception();
  }
  async setCredentials(credentials) {
    this._credentials = credentials;
    await this._updateProtocolRequestInterception();
  }
  async _updateProtocolRequestInterception(initial) {
    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
    if (enabled === this._protocolRequestInterceptionEnabled)
      return;
    this._protocolRequestInterceptionEnabled = enabled;
    if (initial && !enabled)
      return;
    const cachePromise = this._session.send("network.setCacheBehavior", { cacheBehavior: enabled ? "bypass" : "default" });
    let interceptPromise = Promise.resolve(void 0);
    if (enabled) {
      interceptPromise = this._session.send("network.addIntercept", {
        phases: [Network2.InterceptPhase.AuthRequired, Network2.InterceptPhase.BeforeRequestSent],
        urlPatterns: [{ type: "pattern" }]
        // urlPatterns: [{ type: 'string', pattern: '*' }],
      }).then((r) => {
        this._intercepId = r.intercept;
      });
    } else if (this._intercepId) {
      interceptPromise = this._session.send("network.removeIntercept", { intercept: this._intercepId });
      this._intercepId = void 0;
    }
    await Promise.all([cachePromise, interceptPromise]);
  }
};
var BidiRequest = class {
  static {
    __name(this, "BidiRequest");
  }
  constructor(frame, redirectedFrom, payload, route) {
    this._id = payload.request.request;
    if (redirectedFrom)
      redirectedFrom._redirectedTo = this;
    const postDataBuffer = null;
    this.request = new Request(
      frame._page._browserContext,
      frame,
      null,
      redirectedFrom ? redirectedFrom.request : null,
      payload.navigation ?? void 0,
      payload.request.url,
      "other",
      payload.request.method,
      postDataBuffer,
      fromBidiHeaders(payload.request.headers)
    );
    this.request.setRawRequestHeaders(null);
    this.request._setBodySize(payload.request.bodySize || 0);
    this._originalRequestRoute = route ?? redirectedFrom?._originalRequestRoute;
    route?._setRequest(this.request);
  }
  _finalRequest() {
    let request4 = this;
    while (request4._redirectedTo)
      request4 = request4._redirectedTo;
    return request4;
  }
};
var BidiRouteImpl = class {
  static {
    __name(this, "BidiRouteImpl");
  }
  constructor(session2, requestId) {
    this._session = session2;
    this._requestId = requestId;
  }
  _setRequest(request4) {
    this._request = request4;
  }
  async continue(overrides) {
    let headers = overrides.headers || this._request.headers();
    if (overrides.postData && headers) {
      headers = headers.map((header) => {
        if (header.name.toLowerCase() === "content-length")
          return { name: header.name, value: overrides.postData.byteLength.toString() };
        return header;
      });
    }
    this._alreadyContinuedHeaders = headers;
    await this._session.sendMayFail("network.continueRequest", {
      request: this._requestId,
      url: overrides.url,
      method: overrides.method,
      ...toBidiRequestHeaders(this._alreadyContinuedHeaders),
      body: overrides.postData ? { type: "base64", value: Buffer.from(overrides.postData).toString("base64") } : void 0
    });
  }
  async fulfill(response) {
    const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
    await this._session.sendMayFail("network.provideResponse", {
      request: this._requestId,
      statusCode: response.status,
      reasonPhrase: statusText(response.status),
      ...toBidiResponseHeaders(response.headers),
      body: { type: "base64", value: base64body }
    });
  }
  async abort(errorCode) {
    await this._session.sendMayFail("network.failRequest", {
      request: this._requestId
    });
  }
};
function fromBidiHeaders(bidiHeaders) {
  const result = [];
  for (const { name, value } of bidiHeaders)
    result.push({ name, value: bidiBytesValueToString(value) });
  return result;
}
__name(fromBidiHeaders, "fromBidiHeaders");
function toBidiRequestHeaders(allHeaders) {
  const bidiHeaders = toBidiHeaders(allHeaders);
  return { headers: bidiHeaders };
}
__name(toBidiRequestHeaders, "toBidiRequestHeaders");
function toBidiResponseHeaders(headers) {
  const setCookieHeaders = headers.filter((h) => h.name.toLowerCase() === "set-cookie");
  const otherHeaders = headers.filter((h) => h.name.toLowerCase() !== "set-cookie");
  const rawCookies = setCookieHeaders.map((h) => parseRawCookie(h.value));
  const cookies = rawCookies.filter(Boolean).map((c) => {
    return {
      ...c,
      value: { type: "string", value: c.value },
      sameSite: toBidiSameSite(c.sameSite)
    };
  });
  return { cookies, headers: toBidiHeaders(otherHeaders) };
}
__name(toBidiResponseHeaders, "toBidiResponseHeaders");
function toBidiHeaders(headers) {
  return headers.map(({ name, value }) => ({ name, value: { type: "string", value } }));
}
__name(toBidiHeaders, "toBidiHeaders");
function bidiBytesValueToString(value) {
  if (value.type === "string")
    return value.value;
  if (value.type === "base64")
    return Buffer.from(value.type, "base64").toString("binary");
  return "unknown value type: " + value.type;
}
__name(bidiBytesValueToString, "bidiBytesValueToString");
function toBidiSameSite(sameSite) {
  if (!sameSite)
    return void 0;
  if (sameSite === "Strict")
    return Network2.SameSite.Strict;
  if (sameSite === "Lax")
    return Network2.SameSite.Lax;
  return Network2.SameSite.None;
}
__name(toBidiSameSite, "toBidiSameSite");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiPage.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiExecutionContext.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/third_party/bidiDeserializer.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BidiDeserializer = class _BidiDeserializer {
  static {
    __name(this, "BidiDeserializer");
  }
  static deserialize(result) {
    if (!result)
      return void 0;
    switch (result.type) {
      case "array":
        return result.value?.map((value) => {
          return _BidiDeserializer.deserialize(value);
        });
      case "set":
        return result.value?.reduce((acc, value) => {
          return acc.add(_BidiDeserializer.deserialize(value));
        }, /* @__PURE__ */ new Set());
      case "object":
        return result.value?.reduce((acc, tuple) => {
          const { key, value } = _BidiDeserializer._deserializeTuple(tuple);
          acc[key] = value;
          return acc;
        }, {});
      case "map":
        return result.value?.reduce((acc, tuple) => {
          const { key, value } = _BidiDeserializer._deserializeTuple(tuple);
          return acc.set(key, value);
        }, /* @__PURE__ */ new Map());
      case "promise":
        return {};
      case "regexp":
        return new RegExp(result.value.pattern, result.value.flags);
      case "date":
        return new Date(result.value);
      case "undefined":
        return void 0;
      case "null":
        return null;
      case "number":
        return _BidiDeserializer._deserializeNumber(result.value);
      case "bigint":
        return BigInt(result.value);
      case "boolean":
        return Boolean(result.value);
      case "string":
        return result.value;
    }
    throw new Error(`Deserialization of type ${result.type} not supported.`);
  }
  static _deserializeNumber(value) {
    switch (value) {
      case "-0":
        return -0;
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return -Infinity;
      default:
        return value;
    }
  }
  static _deserializeTuple([serializedKey, serializedValue]) {
    const key = typeof serializedKey === "string" ? serializedKey : _BidiDeserializer.deserialize(serializedKey);
    const value = _BidiDeserializer.deserialize(serializedValue);
    return { key, value };
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/third_party/bidiSerializer.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var UnserializableError = class extends Error {
  static {
    __name(this, "UnserializableError");
  }
};
var BidiSerializer = class _BidiSerializer {
  static {
    __name(this, "BidiSerializer");
  }
  static serialize(arg) {
    switch (typeof arg) {
      case "symbol":
      case "function":
        throw new UnserializableError(`Unable to serializable ${typeof arg}`);
      case "object":
        return _BidiSerializer._serializeObject(arg);
      case "undefined":
        return {
          type: "undefined"
        };
      case "number":
        return _BidiSerializer._serializeNumber(arg);
      case "bigint":
        return {
          type: "bigint",
          value: arg.toString()
        };
      case "string":
        return {
          type: "string",
          value: arg
        };
      case "boolean":
        return {
          type: "boolean",
          value: arg
        };
    }
  }
  static _serializeNumber(arg) {
    let value;
    if (Object.is(arg, -0)) {
      value = "-0";
    } else if (Object.is(arg, Infinity)) {
      value = "Infinity";
    } else if (Object.is(arg, -Infinity)) {
      value = "-Infinity";
    } else if (Object.is(arg, NaN)) {
      value = "NaN";
    } else {
      value = arg;
    }
    return {
      type: "number",
      value
    };
  }
  static _serializeObject(arg) {
    if (arg === null) {
      return {
        type: "null"
      };
    } else if (Array.isArray(arg)) {
      const parsedArray = arg.map((subArg) => {
        return _BidiSerializer.serialize(subArg);
      });
      return {
        type: "array",
        value: parsedArray
      };
    } else if (isPlainObject(arg)) {
      try {
        JSON.stringify(arg);
      } catch (error4) {
        if (error4 instanceof TypeError && error4.message.startsWith("Converting circular structure to JSON")) {
          error4.message += " Recursive objects are not allowed.";
        }
        throw error4;
      }
      const parsedObject = [];
      for (const key in arg) {
        parsedObject.push([_BidiSerializer.serialize(key), _BidiSerializer.serialize(arg[key])]);
      }
      return {
        type: "object",
        value: parsedObject
      };
    } else if (isRegExp6(arg)) {
      return {
        type: "regexp",
        value: {
          pattern: arg.source,
          flags: arg.flags
        }
      };
    } else if (isDate3(arg)) {
      return {
        type: "date",
        value: arg.toISOString()
      };
    }
    throw new UnserializableError(
      "Custom object serialization not possible. Use plain objects instead."
    );
  }
};
var isPlainObject = /* @__PURE__ */ __name((obj) => {
  return typeof obj === "object" && obj?.constructor === Object;
}, "isPlainObject");
var isRegExp6 = /* @__PURE__ */ __name((obj) => {
  return typeof obj === "object" && obj?.constructor === RegExp;
}, "isRegExp");
var isDate3 = /* @__PURE__ */ __name((obj) => {
  return typeof obj === "object" && obj?.constructor === Date;
}, "isDate");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiExecutionContext.js
var BidiExecutionContext = class {
  static {
    __name(this, "BidiExecutionContext");
  }
  constructor(session2, realmInfo) {
    this._session = session2;
    if (realmInfo.type === "window") {
      this._target = {
        context: realmInfo.context,
        sandbox: realmInfo.sandbox
      };
    } else {
      this._target = {
        realm: realmInfo.realm
      };
    }
  }
  async rawEvaluateJSON(expression) {
    const response = await this._session.send("script.evaluate", {
      expression,
      target: this._target,
      serializationOptions: {
        maxObjectDepth: 10,
        maxDomDepth: 10
      },
      awaitPromise: true,
      userActivation: true
    });
    if (response.type === "success")
      return BidiDeserializer.deserialize(response.result);
    if (response.type === "exception")
      throw new JavaScriptErrorInEvaluate(response.exceptionDetails.text + "\nFull val: " + JSON.stringify(response.exceptionDetails));
    throw new JavaScriptErrorInEvaluate("Unexpected response type: " + JSON.stringify(response));
  }
  async rawEvaluateHandle(context2, expression) {
    const response = await this._session.send("script.evaluate", {
      expression,
      target: this._target,
      resultOwnership: Script.ResultOwnership.Root,
      // Necessary for the handle to be returned.
      serializationOptions: { maxObjectDepth: 0, maxDomDepth: 0 },
      awaitPromise: true,
      userActivation: true
    });
    if (response.type === "success") {
      if ("handle" in response.result)
        return createHandle2(context2, response.result);
      throw new JavaScriptErrorInEvaluate("Cannot get handle: " + JSON.stringify(response.result));
    }
    if (response.type === "exception")
      throw new JavaScriptErrorInEvaluate(response.exceptionDetails.text + "\nFull val: " + JSON.stringify(response.exceptionDetails));
    throw new JavaScriptErrorInEvaluate("Unexpected response type: " + JSON.stringify(response));
  }
  async evaluateWithArguments(functionDeclaration, returnByValue, utilityScript, values, handles) {
    const response = await this._session.send("script.callFunction", {
      functionDeclaration,
      target: this._target,
      arguments: [
        { handle: utilityScript._objectId },
        ...values.map(BidiSerializer.serialize),
        ...handles.map((handle) => ({ handle: handle._objectId }))
      ],
      resultOwnership: returnByValue ? void 0 : Script.ResultOwnership.Root,
      // Necessary for the handle to be returned.
      serializationOptions: returnByValue ? {} : { maxObjectDepth: 0, maxDomDepth: 0 },
      awaitPromise: true,
      userActivation: true
    });
    if (response.type === "exception")
      throw new JavaScriptErrorInEvaluate(response.exceptionDetails.text + "\nFull val: " + JSON.stringify(response.exceptionDetails));
    if (response.type === "success") {
      if (returnByValue)
        return parseEvaluationResultValue(BidiDeserializer.deserialize(response.result));
      return createHandle2(utilityScript._context, response.result);
    }
    throw new JavaScriptErrorInEvaluate("Unexpected response type: " + JSON.stringify(response));
  }
  async getProperties(handle) {
    const names = await handle.evaluate((object) => {
      const names2 = [];
      const descriptors = Object.getOwnPropertyDescriptors(object);
      for (const name in descriptors) {
        if (descriptors[name]?.enumerable)
          names2.push(name);
      }
      return names2;
    });
    const values = await Promise.all(names.map((name) => handle.evaluateHandle((object, name2) => object[name2], name)));
    const map2 = /* @__PURE__ */ new Map();
    for (let i = 0; i < names.length; i++)
      map2.set(names[i], values[i]);
    return map2;
  }
  async releaseHandle(handle) {
    if (!handle._objectId)
      return;
    await this._session.send("script.disown", {
      target: this._target,
      handles: [handle._objectId]
    });
  }
  async nodeIdForElementHandle(handle) {
    const shared = await this._remoteValueForReference({ handle: handle._objectId });
    if (!("sharedId" in shared))
      throw new Error("Element is not a node");
    return {
      sharedId: shared.sharedId
    };
  }
  async remoteObjectForNodeId(context2, nodeId) {
    const result = await this._remoteValueForReference(nodeId, true);
    if (!("handle" in result))
      throw new Error("Can't get remote object for nodeId");
    return createHandle2(context2, result);
  }
  async contentFrameIdForFrame(handle) {
    const contentWindow = await this._rawCallFunction("e => e.contentWindow", { handle: handle._objectId });
    if (contentWindow?.type === "window")
      return contentWindow.value.context;
    return null;
  }
  async frameIdForWindowHandle(handle) {
    if (!handle._objectId)
      throw new Error("JSHandle is not a DOM node handle");
    const contentWindow = await this._remoteValueForReference({ handle: handle._objectId });
    if (contentWindow.type === "window")
      return contentWindow.value.context;
    return null;
  }
  async _remoteValueForReference(reference, createHandle22) {
    return await this._rawCallFunction("e => e", reference, createHandle22);
  }
  async _rawCallFunction(functionDeclaration, arg, createHandle22) {
    const response = await this._session.send("script.callFunction", {
      functionDeclaration,
      target: this._target,
      arguments: [arg],
      // "Root" is necessary for the handle to be returned.
      resultOwnership: createHandle22 ? Script.ResultOwnership.Root : Script.ResultOwnership.None,
      serializationOptions: { maxObjectDepth: 0, maxDomDepth: 0 },
      awaitPromise: true,
      userActivation: true
    });
    if (response.type === "exception")
      throw new JavaScriptErrorInEvaluate(response.exceptionDetails.text + "\nFull val: " + JSON.stringify(response.exceptionDetails));
    if (response.type === "success")
      return response.result;
    throw new JavaScriptErrorInEvaluate("Unexpected response type: " + JSON.stringify(response));
  }
};
function renderPreview2(remoteObject) {
  if (remoteObject.type === "undefined")
    return "undefined";
  if (remoteObject.type === "null")
    return "null";
  if ("value" in remoteObject)
    return String(remoteObject.value);
  return `<${remoteObject.type}>`;
}
__name(renderPreview2, "renderPreview");
function remoteObjectValue(remoteObject) {
  if (remoteObject.type === "undefined")
    return void 0;
  if (remoteObject.type === "null")
    return null;
  if (remoteObject.type === "number" && typeof remoteObject.value === "string")
    return parseUnserializableValue(remoteObject.value);
  if ("value" in remoteObject)
    return remoteObject.value;
  return void 0;
}
__name(remoteObjectValue, "remoteObjectValue");
function createHandle2(context2, remoteObject) {
  if (remoteObject.type === "node") {
    assert3(context2 instanceof FrameExecutionContext);
    return new ElementHandle(context2, remoteObject.handle);
  }
  const objectId = "handle" in remoteObject ? remoteObject.handle : void 0;
  return new JSHandle(context2, remoteObject.type, renderPreview2(remoteObject), objectId, remoteObjectValue(remoteObject));
}
__name(createHandle2, "createHandle");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiInput.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/third_party/bidiKeyboard.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var getBidiKeyValue = /* @__PURE__ */ __name((keyName) => {
  switch (keyName) {
    case "\r":
    case "\n":
      keyName = "Enter";
      break;
  }
  if ([...keyName].length === 1) {
    return keyName;
  }
  switch (keyName) {
    case "Cancel":
      return "\uE001";
    case "Help":
      return "\uE002";
    case "Backspace":
      return "\uE003";
    case "Tab":
      return "\uE004";
    case "Clear":
      return "\uE005";
    case "Enter":
      return "\uE007";
    case "Shift":
    case "ShiftLeft":
      return "\uE008";
    case "Control":
    case "ControlLeft":
      return "\uE009";
    case "Alt":
    case "AltLeft":
      return "\uE00A";
    case "Pause":
      return "\uE00B";
    case "Escape":
      return "\uE00C";
    case "PageUp":
      return "\uE00E";
    case "PageDown":
      return "\uE00F";
    case "End":
      return "\uE010";
    case "Home":
      return "\uE011";
    case "ArrowLeft":
      return "\uE012";
    case "ArrowUp":
      return "\uE013";
    case "ArrowRight":
      return "\uE014";
    case "ArrowDown":
      return "\uE015";
    case "Insert":
      return "\uE016";
    case "Delete":
      return "\uE017";
    case "NumpadEqual":
      return "\uE019";
    case "Numpad0":
      return "\uE01A";
    case "Numpad1":
      return "\uE01B";
    case "Numpad2":
      return "\uE01C";
    case "Numpad3":
      return "\uE01D";
    case "Numpad4":
      return "\uE01E";
    case "Numpad5":
      return "\uE01F";
    case "Numpad6":
      return "\uE020";
    case "Numpad7":
      return "\uE021";
    case "Numpad8":
      return "\uE022";
    case "Numpad9":
      return "\uE023";
    case "NumpadMultiply":
      return "\uE024";
    case "NumpadAdd":
      return "\uE025";
    case "NumpadSubtract":
      return "\uE027";
    case "NumpadDecimal":
      return "\uE028";
    case "NumpadDivide":
      return "\uE029";
    case "F1":
      return "\uE031";
    case "F2":
      return "\uE032";
    case "F3":
      return "\uE033";
    case "F4":
      return "\uE034";
    case "F5":
      return "\uE035";
    case "F6":
      return "\uE036";
    case "F7":
      return "\uE037";
    case "F8":
      return "\uE038";
    case "F9":
      return "\uE039";
    case "F10":
      return "\uE03A";
    case "F11":
      return "\uE03B";
    case "F12":
      return "\uE03C";
    case "Meta":
    case "MetaLeft":
      return "\uE03D";
    case "ShiftRight":
      return "\uE050";
    case "ControlRight":
      return "\uE051";
    case "AltRight":
      return "\uE052";
    case "MetaRight":
      return "\uE053";
    case "Space":
      return " ";
    case "Digit0":
      return "0";
    case "Digit1":
      return "1";
    case "Digit2":
      return "2";
    case "Digit3":
      return "3";
    case "Digit4":
      return "4";
    case "Digit5":
      return "5";
    case "Digit6":
      return "6";
    case "Digit7":
      return "7";
    case "Digit8":
      return "8";
    case "Digit9":
      return "9";
    case "KeyA":
      return "a";
    case "KeyB":
      return "b";
    case "KeyC":
      return "c";
    case "KeyD":
      return "d";
    case "KeyE":
      return "e";
    case "KeyF":
      return "f";
    case "KeyG":
      return "g";
    case "KeyH":
      return "h";
    case "KeyI":
      return "i";
    case "KeyJ":
      return "j";
    case "KeyK":
      return "k";
    case "KeyL":
      return "l";
    case "KeyM":
      return "m";
    case "KeyN":
      return "n";
    case "KeyO":
      return "o";
    case "KeyP":
      return "p";
    case "KeyQ":
      return "q";
    case "KeyR":
      return "r";
    case "KeyS":
      return "s";
    case "KeyT":
      return "t";
    case "KeyU":
      return "u";
    case "KeyV":
      return "v";
    case "KeyW":
      return "w";
    case "KeyX":
      return "x";
    case "KeyY":
      return "y";
    case "KeyZ":
      return "z";
    case "Semicolon":
      return ";";
    case "Equal":
      return "=";
    case "Comma":
      return ",";
    case "Minus":
      return "-";
    case "Period":
      return ".";
    case "Slash":
      return "/";
    case "Backquote":
      return "`";
    case "BracketLeft":
      return "[";
    case "Backslash":
      return "\\";
    case "BracketRight":
      return "]";
    case "Quote":
      return '"';
    default:
      throw new Error(`Unknown key: "${keyName}"`);
  }
}, "getBidiKeyValue");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiInput.js
var RawKeyboardImpl2 = class {
  static {
    __name(this, "RawKeyboardImpl");
  }
  constructor(session2) {
    this._session = session2;
  }
  setSession(session2) {
    this._session = session2;
  }
  async keydown(modifiers, keyName, description, autoRepeat) {
    keyName = resolveSmartModifierString(keyName);
    const actions = [];
    actions.push({ type: "keyDown", value: getBidiKeyValue(keyName) });
    await this._performActions(actions);
  }
  async keyup(modifiers, keyName, description) {
    keyName = resolveSmartModifierString(keyName);
    const actions = [];
    actions.push({ type: "keyUp", value: getBidiKeyValue(keyName) });
    await this._performActions(actions);
  }
  async sendText(text) {
    const actions = [];
    for (const char of text) {
      const value = getBidiKeyValue(char);
      actions.push({ type: "keyDown", value });
      actions.push({ type: "keyUp", value });
    }
    await this._performActions(actions);
  }
  async _performActions(actions) {
    await this._session.send("input.performActions", {
      context: this._session.sessionId,
      actions: [
        {
          type: "key",
          id: "pw_keyboard",
          actions
        }
      ]
    });
  }
};
var RawMouseImpl2 = class {
  static {
    __name(this, "RawMouseImpl");
  }
  constructor(session2) {
    this._session = session2;
  }
  async move(x, y, button, buttons, modifiers, forClick) {
    await this._performActions([{ type: "pointerMove", x, y }]);
  }
  async down(x, y, button, buttons, modifiers, clickCount) {
    await this._performActions([{ type: "pointerDown", button: toBidiButton(button) }]);
  }
  async up(x, y, button, buttons, modifiers, clickCount) {
    await this._performActions([{ type: "pointerUp", button: toBidiButton(button) }]);
  }
  async wheel(x, y, buttons, modifiers, deltaX, deltaY) {
    x = Math.floor(x);
    y = Math.floor(y);
    await this._session.send("input.performActions", {
      context: this._session.sessionId,
      actions: [
        {
          type: "wheel",
          id: "pw_mouse_wheel",
          actions: [{ type: "scroll", x, y, deltaX, deltaY }]
        }
      ]
    });
  }
  async _performActions(actions) {
    await this._session.send("input.performActions", {
      context: this._session.sessionId,
      actions: [
        {
          type: "pointer",
          id: "pw_mouse",
          parameters: {
            pointerType: Input.PointerType.Mouse
          },
          actions
        }
      ]
    });
  }
};
var RawTouchscreenImpl2 = class {
  static {
    __name(this, "RawTouchscreenImpl");
  }
  constructor(session2) {
    this._session = session2;
  }
  async tap(x, y, modifiers) {
  }
};
function toBidiButton(button) {
  switch (button) {
    case "left":
      return 0;
    case "right":
      return 2;
    case "middle":
      return 1;
  }
  throw new Error("Unknown button: " + button);
}
__name(toBidiButton, "toBidiButton");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiPdf.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var PagePaperFormats2 = {
  letter: { width: 8.5, height: 11 },
  legal: { width: 8.5, height: 14 },
  tabloid: { width: 11, height: 17 },
  ledger: { width: 17, height: 11 },
  a0: { width: 33.1, height: 46.8 },
  a1: { width: 23.4, height: 33.1 },
  a2: { width: 16.54, height: 23.4 },
  a3: { width: 11.7, height: 16.54 },
  a4: { width: 8.27, height: 11.7 },
  a5: { width: 5.83, height: 8.27 },
  a6: { width: 4.13, height: 5.83 }
};
var unitToPixels2 = {
  "px": 1,
  "in": 96,
  "cm": 37.8,
  "mm": 3.78
};
function convertPrintParameterToInches2(text) {
  if (text === void 0)
    return void 0;
  let unit = text.substring(text.length - 2).toLowerCase();
  let valueText = "";
  if (unitToPixels2.hasOwnProperty(unit)) {
    valueText = text.substring(0, text.length - 2);
  } else {
    unit = "px";
    valueText = text;
  }
  const value = Number(valueText);
  assert3(!isNaN(value), "Failed to parse parameter value: " + text);
  const pixels = value * unitToPixels2[unit];
  return pixels / 96;
}
__name(convertPrintParameterToInches2, "convertPrintParameterToInches");
var BidiPDF = class {
  static {
    __name(this, "BidiPDF");
  }
  constructor(session2) {
    this._session = session2;
  }
  async generate(options2) {
    const {
      scale = 1,
      printBackground = false,
      landscape = false,
      pageRanges = "",
      margin = {}
    } = options2;
    let paperWidth = 8.5;
    let paperHeight = 11;
    if (options2.format) {
      const format2 = PagePaperFormats2[options2.format.toLowerCase()];
      assert3(format2, "Unknown paper format: " + options2.format);
      paperWidth = format2.width;
      paperHeight = format2.height;
    } else {
      paperWidth = convertPrintParameterToInches2(options2.width) || paperWidth;
      paperHeight = convertPrintParameterToInches2(options2.height) || paperHeight;
    }
    const { data } = await this._session.send("browsingContext.print", {
      context: this._session.sessionId,
      background: printBackground,
      margin: {
        bottom: convertPrintParameterToInches2(margin.bottom) || 0,
        left: convertPrintParameterToInches2(margin.left) || 0,
        right: convertPrintParameterToInches2(margin.right) || 0,
        top: convertPrintParameterToInches2(margin.top) || 0
      },
      orientation: landscape ? "landscape" : "portrait",
      page: {
        width: paperWidth,
        height: paperHeight
      },
      pageRanges: pageRanges ? pageRanges.split(",").map((r) => r.trim()) : void 0,
      scale
    });
    return Buffer.from(data, "base64");
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiPage.js
var UTILITY_WORLD_NAME2 = "__playwright_utility_world__";
var kPlaywrightBindingChannel = "playwrightChannel";
var BidiPage = class {
  static {
    __name(this, "BidiPage");
  }
  constructor(browserContext, bidiSession, opener) {
    this._sessionListeners = [];
    this._initScriptIds = [];
    this._session = bidiSession;
    this._opener = opener;
    this.rawKeyboard = new RawKeyboardImpl2(bidiSession);
    this.rawMouse = new RawMouseImpl2(bidiSession);
    this.rawTouchscreen = new RawTouchscreenImpl2(bidiSession);
    this._realmToContext = /* @__PURE__ */ new Map();
    this._page = new Page(this, browserContext);
    this._browserContext = browserContext;
    this._networkManager = new BidiNetworkManager(this._session, this._page, this._onNavigationResponseStarted.bind(this));
    this._pdf = new BidiPDF(this._session);
    this._page.on(Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame, false));
    this._sessionListeners = [
      eventsHelper.addEventListener(bidiSession, "script.realmCreated", this._onRealmCreated.bind(this)),
      eventsHelper.addEventListener(bidiSession, "script.message", this._onScriptMessage.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.contextDestroyed", this._onBrowsingContextDestroyed.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.navigationStarted", this._onNavigationStarted.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.navigationAborted", this._onNavigationAborted.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.navigationFailed", this._onNavigationFailed.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.fragmentNavigated", this._onFragmentNavigated.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.domContentLoaded", this._onDomContentLoaded.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.load", this._onLoad.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.userPromptOpened", this._onUserPromptOpened.bind(this)),
      eventsHelper.addEventListener(bidiSession, "log.entryAdded", this._onLogEntryAdded.bind(this))
    ];
    this._initialize().then(
      () => this._page.reportAsNew(this._opener?._page),
      (error4) => this._page.reportAsNew(this._opener?._page, error4)
    );
  }
  async _initialize() {
    this._onFrameAttached(this._session.sessionId, null);
    await Promise.all([
      this.updateHttpCredentials(),
      this.updateRequestInterception(),
      this._installMainBinding(),
      this._addAllInitScripts()
    ]);
  }
  async _addAllInitScripts() {
    return Promise.all(this._page.allInitScripts().map((initScript) => this.addInitScript(initScript)));
  }
  didClose() {
    this._session.dispose();
    eventsHelper.removeEventListeners(this._sessionListeners);
    this._page._didClose();
  }
  _onFrameAttached(frameId, parentFrameId) {
    return this._page._frameManager.frameAttached(frameId, parentFrameId);
  }
  _removeContextsForFrame(frame, notifyFrame) {
    for (const [contextId, context2] of this._realmToContext) {
      if (context2.frame === frame) {
        this._realmToContext.delete(contextId);
        if (notifyFrame)
          frame._contextDestroyed(context2);
      }
    }
  }
  _onRealmCreated(realmInfo) {
    if (this._realmToContext.has(realmInfo.realm))
      return;
    if (realmInfo.type !== "window")
      return;
    const frame = this._page._frameManager.frame(realmInfo.context);
    if (!frame)
      return;
    let worldName;
    if (!realmInfo.sandbox) {
      worldName = "main";
      this._touchUtilityWorld(realmInfo.context);
    } else if (realmInfo.sandbox === UTILITY_WORLD_NAME2) {
      worldName = "utility";
    } else {
      return;
    }
    const delegate = new BidiExecutionContext(this._session, realmInfo);
    const context2 = new FrameExecutionContext(delegate, frame, worldName);
    frame._contextCreated(worldName, context2);
    this._realmToContext.set(realmInfo.realm, context2);
  }
  async _touchUtilityWorld(context2) {
    await this._session.sendMayFail("script.evaluate", {
      expression: "1 + 1",
      target: {
        context: context2,
        sandbox: UTILITY_WORLD_NAME2
      },
      serializationOptions: {
        maxObjectDepth: 10,
        maxDomDepth: 10
      },
      awaitPromise: true,
      userActivation: true
    });
  }
  _onRealmDestroyed(params) {
    const context2 = this._realmToContext.get(params.realm);
    if (!context2)
      return false;
    this._realmToContext.delete(params.realm);
    context2.frame._contextDestroyed(context2);
    return true;
  }
  // TODO: route the message directly to the browser
  _onBrowsingContextDestroyed(params) {
    this._browserContext._browser._onBrowsingContextDestroyed(params);
  }
  _onNavigationStarted(params) {
    const frameId = params.context;
    this._page._frameManager.frameRequestedNavigation(frameId, params.navigation);
    const url4 = params.url.toLowerCase();
    if (url4.startsWith("file:") || url4.startsWith("data:") || url4 === "about:blank") {
      const frame = this._page._frameManager.frame(frameId);
      if (frame)
        this._page._frameManager.frameCommittedNewDocumentNavigation(
          frameId,
          params.url,
          "",
          params.navigation,
          /* initial */
          false
        );
    }
  }
  // TODO: there is no separate event for committed navigation, so we approximate it with responseStarted.
  _onNavigationResponseStarted(params) {
    const frameId = params.context;
    const frame = this._page._frameManager.frame(frameId);
    assert3(frame);
    this._page._frameManager.frameCommittedNewDocumentNavigation(
      frameId,
      params.response.url,
      "",
      params.navigation,
      /* initial */
      false
    );
  }
  _onDomContentLoaded(params) {
    const frameId = params.context;
    this._page._frameManager.frameLifecycleEvent(frameId, "domcontentloaded");
  }
  _onLoad(params) {
    this._page._frameManager.frameLifecycleEvent(params.context, "load");
  }
  _onNavigationAborted(params) {
    this._page._frameManager.frameAbortedNavigation(params.context, "Navigation aborted", params.navigation || void 0);
  }
  _onNavigationFailed(params) {
    this._page._frameManager.frameAbortedNavigation(params.context, "Navigation failed", params.navigation || void 0);
  }
  _onFragmentNavigated(params) {
    this._page._frameManager.frameCommittedSameDocumentNavigation(params.context, params.url);
  }
  _onUserPromptOpened(event) {
    this._page.emitOnContext(BrowserContext.Events.Dialog, new Dialog(
      this._page,
      event.type,
      event.message,
      async (accept, userText) => {
        await this._session.send("browsingContext.handleUserPrompt", { context: event.context, accept, userText });
      },
      event.defaultValue
    ));
  }
  _onLogEntryAdded(params) {
    if (params.type !== "console")
      return;
    const entry = params;
    const context2 = this._realmToContext.get(params.source.realm);
    if (!context2)
      return;
    const callFrame = params.stackTrace?.callFrames[0];
    const location2 = callFrame ?? { url: "", lineNumber: 1, columnNumber: 1 };
    this._page._addConsoleMessage(entry.method, entry.args.map((arg) => createHandle2(context2, arg)), location2, params.text || void 0);
  }
  async navigateFrame(frame, url4, referrer) {
    const { navigation } = await this._session.send("browsingContext.navigate", {
      context: frame._id,
      url: url4
    });
    return { newDocumentId: navigation || void 0 };
  }
  async updateExtraHTTPHeaders() {
  }
  async updateEmulateMedia() {
  }
  async updateUserAgent() {
  }
  async bringToFront() {
    await this._session.send("browsingContext.activate", {
      context: this._session.sessionId
    });
  }
  async updateEmulatedViewportSize() {
    const options2 = this._browserContext._options;
    const deviceSize = this._page.emulatedSize();
    if (deviceSize === null)
      return;
    const viewportSize = deviceSize.viewport;
    await this._session.send("browsingContext.setViewport", {
      context: this._session.sessionId,
      viewport: {
        width: viewportSize.width,
        height: viewportSize.height
      },
      devicePixelRatio: options2.deviceScaleFactor || 1
    });
  }
  async updateRequestInterception() {
    await this._networkManager.setRequestInterception(this._page.needsRequestInterception());
  }
  async updateOffline() {
  }
  async updateHttpCredentials() {
    await this._networkManager.setCredentials(this._browserContext._options.httpCredentials);
  }
  async updateFileChooserInterception() {
  }
  async reload() {
    await this._session.send("browsingContext.reload", {
      context: this._session.sessionId,
      // ignoreCache: true,
      wait: BrowsingContext.ReadinessState.Interactive
    });
  }
  async goBack() {
    return await this._session.send("browsingContext.traverseHistory", {
      context: this._session.sessionId,
      delta: -1
    }).then(() => true).catch(() => false);
  }
  async goForward() {
    return await this._session.send("browsingContext.traverseHistory", {
      context: this._session.sessionId,
      delta: 1
    }).then(() => true).catch(() => false);
  }
  async requestGC() {
    throw new Error("Method not implemented.");
  }
  // TODO: consider calling this only when bindings are added.
  // TODO: delete this method once we can add preload script for persistent context.
  async _installMainBinding() {
    if (this._browserContext._browserContextId)
      return;
    const functionDeclaration = addMainBinding.toString();
    const args = [{
      type: "channel",
      value: {
        channel: kPlaywrightBindingChannel,
        ownership: Script.ResultOwnership.Root
      }
    }];
    const promises2 = [];
    promises2.push(this._session.send("script.addPreloadScript", {
      functionDeclaration,
      arguments: args
    }));
    promises2.push(this._session.send("script.callFunction", {
      functionDeclaration,
      arguments: args,
      target: toBidiExecutionContext(await this._page.mainFrame()._mainContext())._target,
      awaitPromise: false,
      userActivation: false
    }));
    await Promise.all(promises2);
  }
  async _onScriptMessage(event) {
    if (event.channel !== kPlaywrightBindingChannel)
      return;
    const pageOrError = await this._page.waitForInitializedOrError();
    if (pageOrError instanceof Error)
      return;
    const context2 = this._realmToContext.get(event.source.realm);
    if (!context2)
      return;
    if (event.data.type !== "string")
      return;
    await this._page._onBindingCalled(event.data.value, context2);
  }
  async addInitScript(initScript) {
    const { script } = await this._session.send("script.addPreloadScript", {
      // TODO: remove function call from the source.
      functionDeclaration: `() => { return ${initScript.source} }`,
      // TODO: push to iframes?
      contexts: [this._session.sessionId]
    });
    if (!initScript.internal)
      this._initScriptIds.push(script);
  }
  async removeNonInternalInitScripts() {
    const promises2 = this._initScriptIds.map((script) => this._session.send("script.removePreloadScript", { script }));
    this._initScriptIds = [];
    await Promise.all(promises2);
  }
  async closePage(runBeforeUnload) {
    await this._session.send("browsingContext.close", {
      context: this._session.sessionId,
      promptUnload: runBeforeUnload
    });
  }
  async setBackgroundColor(color) {
  }
  async takeScreenshot(progress3, format2, documentRect, viewportRect, quality, fitsViewport, scale) {
    const rect = documentRect || viewportRect;
    const { data } = await this._session.send("browsingContext.captureScreenshot", {
      context: this._session.sessionId,
      format: {
        type: `image/${format2 === "png" ? "png" : "jpeg"}`,
        quality: quality ? quality / 100 : 0.8
      },
      origin: documentRect ? "document" : "viewport",
      clip: {
        type: "box",
        ...rect
      }
    });
    return Buffer.from(data, "base64");
  }
  async getContentFrame(handle) {
    const executionContext = toBidiExecutionContext(handle._context);
    const frameId = await executionContext.contentFrameIdForFrame(handle);
    if (!frameId)
      return null;
    return this._page._frameManager.frame(frameId);
  }
  async getOwnerFrame(handle) {
    const windowHandle = await handle.evaluateHandle((node2) => {
      const doc = node2.ownerDocument ?? node2;
      return doc.defaultView;
    });
    if (!windowHandle)
      return null;
    const executionContext = toBidiExecutionContext(handle._context);
    return executionContext.frameIdForWindowHandle(windowHandle);
  }
  async getBoundingBox(handle) {
    const box = await handle.evaluate((element) => {
      if (!(element instanceof Element))
        return null;
      const rect = element.getBoundingClientRect();
      return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
    });
    if (!box)
      return null;
    const position = await this._framePosition(handle._frame);
    if (!position)
      return null;
    box.x += position.x;
    box.y += position.y;
    return box;
  }
  // TODO: move to Frame.
  async _framePosition(frame) {
    if (frame === this._page.mainFrame())
      return { x: 0, y: 0 };
    const element = await frame.frameElement();
    const box = await element.boundingBox();
    if (!box)
      return null;
    const style = await element.evaluateInUtility(([injected, iframe]) => injected.describeIFrameStyle(iframe), {}).catch((e) => "error:notconnected");
    if (style === "error:notconnected" || style === "transformed")
      return null;
    box.x += style.left;
    box.y += style.top;
    return box;
  }
  async scrollRectIntoViewIfNeeded(handle, rect) {
    return await handle.evaluateInUtility(([injected, node2]) => {
      node2.scrollIntoView({
        block: "center",
        inline: "center",
        behavior: "instant"
      });
    }, null).then(() => "done").catch((e) => {
      if (e instanceof Error && e.message.includes("Node is detached from document"))
        return "error:notconnected";
      if (e instanceof Error && e.message.includes("Node does not have a layout object"))
        return "error:notvisible";
      throw e;
    });
  }
  async setScreencastOptions(options2) {
  }
  rafCountForStablePosition() {
    return 1;
  }
  async getContentQuads(handle) {
    const quads = await handle.evaluateInUtility(([injected, node2]) => {
      if (!node2.isConnected)
        return "error:notconnected";
      const rects = node2.getClientRects();
      if (!rects)
        return null;
      return [...rects].map((rect) => [
        { x: rect.left, y: rect.top },
        { x: rect.right, y: rect.top },
        { x: rect.right, y: rect.bottom },
        { x: rect.left, y: rect.bottom }
      ]);
    }, null);
    if (!quads || quads === "error:notconnected")
      return quads;
    const position = await this._framePosition(handle._frame);
    if (!position)
      return null;
    quads.forEach((quad) => quad.forEach((point) => {
      point.x += position.x;
      point.y += position.y;
    }));
    return quads;
  }
  async setInputFilePaths(handle, paths) {
    const fromContext = toBidiExecutionContext(handle._context);
    await this._session.send("input.setFiles", {
      context: this._session.sessionId,
      element: await fromContext.nodeIdForElementHandle(handle),
      files: paths
    });
  }
  async adoptElementHandle(handle, to) {
    const fromContext = toBidiExecutionContext(handle._context);
    const nodeId = await fromContext.nodeIdForElementHandle(handle);
    const executionContext = toBidiExecutionContext(to);
    return await executionContext.remoteObjectForNodeId(to, nodeId);
  }
  async getAccessibilityTree(needle) {
    throw new Error("Method not implemented.");
  }
  async inputActionEpilogue() {
  }
  async resetForReuse() {
  }
  async pdf(options2) {
    return this._pdf.generate(options2);
  }
  async getFrameElement(frame) {
    const parent = frame.parentFrame();
    if (!parent)
      throw new Error("Frame has been detached.");
    const parentContext = await parent._mainContext();
    const list = await parentContext.evaluateHandle(() => {
      return [...document.querySelectorAll("iframe,frame")];
    });
    const length = await list.evaluate((list2) => list2.length);
    let foundElement = null;
    for (let i = 0; i < length; i++) {
      const element = await list.evaluateHandle((list2, i2) => list2[i2], i);
      const candidate = await element.contentFrame();
      if (frame === candidate) {
        foundElement = element;
        break;
      } else {
        element.dispose();
      }
    }
    list.dispose();
    if (!foundElement)
      throw new Error("Frame has been detached.");
    return foundElement;
  }
  shouldToggleStyleSheetToSyncAnimations() {
    return true;
  }
};
function addMainBinding(callback) {
  globalThis["__playwright__binding__"] = callback;
}
__name(addMainBinding, "addMainBinding");
function toBidiExecutionContext(executionContext) {
  return executionContext.delegate;
}
__name(toBidiExecutionContext, "toBidiExecutionContext");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiBrowser.js
var BidiBrowser = class _BidiBrowser extends Browser {
  static {
    __name(this, "BidiBrowser");
  }
  constructor(parent, transport, options2) {
    super(parent, options2);
    this._contexts = /* @__PURE__ */ new Map();
    this._bidiPages = /* @__PURE__ */ new Map();
    this._connection = new BidiConnection(transport, this._onDisconnect.bind(this), options2.protocolLogger, options2.browserLogsCollector);
    this._browserSession = this._connection.browserSession;
    this._eventListeners = [
      eventsHelper.addEventListener(this._browserSession, "browsingContext.contextCreated", this._onBrowsingContextCreated.bind(this)),
      eventsHelper.addEventListener(this._browserSession, "script.realmDestroyed", this._onScriptRealmDestroyed.bind(this))
    ];
  }
  static async connect(parent, transport, options2) {
    const browser3 = new _BidiBrowser(parent, transport, options2);
    if (options2.__testHookOnConnectToBrowser)
      await options2.__testHookOnConnectToBrowser();
    let proxy;
    if (options2.proxy) {
      proxy = {
        proxyType: "manual"
      };
      const url4 = new URL(options2.proxy.server);
      switch (url4.protocol) {
        case "http:":
          proxy.httpProxy = url4.host;
          break;
        case "https:":
          proxy.httpsProxy = url4.host;
          break;
        case "socks4:":
          proxy.socksProxy = url4.host;
          proxy.socksVersion = 4;
          break;
        case "socks5:":
          proxy.socksProxy = url4.host;
          proxy.socksVersion = 5;
          break;
        default:
          throw new Error("Invalid proxy server protocol: " + options2.proxy.server);
      }
      if (options2.proxy.bypass)
        proxy.noProxy = options2.proxy.bypass.split(",");
    }
    browser3._bidiSessionInfo = await browser3._browserSession.send("session.new", {
      capabilities: {
        alwaysMatch: {
          acceptInsecureCerts: false,
          proxy,
          unhandledPromptBehavior: {
            default: Session2.UserPromptHandlerType.Ignore
          },
          webSocketUrl: true
        }
      }
    });
    await browser3._browserSession.send("session.subscribe", {
      events: [
        "browsingContext",
        "network",
        "log",
        "script"
      ]
    });
    if (options2.persistent) {
      const context2 = new BidiBrowserContext(browser3, void 0, options2.persistent);
      browser3._defaultContext = context2;
      await context2._initialize();
      const page = await browser3._defaultContext.doCreateNewPage();
      await page.waitForInitializedOrError();
    }
    return browser3;
  }
  _onDisconnect() {
    this._didClose();
  }
  async doCreateNewContext(options2) {
    const { userContext } = await this._browserSession.send("browser.createUserContext", {});
    const context2 = new BidiBrowserContext(this, userContext, options2);
    await context2._initialize();
    this._contexts.set(userContext, context2);
    return context2;
  }
  contexts() {
    return Array.from(this._contexts.values());
  }
  version() {
    return this._bidiSessionInfo.capabilities.browserVersion;
  }
  userAgent() {
    return this._bidiSessionInfo.capabilities.userAgent;
  }
  isConnected() {
    return !this._connection.isClosed();
  }
  _onBrowsingContextCreated(event) {
    if (event.parent) {
      const parentFrameId = event.parent;
      for (const page2 of this._bidiPages.values()) {
        const parentFrame = page2._page._frameManager.frame(parentFrameId);
        if (!parentFrame)
          continue;
        page2._session.addFrameBrowsingContext(event.context);
        page2._page._frameManager.frameAttached(event.context, parentFrameId);
        const frame = page2._page._frameManager.frame(event.context);
        if (frame)
          frame._url = event.url;
        return;
      }
      return;
    }
    let context2 = this._contexts.get(event.userContext);
    if (!context2)
      context2 = this._defaultContext;
    if (!context2)
      return;
    const session2 = this._connection.createMainFrameBrowsingContextSession(event.context);
    const opener = event.originalOpener && this._bidiPages.get(event.originalOpener);
    const page = new BidiPage(context2, session2, opener || null);
    page._page.mainFrame()._url = event.url;
    this._bidiPages.set(event.context, page);
  }
  _onBrowsingContextDestroyed(event) {
    if (event.parent) {
      this._browserSession.removeFrameBrowsingContext(event.context);
      const parentFrameId = event.parent;
      for (const page of this._bidiPages.values()) {
        const parentFrame = page._page._frameManager.frame(parentFrameId);
        if (!parentFrame)
          continue;
        page._page._frameManager.frameDetached(event.context);
        return;
      }
      return;
    }
    const bidiPage = this._bidiPages.get(event.context);
    if (!bidiPage)
      return;
    bidiPage.didClose();
    this._bidiPages.delete(event.context);
  }
  _onScriptRealmDestroyed(event) {
    for (const page of this._bidiPages.values()) {
      if (page._onRealmDestroyed(event))
        return;
    }
  }
};
var BidiBrowserContext = class extends BrowserContext {
  static {
    __name(this, "BidiBrowserContext");
  }
  constructor(browser3, browserContextId, options2) {
    super(browser3, options2, browserContextId);
    this._initScriptIds = [];
    this._originToPermissions = /* @__PURE__ */ new Map();
    this._authenticateProxyViaHeader();
  }
  _bidiPages() {
    return [...this._browser._bidiPages.values()].filter((bidiPage) => bidiPage._browserContext === this);
  }
  async _initialize() {
    const promises2 = [
      super._initialize(),
      this._installMainBinding()
    ];
    if (this._options.viewport) {
      promises2.push(this._browser._browserSession.send("browsingContext.setViewport", {
        viewport: {
          width: this._options.viewport.width,
          height: this._options.viewport.height
        },
        devicePixelRatio: this._options.deviceScaleFactor || 1,
        userContexts: [this._userContextId()]
      }));
    }
    if (this._options.geolocation)
      promises2.push(this.setGeolocation(this._options.geolocation));
    await Promise.all(promises2);
  }
  // TODO: consider calling this only when bindings are added.
  async _installMainBinding() {
    const functionDeclaration = addMainBinding.toString();
    const args = [{
      type: "channel",
      value: {
        channel: kPlaywrightBindingChannel,
        ownership: Script.ResultOwnership.Root
      }
    }];
    await this._browser._browserSession.send("script.addPreloadScript", {
      functionDeclaration,
      arguments: args,
      userContexts: [this._userContextId()]
    });
  }
  possiblyUninitializedPages() {
    return this._bidiPages().map((bidiPage) => bidiPage._page);
  }
  async doCreateNewPage() {
    assertBrowserContextIsNotOwned(this);
    const { context: context2 } = await this._browser._browserSession.send("browsingContext.create", {
      type: BrowsingContext.CreateType.Window,
      userContext: this._browserContextId
    });
    return this._browser._bidiPages.get(context2)._page;
  }
  async doGetCookies(urls) {
    const { cookies } = await this._browser._browserSession.send(
      "storage.getCookies",
      { partition: { type: "storageKey", userContext: this._browserContextId } }
    );
    return filterCookies(cookies.map((c) => {
      const copy = {
        name: c.name,
        value: bidiBytesValueToString(c.value),
        domain: c.domain,
        path: c.path,
        httpOnly: c.httpOnly,
        secure: c.secure,
        expires: c.expiry ?? -1,
        sameSite: c.sameSite ? fromBidiSameSite(c.sameSite) : "None"
      };
      return copy;
    }), urls);
  }
  async addCookies(cookies) {
    cookies = rewriteCookies(cookies);
    const promises2 = cookies.map((c) => {
      const cookie = {
        name: c.name,
        value: { type: "string", value: c.value },
        domain: c.domain,
        path: c.path,
        httpOnly: c.httpOnly,
        secure: c.secure,
        sameSite: c.sameSite && toBidiSameSite2(c.sameSite),
        expiry: c.expires === -1 || c.expires === void 0 ? void 0 : Math.round(c.expires)
      };
      return this._browser._browserSession.send(
        "storage.setCookie",
        { cookie, partition: { type: "storageKey", userContext: this._browserContextId } }
      );
    });
    await Promise.all(promises2);
  }
  async doClearCookies() {
    await this._browser._browserSession.send(
      "storage.deleteCookies",
      { partition: { type: "storageKey", userContext: this._browserContextId } }
    );
  }
  async doGrantPermissions(origin, permissions) {
    const currentPermissions = this._originToPermissions.get(origin) || [];
    const toGrant = permissions.filter((permission2) => !currentPermissions.includes(permission2));
    this._originToPermissions.set(origin, [...currentPermissions, ...toGrant]);
    await Promise.all(toGrant.map((permission2) => this._setPermission(origin, permission2, Permissions.PermissionState.Granted)));
  }
  async doClearPermissions() {
    const currentPermissions = [...this._originToPermissions.entries()];
    this._originToPermissions = /* @__PURE__ */ new Map();
    await Promise.all(currentPermissions.map(([origin, permissions]) => permissions.map(
      (p) => this._setPermission(origin, p, Permissions.PermissionState.Prompt)
    )));
  }
  async _setPermission(origin, permission2, state) {
    await this._browser._browserSession.send("permissions.setPermission", {
      descriptor: {
        name: permission2
      },
      state,
      origin,
      userContext: this._browserContextId || "default"
    });
  }
  async setGeolocation(geolocation) {
    verifyGeolocation(geolocation);
    this._options.geolocation = geolocation;
    await this._browser._browserSession.send("emulation.setGeolocationOverride", {
      coordinates: {
        latitude: geolocation?.latitude,
        longitude: geolocation?.longitude,
        accuracy: geolocation?.accuracy
      },
      userContexts: [this._browserContextId || "default"]
    });
  }
  async setExtraHTTPHeaders(headers) {
  }
  async setUserAgent(userAgent) {
  }
  async setOffline(offline) {
  }
  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;
    for (const page of this.pages())
      await page._delegate.updateHttpCredentials();
  }
  async doAddInitScript(initScript) {
    const { script } = await this._browser._browserSession.send("script.addPreloadScript", {
      // TODO: remove function call from the source.
      functionDeclaration: `() => { return ${initScript.source} }`,
      userContexts: [this._browserContextId || "default"]
    });
    if (!initScript.internal)
      this._initScriptIds.push(script);
  }
  async doRemoveNonInternalInitScripts() {
    const promise = Promise.all(this._initScriptIds.map((script) => this._browser._browserSession.send("script.removePreloadScript", { script })));
    this._initScriptIds = [];
    await promise;
  }
  async doUpdateRequestInterception() {
  }
  onClosePersistent() {
  }
  async clearCache() {
  }
  async doClose(reason) {
    if (!this._browserContextId) {
      await this._browser.close({ reason });
      return;
    }
    await this._browser._browserSession.send("browser.removeUserContext", {
      userContext: this._browserContextId
    });
    this._browser._contexts.delete(this._browserContextId);
  }
  async cancelDownload(uuid) {
  }
  _userContextId() {
    if (this._browserContextId)
      return this._browserContextId;
    return "default";
  }
};
function fromBidiSameSite(sameSite) {
  switch (sameSite) {
    case "strict":
      return "Strict";
    case "lax":
      return "Lax";
    case "none":
      return "None";
  }
  return "None";
}
__name(fromBidiSameSite, "fromBidiSameSite");
function toBidiSameSite2(sameSite) {
  switch (sameSite) {
    case "Strict":
      return Network2.SameSite.Strict;
    case "Lax":
      return Network2.SameSite.Lax;
    case "None":
      return Network2.SameSite.None;
  }
  return Network2.SameSite.None;
}
__name(toBidiSameSite2, "toBidiSameSite");
var Network3;
((Network22) => {
  ((SameSite2) => {
    SameSite2["Strict"] = "strict";
    SameSite2["Lax"] = "lax";
    SameSite2["None"] = "none";
  })(Network22.SameSite || (Network22.SameSite = {}));
})(Network3 || (Network3 = {}));

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiChromium.js
var BidiChromium = class extends BrowserType {
  static {
    __name(this, "BidiChromium");
  }
  constructor(parent) {
    super(parent, "bidi");
    this._useBidi = true;
  }
  async connectToTransport(transport, options2) {
    const bidiTransport = await require$$06.connectBidiOverCdp(transport);
    transport[kBidiOverCdpWrapper] = bidiTransport;
    return BidiBrowser.connect(this.attribution.playwright, bidiTransport, options2);
  }
  doRewriteStartupLog(error4) {
    if (!error4.logs)
      return error4;
    if (error4.logs.includes("Missing X server"))
      error4.logs = "\n" + wrapInASCIIBox(kNoXServerRunningError, 1);
    if (!error4.logs.includes("crbug.com/357670") && !error4.logs.includes("No usable sandbox!") && !error4.logs.includes("crbug.com/638180"))
      return error4;
    error4.logs = [
      `Chromium sandboxing failed!`,
      `================================`,
      `To avoid the sandboxing issue, do either of the following:`,
      `  - (preferred): Configure your environment to support sandboxing`,
      `  - (alternative): Launch Chromium without sandbox using 'chromiumSandbox: false' option`,
      `================================`,
      ``
    ].join("\n");
    return error4;
  }
  amendEnvironment(env3, userDataDir, executable, browserArguments) {
    return env3;
  }
  attemptToGracefullyCloseBrowser(transport) {
    const bidiTransport = transport[kBidiOverCdpWrapper];
    if (bidiTransport)
      transport = bidiTransport;
    transport.send({ method: "browser.close", params: {}, id: kBrowserCloseMessageId2 });
  }
  defaultArgs(options2, isPersistent, userDataDir) {
    const chromeArguments = this._innerDefaultArgs(options2);
    chromeArguments.push(`--user-data-dir=${userDataDir}`);
    chromeArguments.push("--remote-debugging-port=0");
    if (isPersistent)
      chromeArguments.push("about:blank");
    else
      chromeArguments.push("--no-startup-window");
    return chromeArguments;
  }
  readyState(options2) {
    assert3(options2.useWebSocket);
    return new ChromiumReadyState();
  }
  _innerDefaultArgs(options2) {
    const { args = [] } = options2;
    const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
    if (userDataDirArg)
      throw this._createUserDataDirArgMisuseError("--user-data-dir");
    if (args.find((arg) => arg.startsWith("--remote-debugging-pipe")))
      throw new Error("Playwright manages remote debugging connection itself.");
    if (args.find((arg) => !arg.startsWith("-")))
      throw new Error("Arguments can not specify page to be opened");
    const chromeArguments = [...chromiumSwitches];
    if (os_default.platform() === "darwin") {
      chromeArguments.push("--enable-use-zoom-for-dsf=false");
      if (options2.headless)
        chromeArguments.push("--use-angle");
    }
    if (options2.devtools)
      chromeArguments.push("--auto-open-devtools-for-tabs");
    if (options2.headless) {
      chromeArguments.push("--headless");
      chromeArguments.push(
        "--hide-scrollbars",
        "--mute-audio",
        "--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4"
      );
    }
    if (options2.chromiumSandbox !== true)
      chromeArguments.push("--no-sandbox");
    const proxy = options2.proxyOverride || options2.proxy;
    if (proxy) {
      const proxyURL = new URL(proxy.server);
      const isSocks = proxyURL.protocol === "socks5:";
      if (isSocks && !this.attribution.playwright.options.socksProxyPort) {
        chromeArguments.push(`--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`);
      }
      chromeArguments.push(`--proxy-server=${proxy.server}`);
      const proxyBypassRules = [];
      if (this.attribution.playwright.options.socksProxyPort)
        proxyBypassRules.push("<-loopback>");
      if (proxy.bypass)
        proxyBypassRules.push(...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t));
      if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes("<-loopback>"))
        proxyBypassRules.push("<-loopback>");
      if (proxyBypassRules.length > 0)
        chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
    }
    chromeArguments.push(...args);
    return chromeArguments;
  }
};
var ChromiumReadyState = class extends BrowserReadyState {
  static {
    __name(this, "ChromiumReadyState");
  }
  onBrowserOutput(message) {
    const match = message.match(/DevTools listening on (.*)/);
    if (match)
      this._wsEndpoint.resolve(match[1]);
  }
};
var kBidiOverCdpWrapper = Symbol("kBidiConnectionWrapper");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiFirefox.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path26 from "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/third_party/firefoxPrefs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path25 from "node:path";
async function createProfile(options2) {
  if (!fs.existsSync(options2.path)) {
    await fs.promises.mkdir(options2.path, {
      recursive: true
    });
  }
  await writePreferences({
    preferences: {
      ...defaultProfilePreferences(options2.preferences),
      ...options2.preferences
    },
    path: options2.path
  });
}
__name(createProfile, "createProfile");
function defaultProfilePreferences(extraPrefs) {
  const server = "dummy.test";
  const defaultPrefs = {
    // Make sure Shield doesn't hit the network.
    "app.normandy.api_url": "",
    // Disable Firefox old build background check
    "app.update.checkInstallTime": false,
    // Disable automatically upgrading Firefox
    "app.update.disabledForTesting": true,
    // Increase the APZ content response timeout to 1 minute
    "apz.content_response_timeout": 6e4,
    // Prevent various error message on the console
    // jest-puppeteer asserts that no error message is emitted by the console
    "browser.contentblocking.features.standard": "-tp,tpPrivate,cookieBehavior0,-cm,-fp",
    // Enable the dump function: which sends messages to the system
    // console
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1543115
    "browser.dom.window.dump.enabled": true,
    // Make sure newtab weather doesn't hit the network to retrieve weather data.
    "browser.newtabpage.activity-stream.discoverystream.region-weather-config": "",
    // Make sure newtab wallpapers don't hit the network to retrieve wallpaper data.
    "browser.newtabpage.activity-stream.newtabWallpapers.enabled": false,
    "browser.newtabpage.activity-stream.newtabWallpapers.v2.enabled": false,
    // Make sure Topsites doesn't hit the network to retrieve sponsored tiles.
    "browser.newtabpage.activity-stream.showSponsoredTopSites": false,
    // Disable topstories
    "browser.newtabpage.activity-stream.feeds.system.topstories": false,
    // Always display a blank page
    "browser.newtabpage.enabled": false,
    // Background thumbnails in particular cause grief: and disabling
    // thumbnails in general cannot hurt
    "browser.pagethumbnails.capturing_disabled": true,
    // Disable safebrowsing components.
    "browser.safebrowsing.blockedURIs.enabled": false,
    "browser.safebrowsing.downloads.enabled": false,
    "browser.safebrowsing.malware.enabled": false,
    "browser.safebrowsing.phishing.enabled": false,
    // Disable updates to search engines.
    "browser.search.update": false,
    // Do not restore the last open set of tabs if the browser has crashed
    "browser.sessionstore.resume_from_crash": false,
    // Skip check for default browser on startup
    "browser.shell.checkDefaultBrowser": false,
    // Disable newtabpage
    "browser.startup.homepage": "about:blank",
    // Do not redirect user when a milstone upgrade of Firefox is detected
    "browser.startup.homepage_override.mstone": "ignore",
    // Start with a blank page about:blank
    "browser.startup.page": 0,
    // Do not allow background tabs to be zombified on Android: otherwise for
    // tests that open additional tabs: the test harness tab itself might get
    // unloaded
    "browser.tabs.disableBackgroundZombification": false,
    // Do not warn when closing all other open tabs
    "browser.tabs.warnOnCloseOtherTabs": false,
    // Do not warn when multiple tabs will be opened
    "browser.tabs.warnOnOpen": false,
    // Do not automatically offer translations, as tests do not expect this.
    "browser.translations.automaticallyPopup": false,
    // Disable the UI tour.
    "browser.uitour.enabled": false,
    // Turn off search suggestions in the location bar so as not to trigger
    // network connections.
    "browser.urlbar.suggest.searches": false,
    // Disable first run splash page on Windows 10
    "browser.usedOnWindows10.introURL": "",
    // Do not warn on quitting Firefox
    "browser.warnOnQuit": false,
    // Defensively disable data reporting systems
    "datareporting.healthreport.documentServerURI": `http://${server}/dummy/healthreport/`,
    "datareporting.healthreport.logging.consoleEnabled": false,
    "datareporting.healthreport.service.enabled": false,
    "datareporting.healthreport.service.firstRun": false,
    "datareporting.healthreport.uploadEnabled": false,
    // Do not show datareporting policy notifications which can interfere with tests
    "datareporting.policy.dataSubmissionEnabled": false,
    "datareporting.policy.dataSubmissionPolicyBypassNotification": true,
    // DevTools JSONViewer sometimes fails to load dependencies with its require.js.
    // This doesn't affect Puppeteer but spams console (Bug 1424372)
    "devtools.jsonview.enabled": false,
    // Disable popup-blocker
    "dom.disable_open_during_load": false,
    // Enable the support for File object creation in the content process
    // Required for |Page.setFileInputFiles| protocol method.
    "dom.file.createInChild": true,
    // Disable the ProcessHangMonitor
    "dom.ipc.reportProcessHangs": false,
    // Disable slow script dialogues
    "dom.max_chrome_script_run_time": 0,
    "dom.max_script_run_time": 0,
    // Disable background timer throttling to allow tests to run in parallel
    // without a decrease in performance.
    "dom.min_background_timeout_value": 0,
    "dom.min_background_timeout_value_without_budget_throttling": 0,
    "dom.timeout.enable_budget_timer_throttling": false,
    // Disable HTTPS-First upgrades
    "dom.security.https_first": false,
    // Only load extensions from the application and user profile
    // AddonManager.SCOPE_PROFILE + AddonManager.SCOPE_APPLICATION
    "extensions.autoDisableScopes": 0,
    "extensions.enabledScopes": 5,
    // Disable metadata caching for installed add-ons by default
    "extensions.getAddons.cache.enabled": false,
    // Disable installing any distribution extensions or add-ons.
    "extensions.installDistroAddons": false,
    // Disabled screenshots extension
    "extensions.screenshots.disabled": true,
    // Turn off extension updates so they do not bother tests
    "extensions.update.enabled": false,
    // Turn off extension updates so they do not bother tests
    "extensions.update.notifyUser": false,
    // Make sure opening about:addons will not hit the network
    "extensions.webservice.discoverURL": `http://${server}/dummy/discoveryURL`,
    // Allow the application to have focus even it runs in the background
    "focusmanager.testmode": true,
    // Disable useragent updates
    "general.useragent.updates.enabled": false,
    // Always use network provider for geolocation tests so we bypass the
    // macOS dialog raised by the corelocation provider
    "geo.provider.testing": true,
    // Do not scan Wifi
    "geo.wifi.scan": false,
    // No hang monitor
    "hangmonitor.timeout": 0,
    // Show chrome errors and warnings in the error console
    "javascript.options.showInConsole": true,
    // Do not throttle rendering (requestAnimationFrame) in background tabs
    "layout.testing.top-level-always-active": true,
    // Disable download and usage of OpenH264: and Widevine plugins
    "media.gmp-manager.updateEnabled": false,
    // Disable the GFX sanity window
    "media.sanity-test.disabled": true,
    // Disable connectivity service pings
    "network.connectivity-service.enabled": false,
    // Disable experimental feature that is only available in Nightly
    "network.cookie.sameSite.laxByDefault": false,
    // Do not prompt for temporary redirects
    "network.http.prompt-temp-redirect": false,
    // Disable speculative connections so they are not reported as leaking
    // when they are hanging around
    "network.http.speculative-parallel-limit": 0,
    // Do not automatically switch between offline and online
    "network.manage-offline-status": false,
    // Make sure SNTP requests do not hit the network
    "network.sntp.pools": server,
    // Disable Flash.
    "plugin.state.flash": 0,
    "privacy.trackingprotection.enabled": false,
    // Can be removed once Firefox 89 is no longer supported
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1710839
    "remote.enabled": true,
    // Don't do network connections for mitm priming
    "security.certerrors.mitm.priming.enabled": false,
    // Local documents have access to all other local documents,
    // including directory listings
    "security.fileuri.strict_origin_policy": false,
    // Do not wait for the notification button security delay
    "security.notification_enable_delay": 0,
    // Do not automatically fill sign-in forms with known usernames and
    // passwords
    "signon.autofillForms": false,
    // Disable password capture, so that tests that include forms are not
    // influenced by the presence of the persistent doorhanger notification
    "signon.rememberSignons": false,
    // Disable first-run welcome page
    "startup.homepage_welcome_url": "about:blank",
    // Disable first-run welcome page
    "startup.homepage_welcome_url.additional": "",
    // Disable browser animations (tabs, fullscreen, sliding alerts)
    "toolkit.cosmeticAnimations.enabled": false,
    // Prevent starting into safe mode after application crashes
    "toolkit.startup.max_resumed_crashes": -1
  };
  return Object.assign(defaultPrefs, extraPrefs);
}
__name(defaultProfilePreferences, "defaultProfilePreferences");
async function writePreferences(options2) {
  const prefsPath = path25.join(options2.path, "prefs.js");
  const lines = Object.entries(options2.preferences).map(([key, value]) => {
    return `user_pref(${JSON.stringify(key)}, ${JSON.stringify(value)});`;
  });
  const result = await Promise.allSettled([
    fs.promises.writeFile(path25.join(options2.path, "user.js"), lines.join("\n")),
    // Create a backup of the preferences file if it already exitsts.
    fs.promises.access(prefsPath, fs.constants.F_OK).then(
      async () => {
        await fs.promises.copyFile(
          prefsPath,
          path25.join(options2.path, "prefs.js.playwright")
        );
      },
      // Swallow only if file does not exist
      () => {
      }
    )
  ]);
  for (const command2 of result) {
    if (command2.status === "rejected") {
      throw command2.reason;
    }
  }
}
__name(writePreferences, "writePreferences");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/bidiFirefox.js
var BidiFirefox = class extends BrowserType {
  static {
    __name(this, "BidiFirefox");
  }
  constructor(parent) {
    super(parent, "bidi");
    this._useBidi = true;
  }
  async connectToTransport(transport, options2) {
    return BidiBrowser.connect(this.attribution.playwright, transport, options2);
  }
  doRewriteStartupLog(error4) {
    if (!error4.logs)
      return error4;
    if (error4.logs.includes(`as root in a regular user's session is not supported.`))
      error4.logs = "\n" + wrapInASCIIBox(`Firefox is unable to launch if the $HOME folder isn't owned by the current user.
Workaround: Set the HOME=/root environment variable${process.env.GITHUB_ACTION ? " in your GitHub Actions workflow file" : ""} when running Playwright.`, 1);
    if (error4.logs.includes("no DISPLAY environment variable specified"))
      error4.logs = "\n" + wrapInASCIIBox(kNoXServerRunningError, 1);
    return error4;
  }
  amendEnvironment(env3, userDataDir, executable, browserArguments) {
    if (!path26.isAbsolute(os_default.homedir()))
      throw new Error(`Cannot launch Firefox with relative home directory. Did you set ${os_default.platform() === "win32" ? "USERPROFILE" : "HOME"} to a relative path?`);
    env3 = {
      ...env3,
      "MOZ_CRASHREPORTER": "1",
      "MOZ_CRASHREPORTER_NO_REPORT": "1",
      "MOZ_CRASHREPORTER_SHUTDOWN": "1"
    };
    if (os_default.platform() === "linux") {
      return { ...env3, SNAP_NAME: void 0, SNAP_INSTANCE_NAME: void 0 };
    }
    return env3;
  }
  attemptToGracefullyCloseBrowser(transport) {
    transport.send({ method: "browser.close", params: {}, id: kBrowserCloseMessageId2 });
  }
  async prepareUserDataDir(options2, userDataDir) {
    await createProfile({
      path: userDataDir,
      preferences: options2.firefoxUserPrefs || {}
    });
  }
  defaultArgs(options2, isPersistent, userDataDir) {
    const { args = [], headless } = options2;
    const userDataDirArg = args.find((arg) => arg.startsWith("-profile") || arg.startsWith("--profile"));
    if (userDataDirArg)
      throw this._createUserDataDirArgMisuseError("--profile");
    const firefoxArguments = ["--remote-debugging-port=0"];
    if (headless)
      firefoxArguments.push("--headless");
    else
      firefoxArguments.push("--foreground");
    firefoxArguments.push(`--profile`, userDataDir);
    firefoxArguments.push(...args);
    return firefoxArguments;
  }
  readyState(options2) {
    assert3(options2.useWebSocket);
    return new FirefoxReadyState();
  }
};
var FirefoxReadyState = class extends BrowserReadyState {
  static {
    __name(this, "FirefoxReadyState");
  }
  onBrowserOutput(message) {
    const match = message.match(/WebDriver BiDi listening on (ws:\/\/.*)$/);
    if (match)
      this._wsEndpoint.resolve(match[1] + "/session");
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/chromium.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path27 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/crDevTools.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var kBindingName = "__pw_devtools__";
var CRDevTools = class {
  static {
    __name(this, "CRDevTools");
  }
  constructor(preferencesPath) {
    this._preferencesPath = preferencesPath;
    this._savePromise = Promise.resolve();
  }
  install(session2) {
    session2.on("Runtime.bindingCalled", async (event) => {
      if (event.name !== kBindingName)
        return;
      const parsed = JSON.parse(event.payload);
      let result = void 0;
      if (this.__testHookOnBinding)
        this.__testHookOnBinding(parsed);
      if (parsed.method === "getPreferences") {
        if (this._prefs === void 0) {
          try {
            const json = await fs.promises.readFile(this._preferencesPath, "utf8");
            this._prefs = JSON.parse(json);
          } catch (e) {
            this._prefs = {};
          }
        }
        result = this._prefs;
      } else if (parsed.method === "setPreference") {
        this._prefs[parsed.params[0]] = parsed.params[1];
        this._save();
      } else if (parsed.method === "removePreference") {
        delete this._prefs[parsed.params[0]];
        this._save();
      } else if (parsed.method === "clearPreferences") {
        this._prefs = {};
        this._save();
      }
      session2.send("Runtime.evaluate", {
        expression: `window.DevToolsAPI.embedderMessageAck(${parsed.id}, ${JSON.stringify(result)})`,
        contextId: event.executionContextId
      }).catch((e) => null);
    });
    Promise.all([
      session2.send("Runtime.enable"),
      session2.send("Runtime.addBinding", { name: kBindingName }),
      session2.send("Page.enable"),
      session2.send("Page.addScriptToEvaluateOnNewDocument", { source: `
        (() => {
          const init = () => {
            // Lazy init happens when InspectorFrontendHost is initialized.
            // At this point DevToolsHost is ready to be used.
            const host = window.DevToolsHost;
            const old = host.sendMessageToEmbedder.bind(host);
            host.sendMessageToEmbedder = message => {
              if (['getPreferences', 'setPreference', 'removePreference', 'clearPreferences'].includes(JSON.parse(message).method))
                window.${kBindingName}(message);
              else
                old(message);
            };
          };
          let value;
          Object.defineProperty(window, 'InspectorFrontendHost', {
            configurable: true,
            enumerable: true,
            get() { return value; },
            set(v) { value = v; init(); },
          });
        })()
      ` }),
      session2.send("Runtime.runIfWaitingForDebugger")
    ]).catch((e) => null);
  }
  _save() {
    this._savePromise = this._savePromise.then(async () => {
      await fs.promises.writeFile(this._preferencesPath, JSON.stringify(this._prefs)).catch((e) => null);
    });
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/chromium/chromium.js
var ARTIFACTS_FOLDER3 = path27.join(os_default.tmpdir(), "playwright-artifacts-");
var Chromium = class extends BrowserType {
  static {
    __name(this, "Chromium");
  }
  constructor(parent) {
    super(parent, "chromium");
    if (debugMode())
      this._devtools = this._createDevTools();
  }
  async connectOverCDP(metadata, endpointURL, options2) {
    const controller = new ProgressController(metadata, this);
    controller.setLogName("browser");
    return controller.run(async (progress3) => {
      return await this._connectOverCDPInternal(progress3, endpointURL, options2);
    }, TimeoutSettings.timeout(options2));
  }
  async _connectOverCDPInternal(progress3, endpointURL, options2, onClose) {
    let headersMap;
    if (options2.headers)
      headersMap = headersArrayToObject(options2.headers, false);
    if (!headersMap)
      headersMap = { "User-Agent": getUserAgent() };
    else if (headersMap && !Object.keys(headersMap).some((key) => key.toLowerCase() === "user-agent"))
      headersMap["User-Agent"] = getUserAgent();
    const artifactsDir = await fs.promises.mkdtemp(ARTIFACTS_FOLDER3);
    const wsEndpoint = await urlToWSEndpoint2(progress3, endpointURL, headersMap);
    progress3.throwIfAborted();
    const chromeTransport = await WebSocketTransport.connect(progress3, wsEndpoint, { headers: headersMap });
    const cleanedUp = new ManualPromise();
    const doCleanup = /* @__PURE__ */ __name(async () => {
      await removeFolders([artifactsDir]);
      await onClose?.();
      cleanedUp.resolve();
    }, "doCleanup");
    const doClose = /* @__PURE__ */ __name(async () => {
      await chromeTransport.closeAndWait();
      await cleanedUp;
    }, "doClose");
    const browserProcess = { close: doClose, kill: doClose };
    const noDefaultViewport = globalThis.navigator?.userAgent !== "Cloudflare-Workers";
    const persistent = new URL(endpointURL).searchParams.has("persistent") ? { noDefaultViewport } : void 0;
    const browserOptions = {
      slowMo: options2.slowMo,
      name: "chromium",
      isChromium: true,
      persistent,
      browserProcess,
      protocolLogger: helper.debugProtocolLogger(),
      browserLogsCollector: new RecentLogsCollector(),
      artifactsDir,
      downloadsPath: options2.downloadsPath || artifactsDir,
      tracesDir: options2.tracesDir || artifactsDir,
      originalLaunchOptions: {}
    };
    if (persistent)
      validateBrowserContextOptions(persistent, browserOptions);
    progress3.throwIfAborted();
    const browser3 = await CRBrowser.connect(this.attribution.playwright, chromeTransport, browserOptions);
    browser3._isCollocatedWithServer = false;
    browser3.on(Browser.Events.Disconnected, doCleanup);
    return browser3;
  }
  _createDevTools() {
    const directory = registry.findExecutable("chromium").directory;
    return directory ? new CRDevTools(path27.join(directory, "devtools-preferences.json")) : void 0;
  }
  async connectToTransport(transport, options2) {
    let devtools = this._devtools;
    if (options2.__testHookForDevTools) {
      devtools = this._createDevTools();
      await options2.__testHookForDevTools(devtools);
    }
    return CRBrowser.connect(this.attribution.playwright, transport, options2, devtools);
  }
  doRewriteStartupLog(error4) {
    if (!error4.logs)
      return error4;
    if (error4.logs.includes("Missing X server"))
      error4.logs = "\n" + wrapInASCIIBox(kNoXServerRunningError, 1);
    if (!error4.logs.includes("crbug.com/357670") && !error4.logs.includes("No usable sandbox!") && !error4.logs.includes("crbug.com/638180"))
      return error4;
    error4.logs = [
      `Chromium sandboxing failed!`,
      `================================`,
      `To avoid the sandboxing issue, do either of the following:`,
      `  - (preferred): Configure your environment to support sandboxing`,
      `  - (alternative): Launch Chromium without sandbox using 'chromiumSandbox: false' option`,
      `================================`,
      ``
    ].join("\n");
    return error4;
  }
  amendEnvironment(env3, userDataDir, executable, browserArguments) {
    return env3;
  }
  attemptToGracefullyCloseBrowser(transport) {
    const message = { method: "Browser.close", id: kBrowserCloseMessageId, params: {} };
    transport.send(message);
  }
  async _launchWithSeleniumHub(progress3, hubUrl, options2) {
    await this._createArtifactDirs(options2);
    if (!hubUrl.endsWith("/"))
      hubUrl = hubUrl + "/";
    const args = this._innerDefaultArgs(options2);
    args.push("--remote-debugging-port=0");
    const isEdge = options2.channel && options2.channel.startsWith("msedge");
    let desiredCapabilities = {
      "browserName": isEdge ? "MicrosoftEdge" : "chrome",
      [isEdge ? "ms:edgeOptions" : "goog:chromeOptions"]: { args }
    };
    if (process.env.SELENIUM_REMOTE_CAPABILITIES) {
      const remoteCapabilities = parseSeleniumRemoteParams({ name: "capabilities", value: process.env.SELENIUM_REMOTE_CAPABILITIES }, progress3);
      if (remoteCapabilities)
        desiredCapabilities = { ...desiredCapabilities, ...remoteCapabilities };
    }
    let headers = {};
    if (process.env.SELENIUM_REMOTE_HEADERS) {
      const remoteHeaders = parseSeleniumRemoteParams({ name: "headers", value: process.env.SELENIUM_REMOTE_HEADERS }, progress3);
      if (remoteHeaders)
        headers = remoteHeaders;
    }
    progress3.log(`<selenium> connecting to ${hubUrl}`);
    const response = await fetchData({
      url: hubUrl + "session",
      method: "POST",
      headers: {
        "Content-Type": "application/json; charset=utf-8",
        ...headers
      },
      data: JSON.stringify({
        capabilities: { alwaysMatch: desiredCapabilities }
      }),
      timeout: progress3.timeUntilDeadline()
    }, seleniumErrorHandler);
    const value = JSON.parse(response).value;
    const sessionId = value.sessionId;
    progress3.log(`<selenium> connected to sessionId=${sessionId}`);
    const disconnectFromSelenium = /* @__PURE__ */ __name(async () => {
      progress3.log(`<selenium> disconnecting from sessionId=${sessionId}`);
      await fetchData({
        url: hubUrl + "session/" + sessionId,
        method: "DELETE",
        headers
      }).catch((error4) => progress3.log(`<error disconnecting from selenium>: ${error4}`));
      progress3.log(`<selenium> disconnected from sessionId=${sessionId}`);
      gracefullyCloseSet.delete(disconnectFromSelenium);
    }, "disconnectFromSelenium");
    gracefullyCloseSet.add(disconnectFromSelenium);
    try {
      const capabilities = value.capabilities;
      let endpointURL;
      if (capabilities["se:cdp"]) {
        progress3.log(`<selenium> using selenium v4`);
        const endpointURLString = addProtocol(capabilities["se:cdp"]);
        endpointURL = new URL(endpointURLString);
        if (endpointURL.hostname === "localhost" || endpointURL.hostname === "127.0.0.1")
          endpointURL.hostname = new URL(hubUrl).hostname;
        progress3.log(`<selenium> retrieved endpoint ${endpointURL.toString()} for sessionId=${sessionId}`);
      } else {
        progress3.log(`<selenium> using selenium v3`);
        const maybeChromeOptions = capabilities["goog:chromeOptions"];
        const chromeOptions = maybeChromeOptions && typeof maybeChromeOptions === "object" ? maybeChromeOptions : void 0;
        const debuggerAddress = chromeOptions && typeof chromeOptions.debuggerAddress === "string" ? chromeOptions.debuggerAddress : void 0;
        const chromeOptionsURL = typeof maybeChromeOptions === "string" ? maybeChromeOptions : void 0;
        const endpointURLString = addProtocol(debuggerAddress || chromeOptionsURL).replace("localhost", "127.0.0.1");
        progress3.log(`<selenium> retrieved endpoint ${endpointURLString} for sessionId=${sessionId}`);
        endpointURL = new URL(endpointURLString);
        if (endpointURL.hostname === "localhost" || endpointURL.hostname === "127.0.0.1") {
          const sessionInfoUrl = new URL(hubUrl).origin + "/grid/api/testsession?session=" + sessionId;
          try {
            const sessionResponse = await fetchData({
              url: sessionInfoUrl,
              method: "GET",
              timeout: progress3.timeUntilDeadline(),
              headers
            }, seleniumErrorHandler);
            const proxyId = JSON.parse(sessionResponse).proxyId;
            endpointURL.hostname = new URL(proxyId).hostname;
            progress3.log(`<selenium> resolved endpoint ip ${endpointURL.toString()} for sessionId=${sessionId}`);
          } catch (e) {
            progress3.log(`<selenium> unable to resolve endpoint ip for sessionId=${sessionId}, running in standalone?`);
          }
        }
      }
      return await this._connectOverCDPInternal(progress3, endpointURL.toString(), {
        ...options2,
        headers: headersObjectToArray(headers)
      }, disconnectFromSelenium);
    } catch (e) {
      await disconnectFromSelenium();
      throw e;
    }
  }
  defaultArgs(options2, isPersistent, userDataDir) {
    const chromeArguments = this._innerDefaultArgs(options2);
    chromeArguments.push(`--user-data-dir=${userDataDir}`);
    if (options2.useWebSocket)
      chromeArguments.push("--remote-debugging-port=0");
    else
      chromeArguments.push("--remote-debugging-pipe");
    if (isPersistent)
      chromeArguments.push("about:blank");
    else
      chromeArguments.push("--no-startup-window");
    return chromeArguments;
  }
  _innerDefaultArgs(options2) {
    const { args = [] } = options2;
    const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
    if (userDataDirArg)
      throw this._createUserDataDirArgMisuseError("--user-data-dir");
    if (args.find((arg) => arg.startsWith("--remote-debugging-pipe")))
      throw new Error("Playwright manages remote debugging connection itself.");
    if (args.find((arg) => !arg.startsWith("-")))
      throw new Error("Arguments can not specify page to be opened");
    const chromeArguments = [...chromiumSwitches];
    if (os_default.platform() === "darwin") {
      chromeArguments.push("--enable-use-zoom-for-dsf=false");
      if (options2.headless && (!options2.channel || options2.channel === "chromium-headless-shell"))
        chromeArguments.push("--use-angle");
    }
    if (options2.devtools)
      chromeArguments.push("--auto-open-devtools-for-tabs");
    if (options2.headless) {
      chromeArguments.push("--headless");
      chromeArguments.push(
        "--hide-scrollbars",
        "--mute-audio",
        "--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4"
      );
    }
    if (options2.chromiumSandbox !== true)
      chromeArguments.push("--no-sandbox");
    const proxy = options2.proxyOverride || options2.proxy;
    if (proxy) {
      const proxyURL = new URL(proxy.server);
      const isSocks = proxyURL.protocol === "socks5:";
      if (isSocks && !this.attribution.playwright.options.socksProxyPort) {
        chromeArguments.push(`--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`);
      }
      chromeArguments.push(`--proxy-server=${proxy.server}`);
      const proxyBypassRules = [];
      if (this.attribution.playwright.options.socksProxyPort)
        proxyBypassRules.push("<-loopback>");
      if (proxy.bypass)
        proxyBypassRules.push(...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t));
      if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes("<-loopback>"))
        proxyBypassRules.push("<-loopback>");
      if (proxyBypassRules.length > 0)
        chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
    }
    chromeArguments.push(...args);
    return chromeArguments;
  }
  readyState(options2) {
    if (options2.useWebSocket || options2.args?.some((a) => a.startsWith("--remote-debugging-port")))
      return new ChromiumReadyState2();
    return void 0;
  }
  getExecutableName(options2) {
    if (options2.channel)
      return options2.channel;
    return options2.headless ? "chromium-headless-shell" : "chromium";
  }
};
var ChromiumReadyState2 = class extends BrowserReadyState {
  static {
    __name(this, "ChromiumReadyState");
  }
  onBrowserOutput(message) {
    const match = message.match(/DevTools listening on (.*)/);
    if (match)
      this._wsEndpoint.resolve(match[1]);
  }
};
async function urlToWSEndpoint2(progress3, endpointURL, headers) {
  if (endpointURL.startsWith("ws"))
    return endpointURL;
  progress3.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);
  const httpURL = endpointURL.endsWith("/") ? `${endpointURL}json/version/` : `${endpointURL}/json/version/`;
  const json = await fetchData(
    {
      url: httpURL,
      headers
    },
    async (_, resp) => new Error(`Unexpected status ${resp.statusCode} when connecting to ${httpURL}.
This does not look like a DevTools server, try connecting via ws://.`)
  );
  return JSON.parse(json).webSocketDebuggerUrl;
}
__name(urlToWSEndpoint2, "urlToWSEndpoint");
async function seleniumErrorHandler(params, response) {
  const body = await streamToString(response);
  let message = body;
  try {
    const json = JSON.parse(body);
    message = json.value.localizedMessage || json.value.message;
  } catch (e) {
  }
  return new Error(`Error connecting to Selenium at ${params.url}: ${message}`);
}
__name(seleniumErrorHandler, "seleniumErrorHandler");
function addProtocol(url4) {
  if (!["ws://", "wss://", "http://", "https://"].some((protocol) => url4.startsWith(protocol)))
    return "http://" + url4;
  return url4;
}
__name(addProtocol, "addProtocol");
function streamToString(stream) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    stream.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
    stream.on("error", reject);
    stream.on("end", () => resolve(Buffer.concat(chunks).toString("utf8")));
  });
}
__name(streamToString, "streamToString");
function parseSeleniumRemoteParams(env3, progress3) {
  try {
    const parsed = JSON.parse(env3.value);
    progress3.log(`<selenium> using additional ${env3.name} "${env3.value}"`);
    return parsed;
  } catch (e) {
    progress3.log(`<selenium> ignoring additional ${env3.name} "${env3.value}": ${e}`);
  }
}
__name(parseSeleniumRemoteParams, "parseSeleniumRemoteParams");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/debugController.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var internalMetadata = serverSideCallMetadata();
var DebugController = class _DebugController extends SdkObject {
  static {
    __name(this, "DebugController");
  }
  constructor(playwright2) {
    super({ attribution: { isInternalPlaywright: true }, instrumentation: createInstrumentation() }, void 0, "DebugController");
    this._sdkLanguage = "javascript";
    this._codegenId = "playwright-test";
    this._playwright = playwright2;
  }
  static {
    this.Events = {
      StateChanged: "stateChanged",
      InspectRequested: "inspectRequested",
      SourceChanged: "sourceChanged",
      Paused: "paused",
      SetModeRequested: "setModeRequested"
    };
  }
  initialize(codegenId, sdkLanguage) {
    this._codegenId = codegenId;
    this._sdkLanguage = sdkLanguage;
  }
  dispose() {
    this.setReportStateChanged(false);
  }
  setReportStateChanged(enabled) {
    if (enabled && !this._trackHierarchyListener) {
      this._trackHierarchyListener = {
        onPageOpen: /* @__PURE__ */ __name(() => this._emitSnapshot(false), "onPageOpen"),
        onPageClose: /* @__PURE__ */ __name(() => this._emitSnapshot(false), "onPageClose")
      };
      this._playwright.instrumentation.addListener(this._trackHierarchyListener, null);
      this._emitSnapshot(true);
    } else if (!enabled && this._trackHierarchyListener) {
      this._playwright.instrumentation.removeListener(this._trackHierarchyListener);
      this._trackHierarchyListener = void 0;
    }
  }
  async resetForReuse() {
    const contexts = /* @__PURE__ */ new Set();
    for (const page of this._playwright.allPages())
      contexts.add(page.context());
    for (const context2 of contexts)
      await context2.resetForReuse(internalMetadata, null);
  }
  async navigate(url4) {
    for (const p of this._playwright.allPages())
      await p.mainFrame().goto(internalMetadata, url4);
  }
  async setRecorderMode(params) {
    await this._closeBrowsersWithoutPages();
    if (params.mode === "none") {
      for (const recorder of await this._allRecorders()) {
        recorder.hideHighlightedSelector();
        recorder.setMode("none");
      }
      return;
    }
    if (!this._playwright.allBrowsers().length)
      await this._playwright.chromium.launch(internalMetadata, { headless: !!process.env.PW_DEBUG_CONTROLLER_HEADLESS });
    const pages = this._playwright.allPages();
    if (!pages.length) {
      const [browser3] = this._playwright.allBrowsers();
      const { context: context2 } = await browser3.newContextForReuse({}, internalMetadata);
      await context2.newPage(internalMetadata);
    }
    if (params.testIdAttributeName) {
      for (const page of this._playwright.allPages())
        page.context().selectors().setTestIdAttributeName(params.testIdAttributeName);
    }
    for (const recorder of await this._allRecorders()) {
      recorder.hideHighlightedSelector();
      if (params.mode !== "inspecting")
        recorder.setOutput(this._codegenId, params.file);
      recorder.setMode(params.mode);
    }
  }
  async highlight(params) {
    if (params.selector)
      unsafeLocatorOrSelectorAsSelector(this._sdkLanguage, params.selector, "data-testid");
    const ariaTemplate = params.ariaTemplate ? parseAriaSnapshotUnsafe(yaml2, params.ariaTemplate) : void 0;
    for (const recorder of await this._allRecorders()) {
      if (ariaTemplate)
        recorder.setHighlightedAriaTemplate(ariaTemplate);
      else if (params.selector)
        recorder.setHighlightedSelector(this._sdkLanguage, params.selector);
    }
  }
  async hideHighlight() {
    for (const recorder of await this._allRecorders())
      recorder.hideHighlightedSelector();
    await this._playwright.hideHighlight();
  }
  allBrowsers() {
    return [...this._playwright.allBrowsers()];
  }
  async resume() {
    for (const recorder of await this._allRecorders())
      recorder.resume();
  }
  async kill() {
    gracefullyProcessExitDoNotHang(0);
  }
  async closeAllBrowsers() {
    await Promise.all(this.allBrowsers().map((browser3) => browser3.close({ reason: "Close all browsers requested" })));
  }
  _emitSnapshot(initial) {
    const pageCount = this._playwright.allPages().length;
    if (initial && !pageCount)
      return;
    this.emit(_DebugController.Events.StateChanged, { pageCount });
  }
  async _allRecorders() {
    const contexts = /* @__PURE__ */ new Set();
    for (const page of this._playwright.allPages())
      contexts.add(page.context());
    const result = await Promise.all([...contexts].map((c) => Recorder.showInspector(c, { omitCallTracking: true }, () => Promise.resolve(new InspectingRecorderApp(this)))));
    return result.filter(Boolean);
  }
  async _closeBrowsersWithoutPages() {
    for (const browser3 of this._playwright.allBrowsers()) {
      for (const context2 of browser3.contexts()) {
        if (!context2.pages().length)
          await context2.close({ reason: "Browser collected" });
      }
      if (!browser3.contexts())
        await browser3.close({ reason: "Browser collected" });
    }
  }
};
var InspectingRecorderApp = class extends EmptyRecorderApp {
  static {
    __name(this, "InspectingRecorderApp");
  }
  constructor(debugController) {
    super();
    this._debugController = debugController;
  }
  async elementPicked(elementInfo) {
    const locator = asLocator(this._debugController._sdkLanguage, elementInfo.selector);
    this._debugController.emit(DebugController.Events.InspectRequested, { selector: elementInfo.selector, locator, ariaSnapshot: elementInfo.ariaSnapshot });
  }
  async setSources(sources) {
    const source7 = sources.find((s) => s.id === this._debugController._codegenId);
    const { text, header, footer, actions } = source7 || { text: "" };
    this._debugController.emit(DebugController.Events.SourceChanged, { text, header, footer, actions });
  }
  async setPaused(paused) {
    this._debugController.emit(DebugController.Events.Paused, { paused });
  }
  async setMode(mode) {
    this._debugController.emit(DebugController.Events.SetModeRequested, { mode });
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/firefox/firefox.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path28 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/firefox/ffBrowser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/firefox/ffConnection.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter16 } from "node:events";
var ConnectionEvents2 = {
  Disconnected: Symbol("Disconnected")
};
var kBrowserCloseMessageId3 = -9999;
var FFConnection = class extends EventEmitter16 {
  static {
    __name(this, "FFConnection");
  }
  constructor(transport, protocolLogger, browserLogsCollector) {
    super();
    this.setMaxListeners(0);
    this._transport = transport;
    this._protocolLogger = protocolLogger;
    this._browserLogsCollector = browserLogsCollector;
    this._lastId = 0;
    this._sessions = /* @__PURE__ */ new Map();
    this._closed = false;
    this.rootSession = new FFSession(this, "", (message) => this._rawSend(message));
    this._sessions.set("", this.rootSession);
    this._transport.onmessage = this._onMessage.bind(this);
    this._transport.onclose = this._onClose.bind(this);
  }
  nextMessageId() {
    return ++this._lastId;
  }
  _rawSend(message) {
    this._protocolLogger("send", message);
    this._transport.send(message);
  }
  async _onMessage(message) {
    this._protocolLogger("receive", message);
    if (message.id === kBrowserCloseMessageId3)
      return;
    const session2 = this._sessions.get(message.sessionId || "");
    if (session2)
      session2.dispatchMessage(message);
  }
  _onClose(reason) {
    this._closed = true;
    this._transport.onmessage = void 0;
    this._transport.onclose = void 0;
    this._browserDisconnectedLogs = helper.formatBrowserLogs(this._browserLogsCollector.recentLogs(), reason);
    this.rootSession.dispose();
    Promise.resolve().then(() => this.emit(ConnectionEvents2.Disconnected));
  }
  close() {
    if (!this._closed)
      this._transport.close();
  }
  createSession(sessionId) {
    const session2 = new FFSession(this, sessionId, (message) => this._rawSend({ ...message, sessionId }));
    this._sessions.set(sessionId, session2);
    return session2;
  }
};
var FFSession = class extends EventEmitter16 {
  static {
    __name(this, "FFSession");
  }
  constructor(connection, sessionId, rawSend) {
    super();
    this._disposed = false;
    this._crashed = false;
    this.setMaxListeners(0);
    this._callbacks = /* @__PURE__ */ new Map();
    this._connection = connection;
    this._sessionId = sessionId;
    this._rawSend = rawSend;
    this.on = super.on;
    this.addListener = super.addListener;
    this.off = super.removeListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }
  markAsCrashed() {
    this._crashed = true;
  }
  async send(method, params) {
    if (this._crashed || this._disposed || this._connection._closed || this._connection._browserDisconnectedLogs)
      throw new ProtocolError(this._crashed ? "crashed" : "closed", void 0, this._connection._browserDisconnectedLogs);
    const id = this._connection.nextMessageId();
    this._rawSend({ method, params, id });
    return new Promise((resolve, reject) => {
      this._callbacks.set(id, { resolve, reject, error: new ProtocolError("error", method) });
    });
  }
  sendMayFail(method, params) {
    return this.send(method, params).catch((error4) => debugLogger.log("error", error4));
  }
  dispatchMessage(object) {
    if (object.id) {
      const callback = this._callbacks.get(object.id);
      if (callback) {
        this._callbacks.delete(object.id);
        if (object.error) {
          callback.error.setMessage(object.error.message);
          callback.reject(callback.error);
        } else {
          callback.resolve(object.result);
        }
      }
    } else {
      Promise.resolve().then(() => this.emit(object.method, object.params));
    }
  }
  dispose() {
    this._disposed = true;
    this._connection._sessions.delete(this._sessionId);
    for (const callback of this._callbacks.values()) {
      callback.error.type = this._crashed ? "crashed" : "closed";
      callback.error.logs = this._connection._browserDisconnectedLogs;
      callback.reject(callback.error);
    }
    this._callbacks.clear();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/firefox/ffPage.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/firefox/ffAccessibility.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function getAccessibilityTree2(session2, needle) {
  const objectId = needle ? needle._objectId : void 0;
  const { tree } = await session2.send("Accessibility.getFullAXTree", { objectId });
  const axNode = new FFAXNode(tree);
  return {
    tree: axNode,
    needle: needle ? axNode._findNeedle() : null
  };
}
__name(getAccessibilityTree2, "getAccessibilityTree");
var FFRoleToARIARole = new Map(Object.entries({
  "pushbutton": "button",
  "checkbutton": "checkbox",
  "editcombobox": "combobox",
  "content deletion": "deletion",
  "footnote": "doc-footnote",
  "non-native document": "document",
  "grouping": "group",
  "graphic": "img",
  "content insertion": "insertion",
  "animation": "marquee",
  "flat equation": "math",
  "menupopup": "menu",
  "check menu item": "menuitemcheckbox",
  "radio menu item": "menuitemradio",
  "listbox option": "option",
  "radiobutton": "radio",
  "statusbar": "status",
  "pagetab": "tab",
  "pagetablist": "tablist",
  "propertypage": "tabpanel",
  "entry": "textbox",
  "outline": "tree",
  "tree table": "treegrid",
  "outlineitem": "treeitem"
}));
var FFAXNode = class _FFAXNode {
  static {
    __name(this, "FFAXNode");
  }
  constructor(payload) {
    this._payload = payload;
    this._children = (payload.children || []).map((x) => new _FFAXNode(x));
    this._editable = !!payload.editable;
    this._richlyEditable = this._editable && (payload.tag !== "textarea" && payload.tag !== "input");
    this._focusable = !!payload.focusable;
    this._expanded = !!payload.expanded;
    this._name = this._payload.name;
    this._role = this._payload.role;
  }
  _isPlainTextField() {
    if (this._richlyEditable)
      return false;
    if (this._editable)
      return true;
    return this._role === "entry";
  }
  _isTextOnlyObject() {
    const role = this._role;
    return role === "text leaf" || role === "text" || role === "statictext";
  }
  _hasFocusableChild() {
    if (this._cachedHasFocusableChild === void 0) {
      this._cachedHasFocusableChild = false;
      for (const child of this._children) {
        if (child._focusable || child._hasFocusableChild()) {
          this._cachedHasFocusableChild = true;
          break;
        }
      }
    }
    return this._cachedHasFocusableChild;
  }
  children() {
    return this._children;
  }
  _findNeedle() {
    if (this._payload.foundObject)
      return this;
    for (const child of this._children) {
      const found = child._findNeedle();
      if (found)
        return found;
    }
    return null;
  }
  isLeafNode() {
    if (!this._children.length)
      return true;
    if (this._isPlainTextField() || this._isTextOnlyObject())
      return true;
    switch (this._role) {
      case "graphic":
      case "scrollbar":
      case "slider":
      case "separator":
      case "progressbar":
        return true;
    }
    if (this._hasFocusableChild())
      return false;
    if (this._focusable && this._role !== "document" && this._name)
      return true;
    if (this._role === "heading" && this._name)
      return true;
    return false;
  }
  isControl() {
    switch (this._role) {
      case "checkbutton":
      case "check menu item":
      case "check rich option":
      case "combobox":
      case "combobox option":
      case "color chooser":
      case "listbox":
      case "listbox option":
      case "listbox rich option":
      case "popup menu":
      case "menupopup":
      case "menuitem":
      case "menubar":
      case "button":
      case "pushbutton":
      case "radiobutton":
      case "radio menuitem":
      case "scrollbar":
      case "slider":
      case "spinbutton":
      case "switch":
      case "pagetab":
      case "entry":
      case "tree table":
        return true;
      default:
        return false;
    }
  }
  isInteresting(insideControl) {
    if (this._focusable || this._richlyEditable)
      return true;
    if (this.isControl())
      return true;
    if (insideControl)
      return false;
    return this.isLeafNode() && !!this._name.trim();
  }
  serialize() {
    const node2 = {
      role: FFRoleToARIARole.get(this._role) || this._role,
      name: this._name || ""
    };
    const userStringProperties = [
      "name",
      "description",
      "roledescription",
      "valuetext",
      "keyshortcuts"
    ];
    for (const userStringProperty of userStringProperties) {
      if (!(userStringProperty in this._payload))
        continue;
      node2[userStringProperty] = this._payload[userStringProperty];
    }
    const booleanProperties = [
      "disabled",
      "expanded",
      "focused",
      "modal",
      "multiline",
      "multiselectable",
      "readonly",
      "required",
      "selected"
    ];
    for (const booleanProperty of booleanProperties) {
      if (this._role === "document" && booleanProperty === "focused")
        continue;
      const value = this._payload[booleanProperty];
      if (!value)
        continue;
      node2[booleanProperty] = value;
    }
    const numericalProperties = [
      "level"
    ];
    for (const numericalProperty of numericalProperties) {
      if (!(numericalProperty in this._payload))
        continue;
      node2[numericalProperty] = this._payload[numericalProperty];
    }
    const tokenProperties = [
      "autocomplete",
      "haspopup",
      "orientation"
    ];
    for (const tokenProperty of tokenProperties) {
      const value = this._payload[tokenProperty];
      if (!value || value === "false")
        continue;
      node2[tokenProperty] = value;
    }
    const axNode = node2;
    axNode.valueString = this._payload.value;
    if ("checked" in this._payload)
      axNode.checked = this._payload.checked === true ? "checked" : this._payload.checked === "mixed" ? "mixed" : "unchecked";
    if ("pressed" in this._payload)
      axNode.pressed = this._payload.pressed === true ? "pressed" : "released";
    if ("invalid" in this._payload)
      axNode.invalid = this._payload.invalid === true ? "true" : "false";
    return axNode;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/firefox/ffExecutionContext.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FFExecutionContext = class {
  static {
    __name(this, "FFExecutionContext");
  }
  constructor(session2, executionContextId) {
    this._session = session2;
    this._executionContextId = executionContextId;
  }
  async rawEvaluateJSON(expression) {
    const payload = await this._session.send("Runtime.evaluate", {
      expression,
      returnByValue: true,
      executionContextId: this._executionContextId
    }).catch(rewriteError2);
    checkException(payload.exceptionDetails);
    return payload.result.value;
  }
  async rawEvaluateHandle(context2, expression) {
    const payload = await this._session.send("Runtime.evaluate", {
      expression,
      returnByValue: false,
      executionContextId: this._executionContextId
    }).catch(rewriteError2);
    checkException(payload.exceptionDetails);
    return createHandle3(context2, payload.result);
  }
  async evaluateWithArguments(expression, returnByValue, utilityScript, values, handles) {
    const payload = await this._session.send("Runtime.callFunction", {
      functionDeclaration: expression,
      args: [
        { objectId: utilityScript._objectId, value: void 0 },
        ...values.map((value) => ({ value })),
        ...handles.map((handle) => ({ objectId: handle._objectId, value: void 0 }))
      ],
      returnByValue,
      executionContextId: this._executionContextId
    }).catch(rewriteError2);
    checkException(payload.exceptionDetails);
    if (returnByValue)
      return parseEvaluationResultValue(payload.result.value);
    return createHandle3(utilityScript._context, payload.result);
  }
  async getProperties(object) {
    const response = await this._session.send("Runtime.getObjectProperties", {
      executionContextId: this._executionContextId,
      objectId: object._objectId
    });
    const result = /* @__PURE__ */ new Map();
    for (const property of response.properties)
      result.set(property.name, createHandle3(object._context, property.value));
    return result;
  }
  async releaseHandle(handle) {
    if (!handle._objectId)
      return;
    await this._session.send("Runtime.disposeObject", {
      executionContextId: this._executionContextId,
      objectId: handle._objectId
    });
  }
};
function checkException(exceptionDetails) {
  if (!exceptionDetails)
    return;
  if (exceptionDetails.value)
    throw new JavaScriptErrorInEvaluate(JSON.stringify(exceptionDetails.value));
  else
    throw new JavaScriptErrorInEvaluate(exceptionDetails.text + (exceptionDetails.stack ? "\n" + exceptionDetails.stack : ""));
}
__name(checkException, "checkException");
function rewriteError2(error4) {
  if (error4.message.includes("cyclic object value") || error4.message.includes("Object is not serializable"))
    return { result: { type: "undefined", value: void 0 } };
  if (error4 instanceof TypeError && error4.message.startsWith("Converting circular structure to JSON"))
    rewriteErrorMessage(error4, error4.message + " Are you passing a nested JSHandle?");
  if (!isJavaScriptErrorInEvaluate(error4) && !isSessionClosedError(error4))
    throw new Error("Execution context was destroyed, most likely because of a navigation.");
  throw error4;
}
__name(rewriteError2, "rewriteError");
function potentiallyUnserializableValue2(remoteObject) {
  const value = remoteObject.value;
  const unserializableValue = remoteObject.unserializableValue;
  return unserializableValue ? parseUnserializableValue(unserializableValue) : value;
}
__name(potentiallyUnserializableValue2, "potentiallyUnserializableValue");
function renderPreview3(object) {
  if (object.type === "undefined")
    return "undefined";
  if (object.unserializableValue)
    return String(object.unserializableValue);
  if (object.type === "symbol")
    return "Symbol()";
  if (object.subtype === "regexp")
    return "RegExp";
  if (object.subtype === "weakmap")
    return "WeakMap";
  if (object.subtype === "weakset")
    return "WeakSet";
  if (object.subtype)
    return object.subtype[0].toUpperCase() + object.subtype.slice(1);
  if ("value" in object)
    return String(object.value);
}
__name(renderPreview3, "renderPreview");
function createHandle3(context2, remoteObject) {
  if (remoteObject.subtype === "node") {
    assert3(context2 instanceof FrameExecutionContext);
    return new ElementHandle(context2, remoteObject.objectId);
  }
  return new JSHandle(context2, remoteObject.subtype || remoteObject.type || "", renderPreview3(remoteObject), remoteObject.objectId, potentiallyUnserializableValue2(remoteObject));
}
__name(createHandle3, "createHandle");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/firefox/ffInput.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function toModifiersMask2(modifiers) {
  let mask = 0;
  if (modifiers.has("Alt"))
    mask |= 1;
  if (modifiers.has("Control"))
    mask |= 2;
  if (modifiers.has("Shift"))
    mask |= 4;
  if (modifiers.has("Meta"))
    mask |= 8;
  return mask;
}
__name(toModifiersMask2, "toModifiersMask");
function toButtonNumber(button) {
  if (button === "left")
    return 0;
  if (button === "middle")
    return 1;
  if (button === "right")
    return 2;
  return 0;
}
__name(toButtonNumber, "toButtonNumber");
function toButtonsMask2(buttons) {
  let mask = 0;
  if (buttons.has("left"))
    mask |= 1;
  if (buttons.has("right"))
    mask |= 2;
  if (buttons.has("middle"))
    mask |= 4;
  return mask;
}
__name(toButtonsMask2, "toButtonsMask");
var RawKeyboardImpl3 = class {
  static {
    __name(this, "RawKeyboardImpl");
  }
  constructor(client) {
    this._client = client;
  }
  async keydown(modifiers, keyName, description, autoRepeat) {
    let text = description.text;
    if (text === "\r")
      text = "";
    const { code, key, location: location2 } = description;
    await this._client.send("Page.dispatchKeyEvent", {
      type: "keydown",
      keyCode: description.keyCodeWithoutLocation,
      code,
      key,
      repeat: autoRepeat,
      location: location2,
      text
    });
  }
  async keyup(modifiers, keyName, description) {
    const { code, key, location: location2 } = description;
    await this._client.send("Page.dispatchKeyEvent", {
      type: "keyup",
      key,
      keyCode: description.keyCodeWithoutLocation,
      code,
      location: location2,
      repeat: false
    });
  }
  async sendText(text) {
    await this._client.send("Page.insertText", { text });
  }
};
var RawMouseImpl3 = class {
  static {
    __name(this, "RawMouseImpl");
  }
  constructor(client) {
    this._client = client;
  }
  async move(x, y, button, buttons, modifiers, forClick) {
    await this._client.send("Page.dispatchMouseEvent", {
      type: "mousemove",
      button: 0,
      buttons: toButtonsMask2(buttons),
      x: Math.floor(x),
      y: Math.floor(y),
      modifiers: toModifiersMask2(modifiers)
    });
  }
  async down(x, y, button, buttons, modifiers, clickCount) {
    await this._client.send("Page.dispatchMouseEvent", {
      type: "mousedown",
      button: toButtonNumber(button),
      buttons: toButtonsMask2(buttons),
      x: Math.floor(x),
      y: Math.floor(y),
      modifiers: toModifiersMask2(modifiers),
      clickCount
    });
  }
  async up(x, y, button, buttons, modifiers, clickCount) {
    await this._client.send("Page.dispatchMouseEvent", {
      type: "mouseup",
      button: toButtonNumber(button),
      buttons: toButtonsMask2(buttons),
      x: Math.floor(x),
      y: Math.floor(y),
      modifiers: toModifiersMask2(modifiers),
      clickCount
    });
  }
  async wheel(x, y, buttons, modifiers, deltaX, deltaY) {
    await this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, { world: "utility" });
    await this._client.send("Page.dispatchWheelEvent", {
      deltaX,
      deltaY,
      x: Math.floor(x),
      y: Math.floor(y),
      deltaZ: 0,
      modifiers: toModifiersMask2(modifiers)
    });
  }
  setPage(page) {
    this._page = page;
  }
};
var RawTouchscreenImpl3 = class {
  static {
    __name(this, "RawTouchscreenImpl");
  }
  constructor(client) {
    this._client = client;
  }
  async tap(x, y, modifiers) {
    await this._client.send("Page.dispatchTapEvent", {
      x,
      y,
      modifiers: toModifiersMask2(modifiers)
    });
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/firefox/ffNetworkManager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FFNetworkManager = class {
  static {
    __name(this, "FFNetworkManager");
  }
  constructor(session2, page) {
    this._session = session2;
    this._requests = /* @__PURE__ */ new Map();
    this._page = page;
    this._eventListeners = [
      eventsHelper.addEventListener(session2, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this)),
      eventsHelper.addEventListener(session2, "Network.responseReceived", this._onResponseReceived.bind(this)),
      eventsHelper.addEventListener(session2, "Network.requestFinished", this._onRequestFinished.bind(this)),
      eventsHelper.addEventListener(session2, "Network.requestFailed", this._onRequestFailed.bind(this))
    ];
  }
  dispose() {
    eventsHelper.removeEventListeners(this._eventListeners);
  }
  async setRequestInterception(enabled) {
    await Promise.all([
      this._session.send("Network.setRequestInterception", { enabled }),
      this._session.send("Page.setCacheDisabled", { cacheDisabled: enabled })
    ]);
  }
  _onRequestWillBeSent(event) {
    const redirectedFrom = event.redirectedFrom ? this._requests.get(event.redirectedFrom) || null : null;
    const frame = redirectedFrom ? redirectedFrom.request.frame() : event.frameId ? this._page._frameManager.frame(event.frameId) : null;
    if (!frame)
      return;
    if (redirectedFrom)
      this._requests.delete(redirectedFrom._id);
    const request4 = new InterceptableRequest2(frame, redirectedFrom, event);
    let route;
    if (event.isIntercepted)
      route = new FFRouteImpl(this._session, request4);
    this._requests.set(request4._id, request4);
    this._page._frameManager.requestStarted(request4.request, route);
  }
  _onResponseReceived(event) {
    const request4 = this._requests.get(event.requestId);
    if (!request4)
      return;
    const getResponseBody = /* @__PURE__ */ __name(async () => {
      const response2 = await this._session.send("Network.getResponseBody", {
        requestId: request4._id
      });
      if (response2.evicted)
        throw new Error(`Response body for ${request4.request.method()} ${request4.request.url()} was evicted!`);
      return Buffer.from(response2.base64body, "base64");
    }, "getResponseBody");
    const startTime = event.timing.startTime;
    function relativeToStart(time3) {
      if (!time3)
        return -1;
      return (time3 - startTime) / 1e3;
    }
    __name(relativeToStart, "relativeToStart");
    const timing = {
      startTime: startTime / 1e3,
      domainLookupStart: relativeToStart(event.timing.domainLookupStart),
      domainLookupEnd: relativeToStart(event.timing.domainLookupEnd),
      connectStart: relativeToStart(event.timing.connectStart),
      secureConnectionStart: relativeToStart(event.timing.secureConnectionStart),
      connectEnd: relativeToStart(event.timing.connectEnd),
      requestStart: relativeToStart(event.timing.requestStart),
      responseStart: relativeToStart(event.timing.responseStart)
    };
    const response = new Response2(request4.request, event.status, event.statusText, parseMultivalueHeaders(event.headers), timing, getResponseBody, event.fromServiceWorker);
    if (event?.remoteIPAddress && typeof event?.remotePort === "number") {
      response._serverAddrFinished({
        ipAddress: event.remoteIPAddress,
        port: event.remotePort
      });
    } else {
      response._serverAddrFinished();
    }
    response._securityDetailsFinished({
      protocol: event?.securityDetails?.protocol,
      subjectName: event?.securityDetails?.subjectName,
      issuer: event?.securityDetails?.issuer,
      validFrom: event?.securityDetails?.validFrom,
      validTo: event?.securityDetails?.validTo
    });
    response.setRawResponseHeaders(null);
    response.setResponseHeadersSize(null);
    this._page._frameManager.requestReceivedResponse(response);
  }
  _onRequestFinished(event) {
    const request4 = this._requests.get(event.requestId);
    if (!request4)
      return;
    const response = request4.request._existingResponse();
    response.setTransferSize(event.transferSize);
    response.setEncodedBodySize(event.encodedBodySize);
    const isRedirected = response.status() >= 300 && response.status() <= 399;
    const responseEndTime = event.responseEndTime ? event.responseEndTime / 1e3 - response.timing().startTime : -1;
    if (isRedirected) {
      response._requestFinished(responseEndTime);
    } else {
      this._requests.delete(request4._id);
      response._requestFinished(responseEndTime);
    }
    if (event.protocolVersion)
      response._setHttpVersion(event.protocolVersion);
    this._page._frameManager.reportRequestFinished(request4.request, response);
  }
  _onRequestFailed(event) {
    const request4 = this._requests.get(event.requestId);
    if (!request4)
      return;
    this._requests.delete(request4._id);
    const response = request4.request._existingResponse();
    if (response) {
      response.setTransferSize(null);
      response.setEncodedBodySize(null);
      response._requestFinished(-1);
    }
    request4.request._setFailureText(event.errorCode);
    this._page._frameManager.requestFailed(request4.request, event.errorCode === "NS_BINDING_ABORTED");
  }
};
var causeToResourceType = {
  TYPE_INVALID: "other",
  TYPE_OTHER: "other",
  TYPE_SCRIPT: "script",
  TYPE_IMAGE: "image",
  TYPE_STYLESHEET: "stylesheet",
  TYPE_OBJECT: "other",
  TYPE_DOCUMENT: "document",
  TYPE_SUBDOCUMENT: "document",
  TYPE_REFRESH: "document",
  TYPE_XBL: "other",
  TYPE_PING: "other",
  TYPE_XMLHTTPREQUEST: "xhr",
  TYPE_OBJECT_SUBREQUEST: "other",
  TYPE_DTD: "other",
  TYPE_FONT: "font",
  TYPE_MEDIA: "media",
  TYPE_WEBSOCKET: "websocket",
  TYPE_CSP_REPORT: "other",
  TYPE_XSLT: "other",
  TYPE_BEACON: "other",
  TYPE_FETCH: "fetch",
  TYPE_IMAGESET: "image",
  TYPE_WEB_MANIFEST: "manifest"
};
var internalCauseToResourceType = {
  TYPE_INTERNAL_EVENTSOURCE: "eventsource"
};
var InterceptableRequest2 = class {
  static {
    __name(this, "InterceptableRequest");
  }
  constructor(frame, redirectedFrom, payload) {
    this._id = payload.requestId;
    if (redirectedFrom)
      redirectedFrom._redirectedTo = this;
    let postDataBuffer = null;
    if (payload.postData)
      postDataBuffer = Buffer.from(payload.postData, "base64");
    this.request = new Request(
      frame._page._browserContext,
      frame,
      null,
      redirectedFrom ? redirectedFrom.request : null,
      payload.navigationId,
      payload.url,
      internalCauseToResourceType[payload.internalCause] || causeToResourceType[payload.cause] || "other",
      payload.method,
      postDataBuffer,
      payload.headers
    );
    this.request.setRawRequestHeaders(null);
  }
  _finalRequest() {
    let request4 = this;
    while (request4._redirectedTo)
      request4 = request4._redirectedTo;
    return request4;
  }
};
var FFRouteImpl = class {
  static {
    __name(this, "FFRouteImpl");
  }
  constructor(session2, request4) {
    this._session = session2;
    this._request = request4;
  }
  async continue(overrides) {
    await this._session.sendMayFail("Network.resumeInterceptedRequest", {
      requestId: this._request._id,
      url: overrides.url,
      method: overrides.method,
      headers: overrides.headers,
      postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
    });
  }
  async fulfill(response) {
    const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
    await this._session.sendMayFail("Network.fulfillInterceptedRequest", {
      requestId: this._request._id,
      status: response.status,
      statusText: statusText(response.status),
      headers: response.headers,
      base64body
    });
  }
  async abort(errorCode) {
    await this._session.sendMayFail("Network.abortInterceptedRequest", {
      requestId: this._request._id,
      errorCode
    });
  }
};
function parseMultivalueHeaders(headers) {
  const result = [];
  for (const header of headers) {
    const separator = header.name.toLowerCase() === "set-cookie" ? "\n" : ",";
    const tokens = header.value.split(separator).map((s) => s.trim());
    for (const token of tokens)
      result.push({ name: header.name, value: token });
  }
  return result;
}
__name(parseMultivalueHeaders, "parseMultivalueHeaders");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/firefox/ffPage.js
var UTILITY_WORLD_NAME3 = "__playwright_utility_world__";
var FFPage = class {
  static {
    __name(this, "FFPage");
  }
  constructor(session2, browserContext, opener) {
    this.cspErrorsAsynchronousForInlineScripts = true;
    this._reportedAsNew = false;
    this._workers = /* @__PURE__ */ new Map();
    this._initScripts = [];
    this._session = session2;
    this._opener = opener;
    this.rawKeyboard = new RawKeyboardImpl3(session2);
    this.rawMouse = new RawMouseImpl3(session2);
    this.rawTouchscreen = new RawTouchscreenImpl3(session2);
    this._contextIdToContext = /* @__PURE__ */ new Map();
    this._browserContext = browserContext;
    this._page = new Page(this, browserContext);
    this.rawMouse.setPage(this._page);
    this._networkManager = new FFNetworkManager(session2, this._page);
    this._page.on(Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame));
    this._eventListeners = [
      eventsHelper.addEventListener(this._session, "Page.eventFired", this._onEventFired.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.frameAttached", this._onFrameAttached.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.frameDetached", this._onFrameDetached.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.navigationAborted", this._onNavigationAborted.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.navigationCommitted", this._onNavigationCommitted.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.navigationStarted", this._onNavigationStarted.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.sameDocumentNavigation", this._onSameDocumentNavigation.bind(this)),
      eventsHelper.addEventListener(this._session, "Runtime.executionContextCreated", this._onExecutionContextCreated.bind(this)),
      eventsHelper.addEventListener(this._session, "Runtime.executionContextDestroyed", this._onExecutionContextDestroyed.bind(this)),
      eventsHelper.addEventListener(this._session, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.linkClicked", (event) => this._onLinkClicked(event.phase)),
      eventsHelper.addEventListener(this._session, "Page.uncaughtError", this._onUncaughtError.bind(this)),
      eventsHelper.addEventListener(this._session, "Runtime.console", this._onConsole.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.dialogOpened", this._onDialogOpened.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.bindingCalled", this._onBindingCalled.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.fileChooserOpened", this._onFileChooserOpened.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.workerCreated", this._onWorkerCreated.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.workerDestroyed", this._onWorkerDestroyed.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.dispatchMessageFromWorker", this._onDispatchMessageFromWorker.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.crashed", this._onCrashed.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.videoRecordingStarted", this._onVideoRecordingStarted.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.webSocketCreated", this._onWebSocketCreated.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.webSocketClosed", this._onWebSocketClosed.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.webSocketFrameReceived", this._onWebSocketFrameReceived.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.webSocketFrameSent", this._onWebSocketFrameSent.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.screencastFrame", this._onScreencastFrame.bind(this))
    ];
    this._session.once("Page.ready", () => {
      if (this._reportedAsNew)
        return;
      this._reportedAsNew = true;
      this._page.reportAsNew(this._opener?._page);
    });
    this.addInitScript(new InitScript("", true), UTILITY_WORLD_NAME3).catch((e) => this._markAsError(e));
  }
  async _markAsError(error4) {
    if (this._reportedAsNew)
      return;
    this._reportedAsNew = true;
    this._page.reportAsNew(this._opener?._page, error4);
  }
  _onWebSocketCreated(event) {
    this._page._frameManager.onWebSocketCreated(webSocketId(event.frameId, event.wsid), event.requestURL);
    this._page._frameManager.onWebSocketRequest(webSocketId(event.frameId, event.wsid));
  }
  _onWebSocketClosed(event) {
    if (event.error)
      this._page._frameManager.webSocketError(webSocketId(event.frameId, event.wsid), event.error);
    this._page._frameManager.webSocketClosed(webSocketId(event.frameId, event.wsid));
  }
  _onWebSocketFrameReceived(event) {
    this._page._frameManager.webSocketFrameReceived(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
  }
  _onWebSocketFrameSent(event) {
    this._page._frameManager.onWebSocketFrameSent(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
  }
  _onExecutionContextCreated(payload) {
    const { executionContextId, auxData } = payload;
    const frame = this._page._frameManager.frame(auxData.frameId);
    if (!frame)
      return;
    const delegate = new FFExecutionContext(this._session, executionContextId);
    let worldName = null;
    if (auxData.name === UTILITY_WORLD_NAME3)
      worldName = "utility";
    else if (!auxData.name)
      worldName = "main";
    const context2 = new FrameExecutionContext(delegate, frame, worldName);
    if (worldName)
      frame._contextCreated(worldName, context2);
    this._contextIdToContext.set(executionContextId, context2);
  }
  _onExecutionContextDestroyed(payload) {
    const { executionContextId } = payload;
    const context2 = this._contextIdToContext.get(executionContextId);
    if (!context2)
      return;
    this._contextIdToContext.delete(executionContextId);
    context2.frame._contextDestroyed(context2);
  }
  _onExecutionContextsCleared() {
    for (const executionContextId of Array.from(this._contextIdToContext.keys()))
      this._onExecutionContextDestroyed({ executionContextId });
  }
  _removeContextsForFrame(frame) {
    for (const [contextId, context2] of this._contextIdToContext) {
      if (context2.frame === frame)
        this._contextIdToContext.delete(contextId);
    }
  }
  _onLinkClicked(phase) {
    if (phase === "before")
      this._page._frameManager.frameWillPotentiallyRequestNavigation();
    else
      this._page._frameManager.frameDidPotentiallyRequestNavigation();
  }
  _onNavigationStarted(params) {
    this._page._frameManager.frameRequestedNavigation(params.frameId, params.navigationId);
  }
  _onNavigationAborted(params) {
    this._page._frameManager.frameAbortedNavigation(params.frameId, params.errorText, params.navigationId);
  }
  _onNavigationCommitted(params) {
    for (const [workerId, worker] of this._workers) {
      if (worker.frameId === params.frameId)
        this._onWorkerDestroyed({ workerId });
    }
    this._page._frameManager.frameCommittedNewDocumentNavigation(params.frameId, params.url, params.name || "", params.navigationId || "", false);
  }
  _onSameDocumentNavigation(params) {
    this._page._frameManager.frameCommittedSameDocumentNavigation(params.frameId, params.url);
  }
  _onFrameAttached(params) {
    this._page._frameManager.frameAttached(params.frameId, params.parentFrameId);
  }
  _onFrameDetached(params) {
    this._page._frameManager.frameDetached(params.frameId);
  }
  _onEventFired(payload) {
    const { frameId, name } = payload;
    if (name === "load")
      this._page._frameManager.frameLifecycleEvent(frameId, "load");
    if (name === "DOMContentLoaded")
      this._page._frameManager.frameLifecycleEvent(frameId, "domcontentloaded");
  }
  _onUncaughtError(params) {
    const { name, message } = splitErrorMessage(params.message);
    const error4 = new Error(message);
    error4.stack = params.message + "\n" + params.stack.split("\n").filter(Boolean).map((a) => a.replace(/([^@]*)@(.*)/, "    at $1 ($2)")).join("\n");
    error4.name = name;
    this._page.emitOnContextOnceInitialized(BrowserContext.Events.PageError, error4, this._page);
  }
  _onConsole(payload) {
    const { type: type2, args, executionContextId, location: location2 } = payload;
    const context2 = this._contextIdToContext.get(executionContextId);
    if (!context2)
      return;
    this._page._addConsoleMessage(type2 === "warn" ? "warning" : type2, args.map((arg) => createHandle3(context2, arg)), location2);
  }
  _onDialogOpened(params) {
    this._page.emitOnContext(BrowserContext.Events.Dialog, new Dialog(
      this._page,
      params.type,
      params.message,
      async (accept, promptText) => {
        await this._session.sendMayFail("Page.handleDialog", { dialogId: params.dialogId, accept, promptText });
      },
      params.defaultValue
    ));
  }
  async _onBindingCalled(event) {
    const pageOrError = await this._page.waitForInitializedOrError();
    if (!(pageOrError instanceof Error)) {
      const context2 = this._contextIdToContext.get(event.executionContextId);
      if (context2)
        await this._page._onBindingCalled(event.payload, context2);
    }
  }
  async _onFileChooserOpened(payload) {
    const { executionContextId, element } = payload;
    const context2 = this._contextIdToContext.get(executionContextId);
    if (!context2)
      return;
    const handle = createHandle3(context2, element).asElement();
    await this._page._onFileChooserOpened(handle);
  }
  async _onWorkerCreated(event) {
    const workerId = event.workerId;
    const worker = new Worker(this._page, event.url);
    const workerSession = new FFSession(this._session._connection, workerId, (message) => {
      this._session.send("Page.sendMessageToWorker", {
        frameId: event.frameId,
        workerId,
        message: JSON.stringify(message)
      }).catch((e) => {
        workerSession.dispatchMessage({ id: message.id, method: "", params: {}, error: { message: e.message, data: void 0 } });
      });
    });
    this._workers.set(workerId, { session: workerSession, frameId: event.frameId });
    this._page._addWorker(workerId, worker);
    workerSession.once("Runtime.executionContextCreated", (event2) => {
      worker._createExecutionContext(new FFExecutionContext(workerSession, event2.executionContextId));
    });
    workerSession.on("Runtime.console", (event2) => {
      const { type: type2, args, location: location2 } = event2;
      const context2 = worker._existingExecutionContext;
      this._page._addConsoleMessage(type2, args.map((arg) => createHandle3(context2, arg)), location2);
    });
  }
  _onWorkerDestroyed(event) {
    const workerId = event.workerId;
    const worker = this._workers.get(workerId);
    if (!worker)
      return;
    worker.session.dispose();
    this._workers.delete(workerId);
    this._page._removeWorker(workerId);
  }
  async _onDispatchMessageFromWorker(event) {
    const worker = this._workers.get(event.workerId);
    if (!worker)
      return;
    worker.session.dispatchMessage(JSON.parse(event.message));
  }
  async _onCrashed(event) {
    this._session.markAsCrashed();
    this._page._didCrash();
  }
  _onVideoRecordingStarted(event) {
    this._browserContext._browser._videoStarted(this._browserContext, event.screencastId, event.file, this._page.waitForInitializedOrError());
  }
  didClose() {
    this._markAsError(new TargetClosedError());
    this._session.dispose();
    eventsHelper.removeEventListeners(this._eventListeners);
    this._networkManager.dispose();
    this._page._didClose();
  }
  async navigateFrame(frame, url4, referer) {
    const response = await this._session.send("Page.navigate", { url: url4, referer, frameId: frame._id });
    return { newDocumentId: response.navigationId || void 0 };
  }
  async updateExtraHTTPHeaders() {
    await this._session.send("Network.setExtraHTTPHeaders", { headers: this._page.extraHTTPHeaders() || [] });
  }
  async updateEmulatedViewportSize() {
    const viewportSize = this._page.viewportSize();
    await this._session.send("Page.setViewportSize", { viewportSize });
  }
  async bringToFront() {
    await this._session.send("Page.bringToFront", {});
  }
  async updateEmulateMedia() {
    const emulatedMedia = this._page.emulatedMedia();
    const colorScheme = emulatedMedia.colorScheme === "no-override" ? void 0 : emulatedMedia.colorScheme;
    const reducedMotion = emulatedMedia.reducedMotion === "no-override" ? void 0 : emulatedMedia.reducedMotion;
    const forcedColors = emulatedMedia.forcedColors === "no-override" ? void 0 : emulatedMedia.forcedColors;
    const contrast = emulatedMedia.contrast === "no-override" ? void 0 : emulatedMedia.contrast;
    await this._session.send("Page.setEmulatedMedia", {
      // Empty string means reset.
      type: emulatedMedia.media === "no-override" ? "" : emulatedMedia.media,
      colorScheme,
      reducedMotion,
      forcedColors,
      contrast
    });
  }
  async updateRequestInterception() {
    await this._networkManager.setRequestInterception(this._page.needsRequestInterception());
  }
  async updateFileChooserInterception() {
    const enabled = this._page.fileChooserIntercepted();
    await this._session.send("Page.setInterceptFileChooserDialog", { enabled }).catch(() => {
    });
  }
  async reload() {
    await this._session.send("Page.reload");
  }
  async goBack() {
    const { success } = await this._session.send("Page.goBack", { frameId: this._page.mainFrame()._id });
    return success;
  }
  async goForward() {
    const { success } = await this._session.send("Page.goForward", { frameId: this._page.mainFrame()._id });
    return success;
  }
  async requestGC() {
    await this._session.send("Heap.collectGarbage");
  }
  async addInitScript(initScript, worldName) {
    this._initScripts.push({ initScript, worldName });
    await this._session.send("Page.setInitScripts", { scripts: this._initScripts.map((s) => ({ script: s.initScript.source, worldName: s.worldName })) });
  }
  async removeNonInternalInitScripts() {
    this._initScripts = this._initScripts.filter((s) => s.initScript.internal);
    await this._session.send("Page.setInitScripts", { scripts: this._initScripts.map((s) => ({ script: s.initScript.source, worldName: s.worldName })) });
  }
  async closePage(runBeforeUnload) {
    await this._session.send("Page.close", { runBeforeUnload });
  }
  async setBackgroundColor(color) {
    if (color)
      throw new Error("Not implemented");
  }
  async takeScreenshot(progress3, format2, documentRect, viewportRect, quality, fitsViewport, scale) {
    if (!documentRect) {
      const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress3, () => ({ x: window.scrollX, y: window.scrollY }));
      documentRect = {
        x: viewportRect.x + scrollOffset.x,
        y: viewportRect.y + scrollOffset.y,
        width: viewportRect.width,
        height: viewportRect.height
      };
    }
    progress3.throwIfAborted();
    const { data } = await this._session.send("Page.screenshot", {
      mimeType: "image/" + format2,
      clip: documentRect,
      quality,
      omitDeviceScaleFactor: scale === "css"
    });
    return Buffer.from(data, "base64");
  }
  async getContentFrame(handle) {
    const { contentFrameId } = await this._session.send("Page.describeNode", {
      frameId: handle._context.frame._id,
      objectId: handle._objectId
    });
    if (!contentFrameId)
      return null;
    return this._page._frameManager.frame(contentFrameId);
  }
  async getOwnerFrame(handle) {
    const { ownerFrameId } = await this._session.send("Page.describeNode", {
      frameId: handle._context.frame._id,
      objectId: handle._objectId
    });
    return ownerFrameId || null;
  }
  async getBoundingBox(handle) {
    const quads = await this.getContentQuads(handle);
    if (!quads || !quads.length)
      return null;
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (const quad of quads) {
      for (const point of quad) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
    }
    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
  }
  async scrollRectIntoViewIfNeeded(handle, rect) {
    return await this._session.send("Page.scrollIntoViewIfNeeded", {
      frameId: handle._context.frame._id,
      objectId: handle._objectId,
      rect
    }).then(() => "done").catch((e) => {
      if (e instanceof Error && e.message.includes("Node is detached from document"))
        return "error:notconnected";
      if (e instanceof Error && e.message.includes("Node does not have a layout object"))
        return "error:notvisible";
      throw e;
    });
  }
  async setScreencastOptions(options2) {
    if (options2) {
      const { screencastId } = await this._session.send("Page.startScreencast", options2);
      this._screencastId = screencastId;
    } else {
      await this._session.send("Page.stopScreencast");
    }
  }
  _onScreencastFrame(event) {
    if (!this._screencastId)
      return;
    const screencastId = this._screencastId;
    this._page.throttleScreencastFrameAck(() => {
      this._session.send("Page.screencastFrameAck", { screencastId }).catch((e) => debugLogger.log("error", e));
    });
    const buffer2 = Buffer.from(event.data, "base64");
    this._page.emit(Page.Events.ScreencastFrame, {
      buffer: buffer2,
      width: event.deviceWidth,
      height: event.deviceHeight
    });
  }
  rafCountForStablePosition() {
    return 1;
  }
  async getContentQuads(handle) {
    const result = await this._session.sendMayFail("Page.getContentQuads", {
      frameId: handle._context.frame._id,
      objectId: handle._objectId
    });
    if (!result)
      return null;
    return result.quads.map((quad) => [quad.p1, quad.p2, quad.p3, quad.p4]);
  }
  async setInputFilePaths(handle, files) {
    await this._session.send("Page.setFileInputFiles", {
      frameId: handle._context.frame._id,
      objectId: handle._objectId,
      files
    });
  }
  async adoptElementHandle(handle, to) {
    const result = await this._session.send("Page.adoptNode", {
      frameId: handle._context.frame._id,
      objectId: handle._objectId,
      executionContextId: to.delegate._executionContextId
    });
    if (!result.remoteObject)
      throw new Error(kUnableToAdoptErrorMessage);
    return createHandle3(to, result.remoteObject);
  }
  async getAccessibilityTree(needle) {
    return getAccessibilityTree2(this._session, needle);
  }
  async inputActionEpilogue() {
  }
  async resetForReuse() {
    await this.rawMouse.move(-1, -1, "none", /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), false);
  }
  async getFrameElement(frame) {
    const parent = frame.parentFrame();
    if (!parent)
      throw new Error("Frame has been detached.");
    const context2 = await parent._mainContext();
    const result = await this._session.send("Page.adoptNode", {
      frameId: frame._id,
      executionContextId: context2.delegate._executionContextId
    });
    if (!result.remoteObject)
      throw new Error("Frame has been detached.");
    return createHandle3(context2, result.remoteObject);
  }
  shouldToggleStyleSheetToSyncAnimations() {
    return false;
  }
};
function webSocketId(frameId, wsid) {
  return `${frameId}---${wsid}`;
}
__name(webSocketId, "webSocketId");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/firefox/ffBrowser.js
var FFBrowser = class _FFBrowser extends Browser {
  static {
    __name(this, "FFBrowser");
  }
  constructor(parent, connection, options2) {
    super(parent, options2);
    this._version = "";
    this._userAgent = "";
    this._connection = connection;
    this.session = connection.rootSession;
    this._ffPages = /* @__PURE__ */ new Map();
    this._contexts = /* @__PURE__ */ new Map();
    this._connection.on(ConnectionEvents2.Disconnected, () => this._onDisconnect());
    this.session.on("Browser.attachedToTarget", this._onAttachedToTarget.bind(this));
    this.session.on("Browser.detachedFromTarget", this._onDetachedFromTarget.bind(this));
    this.session.on("Browser.downloadCreated", this._onDownloadCreated.bind(this));
    this.session.on("Browser.downloadFinished", this._onDownloadFinished.bind(this));
    this.session.on("Browser.videoRecordingFinished", this._onVideoRecordingFinished.bind(this));
  }
  static async connect(parent, transport, options2) {
    const connection = new FFConnection(transport, options2.protocolLogger, options2.browserLogsCollector);
    const browser3 = new _FFBrowser(parent, connection, options2);
    if (options2.__testHookOnConnectToBrowser)
      await options2.__testHookOnConnectToBrowser();
    let firefoxUserPrefs = options2.originalLaunchOptions.firefoxUserPrefs ?? {};
    if (Object.keys(kBandaidFirefoxUserPrefs).length)
      firefoxUserPrefs = { ...kBandaidFirefoxUserPrefs, ...firefoxUserPrefs };
    const promises2 = [
      browser3.session.send("Browser.enable", {
        attachToDefaultContext: !!options2.persistent,
        userPrefs: Object.entries(firefoxUserPrefs).map(([name, value]) => ({ name, value }))
      }),
      browser3._initVersion()
    ];
    if (options2.persistent) {
      browser3._defaultContext = new FFBrowserContext(browser3, void 0, options2.persistent);
      promises2.push(browser3._defaultContext._initialize());
    }
    const proxy = options2.originalLaunchOptions.proxyOverride || options2.proxy;
    if (proxy)
      promises2.push(browser3.session.send("Browser.setBrowserProxy", toJugglerProxyOptions(proxy)));
    await Promise.all(promises2);
    return browser3;
  }
  async _initVersion() {
    const result = await this.session.send("Browser.getInfo");
    this._version = result.version.substring(result.version.indexOf("/") + 1);
    this._userAgent = result.userAgent;
  }
  isConnected() {
    return !this._connection._closed;
  }
  async doCreateNewContext(options2) {
    if (options2.isMobile)
      throw new Error("options.isMobile is not supported in Firefox");
    const { browserContextId } = await this.session.send("Browser.createBrowserContext", { removeOnDetach: true });
    const context2 = new FFBrowserContext(this, browserContextId, options2);
    await context2._initialize();
    this._contexts.set(browserContextId, context2);
    return context2;
  }
  contexts() {
    return Array.from(this._contexts.values());
  }
  version() {
    return this._version;
  }
  userAgent() {
    return this._userAgent;
  }
  _onDetachedFromTarget(payload) {
    const ffPage = this._ffPages.get(payload.targetId);
    this._ffPages.delete(payload.targetId);
    ffPage.didClose();
  }
  _onAttachedToTarget(payload) {
    const { targetId, browserContextId, openerId, type: type2 } = payload.targetInfo;
    assert3(type2 === "page");
    const context2 = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;
    assert3(context2, `Unknown context id:${browserContextId}, _defaultContext: ${this._defaultContext}`);
    const session2 = this._connection.createSession(payload.sessionId);
    const opener = openerId ? this._ffPages.get(openerId) : null;
    const ffPage = new FFPage(session2, context2, opener);
    this._ffPages.set(targetId, ffPage);
  }
  _onDownloadCreated(payload) {
    const ffPage = this._ffPages.get(payload.pageTargetId);
    if (!ffPage)
      return;
    ffPage._page._frameManager.frameAbortedNavigation(payload.frameId, "Download is starting");
    let originPage = ffPage._page.initializedOrUndefined();
    if (!originPage) {
      ffPage._markAsError(new Error("Starting new page download"));
      if (ffPage._opener)
        originPage = ffPage._opener._page.initializedOrUndefined();
    }
    if (!originPage)
      return;
    this._downloadCreated(originPage, payload.uuid, payload.url, payload.suggestedFileName);
  }
  _onDownloadFinished(payload) {
    const error4 = payload.canceled ? "canceled" : payload.error;
    this._downloadFinished(payload.uuid, error4);
  }
  _onVideoRecordingFinished(payload) {
    this._takeVideo(payload.screencastId)?.reportFinished();
  }
  _onDisconnect() {
    for (const video of this._idToVideo.values())
      video.artifact.reportFinished(new TargetClosedError());
    this._idToVideo.clear();
    for (const ffPage of this._ffPages.values())
      ffPage.didClose();
    this._ffPages.clear();
    this._didClose();
  }
};
var FFBrowserContext = class extends BrowserContext {
  static {
    __name(this, "FFBrowserContext");
  }
  constructor(browser3, browserContextId, options2) {
    super(browser3, options2, browserContextId);
  }
  async _initialize() {
    assert3(!this._ffPages().length);
    const browserContextId = this._browserContextId;
    const promises2 = [
      super._initialize(),
      this._browser.session.send("Browser.addBinding", { browserContextId: this._browserContextId, name: PageBinding.kPlaywrightBinding, script: "" }),
      this._updateInitScripts()
    ];
    if (this._options.acceptDownloads !== "internal-browser-default") {
      promises2.push(this._browser.session.send("Browser.setDownloadOptions", {
        browserContextId,
        downloadOptions: {
          behavior: this._options.acceptDownloads === "accept" ? "saveToDisk" : "cancel",
          downloadsDir: this._browser.options.downloadsPath
        }
      }));
    }
    if (this._options.viewport) {
      const viewport = {
        viewportSize: { width: this._options.viewport.width, height: this._options.viewport.height },
        deviceScaleFactor: this._options.deviceScaleFactor || 1
      };
      promises2.push(this._browser.session.send("Browser.setDefaultViewport", { browserContextId, viewport }));
    }
    if (this._options.hasTouch)
      promises2.push(this._browser.session.send("Browser.setTouchOverride", { browserContextId, hasTouch: true }));
    if (this._options.userAgent)
      promises2.push(this._browser.session.send("Browser.setUserAgentOverride", { browserContextId, userAgent: this._options.userAgent }));
    if (this._options.bypassCSP)
      promises2.push(this._browser.session.send("Browser.setBypassCSP", { browserContextId, bypassCSP: true }));
    if (this._options.ignoreHTTPSErrors || this._options.internalIgnoreHTTPSErrors)
      promises2.push(this._browser.session.send("Browser.setIgnoreHTTPSErrors", { browserContextId, ignoreHTTPSErrors: true }));
    if (this._options.javaScriptEnabled === false)
      promises2.push(this._browser.session.send("Browser.setJavaScriptDisabled", { browserContextId, javaScriptDisabled: true }));
    if (this._options.locale)
      promises2.push(this._browser.session.send("Browser.setLocaleOverride", { browserContextId, locale: this._options.locale }));
    if (this._options.timezoneId)
      promises2.push(this._browser.session.send("Browser.setTimezoneOverride", { browserContextId, timezoneId: this._options.timezoneId }));
    if (this._options.extraHTTPHeaders || this._options.locale)
      promises2.push(this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []));
    if (this._options.httpCredentials)
      promises2.push(this.setHTTPCredentials(this._options.httpCredentials));
    if (this._options.geolocation)
      promises2.push(this.setGeolocation(this._options.geolocation));
    if (this._options.offline)
      promises2.push(this.setOffline(this._options.offline));
    if (this._options.colorScheme !== "no-override") {
      promises2.push(this._browser.session.send("Browser.setColorScheme", {
        browserContextId,
        colorScheme: this._options.colorScheme !== void 0 ? this._options.colorScheme : "light"
      }));
    }
    if (this._options.reducedMotion !== "no-override") {
      promises2.push(this._browser.session.send("Browser.setReducedMotion", {
        browserContextId,
        reducedMotion: this._options.reducedMotion !== void 0 ? this._options.reducedMotion : "no-preference"
      }));
    }
    if (this._options.forcedColors !== "no-override") {
      promises2.push(this._browser.session.send("Browser.setForcedColors", {
        browserContextId,
        forcedColors: this._options.forcedColors !== void 0 ? this._options.forcedColors : "none"
      }));
    }
    if (this._options.contrast !== "no-override") {
      promises2.push(this._browser.session.send("Browser.setContrast", {
        browserContextId,
        contrast: this._options.contrast !== void 0 ? this._options.contrast : "no-preference"
      }));
    }
    if (this._options.recordVideo) {
      promises2.push(this._ensureVideosPath().then(() => {
        return this._browser.session.send("Browser.setVideoRecordingOptions", {
          // validateBrowserContextOptions ensures correct video size.
          options: {
            ...this._options.recordVideo.size,
            dir: this._options.recordVideo.dir
          },
          browserContextId: this._browserContextId
        });
      }));
    }
    const proxy = this._options.proxyOverride || this._options.proxy;
    if (proxy) {
      promises2.push(this._browser.session.send("Browser.setContextProxy", {
        browserContextId: this._browserContextId,
        ...toJugglerProxyOptions(proxy)
      }));
    }
    await Promise.all(promises2);
  }
  _ffPages() {
    return Array.from(this._browser._ffPages.values()).filter((ffPage) => ffPage._browserContext === this);
  }
  possiblyUninitializedPages() {
    return this._ffPages().map((ffPage) => ffPage._page);
  }
  async doCreateNewPage() {
    assertBrowserContextIsNotOwned(this);
    const { targetId } = await this._browser.session.send("Browser.newPage", {
      browserContextId: this._browserContextId
    }).catch((e) => {
      if (e.message.includes("Failed to override timezone"))
        throw new Error(`Invalid timezone ID: ${this._options.timezoneId}`);
      throw e;
    });
    return this._browser._ffPages.get(targetId)._page;
  }
  async doGetCookies(urls) {
    const { cookies } = await this._browser.session.send("Browser.getCookies", { browserContextId: this._browserContextId });
    return filterCookies(cookies.map((c) => {
      const copy = { ...c };
      delete copy.size;
      delete copy.session;
      return copy;
    }), urls);
  }
  async addCookies(cookies) {
    const cc = rewriteCookies(cookies).map((c) => ({
      ...c,
      expires: c.expires === -1 ? void 0 : c.expires
    }));
    await this._browser.session.send("Browser.setCookies", { browserContextId: this._browserContextId, cookies: cc });
  }
  async doClearCookies() {
    await this._browser.session.send("Browser.clearCookies", { browserContextId: this._browserContextId });
  }
  async doGrantPermissions(origin, permissions) {
    const webPermissionToProtocol = /* @__PURE__ */ new Map([
      ["geolocation", "geo"],
      ["persistent-storage", "persistent-storage"],
      ["push", "push"],
      ["notifications", "desktop-notification"]
    ]);
    const filtered = permissions.map((permission2) => {
      const protocolPermission = webPermissionToProtocol.get(permission2);
      if (!protocolPermission)
        throw new Error("Unknown permission: " + permission2);
      return protocolPermission;
    });
    await this._browser.session.send("Browser.grantPermissions", { origin, browserContextId: this._browserContextId, permissions: filtered });
  }
  async doClearPermissions() {
    await this._browser.session.send("Browser.resetPermissions", { browserContextId: this._browserContextId });
  }
  async setGeolocation(geolocation) {
    verifyGeolocation(geolocation);
    this._options.geolocation = geolocation;
    await this._browser.session.send("Browser.setGeolocationOverride", { browserContextId: this._browserContextId, geolocation: geolocation || null });
  }
  async setExtraHTTPHeaders(headers) {
    this._options.extraHTTPHeaders = headers;
    let allHeaders = this._options.extraHTTPHeaders;
    if (this._options.locale)
      allHeaders = mergeHeaders([allHeaders, singleHeader("Accept-Language", this._options.locale)]);
    await this._browser.session.send("Browser.setExtraHTTPHeaders", { browserContextId: this._browserContextId, headers: allHeaders });
  }
  async setUserAgent(userAgent) {
    await this._browser.session.send("Browser.setUserAgentOverride", { browserContextId: this._browserContextId, userAgent: userAgent || null });
  }
  async setOffline(offline) {
    this._options.offline = offline;
    await this._browser.session.send("Browser.setOnlineOverride", { browserContextId: this._browserContextId, override: offline ? "offline" : "online" });
  }
  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;
    let credentials = null;
    if (httpCredentials) {
      const { username, password, origin } = httpCredentials;
      credentials = { username, password, origin };
    }
    await this._browser.session.send("Browser.setHTTPCredentials", { browserContextId: this._browserContextId, credentials });
  }
  async doAddInitScript(initScript) {
    await this._updateInitScripts();
  }
  async doRemoveNonInternalInitScripts() {
    await this._updateInitScripts();
  }
  async _updateInitScripts() {
    const bindingScripts = [...this._pageBindings.values()].map((binding3) => binding3.initScript.source);
    const initScripts = this.initScripts.map((script) => script.source);
    await this._browser.session.send("Browser.setInitScripts", { browserContextId: this._browserContextId, scripts: [kBuiltinsScript.source, ...bindingScripts, ...initScripts].map((script) => ({ script })) });
  }
  async doUpdateRequestInterception() {
    await Promise.all([
      this._browser.session.send("Browser.setRequestInterception", { browserContextId: this._browserContextId, enabled: !!this._requestInterceptor }),
      this._browser.session.send("Browser.setCacheDisabled", { browserContextId: this._browserContextId, cacheDisabled: !!this._requestInterceptor })
    ]);
  }
  onClosePersistent() {
  }
  async clearCache() {
    await this._browser.session.send("Browser.clearCache");
  }
  async doClose(reason) {
    if (!this._browserContextId) {
      if (this._options.recordVideo) {
        await this._browser.session.send("Browser.setVideoRecordingOptions", {
          options: void 0,
          browserContextId: this._browserContextId
        });
      }
      await this._browser.close({ reason });
    } else {
      await this._browser.session.send("Browser.removeBrowserContext", { browserContextId: this._browserContextId });
      this._browser._contexts.delete(this._browserContextId);
    }
  }
  async cancelDownload(uuid) {
    await this._browser.session.send("Browser.cancelDownload", { uuid });
  }
};
function toJugglerProxyOptions(proxy) {
  const proxyServer = new URL(proxy.server);
  let port = parseInt(proxyServer.port, 10);
  let type2 = "http";
  if (proxyServer.protocol === "socks5:")
    type2 = "socks";
  else if (proxyServer.protocol === "socks4:")
    type2 = "socks4";
  else if (proxyServer.protocol === "https:")
    type2 = "https";
  if (proxyServer.port === "") {
    if (proxyServer.protocol === "http:")
      port = 80;
    else if (proxyServer.protocol === "https:")
      port = 443;
  }
  return {
    type: type2,
    bypass: proxy.bypass ? proxy.bypass.split(",").map((domain2) => domain2.trim()) : [],
    host: proxyServer.hostname,
    port,
    username: proxy.username,
    password: proxy.password
  };
}
__name(toJugglerProxyOptions, "toJugglerProxyOptions");
var kBandaidFirefoxUserPrefs = {};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/firefox/firefox.js
var Firefox = class extends BrowserType {
  static {
    __name(this, "Firefox");
  }
  constructor(parent) {
    super(parent, "firefox");
  }
  connectToTransport(transport, options2) {
    return FFBrowser.connect(this.attribution.playwright, transport, options2);
  }
  doRewriteStartupLog(error4) {
    if (!error4.logs)
      return error4;
    if (error4.logs.includes(`as root in a regular user's session is not supported.`))
      error4.logs = "\n" + wrapInASCIIBox(`Firefox is unable to launch if the $HOME folder isn't owned by the current user.
Workaround: Set the HOME=/root environment variable${process.env.GITHUB_ACTION ? " in your GitHub Actions workflow file" : ""} when running Playwright.`, 1);
    if (error4.logs.includes("no DISPLAY environment variable specified"))
      error4.logs = "\n" + wrapInASCIIBox(kNoXServerRunningError, 1);
    return error4;
  }
  amendEnvironment(env3, userDataDir, executable, browserArguments) {
    if (!path28.isAbsolute(os_default.homedir()))
      throw new Error(`Cannot launch Firefox with relative home directory. Did you set ${os_default.platform() === "win32" ? "USERPROFILE" : "HOME"} to a relative path?`);
    if (os_default.platform() === "linux") {
      return { ...env3, SNAP_NAME: void 0, SNAP_INSTANCE_NAME: void 0 };
    }
    return env3;
  }
  attemptToGracefullyCloseBrowser(transport) {
    const message = { method: "Browser.close", params: {}, id: kBrowserCloseMessageId3 };
    transport.send(message);
  }
  defaultArgs(options2, isPersistent, userDataDir) {
    const { args = [], headless } = options2;
    const userDataDirArg = args.find((arg) => arg.startsWith("-profile") || arg.startsWith("--profile"));
    if (userDataDirArg)
      throw this._createUserDataDirArgMisuseError("--profile");
    if (args.find((arg) => arg.startsWith("-juggler")))
      throw new Error("Use the port parameter instead of -juggler argument");
    const firefoxArguments = ["-no-remote"];
    if (headless) {
      firefoxArguments.push("-headless");
    } else {
      firefoxArguments.push("-wait-for-browser");
      firefoxArguments.push("-foreground");
    }
    firefoxArguments.push(`-profile`, userDataDir);
    firefoxArguments.push("-juggler-pipe");
    firefoxArguments.push(...args);
    if (isPersistent)
      firefoxArguments.push("about:blank");
    else
      firefoxArguments.push("-silent");
    return firefoxArguments;
  }
  readyState(options2) {
    return new JugglerReadyState();
  }
};
var JugglerReadyState = class extends BrowserReadyState {
  static {
    __name(this, "JugglerReadyState");
  }
  onBrowserOutput(message) {
    if (message.includes("Juggler listening to the pipe"))
      this._wsEndpoint.resolve(void 0);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/webkit.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path30 from "node:path";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/wkConnection.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter17 } from "node:events";
import "node:path";
import "node:url";
var kBrowserCloseMessageId4 = -9999;
var kPageProxyMessageReceived = Symbol("kPageProxyMessageReceived");
var WKConnection = class {
  static {
    __name(this, "WKConnection");
  }
  constructor(transport, onDisconnect, protocolLogger, browserLogsCollector) {
    this._lastId = 0;
    this._closed = false;
    this._transport = transport;
    this._onDisconnect = onDisconnect;
    this._protocolLogger = protocolLogger;
    this._browserLogsCollector = browserLogsCollector;
    this.browserSession = new WKSession(this, "", (message) => {
      this.rawSend(message);
    });
    this._transport.onmessage = this._dispatchMessage.bind(this);
    this._transport.onclose = this._onClose.bind(this);
  }
  nextMessageId() {
    return ++this._lastId;
  }
  rawSend(message) {
    this._protocolLogger("send", message);
    this._transport.send(message);
  }
  _dispatchMessage(message) {
    this._protocolLogger("receive", message);
    if (message.id === kBrowserCloseMessageId4)
      return;
    if (message.pageProxyId) {
      const payload = { message, pageProxyId: message.pageProxyId };
      this.browserSession.dispatchMessage({ method: kPageProxyMessageReceived, params: payload });
      return;
    }
    this.browserSession.dispatchMessage(message);
  }
  _onClose(reason) {
    this._closed = true;
    this._transport.onmessage = void 0;
    this._transport.onclose = void 0;
    this._browserDisconnectedLogs = helper.formatBrowserLogs(this._browserLogsCollector.recentLogs(), reason);
    this.browserSession.dispose();
    this._onDisconnect();
  }
  isClosed() {
    return this._closed;
  }
  close() {
    if (!this._closed)
      this._transport.close();
  }
};
var WKSession = class extends EventEmitter17 {
  static {
    __name(this, "WKSession");
  }
  constructor(connection, sessionId, rawSend) {
    super();
    this._disposed = false;
    this._callbacks = /* @__PURE__ */ new Map();
    this._crashed = false;
    this.setMaxListeners(0);
    this.connection = connection;
    this.sessionId = sessionId;
    this._rawSend = rawSend;
    this.on = super.on;
    this.off = super.removeListener;
    this.addListener = super.addListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }
  async send(method, params) {
    if (this._crashed || this._disposed || this.connection._browserDisconnectedLogs)
      throw new ProtocolError(this._crashed ? "crashed" : "closed", void 0, this.connection._browserDisconnectedLogs);
    const id = this.connection.nextMessageId();
    const messageObj = { id, method, params };
    this._rawSend(messageObj);
    return new Promise((resolve, reject) => {
      this._callbacks.set(id, { resolve, reject, error: new ProtocolError("error", method) });
    });
  }
  sendMayFail(method, params) {
    return this.send(method, params).catch((error4) => debugLogger.log("error", error4));
  }
  markAsCrashed() {
    this._crashed = true;
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    for (const callback of this._callbacks.values()) {
      callback.error.type = this._crashed ? "crashed" : "closed";
      callback.error.logs = this.connection._browserDisconnectedLogs;
      callback.reject(callback.error);
    }
    this._callbacks.clear();
    this._disposed = true;
  }
  dispatchMessage(object) {
    if (object.id && this._callbacks.has(object.id)) {
      const callback = this._callbacks.get(object.id);
      this._callbacks.delete(object.id);
      if (object.error) {
        callback.error.setMessage(object.error.message);
        callback.reject(callback.error);
      } else {
        callback.resolve(object.result);
      }
    } else if (object.id && !object.error) {
      assert3(this.isDisposed());
    } else {
      Promise.resolve().then(() => this.emit(object.method, object.params));
    }
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/wkBrowser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/wkPage.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path29 from "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/wkAccessibility.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function getAccessibilityTree3(session2, needle) {
  const objectId = needle ? needle._objectId : void 0;
  const { axNode } = await session2.send("Page.accessibilitySnapshot", { objectId });
  const tree = new WKAXNode(axNode);
  return {
    tree,
    needle: needle ? tree._findNeedle() : null
  };
}
__name(getAccessibilityTree3, "getAccessibilityTree");
var WKRoleToARIARole = new Map(Object.entries({
  "TextField": "textbox"
}));
var WKUnhelpfulRoleDescriptions = new Map(Object.entries({
  "WebArea": "HTML content",
  "Summary": "summary",
  "DescriptionList": "description list",
  "ImageMap": "image map",
  "ListMarker": "list marker",
  "Video": "video playback",
  "Mark": "highlighted",
  "contentinfo": "content information",
  "Details": "details",
  "DescriptionListDetail": "description",
  "DescriptionListTerm": "term",
  "alertdialog": "web alert dialog",
  "dialog": "web dialog",
  "status": "application status",
  "tabpanel": "tab panel",
  "application": "web application"
}));
var WKAXNode = class _WKAXNode {
  static {
    __name(this, "WKAXNode");
  }
  constructor(payload) {
    this._payload = payload;
    this._children = [];
    for (const payload2 of this._payload.children || [])
      this._children.push(new _WKAXNode(payload2));
  }
  children() {
    return this._children;
  }
  _findNeedle() {
    if (this._payload.found)
      return this;
    for (const child of this._children) {
      const found = child._findNeedle();
      if (found)
        return found;
    }
    return null;
  }
  isControl() {
    switch (this._payload.role) {
      case "button":
      case "checkbox":
      case "ColorWell":
      case "combobox":
      case "DisclosureTriangle":
      case "listbox":
      case "menu":
      case "menubar":
      case "menuitem":
      case "menuitemcheckbox":
      case "menuitemradio":
      case "radio":
      case "scrollbar":
      case "searchbox":
      case "slider":
      case "spinbutton":
      case "switch":
      case "tab":
      case "textbox":
      case "TextField":
      case "tree":
        return true;
      default:
        return false;
    }
  }
  _isTextControl() {
    switch (this._payload.role) {
      case "combobox":
      case "searchfield":
      case "textbox":
      case "TextField":
        return true;
    }
    return false;
  }
  _name() {
    if (this._payload.role === "text")
      return this._payload.value || "";
    return this._payload.name || "";
  }
  isInteresting(insideControl) {
    const { role, focusable } = this._payload;
    const name = this._name();
    if (role === "ScrollArea")
      return false;
    if (role === "WebArea")
      return true;
    if (focusable || role === "MenuListOption")
      return true;
    if (this.isControl())
      return true;
    if (insideControl)
      return false;
    return this.isLeafNode() && !!name;
  }
  _hasRedundantTextChild() {
    if (this._children.length !== 1)
      return false;
    const child = this._children[0];
    return child._payload.role === "text" && this._payload.name === child._payload.value;
  }
  isLeafNode() {
    if (!this._children.length)
      return true;
    if (this._isTextControl())
      return true;
    if (this._hasRedundantTextChild())
      return true;
    return false;
  }
  serialize() {
    const node2 = {
      role: WKRoleToARIARole.get(this._payload.role) || this._payload.role,
      name: this._name()
    };
    if ("description" in this._payload && this._payload.description !== node2.name)
      node2.description = this._payload.description;
    if ("roledescription" in this._payload) {
      const roledescription = this._payload.roledescription;
      if (roledescription !== this._payload.role && WKUnhelpfulRoleDescriptions.get(this._payload.role) !== roledescription)
        node2.roledescription = roledescription;
    }
    if ("value" in this._payload && this._payload.role !== "text") {
      if (typeof this._payload.value === "string")
        node2.valueString = this._payload.value;
      else if (typeof this._payload.value === "number")
        node2.valueNumber = this._payload.value;
    }
    if ("checked" in this._payload)
      node2.checked = this._payload.checked === "true" ? "checked" : this._payload.checked === "false" ? "unchecked" : "mixed";
    if ("pressed" in this._payload)
      node2.pressed = this._payload.pressed === "true" ? "pressed" : this._payload.pressed === "false" ? "released" : "mixed";
    const userStringProperties = [
      "keyshortcuts",
      "valuetext"
    ];
    for (const userStringProperty of userStringProperties) {
      if (!(userStringProperty in this._payload))
        continue;
      node2[userStringProperty] = this._payload[userStringProperty];
    }
    const booleanProperties = [
      "disabled",
      "expanded",
      "focused",
      "modal",
      "multiselectable",
      "readonly",
      "required",
      "selected"
    ];
    for (const booleanProperty of booleanProperties) {
      if (booleanProperty === "focused" && (this._payload.role === "WebArea" || this._payload.role === "ScrollArea"))
        continue;
      const value = this._payload[booleanProperty];
      if (!value)
        continue;
      node2[booleanProperty] = value;
    }
    const numericalProperties = [
      "level",
      "valuemax",
      "valuemin"
    ];
    for (const numericalProperty of numericalProperties) {
      if (!(numericalProperty in this._payload))
        continue;
      node2[numericalProperty] = this._payload[numericalProperty];
    }
    const tokenProperties = [
      "autocomplete",
      "haspopup",
      "invalid"
    ];
    for (const tokenProperty of tokenProperties) {
      const value = this._payload[tokenProperty];
      if (!value || value === "false")
        continue;
      node2[tokenProperty] = value;
    }
    const orientationIsApplicable = /* @__PURE__ */ new Set([
      "ScrollArea",
      "scrollbar",
      "listbox",
      "combobox",
      "menu",
      "tree",
      "separator",
      "slider",
      "tablist",
      "toolbar"
    ]);
    if (this._payload.orientation && orientationIsApplicable.has(this._payload.role))
      node2.orientation = this._payload.orientation;
    return node2;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/wkExecutionContext.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WKExecutionContext = class {
  static {
    __name(this, "WKExecutionContext");
  }
  constructor(session2, contextId) {
    this._session = session2;
    this._contextId = contextId;
  }
  async rawEvaluateJSON(expression) {
    try {
      const response = await this._session.send("Runtime.evaluate", {
        expression,
        contextId: this._contextId,
        returnByValue: true
      });
      if (response.wasThrown)
        throw new JavaScriptErrorInEvaluate(response.result.description);
      return response.result.value;
    } catch (error4) {
      throw rewriteError3(error4);
    }
  }
  async rawEvaluateHandle(context2, expression) {
    try {
      const response = await this._session.send("Runtime.evaluate", {
        expression,
        contextId: this._contextId,
        returnByValue: false
      });
      if (response.wasThrown)
        throw new JavaScriptErrorInEvaluate(response.result.description);
      return createHandle4(context2, response.result);
    } catch (error4) {
      throw rewriteError3(error4);
    }
  }
  async evaluateWithArguments(expression, returnByValue, utilityScript, values, handles) {
    try {
      const response = await this._session.send("Runtime.callFunctionOn", {
        functionDeclaration: expression,
        objectId: utilityScript._objectId,
        arguments: [
          { objectId: utilityScript._objectId },
          ...values.map((value) => ({ value })),
          ...handles.map((handle) => ({ objectId: handle._objectId }))
        ],
        returnByValue,
        emulateUserGesture: true,
        awaitPromise: true
      });
      if (response.wasThrown)
        throw new JavaScriptErrorInEvaluate(response.result.description);
      if (returnByValue)
        return parseEvaluationResultValue(response.result.value);
      return createHandle4(utilityScript._context, response.result);
    } catch (error4) {
      throw rewriteError3(error4);
    }
  }
  async getProperties(object) {
    const response = await this._session.send("Runtime.getProperties", {
      objectId: object._objectId,
      ownProperties: true
    });
    const result = /* @__PURE__ */ new Map();
    for (const property of response.properties) {
      if (!property.enumerable || !property.value)
        continue;
      result.set(property.name, createHandle4(object._context, property.value));
    }
    return result;
  }
  async releaseHandle(handle) {
    if (!handle._objectId)
      return;
    await this._session.send("Runtime.releaseObject", { objectId: handle._objectId });
  }
};
function potentiallyUnserializableValue3(remoteObject) {
  const value = remoteObject.value;
  const isUnserializable = remoteObject.type === "number" && ["NaN", "-Infinity", "Infinity", "-0"].includes(remoteObject.description);
  return isUnserializable ? parseUnserializableValue(remoteObject.description) : value;
}
__name(potentiallyUnserializableValue3, "potentiallyUnserializableValue");
function rewriteError3(error4) {
  if (error4.message.includes("Object has too long reference chain"))
    throw new Error("Cannot serialize result: object reference chain is too long.");
  if (!isJavaScriptErrorInEvaluate(error4) && !isSessionClosedError(error4))
    return new Error("Execution context was destroyed, most likely because of a navigation.");
  return error4;
}
__name(rewriteError3, "rewriteError");
function renderPreview4(object) {
  if (object.type === "undefined")
    return "undefined";
  if ("value" in object)
    return String(object.value);
  if (object.description === "Object" && object.preview) {
    const tokens = [];
    for (const { name, value } of object.preview.properties)
      tokens.push(`${name}: ${value}`);
    return `{${tokens.join(", ")}}`;
  }
  if (object.subtype === "array" && object.preview)
    return sparseArrayToString(object.preview.properties);
  return object.description;
}
__name(renderPreview4, "renderPreview");
function createHandle4(context2, remoteObject) {
  if (remoteObject.subtype === "node") {
    assert3(context2 instanceof FrameExecutionContext);
    return new ElementHandle(context2, remoteObject.objectId);
  }
  const isPromise = remoteObject.className === "Promise";
  return new JSHandle(context2, isPromise ? "promise" : remoteObject.subtype || remoteObject.type, renderPreview4(remoteObject), remoteObject.objectId, potentiallyUnserializableValue3(remoteObject));
}
__name(createHandle4, "createHandle");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/wkInput.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
function toModifiersMask3(modifiers) {
  let mask = 0;
  if (modifiers.has("Shift"))
    mask |= 1;
  if (modifiers.has("Control"))
    mask |= 2;
  if (modifiers.has("Alt"))
    mask |= 4;
  if (modifiers.has("Meta"))
    mask |= 8;
  return mask;
}
__name(toModifiersMask3, "toModifiersMask");
function toButtonsMask3(buttons) {
  let mask = 0;
  if (buttons.has("left"))
    mask |= 1;
  if (buttons.has("right"))
    mask |= 2;
  if (buttons.has("middle"))
    mask |= 4;
  return mask;
}
__name(toButtonsMask3, "toButtonsMask");
var RawKeyboardImpl4 = class {
  static {
    __name(this, "RawKeyboardImpl");
  }
  constructor(session2) {
    this._pageProxySession = session2;
  }
  setSession(session2) {
    this._session = session2;
  }
  async keydown(modifiers, keyName, description, autoRepeat) {
    const parts = [];
    for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
      if (modifiers.has(modifier))
        parts.push(modifier);
    }
    const { code, keyCode, key, text } = description;
    parts.push(code);
    const shortcut = parts.join("+");
    let commands = macEditingCommands[shortcut];
    if (isString2(commands))
      commands = [commands];
    await this._pageProxySession.send("Input.dispatchKeyEvent", {
      type: "keyDown",
      modifiers: toModifiersMask3(modifiers),
      windowsVirtualKeyCode: keyCode,
      code,
      key,
      text,
      unmodifiedText: text,
      autoRepeat,
      macCommands: commands,
      isKeypad: description.location === keypadLocation2
    });
  }
  async keyup(modifiers, keyName, description) {
    const { code, key } = description;
    await this._pageProxySession.send("Input.dispatchKeyEvent", {
      type: "keyUp",
      modifiers: toModifiersMask3(modifiers),
      key,
      windowsVirtualKeyCode: description.keyCode,
      code,
      isKeypad: description.location === keypadLocation2
    });
  }
  async sendText(text) {
    await this._session.send("Page.insertText", { text });
  }
};
var RawMouseImpl4 = class {
  static {
    __name(this, "RawMouseImpl");
  }
  constructor(session2) {
    this._pageProxySession = session2;
  }
  setSession(session2) {
    this._session = session2;
  }
  async move(x, y, button, buttons, modifiers, forClick) {
    await this._pageProxySession.send("Input.dispatchMouseEvent", {
      type: "move",
      button,
      buttons: toButtonsMask3(buttons),
      x,
      y,
      modifiers: toModifiersMask3(modifiers)
    });
  }
  async down(x, y, button, buttons, modifiers, clickCount) {
    await this._pageProxySession.send("Input.dispatchMouseEvent", {
      type: "down",
      button,
      buttons: toButtonsMask3(buttons),
      x,
      y,
      modifiers: toModifiersMask3(modifiers),
      clickCount
    });
  }
  async up(x, y, button, buttons, modifiers, clickCount) {
    await this._pageProxySession.send("Input.dispatchMouseEvent", {
      type: "up",
      button,
      buttons: toButtonsMask3(buttons),
      x,
      y,
      modifiers: toModifiersMask3(modifiers),
      clickCount
    });
  }
  async wheel(x, y, buttons, modifiers, deltaX, deltaY) {
    if (this._page?._browserContext._options.isMobile)
      throw new Error("Mouse wheel is not supported in mobile WebKit");
    await this._session.send("Page.updateScrollingState");
    await this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, { world: "utility" });
    await this._pageProxySession.send("Input.dispatchWheelEvent", {
      x,
      y,
      deltaX,
      deltaY,
      modifiers: toModifiersMask3(modifiers)
    });
  }
  setPage(page) {
    this._page = page;
  }
};
var RawTouchscreenImpl4 = class {
  static {
    __name(this, "RawTouchscreenImpl");
  }
  constructor(session2) {
    this._pageProxySession = session2;
  }
  async tap(x, y, modifiers) {
    await this._pageProxySession.send("Input.dispatchTapEvent", {
      x,
      y,
      modifiers: toModifiersMask3(modifiers)
    });
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/wkInterceptableRequest.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var errorReasons2 = {
  "aborted": "Cancellation",
  "accessdenied": "AccessControl",
  "addressunreachable": "General",
  "blockedbyclient": "Cancellation",
  "blockedbyresponse": "General",
  "connectionaborted": "General",
  "connectionclosed": "General",
  "connectionfailed": "General",
  "connectionrefused": "General",
  "connectionreset": "General",
  "internetdisconnected": "General",
  "namenotresolved": "General",
  "timedout": "Timeout",
  "failed": "General"
};
var WKInterceptableRequest = class {
  static {
    __name(this, "WKInterceptableRequest");
  }
  constructor(session2, frame, event, redirectedFrom, documentId) {
    this._session = session2;
    this._requestId = event.requestId;
    const resourceType = event.type ? event.type.toLowerCase() : redirectedFrom ? redirectedFrom.request.resourceType() : "other";
    let postDataBuffer = null;
    this._timestamp = event.timestamp;
    this._wallTime = event.walltime * 1e3;
    if (event.request.postData)
      postDataBuffer = Buffer.from(event.request.postData, "base64");
    this.request = new Request(
      frame._page._browserContext,
      frame,
      null,
      redirectedFrom?.request || null,
      documentId,
      event.request.url,
      resourceType,
      event.request.method,
      postDataBuffer,
      headersObjectToArray(event.request.headers)
    );
  }
  adoptRequestFromNewProcess(newSession, requestId) {
    this._session = newSession;
    this._requestId = requestId;
  }
  createResponse(responsePayload) {
    const getResponseBody = /* @__PURE__ */ __name(async () => {
      const response2 = await this._session.send("Network.getResponseBody", { requestId: this._requestId });
      return Buffer.from(response2.body, response2.base64Encoded ? "base64" : "utf8");
    }, "getResponseBody");
    const timingPayload = responsePayload.timing;
    const timing = {
      startTime: this._wallTime,
      domainLookupStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupStart) : -1,
      domainLookupEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupEnd) : -1,
      connectStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectStart) : -1,
      secureConnectionStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.secureConnectionStart) : -1,
      connectEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectEnd) : -1,
      requestStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.requestStart) : -1,
      responseStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.responseStart) : -1
    };
    const setCookieSeparator = process.platform === "darwin" ? "," : "playwright-set-cookie-separator";
    const response = new Response2(this.request, responsePayload.status, responsePayload.statusText, headersObjectToArray(responsePayload.headers, ",", setCookieSeparator), timing, getResponseBody, responsePayload.source === "service-worker");
    response.setRawResponseHeaders(null);
    response.setTransferSize(null);
    if (responsePayload.requestHeaders && Object.keys(responsePayload.requestHeaders).length) {
      const headers = { ...responsePayload.requestHeaders };
      if (!headers["host"])
        headers["Host"] = new URL(this.request.url()).host;
      this.request.setRawRequestHeaders(headersObjectToArray(headers));
    } else {
      this.request.setRawRequestHeaders(null);
    }
    return response;
  }
};
var WKRouteImpl = class {
  static {
    __name(this, "WKRouteImpl");
  }
  constructor(session2, requestId) {
    this._session = session2;
    this._requestId = requestId;
  }
  async abort(errorCode) {
    const errorType = errorReasons2[errorCode];
    assert3(errorType, "Unknown error code: " + errorCode);
    await this._session.sendMayFail("Network.interceptRequestWithError", { requestId: this._requestId, errorType });
  }
  async fulfill(response) {
    if (300 <= response.status && response.status < 400)
      throw new Error("Cannot fulfill with redirect status: " + response.status);
    let mimeType = response.isBase64 ? "application/octet-stream" : "text/plain";
    const headers = headersArrayToObject(
      response.headers,
      true
      /* lowerCase */
    );
    const contentType = headers["content-type"];
    if (contentType)
      mimeType = contentType.split(";")[0].trim();
    await this._session.sendMayFail("Network.interceptRequestWithResponse", {
      requestId: this._requestId,
      status: response.status,
      statusText: statusText(response.status),
      mimeType,
      headers,
      base64Encoded: response.isBase64,
      content: response.body
    });
  }
  async continue(overrides) {
    await this._session.sendMayFail("Network.interceptWithRequest", {
      requestId: this._requestId,
      url: overrides.url,
      method: overrides.method,
      headers: overrides.headers ? headersArrayToObject(
        overrides.headers,
        false
        /* lowerCase */
      ) : void 0,
      postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
    });
  }
};
function wkMillisToRoundishMillis(value) {
  if (value === -1e3)
    return -1;
  if (value <= 0) {
    return -1;
  }
  return (value * 1e3 | 0) / 1e3;
}
__name(wkMillisToRoundishMillis, "wkMillisToRoundishMillis");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/wkProvisionalPage.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var WKProvisionalPage = class {
  static {
    __name(this, "WKProvisionalPage");
  }
  constructor(session2, page) {
    this._sessionListeners = [];
    this._mainFrameId = null;
    this._session = session2;
    this._wkPage = page;
    this._coopNavigationRequest = page._page.mainFrame().pendingDocument()?.request;
    const overrideFrameId = /* @__PURE__ */ __name((handler) => {
      return (payload) => {
        if (payload.frameId)
          payload.frameId = this._wkPage._page._frameManager.mainFrame()._id;
        handler(payload);
      };
    }, "overrideFrameId");
    const wkPage = this._wkPage;
    this._sessionListeners = [
      eventsHelper.addEventListener(session2, "Network.requestWillBeSent", overrideFrameId((e) => this._onRequestWillBeSent(e))),
      eventsHelper.addEventListener(session2, "Network.requestIntercepted", overrideFrameId((e) => wkPage._onRequestIntercepted(session2, e))),
      eventsHelper.addEventListener(session2, "Network.responseReceived", overrideFrameId((e) => wkPage._onResponseReceived(session2, e))),
      eventsHelper.addEventListener(session2, "Network.loadingFinished", overrideFrameId((e) => this._onLoadingFinished(e))),
      eventsHelper.addEventListener(session2, "Network.loadingFailed", overrideFrameId((e) => this._onLoadingFailed(e)))
    ];
    this.initializationPromise = this._wkPage._initializeSession(session2, true, ({ frameTree }) => this._handleFrameTree(frameTree));
  }
  coopNavigationRequest() {
    return this._coopNavigationRequest;
  }
  dispose() {
    eventsHelper.removeEventListeners(this._sessionListeners);
  }
  commit() {
    assert3(this._mainFrameId);
    this._wkPage._onFrameAttached(this._mainFrameId, null);
  }
  _onRequestWillBeSent(event) {
    if (this._coopNavigationRequest && this._coopNavigationRequest.url() === event.request.url) {
      this._wkPage._adoptRequestFromNewProcess(this._coopNavigationRequest, this._session, event.requestId);
      return;
    }
    this._wkPage._onRequestWillBeSent(this._session, event);
  }
  _onLoadingFinished(event) {
    this._coopNavigationRequest = void 0;
    this._wkPage._onLoadingFinished(event);
  }
  _onLoadingFailed(event) {
    this._coopNavigationRequest = void 0;
    this._wkPage._onLoadingFailed(this._session, event);
  }
  _handleFrameTree(frameTree) {
    assert3(!frameTree.frame.parentId);
    this._mainFrameId = frameTree.frame.id;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/wkWorkers.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WKWorkers = class {
  static {
    __name(this, "WKWorkers");
  }
  constructor(page) {
    this._sessionListeners = [];
    this._workerSessions = /* @__PURE__ */ new Map();
    this._page = page;
  }
  setSession(session2) {
    eventsHelper.removeEventListeners(this._sessionListeners);
    this.clear();
    this._sessionListeners = [
      eventsHelper.addEventListener(session2, "Worker.workerCreated", (event) => {
        const worker = new Worker(this._page, event.url);
        const workerSession = new WKSession(session2.connection, event.workerId, (message) => {
          session2.send("Worker.sendMessageToWorker", {
            workerId: event.workerId,
            message: JSON.stringify(message)
          }).catch((e) => {
            workerSession.dispatchMessage({ id: message.id, error: { message: e.message } });
          });
        });
        this._workerSessions.set(event.workerId, workerSession);
        worker._createExecutionContext(new WKExecutionContext(workerSession, void 0));
        this._page._addWorker(event.workerId, worker);
        workerSession.on("Console.messageAdded", (event2) => this._onConsoleMessage(worker, event2));
        Promise.all([
          workerSession.send("Runtime.enable"),
          workerSession.send("Console.enable"),
          session2.send("Worker.initialized", { workerId: event.workerId })
        ]).catch((e) => {
          this._page._removeWorker(event.workerId);
        });
      }),
      eventsHelper.addEventListener(session2, "Worker.dispatchMessageFromWorker", (event) => {
        const workerSession = this._workerSessions.get(event.workerId);
        if (!workerSession)
          return;
        workerSession.dispatchMessage(JSON.parse(event.message));
      }),
      eventsHelper.addEventListener(session2, "Worker.workerTerminated", (event) => {
        const workerSession = this._workerSessions.get(event.workerId);
        if (!workerSession)
          return;
        workerSession.dispose();
        this._workerSessions.delete(event.workerId);
        this._page._removeWorker(event.workerId);
      })
    ];
  }
  clear() {
    this._page._clearWorkers();
    this._workerSessions.clear();
  }
  async initializeSession(session2) {
    await session2.send("Worker.enable");
  }
  async _onConsoleMessage(worker, event) {
    const { type: type2, level, text, parameters, url: url4, line: lineNumber, column: columnNumber } = event.message;
    let derivedType = type2 || "";
    if (type2 === "log")
      derivedType = level;
    else if (type2 === "timing")
      derivedType = "timeEnd";
    const handles = (parameters || []).map((p) => {
      return createHandle4(worker._existingExecutionContext, p);
    });
    const location2 = {
      url: url4 || "",
      lineNumber: (lineNumber || 1) - 1,
      columnNumber: (columnNumber || 1) - 1
    };
    this._page._addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/wkPage.js
var UTILITY_WORLD_NAME4 = "__playwright_utility_world__";
var WKPage = class _WKPage {
  static {
    __name(this, "WKPage");
  }
  constructor(browserContext, pageProxySession, opener) {
    this._provisionalPage = null;
    this._requestIdToRequest = /* @__PURE__ */ new Map();
    this._requestIdToRequestWillBeSentEvent = /* @__PURE__ */ new Map();
    this._sessionListeners = [];
    this._firstNonInitialNavigationCommittedFulfill = () => {
    };
    this._firstNonInitialNavigationCommittedReject = (e) => {
    };
    this._lastConsoleMessage = null;
    this._requestIdToResponseReceivedPayloadEvent = /* @__PURE__ */ new Map();
    this._recordingVideoFile = null;
    this._screencastGeneration = 0;
    this._pageProxySession = pageProxySession;
    this._opener = opener;
    this.rawKeyboard = new RawKeyboardImpl4(pageProxySession);
    this.rawMouse = new RawMouseImpl4(pageProxySession);
    this.rawTouchscreen = new RawTouchscreenImpl4(pageProxySession);
    this._contextIdToContext = /* @__PURE__ */ new Map();
    this._page = new Page(this, browserContext);
    this.rawMouse.setPage(this._page);
    this._workers = new WKWorkers(this._page);
    this._session = void 0;
    this._browserContext = browserContext;
    this._page.on(Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame, false));
    this._eventListeners = [
      eventsHelper.addEventListener(this._pageProxySession, "Target.targetCreated", this._onTargetCreated.bind(this)),
      eventsHelper.addEventListener(this._pageProxySession, "Target.targetDestroyed", this._onTargetDestroyed.bind(this)),
      eventsHelper.addEventListener(this._pageProxySession, "Target.dispatchMessageFromTarget", this._onDispatchMessageFromTarget.bind(this)),
      eventsHelper.addEventListener(this._pageProxySession, "Target.didCommitProvisionalTarget", this._onDidCommitProvisionalTarget.bind(this)),
      eventsHelper.addEventListener(this._pageProxySession, "Screencast.screencastFrame", this._onScreencastFrame.bind(this))
    ];
    this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
      this._firstNonInitialNavigationCommittedFulfill = f;
      this._firstNonInitialNavigationCommittedReject = r;
    });
    if (opener && !browserContext._options.noDefaultViewport && opener._nextWindowOpenPopupFeatures) {
      const viewportSize = helper.getViewportSizeFromWindowFeatures(opener._nextWindowOpenPopupFeatures);
      opener._nextWindowOpenPopupFeatures = void 0;
      if (viewportSize)
        this._page._emulatedSize = { viewport: viewportSize, screen: viewportSize };
    }
  }
  async _initializePageProxySession() {
    if (this._page._browserContext.isSettingStorageState())
      return;
    const promises2 = [
      this._pageProxySession.send("Dialog.enable"),
      this._pageProxySession.send("Emulation.setActiveAndFocused", { active: true })
    ];
    const contextOptions = this._browserContext._options;
    if (contextOptions.javaScriptEnabled === false)
      promises2.push(this._pageProxySession.send("Emulation.setJavaScriptEnabled", { enabled: false }));
    promises2.push(this._updateViewport());
    promises2.push(this.updateHttpCredentials());
    if (this._browserContext._permissions.size) {
      for (const [key, value] of this._browserContext._permissions)
        promises2.push(this._grantPermissions(key, value));
    }
    if (this._browserContext._options.recordVideo) {
      const outputFile = path29.join(this._browserContext._options.recordVideo.dir, createGuid() + ".webm");
      promises2.push(this._browserContext._ensureVideosPath().then(() => {
        return this._startVideo({
          // validateBrowserContextOptions ensures correct video size.
          ...this._browserContext._options.recordVideo.size,
          outputFile
        });
      }));
    }
    await Promise.all(promises2);
  }
  _setSession(session2) {
    eventsHelper.removeEventListeners(this._sessionListeners);
    this._session = session2;
    this.rawKeyboard.setSession(session2);
    this.rawMouse.setSession(session2);
    this._addSessionListeners();
    this._workers.setSession(session2);
  }
  // This method is called for provisional targets as well. The session passed as the parameter
  // may be different from the current session and may be destroyed without becoming current.
  async _initializeSession(session2, provisional, resourceTreeHandler) {
    await this._initializeSessionMayThrow(session2, resourceTreeHandler).catch((e) => {
      if (provisional && session2.isDisposed())
        return;
      if (this._session === session2)
        throw e;
    });
  }
  async _initializeSessionMayThrow(session2, resourceTreeHandler) {
    const [, frameTree] = await Promise.all([
      // Page agent must be enabled before Runtime.
      session2.send("Page.enable"),
      session2.send("Page.getResourceTree")
    ]);
    resourceTreeHandler(frameTree);
    const promises2 = [
      // Resource tree should be received before first execution context.
      session2.send("Runtime.enable"),
      session2.send("Runtime.addBinding", { name: PageBinding.kPlaywrightBinding }),
      session2.send("Page.createUserWorld", { name: UTILITY_WORLD_NAME4 }).catch((_) => {
      }),
      // Worlds are per-process
      session2.send("Console.enable"),
      session2.send("Network.enable"),
      this._workers.initializeSession(session2)
    ];
    if (this._page.needsRequestInterception()) {
      promises2.push(session2.send("Network.setInterceptionEnabled", { enabled: true }));
      promises2.push(session2.send("Network.setResourceCachingDisabled", { disabled: true }));
      promises2.push(session2.send("Network.addInterception", { url: ".*", stage: "request", isRegex: true }));
    }
    if (this._page._browserContext.isSettingStorageState()) {
      await Promise.all(promises2);
      return;
    }
    const contextOptions = this._browserContext._options;
    if (contextOptions.userAgent)
      promises2.push(this.updateUserAgent());
    const emulatedMedia = this._page.emulatedMedia();
    if (emulatedMedia.media || emulatedMedia.colorScheme || emulatedMedia.reducedMotion || emulatedMedia.forcedColors || emulatedMedia.contrast)
      promises2.push(_WKPage._setEmulateMedia(session2, emulatedMedia.media, emulatedMedia.colorScheme, emulatedMedia.reducedMotion, emulatedMedia.forcedColors, emulatedMedia.contrast));
    const bootstrapScript = this._calculateBootstrapScript();
    if (bootstrapScript.length)
      promises2.push(session2.send("Page.setBootstrapScript", { source: bootstrapScript }));
    this._page.frames().map((frame) => frame.evaluateExpression(bootstrapScript).catch((e) => {
    }));
    if (contextOptions.bypassCSP)
      promises2.push(session2.send("Page.setBypassCSP", { enabled: true }));
    const emulatedSize = this._page.emulatedSize();
    if (emulatedSize) {
      promises2.push(session2.send("Page.setScreenSizeOverride", {
        width: emulatedSize.screen.width,
        height: emulatedSize.screen.height
      }));
    }
    promises2.push(this.updateEmulateMedia());
    promises2.push(session2.send("Network.setExtraHTTPHeaders", { headers: headersArrayToObject(
      this._calculateExtraHTTPHeaders(),
      false
      /* lowerCase */
    ) }));
    if (contextOptions.offline)
      promises2.push(session2.send("Network.setEmulateOfflineState", { offline: true }));
    promises2.push(session2.send("Page.setTouchEmulationEnabled", { enabled: !!contextOptions.hasTouch }));
    if (contextOptions.timezoneId) {
      promises2.push(session2.send("Page.setTimeZone", { timeZone: contextOptions.timezoneId }).catch((e) => {
        throw new Error(`Invalid timezone ID: ${contextOptions.timezoneId}`);
      }));
    }
    if (this._page.fileChooserIntercepted())
      promises2.push(session2.send("Page.setInterceptFileChooserDialog", { enabled: true }));
    promises2.push(session2.send("Page.overrideSetting", { setting: "DeviceOrientationEventEnabled", value: contextOptions.isMobile }));
    promises2.push(session2.send("Page.overrideSetting", { setting: "FullScreenEnabled", value: !contextOptions.isMobile }));
    promises2.push(session2.send("Page.overrideSetting", { setting: "NotificationsEnabled", value: !contextOptions.isMobile }));
    promises2.push(session2.send("Page.overrideSetting", { setting: "PointerLockEnabled", value: !contextOptions.isMobile }));
    promises2.push(session2.send("Page.overrideSetting", { setting: "InputTypeMonthEnabled", value: contextOptions.isMobile }));
    promises2.push(session2.send("Page.overrideSetting", { setting: "InputTypeWeekEnabled", value: contextOptions.isMobile }));
    promises2.push(session2.send("Page.overrideSetting", { setting: "FixedBackgroundsPaintRelativeToDocument", value: contextOptions.isMobile }));
    await Promise.all(promises2);
  }
  _onDidCommitProvisionalTarget(event) {
    const { oldTargetId, newTargetId } = event;
    assert3(this._provisionalPage);
    assert3(this._provisionalPage._session.sessionId === newTargetId, "Unknown new target: " + newTargetId);
    assert3(this._session.sessionId === oldTargetId, "Unknown old target: " + oldTargetId);
    const newSession = this._provisionalPage._session;
    this._provisionalPage.commit();
    this._provisionalPage.dispose();
    this._provisionalPage = null;
    this._setSession(newSession);
  }
  _onTargetDestroyed(event) {
    const { targetId, crashed } = event;
    if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId) {
      this._maybeCancelCoopNavigationRequest(this._provisionalPage);
      this._provisionalPage._session.dispose();
      this._provisionalPage.dispose();
      this._provisionalPage = null;
    } else if (this._session.sessionId === targetId) {
      this._session.dispose();
      eventsHelper.removeEventListeners(this._sessionListeners);
      if (crashed) {
        this._session.markAsCrashed();
        this._page._didCrash();
      }
    }
  }
  didClose() {
    this._pageProxySession.dispose();
    eventsHelper.removeEventListeners(this._sessionListeners);
    eventsHelper.removeEventListeners(this._eventListeners);
    if (this._session)
      this._session.dispose();
    if (this._provisionalPage) {
      this._provisionalPage._session.dispose();
      this._provisionalPage.dispose();
      this._provisionalPage = null;
    }
    this._firstNonInitialNavigationCommittedReject(new TargetClosedError());
    this._page._didClose();
  }
  dispatchMessageToSession(message) {
    this._pageProxySession.dispatchMessage(message);
  }
  handleProvisionalLoadFailed(event) {
    if (!this._page.initializedOrUndefined()) {
      this._firstNonInitialNavigationCommittedReject(new Error("Initial load failed"));
      return;
    }
    if (!this._provisionalPage)
      return;
    let errorText = event.error;
    if (errorText.includes("cancelled"))
      errorText += "; maybe frame was detached?";
    this._page._frameManager.frameAbortedNavigation(this._page.mainFrame()._id, errorText, event.loaderId);
  }
  handleWindowOpen(event) {
    this._nextWindowOpenPopupFeatures = event.windowFeatures;
  }
  async _onTargetCreated(event) {
    const { targetInfo } = event;
    const session2 = new WKSession(this._pageProxySession.connection, targetInfo.targetId, (message) => {
      this._pageProxySession.send("Target.sendMessageToTarget", {
        message: JSON.stringify(message),
        targetId: targetInfo.targetId
      }).catch((e) => {
        session2.dispatchMessage({ id: message.id, error: { message: e.message } });
      });
    });
    assert3(targetInfo.type === "page", "Only page targets are expected in WebKit, received: " + targetInfo.type);
    if (!targetInfo.isProvisional) {
      assert3(!this._page.initializedOrUndefined());
      let pageOrError;
      try {
        this._setSession(session2);
        await Promise.all([
          this._initializePageProxySession(),
          this._initializeSession(session2, false, ({ frameTree }) => this._handleFrameTree(frameTree))
        ]);
        pageOrError = this._page;
      } catch (e) {
        pageOrError = e;
      }
      if (targetInfo.isPaused)
        this._pageProxySession.sendMayFail("Target.resume", { targetId: targetInfo.targetId });
      if (pageOrError instanceof Page && this._page.mainFrame().url() === "") {
        try {
          await this._firstNonInitialNavigationCommittedPromise;
        } catch (e) {
          pageOrError = e;
        }
      } else {
        this._firstNonInitialNavigationCommittedPromise.catch(() => {
        });
      }
      this._page.reportAsNew(this._opener?._page, pageOrError instanceof Page ? void 0 : pageOrError);
    } else {
      assert3(targetInfo.isProvisional);
      assert3(!this._provisionalPage);
      this._provisionalPage = new WKProvisionalPage(session2, this);
      if (targetInfo.isPaused) {
        this._provisionalPage.initializationPromise.then(() => {
          this._pageProxySession.sendMayFail("Target.resume", { targetId: targetInfo.targetId });
        });
      }
    }
  }
  _onDispatchMessageFromTarget(event) {
    const { targetId, message } = event;
    if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId)
      this._provisionalPage._session.dispatchMessage(JSON.parse(message));
    else if (this._session.sessionId === targetId)
      this._session.dispatchMessage(JSON.parse(message));
    else
      throw new Error("Unknown target: " + targetId);
  }
  _addSessionListeners() {
    this._sessionListeners = [
      eventsHelper.addEventListener(this._session, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)),
      eventsHelper.addEventListener(this._session, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)),
      eventsHelper.addEventListener(this._session, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)),
      eventsHelper.addEventListener(this._session, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId)),
      eventsHelper.addEventListener(this._session, "Page.willCheckNavigationPolicy", (event) => this._onWillCheckNavigationPolicy(event.frameId)),
      eventsHelper.addEventListener(this._session, "Page.didCheckNavigationPolicy", (event) => this._onDidCheckNavigationPolicy(event.frameId, event.cancel)),
      eventsHelper.addEventListener(this._session, "Page.frameScheduledNavigation", (event) => this._onFrameScheduledNavigation(event.frameId, event.delay, event.targetIsCurrentFrame)),
      eventsHelper.addEventListener(this._session, "Page.loadEventFired", (event) => this._page._frameManager.frameLifecycleEvent(event.frameId, "load")),
      eventsHelper.addEventListener(this._session, "Page.domContentEventFired", (event) => this._page._frameManager.frameLifecycleEvent(event.frameId, "domcontentloaded")),
      eventsHelper.addEventListener(this._session, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)),
      eventsHelper.addEventListener(this._session, "Runtime.bindingCalled", (event) => this._onBindingCalled(event.contextId, event.argument)),
      eventsHelper.addEventListener(this._session, "Console.messageAdded", (event) => this._onConsoleMessage(event)),
      eventsHelper.addEventListener(this._session, "Console.messageRepeatCountUpdated", (event) => this._onConsoleRepeatCountUpdated(event)),
      eventsHelper.addEventListener(this._pageProxySession, "Dialog.javascriptDialogOpening", (event) => this._onDialog(event)),
      eventsHelper.addEventListener(this._session, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)),
      eventsHelper.addEventListener(this._session, "Network.requestWillBeSent", (e) => this._onRequestWillBeSent(this._session, e)),
      eventsHelper.addEventListener(this._session, "Network.requestIntercepted", (e) => this._onRequestIntercepted(this._session, e)),
      eventsHelper.addEventListener(this._session, "Network.responseReceived", (e) => this._onResponseReceived(this._session, e)),
      eventsHelper.addEventListener(this._session, "Network.loadingFinished", (e) => this._onLoadingFinished(e)),
      eventsHelper.addEventListener(this._session, "Network.loadingFailed", (e) => this._onLoadingFailed(this._session, e)),
      eventsHelper.addEventListener(this._session, "Network.webSocketCreated", (e) => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)),
      eventsHelper.addEventListener(this._session, "Network.webSocketWillSendHandshakeRequest", (e) => this._page._frameManager.onWebSocketRequest(e.requestId)),
      eventsHelper.addEventListener(this._session, "Network.webSocketHandshakeResponseReceived", (e) => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)),
      eventsHelper.addEventListener(this._session, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)),
      eventsHelper.addEventListener(this._session, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)),
      eventsHelper.addEventListener(this._session, "Network.webSocketClosed", (e) => this._page._frameManager.webSocketClosed(e.requestId)),
      eventsHelper.addEventListener(this._session, "Network.webSocketFrameError", (e) => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))
    ];
  }
  async _updateState(method, params) {
    await this._forAllSessions((session2) => session2.send(method, params).then());
  }
  async _forAllSessions(callback) {
    const sessions = [
      this._session
    ];
    if (this._provisionalPage)
      sessions.push(this._provisionalPage._session);
    await Promise.all(sessions.map((session2) => callback(session2).catch((e) => {
    })));
  }
  _onWillCheckNavigationPolicy(frameId) {
    if (this._provisionalPage)
      return;
    this._page._frameManager.frameRequestedNavigation(frameId);
  }
  _onDidCheckNavigationPolicy(frameId, cancel) {
    if (!cancel)
      return;
    if (this._provisionalPage)
      return;
    this._page._frameManager.frameAbortedNavigation(frameId, "Navigation canceled by policy check");
  }
  _onFrameScheduledNavigation(frameId, delay, targetIsCurrentFrame) {
    if (targetIsCurrentFrame)
      this._page._frameManager.frameRequestedNavigation(frameId);
  }
  _handleFrameTree(frameTree) {
    this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
    this._onFrameNavigated(frameTree.frame, true);
    this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, "domcontentloaded");
    this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, "load");
    if (!frameTree.childFrames)
      return;
    for (const child of frameTree.childFrames)
      this._handleFrameTree(child);
  }
  _onFrameAttached(frameId, parentFrameId) {
    return this._page._frameManager.frameAttached(frameId, parentFrameId);
  }
  _onFrameNavigated(framePayload, initial) {
    const frame = this._page._frameManager.frame(framePayload.id);
    assert3(frame);
    this._removeContextsForFrame(frame, true);
    if (!framePayload.parentId)
      this._workers.clear();
    this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || "", framePayload.loaderId, initial);
    if (!initial)
      this._firstNonInitialNavigationCommittedFulfill();
  }
  _onFrameNavigatedWithinDocument(frameId, url4) {
    this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url4);
  }
  _onFrameDetached(frameId) {
    this._page._frameManager.frameDetached(frameId);
  }
  _removeContextsForFrame(frame, notifyFrame) {
    for (const [contextId, context2] of this._contextIdToContext) {
      if (context2.frame === frame) {
        this._contextIdToContext.delete(contextId);
        if (notifyFrame)
          frame._contextDestroyed(context2);
      }
    }
  }
  _onExecutionContextCreated(contextPayload) {
    if (this._contextIdToContext.has(contextPayload.id))
      return;
    const frame = this._page._frameManager.frame(contextPayload.frameId);
    if (!frame)
      return;
    const delegate = new WKExecutionContext(this._session, contextPayload.id);
    let worldName = null;
    if (contextPayload.type === "normal")
      worldName = "main";
    else if (contextPayload.type === "user" && contextPayload.name === UTILITY_WORLD_NAME4)
      worldName = "utility";
    const context2 = new FrameExecutionContext(delegate, frame, worldName);
    if (worldName)
      frame._contextCreated(worldName, context2);
    this._contextIdToContext.set(contextPayload.id, context2);
  }
  async _onBindingCalled(contextId, argument2) {
    const pageOrError = await this._page.waitForInitializedOrError();
    if (!(pageOrError instanceof Error)) {
      const context2 = this._contextIdToContext.get(contextId);
      if (context2)
        await this._page._onBindingCalled(argument2, context2);
    }
  }
  async navigateFrame(frame, url4, referrer) {
    if (this._pageProxySession.isDisposed())
      throw new TargetClosedError();
    const pageProxyId = this._pageProxySession.sessionId;
    const result = await this._pageProxySession.connection.browserSession.send("Playwright.navigate", { url: url4, pageProxyId, frameId: frame._id, referrer });
    return { newDocumentId: result.loaderId };
  }
  _onConsoleMessage(event) {
    const { type: type2, level, text, parameters, url: url4, line: lineNumber, column: columnNumber, source: source7 } = event.message;
    if (level === "error" && source7 === "javascript") {
      const { name, message } = splitErrorMessage(text);
      let stack;
      if (event.message.stackTrace) {
        stack = text + "\n" + event.message.stackTrace.callFrames.map((callFrame) => {
          return `    at ${callFrame.functionName || "unknown"} (${callFrame.url}:${callFrame.lineNumber}:${callFrame.columnNumber})`;
        }).join("\n");
      } else {
        stack = "";
      }
      this._lastConsoleMessage = null;
      const error4 = new Error(message);
      error4.stack = stack;
      error4.name = name;
      this._page.emitOnContextOnceInitialized(BrowserContext.Events.PageError, error4, this._page);
      return;
    }
    let derivedType = type2 || "";
    if (type2 === "log")
      derivedType = level;
    else if (type2 === "timing")
      derivedType = "timeEnd";
    const handles = [];
    for (const p of parameters || []) {
      let context2;
      if (p.objectId) {
        const objectId = JSON.parse(p.objectId);
        context2 = this._contextIdToContext.get(objectId.injectedScriptId);
      } else {
        context2 = [...this._contextIdToContext.values()].find((c) => c.frame === this._page.mainFrame());
      }
      if (!context2)
        return;
      handles.push(createHandle4(context2, p));
    }
    this._lastConsoleMessage = {
      derivedType,
      text,
      handles,
      count: 0,
      location: {
        url: url4 || "",
        lineNumber: (lineNumber || 1) - 1,
        columnNumber: (columnNumber || 1) - 1
      }
    };
    this._onConsoleRepeatCountUpdated({ count: 1 });
  }
  _onConsoleRepeatCountUpdated(event) {
    if (this._lastConsoleMessage) {
      const {
        derivedType,
        text,
        handles,
        count: count3,
        location: location2
      } = this._lastConsoleMessage;
      for (let i = count3; i < event.count; ++i)
        this._page._addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
      this._lastConsoleMessage.count = event.count;
    }
  }
  _onDialog(event) {
    this._page.emitOnContext(BrowserContext.Events.Dialog, new Dialog(
      this._page,
      event.type,
      event.message,
      async (accept, promptText) => {
        if (event.type === "beforeunload" && !accept)
          this._page._frameManager.frameAbortedNavigation(this._page.mainFrame()._id, "navigation cancelled by beforeunload dialog");
        await this._pageProxySession.send("Dialog.handleJavaScriptDialog", { accept, promptText });
      },
      event.defaultPrompt
    ));
  }
  async _onFileChooserOpened(event) {
    let handle;
    try {
      const context2 = await this._page._frameManager.frame(event.frameId)._mainContext();
      handle = createHandle4(context2, event.element).asElement();
    } catch (e) {
      return;
    }
    await this._page._onFileChooserOpened(handle);
  }
  static async _setEmulateMedia(session2, mediaType, colorScheme, reducedMotion, forcedColors, contrast) {
    const promises2 = [];
    promises2.push(session2.send("Page.setEmulatedMedia", { media: mediaType === "no-override" ? "" : mediaType }));
    let appearance = void 0;
    switch (colorScheme) {
      case "light":
        appearance = "Light";
        break;
      case "dark":
        appearance = "Dark";
        break;
      case "no-override":
        appearance = void 0;
        break;
    }
    promises2.push(session2.send("Page.overrideUserPreference", { name: "PrefersColorScheme", value: appearance }));
    let reducedMotionWk = void 0;
    switch (reducedMotion) {
      case "reduce":
        reducedMotionWk = "Reduce";
        break;
      case "no-preference":
        reducedMotionWk = "NoPreference";
        break;
      case "no-override":
        reducedMotionWk = void 0;
        break;
    }
    promises2.push(session2.send("Page.overrideUserPreference", { name: "PrefersReducedMotion", value: reducedMotionWk }));
    let forcedColorsWk = void 0;
    switch (forcedColors) {
      case "active":
        forcedColorsWk = "Active";
        break;
      case "none":
        forcedColorsWk = "None";
        break;
      case "no-override":
        forcedColorsWk = void 0;
        break;
    }
    promises2.push(session2.send("Page.setForcedColors", { forcedColors: forcedColorsWk }));
    let contrastWk = void 0;
    switch (contrast) {
      case "more":
        contrastWk = "More";
        break;
      case "no-preference":
        contrastWk = "NoPreference";
        break;
      case "no-override":
        contrastWk = void 0;
        break;
    }
    promises2.push(session2.send("Page.overrideUserPreference", { name: "PrefersContrast", value: contrastWk }));
    await Promise.all(promises2);
  }
  async updateExtraHTTPHeaders() {
    await this._updateState("Network.setExtraHTTPHeaders", { headers: headersArrayToObject(
      this._calculateExtraHTTPHeaders(),
      false
      /* lowerCase */
    ) });
  }
  _calculateExtraHTTPHeaders() {
    const locale = this._browserContext._options.locale;
    const headers = mergeHeaders([
      this._browserContext._options.extraHTTPHeaders,
      this._page.extraHTTPHeaders(),
      locale ? singleHeader("Accept-Language", locale) : void 0
    ]);
    return headers;
  }
  async updateEmulateMedia() {
    const emulatedMedia = this._page.emulatedMedia();
    const colorScheme = emulatedMedia.colorScheme;
    const reducedMotion = emulatedMedia.reducedMotion;
    const forcedColors = emulatedMedia.forcedColors;
    const contrast = emulatedMedia.contrast;
    await this._forAllSessions((session2) => _WKPage._setEmulateMedia(session2, emulatedMedia.media, colorScheme, reducedMotion, forcedColors, contrast));
  }
  async updateEmulatedViewportSize() {
    this._browserContext._validateEmulatedViewport(this._page.viewportSize());
    await this._updateViewport();
  }
  async updateUserAgent() {
    const contextOptions = this._browserContext._options;
    this._updateState("Page.overrideUserAgent", { value: contextOptions.userAgent });
  }
  async bringToFront() {
    this._pageProxySession.send("Target.activate", {
      targetId: this._session.sessionId
    });
  }
  async _updateViewport() {
    const options2 = this._browserContext._options;
    const deviceSize = this._page.emulatedSize();
    if (deviceSize === null)
      return;
    const viewportSize = deviceSize.viewport;
    const screenSize = deviceSize.screen;
    const promises2 = [
      this._pageProxySession.send("Emulation.setDeviceMetricsOverride", {
        width: viewportSize.width,
        height: viewportSize.height,
        fixedLayout: !!options2.isMobile,
        deviceScaleFactor: options2.deviceScaleFactor || 1
      }),
      this._session.send("Page.setScreenSizeOverride", {
        width: screenSize.width,
        height: screenSize.height
      })
    ];
    if (options2.isMobile) {
      const angle = viewportSize.width > viewportSize.height ? 90 : 0;
      promises2.push(this._pageProxySession.send("Emulation.setOrientationOverride", { angle }));
    }
    await Promise.all(promises2);
  }
  async updateRequestInterception() {
    const enabled = this._page.needsRequestInterception();
    await Promise.all([
      this._updateState("Network.setInterceptionEnabled", { enabled }),
      this._updateState("Network.setResourceCachingDisabled", { disabled: enabled }),
      this._updateState("Network.addInterception", { url: ".*", stage: "request", isRegex: true })
    ]);
  }
  async updateOffline() {
    await this._updateState("Network.setEmulateOfflineState", { offline: !!this._browserContext._options.offline });
  }
  async updateHttpCredentials() {
    const credentials = this._browserContext._options.httpCredentials || { username: "", password: "", origin: "" };
    await this._pageProxySession.send("Emulation.setAuthCredentials", { username: credentials.username, password: credentials.password, origin: credentials.origin });
  }
  async updateFileChooserInterception() {
    const enabled = this._page.fileChooserIntercepted();
    await this._session.send("Page.setInterceptFileChooserDialog", { enabled }).catch(() => {
    });
  }
  async reload() {
    await this._session.send("Page.reload");
  }
  goBack() {
    return this._session.send("Page.goBack").then(() => true).catch((error4) => {
      if (error4 instanceof Error && error4.message.includes(`Protocol error (Page.goBack): Failed to go`))
        return false;
      throw error4;
    });
  }
  goForward() {
    return this._session.send("Page.goForward").then(() => true).catch((error4) => {
      if (error4 instanceof Error && error4.message.includes(`Protocol error (Page.goForward): Failed to go`))
        return false;
      throw error4;
    });
  }
  async requestGC() {
    await this._session.send("Heap.gc");
  }
  async addInitScript(initScript) {
    await this._updateBootstrapScript();
  }
  async removeNonInternalInitScripts() {
    await this._updateBootstrapScript();
  }
  _calculateBootstrapScript() {
    const scripts = [];
    if (!this._page.context()._options.isMobile) {
      scripts.push("delete window.orientation");
      scripts.push("delete window.ondevicemotion");
      scripts.push("delete window.ondeviceorientation");
    }
    scripts.push('if (!window.safari) window.safari = { pushNotification: { toString() { return "[object SafariRemoteNotification]"; } } };');
    scripts.push("if (!window.GestureEvent) window.GestureEvent = function GestureEvent() {};");
    scripts.push(...this._page.allInitScripts().map((script) => script.source));
    return scripts.join(";\n");
  }
  async _updateBootstrapScript() {
    await this._updateState("Page.setBootstrapScript", { source: this._calculateBootstrapScript() });
  }
  async closePage(runBeforeUnload) {
    await this._stopVideo();
    await this._pageProxySession.sendMayFail("Target.close", {
      targetId: this._session.sessionId,
      runBeforeUnload
    });
  }
  async setBackgroundColor(color) {
    await this._session.send("Page.setDefaultBackgroundColorOverride", { color });
  }
  _toolbarHeight() {
    if (this._page._browserContext._browser?.options.headful)
      return hostPlatform === "mac10.15" ? 55 : 59;
    return 0;
  }
  async _startVideo(options2) {
    assert3(!this._recordingVideoFile);
    const { screencastId } = await this._pageProxySession.send("Screencast.startVideo", {
      file: options2.outputFile,
      width: options2.width,
      height: options2.height,
      toolbarHeight: this._toolbarHeight()
    });
    this._recordingVideoFile = options2.outputFile;
    this._browserContext._browser._videoStarted(this._browserContext, screencastId, options2.outputFile, this._page.waitForInitializedOrError());
  }
  async _stopVideo() {
    if (!this._recordingVideoFile)
      return;
    await this._pageProxySession.sendMayFail("Screencast.stopVideo");
    this._recordingVideoFile = null;
  }
  validateScreenshotDimension(side, omitDeviceScaleFactor) {
    if (process.platform === "darwin")
      return;
    if (!omitDeviceScaleFactor && this._page._browserContext._options.deviceScaleFactor)
      side = Math.ceil(side * this._page._browserContext._options.deviceScaleFactor);
    if (side > 32767)
      throw new Error("Cannot take screenshot larger than 32767 pixels on any dimension");
  }
  async takeScreenshot(progress3, format2, documentRect, viewportRect, quality, fitsViewport, scale) {
    const rect = documentRect || viewportRect;
    const omitDeviceScaleFactor = scale === "css";
    this.validateScreenshotDimension(rect.width, omitDeviceScaleFactor);
    this.validateScreenshotDimension(rect.height, omitDeviceScaleFactor);
    const result = await this._session.send("Page.snapshotRect", { ...rect, coordinateSystem: documentRect ? "Page" : "Viewport", omitDeviceScaleFactor });
    const prefix = "data:image/png;base64,";
    let buffer2 = Buffer.from(result.dataURL.substr(prefix.length), "base64");
    if (format2 === "jpeg")
      buffer2 = jpegjs2.encode(PNG2.sync.read(buffer2), quality).data;
    return buffer2;
  }
  async getContentFrame(handle) {
    const nodeInfo = await this._session.send("DOM.describeNode", {
      objectId: handle._objectId
    });
    if (!nodeInfo.contentFrameId)
      return null;
    return this._page._frameManager.frame(nodeInfo.contentFrameId);
  }
  async getOwnerFrame(handle) {
    if (!handle._objectId)
      return null;
    const nodeInfo = await this._session.send("DOM.describeNode", {
      objectId: handle._objectId
    });
    return nodeInfo.ownerFrameId || null;
  }
  async getBoundingBox(handle) {
    const quads = await this.getContentQuads(handle);
    if (!quads || !quads.length)
      return null;
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (const quad of quads) {
      for (const point of quad) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
    }
    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
  }
  async scrollRectIntoViewIfNeeded(handle, rect) {
    return await this._session.send("DOM.scrollIntoViewIfNeeded", {
      objectId: handle._objectId,
      rect
    }).then(() => "done").catch((e) => {
      if (e instanceof Error && e.message.includes("Node does not have a layout object"))
        return "error:notvisible";
      if (e instanceof Error && e.message.includes("Node is detached from document"))
        return "error:notconnected";
      throw e;
    });
  }
  async setScreencastOptions(options2) {
    if (options2) {
      const so = { ...options2, toolbarHeight: this._toolbarHeight() };
      const { generation } = await this._pageProxySession.send("Screencast.startScreencast", so);
      this._screencastGeneration = generation;
    } else {
      await this._pageProxySession.send("Screencast.stopScreencast");
    }
  }
  _onScreencastFrame(event) {
    const generation = this._screencastGeneration;
    this._page.throttleScreencastFrameAck(() => {
      this._pageProxySession.send("Screencast.screencastFrameAck", { generation }).catch((e) => debugLogger.log("error", e));
    });
    const buffer2 = Buffer.from(event.data, "base64");
    this._page.emit(Page.Events.ScreencastFrame, {
      buffer: buffer2,
      width: event.deviceWidth,
      height: event.deviceHeight
    });
  }
  rafCountForStablePosition() {
    return process.platform === "win32" ? 5 : 1;
  }
  async getContentQuads(handle) {
    const result = await this._session.sendMayFail("DOM.getContentQuads", {
      objectId: handle._objectId
    });
    if (!result)
      return null;
    return result.quads.map((quad) => [
      { x: quad[0], y: quad[1] },
      { x: quad[2], y: quad[3] },
      { x: quad[4], y: quad[5] },
      { x: quad[6], y: quad[7] }
    ]);
  }
  async setInputFilePaths(handle, paths) {
    const pageProxyId = this._pageProxySession.sessionId;
    const objectId = handle._objectId;
    await Promise.all([
      this._pageProxySession.connection.browserSession.send("Playwright.grantFileReadAccess", { pageProxyId, paths }),
      this._session.send("DOM.setInputFiles", { objectId, paths })
    ]);
  }
  async adoptElementHandle(handle, to) {
    const result = await this._session.sendMayFail("DOM.resolveNode", {
      objectId: handle._objectId,
      executionContextId: to.delegate._contextId
    });
    if (!result || result.object.subtype === "null")
      throw new Error(kUnableToAdoptErrorMessage);
    return createHandle4(to, result.object);
  }
  async getAccessibilityTree(needle) {
    return getAccessibilityTree3(this._session, needle);
  }
  async inputActionEpilogue() {
  }
  async resetForReuse() {
  }
  async getFrameElement(frame) {
    const parent = frame.parentFrame();
    if (!parent)
      throw new Error("Frame has been detached.");
    const context2 = await parent._mainContext();
    const result = await this._session.send("DOM.resolveNode", {
      frameId: frame._id,
      executionContextId: context2.delegate._contextId
    });
    if (!result || result.object.subtype === "null")
      throw new Error("Frame has been detached.");
    return createHandle4(context2, result.object);
  }
  _maybeCancelCoopNavigationRequest(provisionalPage) {
    const navigationRequest = provisionalPage.coopNavigationRequest();
    for (const [requestId, request4] of this._requestIdToRequest) {
      if (request4.request === navigationRequest) {
        this._onLoadingFailed(provisionalPage._session, {
          requestId,
          errorText: "Provisiolal navigation canceled.",
          timestamp: request4._timestamp,
          canceled: true
        });
        return;
      }
    }
  }
  _adoptRequestFromNewProcess(navigationRequest, newSession, newRequestId) {
    for (const [requestId, request4] of this._requestIdToRequest) {
      if (request4.request === navigationRequest) {
        this._requestIdToRequest.delete(requestId);
        request4.adoptRequestFromNewProcess(newSession, newRequestId);
        this._requestIdToRequest.set(newRequestId, request4);
        return;
      }
    }
  }
  _onRequestWillBeSent(session2, event) {
    if (event.request.url.startsWith("data:"))
      return;
    if (event.request.url.startsWith("about:"))
      return;
    if (this._page.needsRequestInterception() && !event.redirectResponse)
      this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
    else
      this._onRequest(session2, event, false);
  }
  _onRequest(session2, event, intercepted) {
    let redirectedFrom = null;
    if (event.redirectResponse) {
      const request22 = this._requestIdToRequest.get(event.requestId);
      if (request22) {
        this._handleRequestRedirect(request22, event.requestId, event.redirectResponse, event.timestamp);
        redirectedFrom = request22;
      }
    }
    const frame = redirectedFrom ? redirectedFrom.request.frame() : this._page._frameManager.frame(event.frameId);
    if (!frame)
      return;
    const isNavigationRequest = event.type === "Document";
    const documentId = isNavigationRequest ? event.loaderId : void 0;
    const request4 = new WKInterceptableRequest(session2, frame, event, redirectedFrom, documentId);
    let route;
    if (intercepted) {
      route = new WKRouteImpl(session2, event.requestId);
      request4.request.setRawRequestHeaders(null);
    }
    this._requestIdToRequest.set(event.requestId, request4);
    this._page._frameManager.requestStarted(request4.request, route);
  }
  _handleRequestRedirect(request4, requestId, responsePayload, timestamp2) {
    const response = request4.createResponse(responsePayload);
    response._securityDetailsFinished();
    response._serverAddrFinished();
    response.setResponseHeadersSize(null);
    response.setEncodedBodySize(null);
    response._requestFinished(responsePayload.timing ? helper.secondsToRoundishMillis(timestamp2 - request4._timestamp) : -1);
    this._requestIdToRequest.delete(requestId);
    this._page._frameManager.requestReceivedResponse(response);
    this._page._frameManager.reportRequestFinished(request4.request, response);
  }
  _onRequestIntercepted(session2, event) {
    const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
    if (!requestWillBeSentEvent) {
      session2.sendMayFail("Network.interceptWithRequest", { requestId: event.requestId });
      return;
    }
    this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
    this._onRequest(session2, requestWillBeSentEvent, true);
  }
  _onResponseReceived(session2, event) {
    const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
    if (requestWillBeSentEvent) {
      this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
      this._onRequest(session2, requestWillBeSentEvent, false);
    }
    const request4 = this._requestIdToRequest.get(event.requestId);
    if (!request4)
      return;
    this._requestIdToResponseReceivedPayloadEvent.set(event.requestId, event);
    const response = request4.createResponse(event.response);
    this._page._frameManager.requestReceivedResponse(response);
    if (response.status() === 204 && request4.request.isNavigationRequest()) {
      this._onLoadingFailed(session2, {
        requestId: event.requestId,
        errorText: "Aborted: 204 No Content",
        timestamp: event.timestamp
      });
    }
  }
  _onLoadingFinished(event) {
    const request4 = this._requestIdToRequest.get(event.requestId);
    if (!request4)
      return;
    const response = request4.request._existingResponse();
    if (response) {
      const responseReceivedPayload = this._requestIdToResponseReceivedPayloadEvent.get(event.requestId);
      response._serverAddrFinished(parseRemoteAddress(event?.metrics?.remoteAddress));
      response._securityDetailsFinished({
        protocol: isLoadedSecurely(response.url(), response.timing()) ? event.metrics?.securityConnection?.protocol : void 0,
        subjectName: responseReceivedPayload?.response.security?.certificate?.subject,
        validFrom: responseReceivedPayload?.response.security?.certificate?.validFrom,
        validTo: responseReceivedPayload?.response.security?.certificate?.validUntil
      });
      if (event.metrics?.protocol)
        response._setHttpVersion(event.metrics.protocol);
      response.setEncodedBodySize(event.metrics?.responseBodyBytesReceived ?? null);
      response.setResponseHeadersSize(event.metrics?.responseHeaderBytesReceived ?? null);
      response._requestFinished(helper.secondsToRoundishMillis(event.timestamp - request4._timestamp));
    } else {
      request4.request.setRawRequestHeaders(null);
    }
    this._requestIdToResponseReceivedPayloadEvent.delete(event.requestId);
    this._requestIdToRequest.delete(event.requestId);
    this._page._frameManager.reportRequestFinished(request4.request, response);
  }
  _onLoadingFailed(session2, event) {
    const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
    if (requestWillBeSentEvent) {
      this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
      this._onRequest(session2, requestWillBeSentEvent, false);
    }
    const request4 = this._requestIdToRequest.get(event.requestId);
    if (!request4)
      return;
    const response = request4.request._existingResponse();
    if (response) {
      response._serverAddrFinished();
      response._securityDetailsFinished();
      response.setResponseHeadersSize(null);
      response.setEncodedBodySize(null);
      response._requestFinished(helper.secondsToRoundishMillis(event.timestamp - request4._timestamp));
    } else {
      request4.request.setRawRequestHeaders(null);
    }
    this._requestIdToRequest.delete(event.requestId);
    request4.request._setFailureText(event.errorText);
    this._page._frameManager.requestFailed(request4.request, event.errorText.includes("cancelled"));
  }
  async _grantPermissions(origin, permissions) {
    const webPermissionToProtocol = /* @__PURE__ */ new Map([
      ["geolocation", "geolocation"],
      ["notifications", "notifications"],
      ["clipboard-read", "clipboard-read"]
    ]);
    const filtered = permissions.map((permission2) => {
      const protocolPermission = webPermissionToProtocol.get(permission2);
      if (!protocolPermission)
        throw new Error("Unknown permission: " + permission2);
      return protocolPermission;
    });
    await this._pageProxySession.send("Emulation.grantPermissions", { origin, permissions: filtered });
  }
  async _clearPermissions() {
    await this._pageProxySession.send("Emulation.resetPermissions", {});
  }
  shouldToggleStyleSheetToSyncAnimations() {
    return true;
  }
};
function parseRemoteAddress(value) {
  if (!value)
    return;
  try {
    const colon = value.lastIndexOf(":");
    const dot = value.lastIndexOf(".");
    if (dot < 0) {
      return {
        ipAddress: `[${value.slice(0, colon)}]`,
        port: +value.slice(colon + 1)
      };
    }
    if (colon > dot) {
      const [address, port] = value.split(":");
      return {
        ipAddress: address,
        port: +port
      };
    } else {
      const [address, port] = value.split(".");
      return {
        ipAddress: `[${address}]`,
        port: +port
      };
    }
  } catch (_) {
  }
}
__name(parseRemoteAddress, "parseRemoteAddress");
function isLoadedSecurely(url4, timing) {
  try {
    const u = new URL(url4);
    if (u.protocol !== "https:" && u.protocol !== "wss:" && u.protocol !== "sftp:")
      return false;
    if (timing.secureConnectionStart === -1 && timing.connectStart !== -1)
      return false;
    return true;
  } catch (_) {
  }
}
__name(isLoadedSecurely, "isLoadedSecurely");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/wkBrowser.js
var DEFAULT_USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Safari/605.1.15";
var BROWSER_VERSION = "18.4";
var WKBrowser = class _WKBrowser extends Browser {
  static {
    __name(this, "WKBrowser");
  }
  constructor(parent, transport, options2) {
    super(parent, options2);
    this._contexts = /* @__PURE__ */ new Map();
    this._wkPages = /* @__PURE__ */ new Map();
    this._connection = new WKConnection(transport, this._onDisconnect.bind(this), options2.protocolLogger, options2.browserLogsCollector);
    this._browserSession = this._connection.browserSession;
    this._browserSession.on("Playwright.pageProxyCreated", this._onPageProxyCreated.bind(this));
    this._browserSession.on("Playwright.pageProxyDestroyed", this._onPageProxyDestroyed.bind(this));
    this._browserSession.on("Playwright.provisionalLoadFailed", (event) => this._onProvisionalLoadFailed(event));
    this._browserSession.on("Playwright.windowOpen", (event) => this._onWindowOpen(event));
    this._browserSession.on("Playwright.downloadCreated", this._onDownloadCreated.bind(this));
    this._browserSession.on("Playwright.downloadFilenameSuggested", this._onDownloadFilenameSuggested.bind(this));
    this._browserSession.on("Playwright.downloadFinished", this._onDownloadFinished.bind(this));
    this._browserSession.on("Playwright.screencastFinished", this._onScreencastFinished.bind(this));
    this._browserSession.on(kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this));
  }
  static async connect(parent, transport, options2) {
    const browser3 = new _WKBrowser(parent, transport, options2);
    if (options2.__testHookOnConnectToBrowser)
      await options2.__testHookOnConnectToBrowser();
    const promises2 = [
      browser3._browserSession.send("Playwright.enable")
    ];
    if (options2.persistent) {
      options2.persistent.userAgent ||= DEFAULT_USER_AGENT;
      browser3._defaultContext = new WKBrowserContext(browser3, void 0, options2.persistent);
      promises2.push(browser3._defaultContext._initialize());
    }
    await Promise.all(promises2);
    return browser3;
  }
  _onDisconnect() {
    for (const wkPage of this._wkPages.values())
      wkPage.didClose();
    this._wkPages.clear();
    for (const video of this._idToVideo.values())
      video.artifact.reportFinished(new TargetClosedError());
    this._idToVideo.clear();
    this._didClose();
  }
  async doCreateNewContext(options2) {
    const proxy = options2.proxyOverride || options2.proxy;
    const createOptions = proxy ? {
      // Enable socks5 hostname resolution on Windows.
      // See https://github.com/microsoft/playwright/issues/20451
      proxyServer: process.platform === "win32" ? proxy.server.replace(/^socks5:\/\//, "socks5h://") : proxy.server,
      proxyBypassList: proxy.bypass
    } : void 0;
    const { browserContextId } = await this._browserSession.send("Playwright.createContext", createOptions);
    options2.userAgent = options2.userAgent || DEFAULT_USER_AGENT;
    const context2 = new WKBrowserContext(this, browserContextId, options2);
    await context2._initialize();
    this._contexts.set(browserContextId, context2);
    return context2;
  }
  contexts() {
    return Array.from(this._contexts.values());
  }
  version() {
    return BROWSER_VERSION;
  }
  userAgent() {
    return DEFAULT_USER_AGENT;
  }
  _onDownloadCreated(payload) {
    const page = this._wkPages.get(payload.pageProxyId);
    if (!page)
      return;
    page._page._frameManager.frameAbortedNavigation(payload.frameId, "Download is starting");
    let originPage = page._page.initializedOrUndefined();
    if (!originPage) {
      page._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
      if (page._opener)
        originPage = page._opener._page.initializedOrUndefined();
    }
    if (!originPage)
      return;
    this._downloadCreated(originPage, payload.uuid, payload.url);
  }
  _onDownloadFilenameSuggested(payload) {
    this._downloadFilenameSuggested(payload.uuid, payload.suggestedFilename);
  }
  _onDownloadFinished(payload) {
    this._downloadFinished(payload.uuid, payload.error);
  }
  _onScreencastFinished(payload) {
    this._takeVideo(payload.screencastId)?.reportFinished();
  }
  _onPageProxyCreated(event) {
    const pageProxyId = event.pageProxyId;
    let context2 = null;
    if (event.browserContextId) {
      context2 = this._contexts.get(event.browserContextId) || null;
    }
    if (!context2)
      context2 = this._defaultContext;
    if (!context2)
      return;
    const pageProxySession = new WKSession(this._connection, pageProxyId, (message) => {
      this._connection.rawSend({ ...message, pageProxyId });
    });
    const opener = event.openerId ? this._wkPages.get(event.openerId) : void 0;
    const wkPage = new WKPage(context2, pageProxySession, opener || null);
    this._wkPages.set(pageProxyId, wkPage);
  }
  _onPageProxyDestroyed(event) {
    const pageProxyId = event.pageProxyId;
    const wkPage = this._wkPages.get(pageProxyId);
    if (!wkPage)
      return;
    wkPage.didClose();
    this._wkPages.delete(pageProxyId);
  }
  _onPageProxyMessageReceived(event) {
    const wkPage = this._wkPages.get(event.pageProxyId);
    if (!wkPage)
      return;
    wkPage.dispatchMessageToSession(event.message);
  }
  _onProvisionalLoadFailed(event) {
    const wkPage = this._wkPages.get(event.pageProxyId);
    if (!wkPage)
      return;
    wkPage.handleProvisionalLoadFailed(event);
  }
  _onWindowOpen(event) {
    const wkPage = this._wkPages.get(event.pageProxyId);
    if (!wkPage)
      return;
    wkPage.handleWindowOpen(event);
  }
  isConnected() {
    return !this._connection.isClosed();
  }
};
var WKBrowserContext = class extends BrowserContext {
  static {
    __name(this, "WKBrowserContext");
  }
  constructor(browser3, browserContextId, options2) {
    super(browser3, options2, browserContextId);
    this._validateEmulatedViewport(options2.viewport);
    this._authenticateProxyViaHeader();
  }
  async _initialize() {
    assert3(!this._wkPages().length);
    const browserContextId = this._browserContextId;
    const promises2 = [super._initialize()];
    promises2.push(this._browser._browserSession.send("Playwright.setDownloadBehavior", {
      behavior: this._options.acceptDownloads === "accept" ? "allow" : "deny",
      downloadPath: this._browser.options.downloadsPath,
      browserContextId
    }));
    if (this._options.ignoreHTTPSErrors || this._options.internalIgnoreHTTPSErrors)
      promises2.push(this._browser._browserSession.send("Playwright.setIgnoreCertificateErrors", { browserContextId, ignore: true }));
    if (this._options.locale)
      promises2.push(this._browser._browserSession.send("Playwright.setLanguages", { browserContextId, languages: [this._options.locale] }));
    if (this._options.geolocation)
      promises2.push(this.setGeolocation(this._options.geolocation));
    if (this._options.offline)
      promises2.push(this.setOffline(this._options.offline));
    if (this._options.httpCredentials)
      promises2.push(this.setHTTPCredentials(this._options.httpCredentials));
    await Promise.all(promises2);
  }
  _wkPages() {
    return Array.from(this._browser._wkPages.values()).filter((wkPage) => wkPage._browserContext === this);
  }
  possiblyUninitializedPages() {
    return this._wkPages().map((wkPage) => wkPage._page);
  }
  async doCreateNewPage() {
    assertBrowserContextIsNotOwned(this);
    const { pageProxyId } = await this._browser._browserSession.send("Playwright.createPage", { browserContextId: this._browserContextId });
    return this._browser._wkPages.get(pageProxyId)._page;
  }
  async doGetCookies(urls) {
    const { cookies } = await this._browser._browserSession.send("Playwright.getAllCookies", { browserContextId: this._browserContextId });
    return filterCookies(cookies.map((c) => {
      const copy = { ...c };
      copy.expires = c.expires === -1 ? -1 : c.expires / 1e3;
      delete copy.session;
      return copy;
    }), urls);
  }
  async addCookies(cookies) {
    const cc = rewriteCookies(cookies).map((c) => ({
      ...c,
      session: c.expires === -1 || c.expires === void 0,
      expires: c.expires && c.expires !== -1 ? c.expires * 1e3 : c.expires
    }));
    await this._browser._browserSession.send("Playwright.setCookies", { cookies: cc, browserContextId: this._browserContextId });
  }
  async doClearCookies() {
    await this._browser._browserSession.send("Playwright.deleteAllCookies", { browserContextId: this._browserContextId });
  }
  async doGrantPermissions(origin, permissions) {
    await Promise.all(this.pages().map((page) => page._delegate._grantPermissions(origin, permissions)));
  }
  async doClearPermissions() {
    await Promise.all(this.pages().map((page) => page._delegate._clearPermissions()));
  }
  async setGeolocation(geolocation) {
    verifyGeolocation(geolocation);
    this._options.geolocation = geolocation;
    const payload = geolocation ? { ...geolocation, timestamp: Date.now() } : void 0;
    await this._browser._browserSession.send("Playwright.setGeolocationOverride", { browserContextId: this._browserContextId, geolocation: payload });
  }
  async setExtraHTTPHeaders(headers) {
    this._options.extraHTTPHeaders = headers;
    for (const page of this.pages())
      await page._delegate.updateExtraHTTPHeaders();
  }
  async setUserAgent(userAgent) {
    this._options.userAgent = userAgent;
    for (const page of this.pages())
      await page._delegate.updateUserAgent();
  }
  async setOffline(offline) {
    this._options.offline = offline;
    for (const page of this.pages())
      await page._delegate.updateOffline();
  }
  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;
    for (const page of this.pages())
      await page._delegate.updateHttpCredentials();
  }
  async doAddInitScript(initScript) {
    for (const page of this.pages())
      await page._delegate._updateBootstrapScript();
  }
  async doRemoveNonInternalInitScripts() {
    for (const page of this.pages())
      await page._delegate._updateBootstrapScript();
  }
  async doUpdateRequestInterception() {
    for (const page of this.pages())
      await page._delegate.updateRequestInterception();
  }
  onClosePersistent() {
  }
  async clearCache() {
    await this._browser._browserSession.send("Playwright.clearMemoryCache", {
      browserContextId: this._browserContextId
    });
  }
  async doClose(reason) {
    if (!this._browserContextId) {
      await Promise.all(this._wkPages().map((wkPage) => wkPage._stopVideo()));
      await this._browser.close({ reason });
    } else {
      await this._browser._browserSession.send("Playwright.deleteContext", { browserContextId: this._browserContextId });
      this._browser._contexts.delete(this._browserContextId);
    }
  }
  async cancelDownload(uuid) {
    await this._browser._browserSession.send("Playwright.cancelDownload", { uuid });
  }
  _validateEmulatedViewport(viewportSize) {
    if (!viewportSize)
      return;
    if (process.platform === "win32" && this._browser.options.headful && (viewportSize.width < 250 || viewportSize.height < 240))
      throw new Error(`WebKit on Windows has a minimal viewport of 250x240.`);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/webkit/webkit.js
var WebKit = class extends BrowserType {
  static {
    __name(this, "WebKit");
  }
  constructor(parent) {
    super(parent, "webkit");
  }
  connectToTransport(transport, options2) {
    return WKBrowser.connect(this.attribution.playwright, transport, options2);
  }
  amendEnvironment(env3, userDataDir, executable, browserArguments) {
    return { ...env3, CURL_COOKIE_JAR_PATH: path30.join(userDataDir, "cookiejar.db") };
  }
  doRewriteStartupLog(error4) {
    if (!error4.logs)
      return error4;
    if (error4.logs.includes("Failed to open display") || error4.logs.includes("cannot open display"))
      error4.logs = "\n" + wrapInASCIIBox(kNoXServerRunningError, 1);
    return error4;
  }
  attemptToGracefullyCloseBrowser(transport) {
    transport.send({ method: "Playwright.close", params: {}, id: kBrowserCloseMessageId4 });
  }
  defaultArgs(options2, isPersistent, userDataDir) {
    const { args = [], headless } = options2;
    const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
    if (userDataDirArg)
      throw this._createUserDataDirArgMisuseError("--user-data-dir");
    if (args.find((arg) => !arg.startsWith("-")))
      throw new Error("Arguments can not specify page to be opened");
    const webkitArguments = ["--inspector-pipe"];
    if (process.platform === "win32")
      webkitArguments.push("--disable-accelerated-compositing");
    if (headless)
      webkitArguments.push("--headless");
    if (isPersistent)
      webkitArguments.push(`--user-data-dir=${userDataDir}`);
    else
      webkitArguments.push(`--no-startup-window`);
    const proxy = options2.proxyOverride || options2.proxy;
    if (proxy) {
      if (process.platform === "darwin") {
        webkitArguments.push(`--proxy=${proxy.server}`);
        if (proxy.bypass)
          webkitArguments.push(`--proxy-bypass-list=${proxy.bypass}`);
      } else if (process.platform === "linux") {
        webkitArguments.push(`--proxy=${proxy.server}`);
        if (proxy.bypass)
          webkitArguments.push(...proxy.bypass.split(",").map((t) => `--ignore-host=${t}`));
      } else if (process.platform === "win32") {
        webkitArguments.push(`--curl-proxy=${proxy.server.replace(/^socks5:\/\//, "socks5h://")}`);
        if (proxy.bypass)
          webkitArguments.push(`--curl-noproxy=${proxy.bypass}`);
      }
    }
    webkitArguments.push(...args);
    if (isPersistent)
      webkitArguments.push("about:blank");
    return webkitArguments;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/playwright.js
var Playwright = class extends SdkObject {
  static {
    __name(this, "Playwright");
  }
  constructor(options2) {
    super({ attribution: {}, instrumentation: createInstrumentation() }, void 0, "Playwright");
    this._allPages = /* @__PURE__ */ new Set();
    this._allBrowsers = /* @__PURE__ */ new Set();
    this.options = options2;
    this.attribution.playwright = this;
    this.instrumentation.addListener({
      onBrowserOpen: /* @__PURE__ */ __name((browser3) => this._allBrowsers.add(browser3), "onBrowserOpen"),
      onBrowserClose: /* @__PURE__ */ __name((browser3) => this._allBrowsers.delete(browser3), "onBrowserClose"),
      onPageOpen: /* @__PURE__ */ __name((page) => this._allPages.add(page), "onPageOpen"),
      onPageClose: /* @__PURE__ */ __name((page) => this._allPages.delete(page), "onPageClose"),
      onCallLog: /* @__PURE__ */ __name((sdkObject, metadata, logName, message) => {
        debugLogger.log(logName, message);
      }, "onCallLog")
    }, null);
    this.chromium = new Chromium(this);
    this.bidiChromium = new BidiChromium(this);
    this.bidiFirefox = new BidiFirefox(this);
    this.firefox = new Firefox(this);
    this.webkit = new WebKit(this);
    this.electron = new Electron(this);
    this.android = new Android(this, new AdbBackend());
    this.selectors = new Selectors();
    this.debugController = new DebugController(this);
  }
  async hideHighlight() {
    await Promise.all([...this._allPages].map((p) => p.hideHighlight().catch(() => {
    })));
  }
  allBrowsers() {
    return [...this._allBrowsers];
  }
  allPages() {
    return [...this._allPages];
  }
};
function createPlaywright(options2) {
  return new Playwright(options2);
}
__name(createPlaywright, "createPlaywright");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/remote/playwrightConnection.js
import "node:path";
import "node:url";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/dispatchers/debugControllerDispatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:path";
import "node:url";
var DebugControllerDispatcher = class extends Dispatcher {
  static {
    __name(this, "DebugControllerDispatcher");
  }
  constructor(connection, debugController) {
    super(connection, debugController, "DebugController", {});
    this._type_DebugController = true;
    this._listeners = [
      eventsHelper.addEventListener(this._object, DebugController.Events.StateChanged, (params) => {
        this._dispatchEvent("stateChanged", params);
      }),
      eventsHelper.addEventListener(this._object, DebugController.Events.InspectRequested, ({ selector, locator, ariaSnapshot }) => {
        this._dispatchEvent("inspectRequested", { selector, locator, ariaSnapshot });
      }),
      eventsHelper.addEventListener(this._object, DebugController.Events.SourceChanged, ({ text, header, footer, actions }) => {
        this._dispatchEvent("sourceChanged", { text, header, footer, actions });
      }),
      eventsHelper.addEventListener(this._object, DebugController.Events.Paused, ({ paused }) => {
        this._dispatchEvent("paused", { paused });
      }),
      eventsHelper.addEventListener(this._object, DebugController.Events.SetModeRequested, ({ mode }) => {
        this._dispatchEvent("setModeRequested", { mode });
      })
    ];
  }
  async initialize(params) {
    this._object.initialize(params.codegenId, params.sdkLanguage);
  }
  async setReportStateChanged(params) {
    this._object.setReportStateChanged(params.enabled);
  }
  async resetForReuse() {
    await this._object.resetForReuse();
  }
  async navigate(params) {
    await this._object.navigate(params.url);
  }
  async setRecorderMode(params) {
    await this._object.setRecorderMode(params);
  }
  async highlight(params) {
    await this._object.highlight(params);
  }
  async hideHighlight() {
    await this._object.hideHighlight();
  }
  async resume() {
    await this._object.resume();
  }
  async kill() {
    await this._object.kill();
  }
  async closeAllBrowsers() {
    await this._object.closeAllBrowsers();
  }
  _onDispose() {
    eventsHelper.removeEventListeners(this._listeners);
    this._object.dispose();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/remote/playwrightConnection.js
var PlaywrightConnection = class {
  static {
    __name(this, "PlaywrightConnection");
  }
  constructor(lock, clientType, ws3, options2, preLaunched, id, onClose) {
    this._cleanups = [];
    this._disconnected = false;
    this._ws = ws3;
    this._preLaunched = preLaunched;
    this._options = options2;
    options2.launchOptions = filterLaunchOptions(options2.launchOptions, options2.allowFSPaths);
    if (clientType === "reuse-browser" || clientType === "pre-launched-browser-or-android")
      assert3(preLaunched.playwright);
    if (clientType === "pre-launched-browser-or-android")
      assert3(preLaunched.browser || preLaunched.androidDevice);
    this._onClose = onClose;
    this._id = id;
    this._profileName = `${(/* @__PURE__ */ new Date()).toISOString()}-${clientType}`;
    this._dispatcherConnection = new DispatcherConnection();
    this._dispatcherConnection.onmessage = async (message) => {
      await lock;
      if (ws3.readyState !== ws3.CLOSING) {
        const messageString = JSON.stringify(message);
        if (debugLogger.isEnabled("server:channel"))
          debugLogger.log("server:channel", `[${this._id}] ${monotonicTime() * 1e3} SEND \u25BA ${messageString}`);
        if (debugLogger.isEnabled("server:metadata"))
          this.logServerMetadata(message, messageString, "SEND");
        ws3.send(messageString);
      }
    };
    ws3.on("message", async (message) => {
      await lock;
      const messageString = Buffer.from(message).toString();
      const jsonMessage = JSON.parse(messageString);
      if (debugLogger.isEnabled("server:channel"))
        debugLogger.log("server:channel", `[${this._id}] ${monotonicTime() * 1e3} \u25C0 RECV ${messageString}`);
      if (debugLogger.isEnabled("server:metadata"))
        this.logServerMetadata(jsonMessage, messageString, "RECV");
      this._dispatcherConnection.dispatch(jsonMessage);
    });
    ws3.on("close", () => this._onDisconnect());
    ws3.on("error", (error4) => this._onDisconnect(error4));
    if (clientType === "controller") {
      this._root = this._initDebugControllerMode();
      return;
    }
    this._root = new RootDispatcher(this._dispatcherConnection, async (scope, options22) => {
      await startProfiling();
      if (clientType === "reuse-browser")
        return await this._initReuseBrowsersMode(scope);
      if (clientType === "pre-launched-browser-or-android")
        return this._preLaunched.browser ? await this._initPreLaunchedBrowserMode(scope) : await this._initPreLaunchedAndroidMode(scope);
      if (clientType === "launch-browser")
        return await this._initLaunchBrowserMode(scope, options22);
      throw new Error("Unsupported client type: " + clientType);
    });
  }
  async _initLaunchBrowserMode(scope, options2) {
    debugLogger.log("server", `[${this._id}] engaged launch mode for "${this._options.browserName}"`);
    const playwright2 = createPlaywright({ sdkLanguage: options2.sdkLanguage, isServer: true });
    const ownedSocksProxy = await this._createOwnedSocksProxy(playwright2);
    let browserName = this._options.browserName;
    if ("bidi" === browserName) {
      if (this._options.launchOptions?.channel?.toLocaleLowerCase().includes("firefox"))
        browserName = "bidiFirefox";
      else
        browserName = "bidiChromium";
    }
    const browser3 = await playwright2[browserName].launch(serverSideCallMetadata(), this._options.launchOptions);
    this._cleanups.push(async () => {
      for (const browser22 of playwright2.allBrowsers())
        await browser22.close({ reason: "Connection terminated" });
    });
    browser3.on(Browser.Events.Disconnected, () => {
      this.close({ code: 1001, reason: "Browser closed" });
    });
    return new PlaywrightDispatcher(scope, playwright2, ownedSocksProxy, browser3);
  }
  async _initPreLaunchedBrowserMode(scope) {
    debugLogger.log("server", `[${this._id}] engaged pre-launched (browser) mode`);
    const playwright2 = this._preLaunched.playwright;
    this._preLaunched.socksProxy?.setPattern(this._options.socksProxyPattern);
    const browser3 = this._preLaunched.browser;
    browser3.on(Browser.Events.Disconnected, () => {
      this.close({ code: 1001, reason: "Browser closed" });
    });
    const playwrightDispatcher = new PlaywrightDispatcher(scope, playwright2, this._preLaunched.socksProxy, browser3);
    for (const b of playwright2.allBrowsers()) {
      if (b !== browser3)
        await b.close({ reason: "Connection terminated" });
    }
    this._cleanups.push(() => playwrightDispatcher.cleanup());
    return playwrightDispatcher;
  }
  async _initPreLaunchedAndroidMode(scope) {
    debugLogger.log("server", `[${this._id}] engaged pre-launched (Android) mode`);
    const playwright2 = this._preLaunched.playwright;
    const androidDevice = this._preLaunched.androidDevice;
    androidDevice.on(AndroidDevice.Events.Close, () => {
      this.close({ code: 1001, reason: "Android device disconnected" });
    });
    const playwrightDispatcher = new PlaywrightDispatcher(scope, playwright2, void 0, void 0, androidDevice);
    this._cleanups.push(() => playwrightDispatcher.cleanup());
    return playwrightDispatcher;
  }
  _initDebugControllerMode() {
    debugLogger.log("server", `[${this._id}] engaged reuse controller mode`);
    const playwright2 = this._preLaunched.playwright;
    return new DebugControllerDispatcher(this._dispatcherConnection, playwright2.debugController);
  }
  async _initReuseBrowsersMode(scope) {
    debugLogger.log("server", `[${this._id}] engaged reuse browsers mode for ${this._options.browserName}`);
    const playwright2 = this._preLaunched.playwright;
    const requestedOptions = launchOptionsHash(this._options.launchOptions);
    let browser3 = playwright2.allBrowsers().find((b) => {
      if (b.options.name !== this._options.browserName)
        return false;
      const existingOptions = launchOptionsHash(b.options.originalLaunchOptions);
      return existingOptions === requestedOptions;
    });
    for (const b of playwright2.allBrowsers()) {
      if (b === browser3)
        continue;
      if (b.options.name === this._options.browserName && b.options.channel === this._options.launchOptions.channel)
        await b.close({ reason: "Connection terminated" });
    }
    if (!browser3) {
      browser3 = await playwright2[this._options.browserName || "chromium"].launch(serverSideCallMetadata(), {
        ...this._options.launchOptions,
        headless: !!process.env.PW_DEBUG_CONTROLLER_HEADLESS
      });
      browser3.on(Browser.Events.Disconnected, () => {
        this.close({ code: 1001, reason: "Browser closed" });
      });
    }
    this._cleanups.push(async () => {
      for (const browser22 of playwright2.allBrowsers()) {
        for (const context2 of browser22.contexts()) {
          if (!context2.pages().length)
            await context2.close({ reason: "Connection terminated" });
          else
            await context2.stopPendingOperations("Connection closed");
        }
        if (!browser22.contexts())
          await browser22.close({ reason: "Connection terminated" });
      }
    });
    const playwrightDispatcher = new PlaywrightDispatcher(scope, playwright2, void 0, browser3);
    return playwrightDispatcher;
  }
  async _createOwnedSocksProxy(playwright2) {
    if (!this._options.socksProxyPattern)
      return;
    const socksProxy = new SocksProxy();
    socksProxy.setPattern(this._options.socksProxyPattern);
    playwright2.options.socksProxyPort = await socksProxy.listen(0);
    debugLogger.log("server", `[${this._id}] started socks proxy on port ${playwright2.options.socksProxyPort}`);
    this._cleanups.push(() => socksProxy.close());
    return socksProxy;
  }
  async _onDisconnect(error4) {
    this._disconnected = true;
    debugLogger.log("server", `[${this._id}] disconnected. error: ${error4}`);
    this._root._dispose();
    debugLogger.log("server", `[${this._id}] starting cleanup`);
    for (const cleanup of this._cleanups)
      await cleanup().catch(() => {
      });
    await stopProfiling(this._profileName);
    this._onClose();
    debugLogger.log("server", `[${this._id}] finished cleanup`);
  }
  logServerMetadata(message, messageString, direction) {
    const serverLogMetadata = {
      wallTime: Date.now(),
      id: message.id,
      guid: message.guid,
      method: message.method,
      payloadSizeInBytes: Buffer.byteLength(messageString, "utf-8")
    };
    debugLogger.log("server:metadata", (direction === "SEND" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(serverLogMetadata));
  }
  async close(reason) {
    if (this._disconnected)
      return;
    debugLogger.log("server", `[${this._id}] force closing connection: ${reason?.reason || ""} (${reason?.code || 0})`);
    try {
      this._ws.close(reason?.code, reason?.reason);
    } catch (e) {
    }
  }
};
function launchOptionsHash(options2) {
  const copy = { ...options2 };
  for (const k of Object.keys(copy)) {
    const key = k;
    if (copy[key] === defaultLaunchOptions[key])
      delete copy[key];
  }
  for (const key of optionsThatAllowBrowserReuse)
    delete copy[key];
  return JSON.stringify(copy);
}
__name(launchOptionsHash, "launchOptionsHash");
function filterLaunchOptions(options2, allowFSPaths) {
  return {
    channel: options2.channel,
    args: options2.args,
    ignoreAllDefaultArgs: options2.ignoreAllDefaultArgs,
    ignoreDefaultArgs: options2.ignoreDefaultArgs,
    timeout: options2.timeout,
    headless: options2.headless,
    proxy: options2.proxy,
    chromiumSandbox: options2.chromiumSandbox,
    firefoxUserPrefs: options2.firefoxUserPrefs,
    slowMo: options2.slowMo,
    executablePath: isUnderTest() || allowFSPaths ? options2.executablePath : void 0,
    downloadsPath: allowFSPaths ? options2.downloadsPath : void 0
  };
}
__name(filterLaunchOptions, "filterLaunchOptions");
var defaultLaunchOptions = {
  ignoreAllDefaultArgs: false,
  handleSIGINT: false,
  handleSIGTERM: false,
  handleSIGHUP: false,
  headless: true,
  devtools: false
};
var optionsThatAllowBrowserReuse = [
  "headless",
  "tracesDir"
];

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/semaphore.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Semaphore = class {
  static {
    __name(this, "Semaphore");
  }
  constructor(max) {
    this._acquired = 0;
    this._queue = [];
    this._max = max;
  }
  setMax(max) {
    this._max = max;
  }
  acquire() {
    const lock = new ManualPromise();
    this._queue.push(lock);
    this._flush();
    return lock;
  }
  release() {
    --this._acquired;
    this._flush();
  }
  _flush() {
    while (this._acquired < this._max && this._queue.length) {
      ++this._acquired;
      this._queue.shift().resolve();
    }
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/server/utils/wsServer.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var lastConnectionId = 0;
var kConnectionSymbol = Symbol("kConnection");
var perMessageDeflate = {
  serverNoContextTakeover: true,
  zlibDeflateOptions: {
    level: 3
  },
  zlibInflateOptions: {
    chunkSize: 10 * 1024
  },
  threshold: 10 * 1024
};
var WSServer = class {
  static {
    __name(this, "WSServer");
  }
  constructor(delegate) {
    this._delegate = delegate;
  }
  async listen(port = 0, hostname2, path31) {
    debugLogger.log("server", `Server started at ${/* @__PURE__ */ new Date()}`);
    const server = createHttpServer((request4, response) => {
      if (request4.method === "GET" && request4.url === "/json") {
        response.setHeader("Content-Type", "application/json");
        response.end(JSON.stringify({
          wsEndpointPath: path31
        }));
        return;
      }
      response.end("Running");
    });
    server.on("error", (error4) => debugLogger.log("server", String(error4)));
    this.server = server;
    const wsEndpoint = await new Promise((resolve, reject) => {
      server.listen(port, hostname2, () => {
        const address = server.address();
        if (!address) {
          reject(new Error("Could not bind server socket"));
          return;
        }
        const wsEndpoint2 = typeof address === "string" ? `${address}${path31}` : `ws://${hostname2 || "localhost"}:${address.port}${path31}`;
        resolve(wsEndpoint2);
      }).on("error", reject);
    });
    debugLogger.log("server", "Listening at " + wsEndpoint);
    this._wsServer = new wsServer2({
      noServer: true,
      perMessageDeflate
    });
    if (this._delegate.onHeaders)
      this._wsServer.on("headers", (headers) => this._delegate.onHeaders(headers));
    server.on("upgrade", (request4, socket, head) => {
      const pathname = new URL("http://localhost" + request4.url).pathname;
      if (pathname !== path31) {
        socket.write(`HTTP/${request4.httpVersion} 400 Bad Request\r
\r
`);
        socket.destroy();
        return;
      }
      const upgradeResult = this._delegate.onUpgrade?.(request4, socket);
      if (upgradeResult) {
        socket.write(upgradeResult.error);
        socket.destroy();
        return;
      }
      this._wsServer?.handleUpgrade(request4, socket, head, (ws3) => this._wsServer?.emit("connection", ws3, request4));
    });
    this._wsServer.on("connection", (ws3, request4) => {
      debugLogger.log("server", "Connected client ws.extension=" + ws3.extensions);
      const url4 = new URL("http://localhost" + (request4.url || ""));
      const id = String(++lastConnectionId);
      debugLogger.log("server", `[${id}] serving connection: ${request4.url}`);
      const connection = this._delegate.onConnection(request4, url4, ws3, id);
      ws3[kConnectionSymbol] = connection;
    });
    return wsEndpoint;
  }
  async close() {
    const server = this._wsServer;
    if (!server)
      return;
    debugLogger.log("server", "closing websocket server");
    const waitForClose = new Promise((f) => server.close(f));
    await Promise.all(Array.from(server.clients).map(async (ws3) => {
      const connection = ws3[kConnectionSymbol];
      if (connection)
        await connection.close();
      try {
        ws3.terminate();
      } catch (e) {
      }
    }));
    await waitForClose;
    debugLogger.log("server", "closing http server");
    if (this.server)
      await new Promise((f) => this.server.close(f));
    this._wsServer = void 0;
    this.server = void 0;
    debugLogger.log("server", "closed server");
    await this._delegate.onClose?.();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/remote/playwrightServer.js
var PlaywrightServer = class {
  static {
    __name(this, "PlaywrightServer");
  }
  constructor(options2) {
    this._options = options2;
    if (options2.preLaunchedBrowser)
      this._preLaunchedPlaywright = options2.preLaunchedBrowser.attribution.playwright;
    if (options2.preLaunchedAndroidDevice)
      this._preLaunchedPlaywright = options2.preLaunchedAndroidDevice._android.attribution.playwright;
    const browserSemaphore = new Semaphore(this._options.maxConnections);
    const controllerSemaphore = new Semaphore(1);
    const reuseBrowserSemaphore = new Semaphore(1);
    this._wsServer = new WSServer({
      onUpgrade: /* @__PURE__ */ __name((request4, socket) => {
        const uaError = userAgentVersionMatchesErrorMessage(request4.headers["user-agent"] || "");
        if (uaError)
          return { error: `HTTP/${request4.httpVersion} 428 Precondition Required\r
\r
${uaError}` };
      }, "onUpgrade"),
      onHeaders: /* @__PURE__ */ __name((headers) => {
        if (process.env.PWTEST_SERVER_WS_HEADERS)
          headers.push(process.env.PWTEST_SERVER_WS_HEADERS);
      }, "onHeaders"),
      onConnection: /* @__PURE__ */ __name((request4, url4, ws3, id) => {
        const browserHeader = request4.headers["x-playwright-browser"];
        const browserName = url4.searchParams.get("browser") || (Array.isArray(browserHeader) ? browserHeader[0] : browserHeader) || null;
        const proxyHeader = request4.headers["x-playwright-proxy"];
        const proxyValue = url4.searchParams.get("proxy") || (Array.isArray(proxyHeader) ? proxyHeader[0] : proxyHeader);
        const launchOptionsHeader = request4.headers["x-playwright-launch-options"] || "";
        const launchOptionsHeaderValue = Array.isArray(launchOptionsHeader) ? launchOptionsHeader[0] : launchOptionsHeader;
        const launchOptionsParam = url4.searchParams.get("launch-options");
        let launchOptions = {};
        try {
          launchOptions = JSON.parse(launchOptionsParam || launchOptionsHeaderValue);
        } catch (e) {
        }
        const isExtension = this._options.mode === "extension";
        if (isExtension) {
          if (!this._preLaunchedPlaywright)
            this._preLaunchedPlaywright = createPlaywright({ sdkLanguage: "javascript", isServer: true });
        }
        let clientType = "launch-browser";
        let semaphore = browserSemaphore;
        if (isExtension && url4.searchParams.has("debug-controller")) {
          clientType = "controller";
          semaphore = controllerSemaphore;
        } else if (isExtension) {
          clientType = "reuse-browser";
          semaphore = reuseBrowserSemaphore;
        } else if (this._options.mode === "launchServer") {
          clientType = "pre-launched-browser-or-android";
          semaphore = browserSemaphore;
        }
        return new PlaywrightConnection(
          semaphore.acquire(),
          clientType,
          ws3,
          { socksProxyPattern: proxyValue, browserName, launchOptions, allowFSPaths: this._options.mode === "extension" },
          {
            playwright: this._preLaunchedPlaywright,
            browser: this._options.preLaunchedBrowser,
            androidDevice: this._options.preLaunchedAndroidDevice,
            socksProxy: this._options.preLaunchedSocksProxy
          },
          id,
          () => semaphore.release()
        );
      }, "onConnection"),
      onClose: /* @__PURE__ */ __name(async () => {
        debugLogger.log("server", "closing browsers");
        if (this._preLaunchedPlaywright)
          await Promise.all(this._preLaunchedPlaywright.allBrowsers().map((browser3) => browser3.close({ reason: "Playwright Server stopped" })));
        debugLogger.log("server", "closed browsers");
      }, "onClose")
    });
  }
  async listen(port = 0, hostname2) {
    return this._wsServer.listen(port, hostname2, this._options.path);
  }
  async close() {
    await this._wsServer.close();
  }
};
function userAgentVersionMatchesErrorMessage(userAgent) {
  const match = userAgent.match(/^Playwright\/(\d+\.\d+\.\d+)/);
  if (!match) {
    return;
  }
  const received = match[1].split(".").slice(0, 2).join(".");
  const expected = getPlaywrightVersion(true);
  if (received !== expected) {
    return wrapInASCIIBox([
      `Playwright version mismatch:`,
      `  - server version: v${expected}`,
      `  - client version: v${received}`,
      ``,
      `If you are using VSCode extension, restart VSCode.`,
      ``,
      `If you are connecting to a remote service,`,
      `keep your local Playwright version in sync`,
      `with the remote service version.`,
      ``,
      `<3 Playwright Team`
    ].join("\n"), 1);
  }
}
__name(userAgentVersionMatchesErrorMessage, "userAgentVersionMatchesErrorMessage");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/androidServerImpl.js
var AndroidServerLauncherImpl = class {
  static {
    __name(this, "AndroidServerLauncherImpl");
  }
  async launchServer(options2 = {}) {
    const playwright2 = createPlaywright({ sdkLanguage: "javascript", isServer: true });
    let devices2 = await playwright2.android.devices({
      host: options2.adbHost,
      port: options2.adbPort,
      omitDriverInstall: options2.omitDriverInstall
    });
    if (devices2.length === 0)
      throw new Error("No devices found");
    if (options2.deviceSerialNumber) {
      devices2 = devices2.filter((d) => d.serial === options2.deviceSerialNumber);
      if (devices2.length === 0)
        throw new Error(`No device with serial number '${options2.deviceSerialNumber}' was found`);
    }
    if (devices2.length > 1)
      throw new Error(`More than one device found. Please specify deviceSerialNumber`);
    const device = devices2[0];
    const path31 = options2.wsPath ? options2.wsPath.startsWith("/") ? options2.wsPath : `/${options2.wsPath}` : `/${createGuid()}`;
    const server = new PlaywrightServer({ mode: "launchServer", path: path31, maxConnections: 1, preLaunchedAndroidDevice: device });
    const wsEndpoint = await server.listen(options2.port, options2.host);
    const browserServer = new ws2.EventEmitter();
    browserServer.wsEndpoint = () => wsEndpoint;
    browserServer.close = () => device.close();
    browserServer.kill = () => device.close();
    device.on("close", () => {
      server.close();
      browserServer.emit("close");
    });
    return browserServer;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/browserServerImpl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BrowserServerLauncherImpl = class {
  static {
    __name(this, "BrowserServerLauncherImpl");
  }
  constructor(browserName) {
    this._browserName = browserName;
  }
  async launchServer(options2 = {}) {
    const playwright2 = createPlaywright({ sdkLanguage: "javascript", isServer: true });
    const socksProxy = void 0;
    playwright2.options.socksProxyPort = await socksProxy?.listen(0);
    const metadata = serverSideCallMetadata();
    const browser3 = await playwright2[this._browserName].launch(metadata, {
      ...options2,
      ignoreDefaultArgs: Array.isArray(options2.ignoreDefaultArgs) ? options2.ignoreDefaultArgs : void 0,
      ignoreAllDefaultArgs: !!options2.ignoreDefaultArgs && !Array.isArray(options2.ignoreDefaultArgs),
      env: options2.env ? envObjectToArray(options2.env) : void 0
    }, toProtocolLogger(options2.logger)).catch((e) => {
      const log4 = helper.formatBrowserLogs(metadata.log);
      rewriteErrorMessage(e, `${e.message} Failed to launch browser.${log4}`);
      throw e;
    });
    const path31 = options2.wsPath ? options2.wsPath.startsWith("/") ? options2.wsPath : `/${options2.wsPath}` : `/${createGuid()}`;
    const server = new PlaywrightServer({ mode: "launchServer", path: path31, maxConnections: Infinity, preLaunchedBrowser: browser3, preLaunchedSocksProxy: socksProxy });
    const wsEndpoint = await server.listen(options2.port, options2.host);
    const browserServer = new ws2.EventEmitter();
    browserServer.process = () => browser3.options.browserProcess.process;
    browserServer.wsEndpoint = () => wsEndpoint;
    browserServer.close = () => browser3.options.browserProcess.close();
    browserServer[Symbol.asyncDispose] = browserServer.close;
    browserServer.kill = () => browser3.options.browserProcess.kill();
    browserServer._disconnectForTest = () => server.close();
    browserServer._userDataDirForTest = browser3._userDataDirForTest;
    browser3.options.browserProcess.onclose = (exitCode2, signal) => {
      server.close();
      browserServer.emit("close", exitCode2, signal);
    };
    return browserServer;
  }
};
function toProtocolLogger(logger) {
  return logger ? (direction, message) => {
    if (logger.isEnabled("protocol", "verbose"))
      logger.log("protocol", "verbose", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(message), [], {});
  } : void 0;
}
__name(toProtocolLogger, "toProtocolLogger");
function envObjectToArray(env3) {
  const result = [];
  for (const name in env3) {
    if (!Object.is(env3[name], void 0))
      result.push({ name, value: String(env3[name]) });
  }
  return result;
}
__name(envObjectToArray, "envObjectToArray");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/inProcessFactory.js
import "node:path";
import "node:url";
import "node:events";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/connection.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/eventEmitter.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var EventEmitter18 = class {
  static {
    __name(this, "EventEmitter");
  }
  constructor(platform4) {
    this._events = void 0;
    this._eventsCount = 0;
    this._maxListeners = void 0;
    this._pendingHandlers = /* @__PURE__ */ new Map();
    this._platform = platform4;
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
    this.on = this.addListener;
    this.off = this.removeListener;
  }
  setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    this._maxListeners = n;
    return this;
  }
  getMaxListeners() {
    return this._maxListeners === void 0 ? this._platform.defaultMaxListeners() : this._maxListeners;
  }
  emit(type2, ...args) {
    const events = this._events;
    if (events === void 0)
      return false;
    const handler = events?.[type2];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      this._callHandler(type2, handler, args);
    } else {
      const len = handler.length;
      const listeners2 = handler.slice();
      for (let i = 0; i < len; ++i)
        this._callHandler(type2, listeners2[i], args);
    }
    return true;
  }
  _callHandler(type2, handler, args) {
    const promise = Reflect.apply(handler, this, args);
    if (!(promise instanceof Promise))
      return;
    let set2 = this._pendingHandlers.get(type2);
    if (!set2) {
      set2 = /* @__PURE__ */ new Set();
      this._pendingHandlers.set(type2, set2);
    }
    set2.add(promise);
    promise.catch((e) => {
      if (this._rejectionHandler)
        this._rejectionHandler(e);
      else
        throw e;
    }).finally(() => set2.delete(promise));
  }
  addListener(type2, listener) {
    return this._addListener(type2, listener, false);
  }
  on(type2, listener) {
    return this._addListener(type2, listener, false);
  }
  _addListener(type2, listener, prepend) {
    checkListener(listener);
    let events = this._events;
    let existing;
    if (events === void 0) {
      events = this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else {
      if (events.newListener !== void 0) {
        this.emit("newListener", type2, unwrapListener(listener));
        events = this._events;
      }
      existing = events[type2];
    }
    if (existing === void 0) {
      existing = events[type2] = listener;
      ++this._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      const m = this.getMaxListeners();
      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true;
        const w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = this;
        w.type = type2;
        w.count = existing.length;
        if (!this._platform.isUnderTest()) {
          console.warn(w);
        }
      }
    }
    return this;
  }
  prependListener(type2, listener) {
    return this._addListener(type2, listener, true);
  }
  once(type2, listener) {
    checkListener(listener);
    this.on(type2, new OnceWrapper(this, type2, listener).wrapperFunction);
    return this;
  }
  prependOnceListener(type2, listener) {
    checkListener(listener);
    this.prependListener(type2, new OnceWrapper(this, type2, listener).wrapperFunction);
    return this;
  }
  removeListener(type2, listener) {
    checkListener(listener);
    const events = this._events;
    if (events === void 0)
      return this;
    const list = events[type2];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
      } else {
        delete events[type2];
        if (events.removeListener)
          this.emit("removeListener", type2, list.listener ?? listener);
      }
    } else if (typeof list !== "function") {
      let position = -1;
      let originalListener;
      for (let i = list.length - 1; i >= 0; i--) {
        if (list[i] === listener || wrappedListener(list[i]) === listener) {
          originalListener = wrappedListener(list[i]);
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else
        list.splice(position, 1);
      if (list.length === 1)
        events[type2] = list[0];
      if (events.removeListener !== void 0)
        this.emit("removeListener", type2, originalListener || listener);
    }
    return this;
  }
  off(type2, listener) {
    return this.removeListener(type2, listener);
  }
  removeAllListeners(type2, options2) {
    this._removeAllListeners(type2);
    if (!options2)
      return this;
    if (options2.behavior === "wait") {
      const errors3 = [];
      this._rejectionHandler = (error4) => errors3.push(error4);
      return this._waitFor(type2).then(() => {
        if (errors3.length)
          throw errors3[0];
      });
    }
    if (options2.behavior === "ignoreErrors")
      this._rejectionHandler = () => {
      };
    return Promise.resolve();
  }
  _removeAllListeners(type2) {
    const events = this._events;
    if (!events)
      return;
    if (!events.removeListener) {
      if (type2 === void 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events[type2] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events[type2];
      }
      return;
    }
    if (type2 === void 0) {
      const keys = Object.keys(events);
      let key;
      for (let i = 0; i < keys.length; ++i) {
        key = keys[i];
        if (key === "removeListener")
          continue;
        this._removeAllListeners(key);
      }
      this._removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return;
    }
    const listeners2 = events[type2];
    if (typeof listeners2 === "function") {
      this.removeListener(type2, listeners2);
    } else if (listeners2 !== void 0) {
      for (let i = listeners2.length - 1; i >= 0; i--)
        this.removeListener(type2, listeners2[i]);
    }
  }
  listeners(type2) {
    return this._listeners(this, type2, true);
  }
  rawListeners(type2) {
    return this._listeners(this, type2, false);
  }
  listenerCount(type2) {
    const events = this._events;
    if (events !== void 0) {
      const listener = events[type2];
      if (typeof listener === "function")
        return 1;
      if (listener !== void 0)
        return listener.length;
    }
    return 0;
  }
  eventNames() {
    return this._eventsCount > 0 && this._events ? Reflect.ownKeys(this._events) : [];
  }
  async _waitFor(type2) {
    let promises2 = [];
    if (type2) {
      promises2 = [...this._pendingHandlers.get(type2) || []];
    } else {
      promises2 = [];
      for (const [, pending] of this._pendingHandlers)
        promises2.push(...pending);
    }
    await Promise.all(promises2);
  }
  _listeners(target, type2, unwrap) {
    const events = target._events;
    if (events === void 0)
      return [];
    const listener = events[type2];
    if (listener === void 0)
      return [];
    if (typeof listener === "function")
      return unwrap ? [unwrapListener(listener)] : [listener];
    return unwrap ? unwrapListeners(listener) : listener.slice();
  }
};
function checkListener(listener) {
  if (typeof listener !== "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
__name(checkListener, "checkListener");
var OnceWrapper = class {
  static {
    __name(this, "OnceWrapper");
  }
  constructor(eventEmitter, eventType, listener) {
    this._fired = false;
    this._eventEmitter = eventEmitter;
    this._eventType = eventType;
    this._listener = listener;
    this.wrapperFunction = this._handle.bind(this);
    this.wrapperFunction.listener = listener;
  }
  _handle(...args) {
    if (this._fired)
      return;
    this._fired = true;
    this._eventEmitter.removeListener(this._eventType, this.wrapperFunction);
    return this._listener.apply(this._eventEmitter, args);
  }
};
function unwrapListener(l) {
  return wrappedListener(l) ?? l;
}
__name(unwrapListener, "unwrapListener");
function unwrapListeners(arr) {
  return arr.map((l) => wrappedListener(l) ?? l);
}
__name(unwrapListeners, "unwrapListeners");
function wrappedListener(l) {
  return l.listener;
}
__name(wrappedListener, "wrappedListener");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/android.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/browserContext.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/artifact.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/channelOwner.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/cloudflare/apiCallZone.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var apiCallZone = new AsyncLocalStorage();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/clientStackTrace.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function captureLibraryStackTrace(platform4) {
  const stack = captureRawStack();
  let parsedFrames = stack.map((line) => {
    const frame = parseStackFrame(line, platform4.pathSeparator, platform4.showInternalStackFrames());
    if (!frame || !frame.file)
      return null;
    const isPlaywrightLibrary = !!platform4.coreDir && frame.file.startsWith(platform4.coreDir);
    const parsed = {
      frame,
      frameText: line,
      isPlaywrightLibrary
    };
    return parsed;
  }).filter(Boolean);
  let apiName = "";
  for (let i = 0; i < parsedFrames.length - 1; i++) {
    const parsedFrame = parsedFrames[i];
    if (parsedFrame.isPlaywrightLibrary && !parsedFrames[i + 1].isPlaywrightLibrary) {
      apiName = apiName || normalizeAPIName(parsedFrame.frame.function);
      break;
    }
  }
  function normalizeAPIName(name) {
    if (!name)
      return "";
    const match = name.match(/(API|JS|CDP|[A-Z])(.*)/);
    if (!match)
      return name;
    return match[1].toLowerCase() + match[2];
  }
  __name(normalizeAPIName, "normalizeAPIName");
  const filterPrefixes = platform4.boxedStackPrefixes();
  parsedFrames = parsedFrames.filter((f) => {
    if (filterPrefixes.some((prefix) => f.frame.file.startsWith(prefix)))
      return false;
    return true;
  });
  return {
    frames: parsedFrames.map((p) => p.frame),
    apiName
  };
}
__name(captureLibraryStackTrace, "captureLibraryStackTrace");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/channelOwner.js
var ChannelOwner = class _ChannelOwner extends EventEmitter18 {
  static {
    __name(this, "ChannelOwner");
  }
  constructor(parent, type2, guid, initializer) {
    const connection = parent instanceof _ChannelOwner ? parent._connection : parent;
    super(connection._platform);
    this._objects = /* @__PURE__ */ new Map();
    this._eventToSubscriptionMapping = /* @__PURE__ */ new Map();
    this._isInternalType = false;
    this._wasCollected = false;
    this.setMaxListeners(0);
    this._connection = connection;
    this._type = type2;
    this._guid = guid;
    this._parent = parent instanceof _ChannelOwner ? parent : void 0;
    this._instrumentation = this._connection._instrumentation;
    this._connection._objects.set(guid, this);
    if (this._parent) {
      this._parent._objects.set(guid, this);
      this._logger = this._parent._logger;
    }
    this._channel = this._createChannel(new EventEmitter18(connection._platform));
    this._initializer = initializer;
  }
  markAsInternalType() {
    this._isInternalType = true;
  }
  _setEventToSubscriptionMapping(mapping) {
    this._eventToSubscriptionMapping = mapping;
  }
  _updateSubscription(event, enabled) {
    const protocolEvent = this._eventToSubscriptionMapping.get(String(event));
    if (protocolEvent) {
      this._wrapApiCall(async () => {
        await this._channel.updateSubscription({ event: protocolEvent, enabled });
      }, true).catch(() => {
      });
    }
  }
  on(event, listener) {
    if (!this.listenerCount(event))
      this._updateSubscription(event, true);
    super.on(event, listener);
    return this;
  }
  addListener(event, listener) {
    if (!this.listenerCount(event))
      this._updateSubscription(event, true);
    super.addListener(event, listener);
    return this;
  }
  prependListener(event, listener) {
    if (!this.listenerCount(event))
      this._updateSubscription(event, true);
    super.prependListener(event, listener);
    return this;
  }
  off(event, listener) {
    super.off(event, listener);
    if (!this.listenerCount(event))
      this._updateSubscription(event, false);
    return this;
  }
  removeListener(event, listener) {
    super.removeListener(event, listener);
    if (!this.listenerCount(event))
      this._updateSubscription(event, false);
    return this;
  }
  _adopt(child) {
    child._parent._objects.delete(child._guid);
    this._objects.set(child._guid, child);
    child._parent = this;
  }
  _dispose(reason) {
    if (this._parent)
      this._parent._objects.delete(this._guid);
    this._connection._objects.delete(this._guid);
    this._wasCollected = reason === "gc";
    for (const object of [...this._objects.values()])
      object._dispose(reason);
    this._objects.clear();
  }
  _debugScopeState() {
    return {
      _guid: this._guid,
      objects: Array.from(this._objects.values()).map((o) => o._debugScopeState())
    };
  }
  _validatorToWireContext() {
    return {
      tChannelImpl: tChannelImplToWire,
      binary: this._connection.rawBuffers() ? "buffer" : "toBase64",
      isUnderTest: /* @__PURE__ */ __name(() => this._platform.isUnderTest(), "isUnderTest")
    };
  }
  _createChannel(base) {
    const channel2 = new Proxy(base, {
      get: /* @__PURE__ */ __name((obj, prop) => {
        if (typeof prop === "string") {
          const validator = maybeFindValidator(this._type, prop, "Params");
          if (validator) {
            return async (params) => {
              return await this._wrapApiCall(async (apiZone) => {
                const validatedParams = validator(params, "", this._validatorToWireContext());
                if (!apiZone.isInternal && !apiZone.reported) {
                  apiZone.params = params;
                  apiZone.reported = true;
                  this._instrumentation.onApiCallBegin(apiZone);
                  logApiCall(this._platform, this._logger, `=> ${apiZone.apiName} started`);
                  return await this._connection.sendMessageToServer(this, prop, validatedParams, apiZone.apiName, apiZone.frames, apiZone.stepId);
                }
                return await this._connection.sendMessageToServer(this, prop, validatedParams, void 0, [], void 0);
              });
            };
          }
        }
        return obj[prop];
      }, "get")
    });
    channel2._object = this;
    return channel2;
  }
  async _wrapApiCall(func, isInternal) {
    const logger = this._logger;
    const existingApiZone = this._platform.zones.current().data();
    if (existingApiZone)
      return await func(existingApiZone);
    const apiCall = apiCallZone.getStore();
    if (isInternal === void 0)
      isInternal = this._isInternalType;
    const stackTrace = captureLibraryStackTrace(this._platform);
    const apiZone = { apiName: apiCall?.apiName ?? stackTrace.apiName, frames: stackTrace.frames, isInternal, reported: false, userData: void 0, stepId: void 0 };
    try {
      const result = await this._platform.zones.current().push(apiZone).run(async () => await func(apiZone));
      if (!isInternal) {
        logApiCall(this._platform, logger, `<= ${apiZone.apiName} succeeded`);
        this._instrumentation.onApiCallEnd(apiZone);
      }
      return result;
    } catch (e) {
      const innerError = (this._platform.showInternalStackFrames() || this._platform.isUnderTest()) && e.stack ? "\n<inner error>\n" + e.stack : "";
      if (apiZone.apiName && !apiZone.apiName.includes("<anonymous>"))
        e.message = apiZone.apiName + ": " + e.message;
      const stackFrames = "\n" + stringifyStackFrames(stackTrace.frames).join("\n") + innerError;
      if (stackFrames.trim())
        e.stack = e.message + stackFrames;
      else
        e.stack = "";
      if (!isInternal) {
        apiZone.error = e;
        logApiCall(this._platform, logger, `<= ${apiZone.apiName} failed`);
        this._instrumentation.onApiCallEnd(apiZone);
      }
      throw e;
    }
  }
  _toImpl() {
    return this._connection.toImpl?.(this);
  }
  toJSON() {
    return {
      _type: this._type,
      _guid: this._guid
    };
  }
};
function logApiCall(platform4, logger, message) {
  if (logger && logger.isEnabled("api", "info"))
    logger.log("api", "info", message, [], { color: "cyan" });
  platform4.log("api", message);
}
__name(logApiCall, "logApiCall");
function tChannelImplToWire(names, arg, path31, context2) {
  if (arg._object instanceof ChannelOwner && (names === "*" || names.includes(arg._object._type)))
    return { guid: arg._object._guid };
  throw new ValidationError(`${path31}: expected channel ${names.toString()}`);
}
__name(tChannelImplToWire, "tChannelImplToWire");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/stream.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Stream = class extends ChannelOwner {
  static {
    __name(this, "Stream");
  }
  static from(Stream2) {
    return Stream2._object;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
  }
  stream() {
    return this._platform.streamReadable(this._channel);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/fileUtils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var fileUploadSizeLimit2 = 50 * 1024 * 1024;
async function mkdirIfNeeded2(platform4, filePath) {
  await platform4.fs().promises.mkdir(platform4.path().dirname(filePath), { recursive: true }).catch(() => {
  });
}
__name(mkdirIfNeeded2, "mkdirIfNeeded");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/artifact.js
var Artifact2 = class extends ChannelOwner {
  static {
    __name(this, "Artifact");
  }
  static from(channel2) {
    return channel2._object;
  }
  async pathAfterFinished() {
    if (this._connection.isRemote())
      throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
    return (await this._channel.pathAfterFinished()).value;
  }
  async saveAs(path31) {
    if (!this._connection.isRemote()) {
      await this._channel.saveAs({ path: path31 });
      return;
    }
    const result = await this._channel.saveAsStream();
    const stream = Stream.from(result.stream);
    await mkdirIfNeeded2(this._platform, path31);
    await new Promise((resolve, reject) => {
      stream.stream().pipe(this._platform.fs().createWriteStream(path31)).on("finish", resolve).on("error", reject);
    });
  }
  async failure() {
    return (await this._channel.failure()).error || null;
  }
  async createReadStream() {
    const result = await this._channel.stream();
    const stream = Stream.from(result.stream);
    return stream.stream();
  }
  async readIntoBuffer() {
    const stream = await this.createReadStream();
    return await new Promise((resolve, reject) => {
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
      });
      stream.on("end", () => {
        resolve(Buffer.concat(chunks));
      });
      stream.on("error", reject);
    });
  }
  async cancel() {
    return await this._channel.cancel();
  }
  async delete() {
    return await this._channel.delete();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/browser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/cdpSession.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CDPSession2 = class extends ChannelOwner {
  static {
    __name(this, "CDPSession");
  }
  static from(cdpSession) {
    return cdpSession._object;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._channel.on("event", ({ method, params }) => {
      this.emit(method, params);
    });
    this.on = super.on;
    this.addListener = super.addListener;
    this.off = super.removeListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }
  async send(method, params) {
    const result = await this._channel.send({ method, params });
    return result.result;
  }
  async detach() {
    return await this._channel.detach();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TimeoutError2 = class extends Error {
  static {
    __name(this, "TimeoutError");
  }
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};
var TargetClosedError2 = class extends Error {
  static {
    __name(this, "TargetClosedError");
  }
  constructor(cause) {
    super(cause || "Target page, context or browser has been closed");
  }
};
function isTargetClosedError2(error4) {
  return error4 instanceof TargetClosedError2;
}
__name(isTargetClosedError2, "isTargetClosedError");
function serializeError2(e) {
  if (isError3(e))
    return { error: { message: e.message, stack: e.stack, name: e.name } };
  return { value: serializeValue(e, (value) => ({ fallThrough: value })) };
}
__name(serializeError2, "serializeError");
function parseError2(error4) {
  if (!error4.error) {
    if (error4.value === void 0)
      throw new Error("Serialized error must have either an error or a value");
    return parseSerializedValue(error4.value, void 0);
  }
  if (error4.error.name === "TimeoutError") {
    const e2 = new TimeoutError2(error4.error.message);
    e2.stack = error4.error.stack || "";
    return e2;
  }
  if (error4.error.name === "TargetClosedError") {
    const e2 = new TargetClosedError2(error4.error.message);
    e2.stack = error4.error.stack || "";
    return e2;
  }
  const e = new Error(error4.error.message);
  e.stack = error4.error.stack || "";
  e.name = error4.error.name;
  return e;
}
__name(parseError2, "parseError");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/events.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Events = {
  AndroidDevice: {
    WebView: "webview",
    Close: "close"
  },
  AndroidSocket: {
    Data: "data",
    Close: "close"
  },
  AndroidWebView: {
    Close: "close"
  },
  Browser: {
    Disconnected: "disconnected"
  },
  BrowserContext: {
    Console: "console",
    Close: "close",
    Dialog: "dialog",
    Page: "page",
    // Can't use just 'error' due to node.js special treatment of error events.
    // @see https://nodejs.org/api/events.html#events_error_events
    WebError: "weberror",
    BackgroundPage: "backgroundpage",
    ServiceWorker: "serviceworker",
    Request: "request",
    Response: "response",
    RequestFailed: "requestfailed",
    RequestFinished: "requestfinished"
  },
  Page: {
    Close: "close",
    Crash: "crash",
    Console: "console",
    Dialog: "dialog",
    Download: "download",
    FileChooser: "filechooser",
    DOMContentLoaded: "domcontentloaded",
    // Can't use just 'error' due to node.js special treatment of error events.
    // @see https://nodejs.org/api/events.html#events_error_events
    PageError: "pageerror",
    Request: "request",
    Response: "response",
    RequestFailed: "requestfailed",
    RequestFinished: "requestfinished",
    FrameAttached: "frameattached",
    FrameDetached: "framedetached",
    FrameNavigated: "framenavigated",
    Load: "load",
    Popup: "popup",
    WebSocket: "websocket",
    Worker: "worker"
  },
  WebSocket: {
    Close: "close",
    Error: "socketerror",
    FrameReceived: "framereceived",
    FrameSent: "framesent"
  },
  Worker: {
    Close: "close"
  },
  ElectronApplication: {
    Close: "close",
    Console: "console",
    Window: "window"
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/browser.js
var Browser2 = class extends ChannelOwner {
  static {
    __name(this, "Browser");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._contexts = /* @__PURE__ */ new Set();
    this._isConnected = true;
    this._shouldCloseConnectionOnClose = false;
    this._options = {};
    this._name = initializer.name;
    this._channel.on("close", () => this._didClose());
    this._closedPromise = new Promise((f) => this.once(Events.Browser.Disconnected, f));
  }
  static from(browser3) {
    return browser3._object;
  }
  browserType() {
    return this._browserType;
  }
  async newContext(options2 = {}) {
    return await this._innerNewContext(options2, false);
  }
  async _newContextForReuse(options2 = {}) {
    return await this._wrapApiCall(async () => {
      for (const context2 of this._contexts) {
        await this._browserType._willCloseContext(context2);
        for (const page of context2.pages())
          page._onClose();
        context2._onClose();
      }
      return await this._innerNewContext(options2, true);
    }, true);
  }
  async _stopPendingOperations(reason) {
    return await this._wrapApiCall(async () => {
      await this._channel.stopPendingOperations({ reason });
    }, true);
  }
  async _innerNewContext(options2 = {}, forReuse) {
    options2 = { ...this._browserType._playwright._defaultContextOptions, ...options2 };
    const contextOptions = await prepareBrowserContextParams(this._platform, options2);
    const response = forReuse ? await this._channel.newContextForReuse(contextOptions) : await this._channel.newContext(contextOptions);
    const context2 = BrowserContext2.from(response.context);
    await this._browserType._didCreateContext(context2, contextOptions, this._options, options2.logger || this._logger);
    return context2;
  }
  contexts() {
    return [...this._contexts];
  }
  version() {
    return this._initializer.version;
  }
  async newPage(options2 = {}) {
    return await this._wrapApiCall(async () => {
      const context2 = await this.newContext(options2);
      const page = await context2.newPage();
      page._ownedContext = context2;
      context2._ownerPage = page;
      return page;
    });
  }
  isConnected() {
    return this._isConnected;
  }
  async newBrowserCDPSession() {
    return CDPSession2.from((await this._channel.newBrowserCDPSession()).session);
  }
  async startTracing(page, options2 = {}) {
    this._path = options2.path;
    await this._channel.startTracing({ ...options2, page: page ? page._channel : void 0 });
  }
  async stopTracing() {
    const artifact = Artifact2.from((await this._channel.stopTracing()).artifact);
    const buffer2 = await artifact.readIntoBuffer();
    await artifact.delete();
    if (this._path) {
      await mkdirIfNeeded2(this._platform, this._path);
      await this._platform.fs().promises.writeFile(this._path, buffer2);
      this._path = void 0;
    }
    return buffer2;
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async close(options2 = {}) {
    this._closeReason = options2.reason;
    try {
      if (this._shouldCloseConnectionOnClose)
        this._connection.close();
      else
        await this._channel.close(options2);
      await this._closedPromise;
    } catch (e) {
      if (isTargetClosedError2(e))
        return;
      throw e;
    }
  }
  _didClose() {
    this._isConnected = false;
    this.emit(Events.Browser.Disconnected, this);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/clientHelper.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function envObjectToArray2(env3) {
  const result = [];
  for (const name in env3) {
    if (!Object.is(env3[name], void 0))
      result.push({ name, value: String(env3[name]) });
  }
  return result;
}
__name(envObjectToArray2, "envObjectToArray");
async function evaluationScript(platform4, fun, arg, addSourceUrl = true) {
  if (typeof fun === "function") {
    const source7 = `((__name => (${fun.toString()}))(t => t))`;
    const argString = Object.is(arg, void 0) ? "undefined" : JSON.stringify(arg);
    return `(${source7})(${argString})`;
  }
  if (arg !== void 0)
    throw new Error("Cannot evaluate a string with arguments");
  if (isString2(fun))
    return fun;
  if (fun.content !== void 0)
    return fun.content;
  if (fun.path !== void 0) {
    let source7 = await platform4.fs().promises.readFile(fun.path, "utf8");
    if (addSourceUrl)
      source7 = addSourceUrlToScript(source7, fun.path);
    return source7;
  }
  throw new Error("Either path or content property must be present");
}
__name(evaluationScript, "evaluationScript");
function addSourceUrlToScript(source7, path31) {
  return `${source7}
//# sourceURL=${path31.replace(/\n/g, "")}`;
}
__name(addSourceUrlToScript, "addSourceUrlToScript");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/clock.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Clock2 = class {
  static {
    __name(this, "Clock");
  }
  constructor(browserContext) {
    this._browserContext = browserContext;
  }
  async install(options2 = {}) {
    await this._browserContext._channel.clockInstall(options2.time !== void 0 ? parseTime2(options2.time) : {});
  }
  async fastForward(ticks) {
    await this._browserContext._channel.clockFastForward(parseTicks2(ticks));
  }
  async pauseAt(time3) {
    await this._browserContext._channel.clockPauseAt(parseTime2(time3));
  }
  async resume() {
    await this._browserContext._channel.clockResume({});
  }
  async runFor(ticks) {
    await this._browserContext._channel.clockRunFor(parseTicks2(ticks));
  }
  async setFixedTime(time3) {
    await this._browserContext._channel.clockSetFixedTime(parseTime2(time3));
  }
  async setSystemTime(time3) {
    await this._browserContext._channel.clockSetSystemTime(parseTime2(time3));
  }
};
function parseTime2(time3) {
  if (typeof time3 === "number")
    return { timeNumber: time3 };
  if (typeof time3 === "string")
    return { timeString: time3 };
  if (!isFinite(time3.getTime()))
    throw new Error(`Invalid date: ${time3}`);
  return { timeNumber: time3.getTime() };
}
__name(parseTime2, "parseTime");
function parseTicks2(ticks) {
  return {
    ticksNumber: typeof ticks === "number" ? ticks : void 0,
    ticksString: typeof ticks === "string" ? ticks : void 0
  };
}
__name(parseTicks2, "parseTicks");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/consoleMessage.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/jsHandle.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JSHandle2 = class _JSHandle extends ChannelOwner {
  static {
    __name(this, "JSHandle");
  }
  static from(handle) {
    return handle._object;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._preview = this._initializer.preview;
    this._channel.on("previewUpdated", ({ preview }) => this._preview = preview);
  }
  async evaluate(pageFunction, arg) {
    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async evaluateHandle(pageFunction, arg) {
    const result = await this._channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return _JSHandle.from(result.handle);
  }
  async getProperty(propertyName) {
    const result = await this._channel.getProperty({ name: propertyName });
    return _JSHandle.from(result.handle);
  }
  async getProperties() {
    const map2 = /* @__PURE__ */ new Map();
    for (const { name, value } of (await this._channel.getPropertyList()).properties)
      map2.set(name, _JSHandle.from(value));
    return map2;
  }
  async jsonValue() {
    return parseResult((await this._channel.jsonValue()).value);
  }
  asElement() {
    return null;
  }
  async [Symbol.asyncDispose]() {
    await this.dispose();
  }
  async dispose() {
    try {
      await this._channel.dispose();
    } catch (e) {
      if (isTargetClosedError2(e))
        return;
      throw e;
    }
  }
  toString() {
    return this._preview;
  }
};
function serializeArgument(arg) {
  const handles = [];
  const pushHandle = /* @__PURE__ */ __name((channel2) => {
    handles.push(channel2);
    return handles.length - 1;
  }, "pushHandle");
  const value = serializeValue(arg, (value2) => {
    if (value2 instanceof JSHandle2)
      return { h: pushHandle(value2._channel) };
    return { fallThrough: value2 };
  });
  return { value, handles };
}
__name(serializeArgument, "serializeArgument");
function parseResult(value) {
  return parseSerializedValue(value, void 0);
}
__name(parseResult, "parseResult");
function assertMaxArguments(count3, max) {
  if (count3 > max)
    throw new Error("Too many arguments. If you need to pass more than 1 argument to the function wrap them in an object.");
}
__name(assertMaxArguments, "assertMaxArguments");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/page.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/accessibility.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function axNodeFromProtocol(axNode) {
  const result = {
    ...axNode,
    value: axNode.valueNumber !== void 0 ? axNode.valueNumber : axNode.valueString,
    checked: axNode.checked === "checked" ? true : axNode.checked === "unchecked" ? false : axNode.checked,
    pressed: axNode.pressed === "pressed" ? true : axNode.pressed === "released" ? false : axNode.pressed,
    children: axNode.children ? axNode.children.map(axNodeFromProtocol) : void 0
  };
  delete result.valueNumber;
  delete result.valueString;
  return result;
}
__name(axNodeFromProtocol, "axNodeFromProtocol");
var Accessibility2 = class {
  static {
    __name(this, "Accessibility");
  }
  constructor(channel2) {
    this._channel = channel2;
  }
  async snapshot(options2 = {}) {
    const root = options2.root ? options2.root._elementChannel : void 0;
    const result = await this._channel.accessibilitySnapshot({ interestingOnly: options2.interestingOnly, root });
    return result.rootAXNode ? axNodeFromProtocol(result.rootAXNode) : null;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/coverage.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Coverage = class {
  static {
    __name(this, "Coverage");
  }
  constructor(channel2) {
    this._channel = channel2;
  }
  async startJSCoverage(options2 = {}) {
    await this._channel.startJSCoverage(options2);
  }
  async stopJSCoverage() {
    return (await this._channel.stopJSCoverage()).entries;
  }
  async startCSSCoverage(options2 = {}) {
    await this._channel.startCSSCoverage(options2);
  }
  async stopCSSCoverage() {
    return (await this._channel.stopCSSCoverage()).entries;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/download.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Download2 = class {
  static {
    __name(this, "Download");
  }
  constructor(page, url4, suggestedFilename, artifact) {
    this._page = page;
    this._url = url4;
    this._suggestedFilename = suggestedFilename;
    this._artifact = artifact;
  }
  page() {
    return this._page;
  }
  url() {
    return this._url;
  }
  suggestedFilename() {
    return this._suggestedFilename;
  }
  async path() {
    return await this._artifact.pathAfterFinished();
  }
  async saveAs(path31) {
    return await this._artifact.saveAs(path31);
  }
  async failure() {
    return await this._artifact.failure();
  }
  async createReadStream() {
    return await this._artifact.createReadStream();
  }
  async cancel() {
    return await this._artifact.cancel();
  }
  async delete() {
    return await this._artifact.delete();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/elementHandle.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/frame.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/locator.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/locatorUtils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getByAttributeTextSelector(attrName, text, options2) {
  return `internal:attr=[${attrName}=${escapeForAttributeSelector(text, options2?.exact || false)}]`;
}
__name(getByAttributeTextSelector, "getByAttributeTextSelector");
function getByTestIdSelector(testIdAttributeName2, testId) {
  return `internal:testid=[${testIdAttributeName2}=${escapeForAttributeSelector(testId, true)}]`;
}
__name(getByTestIdSelector, "getByTestIdSelector");
function getByLabelSelector(text, options2) {
  return "internal:label=" + escapeForTextSelector(text, !!options2?.exact);
}
__name(getByLabelSelector, "getByLabelSelector");
function getByAltTextSelector(text, options2) {
  return getByAttributeTextSelector("alt", text, options2);
}
__name(getByAltTextSelector, "getByAltTextSelector");
function getByTitleSelector(text, options2) {
  return getByAttributeTextSelector("title", text, options2);
}
__name(getByTitleSelector, "getByTitleSelector");
function getByPlaceholderSelector(text, options2) {
  return getByAttributeTextSelector("placeholder", text, options2);
}
__name(getByPlaceholderSelector, "getByPlaceholderSelector");
function getByTextSelector(text, options2) {
  return "internal:text=" + escapeForTextSelector(text, !!options2?.exact);
}
__name(getByTextSelector, "getByTextSelector");
function getByRoleSelector(role, options2 = {}) {
  const props = [];
  if (options2.checked !== void 0)
    props.push(["checked", String(options2.checked)]);
  if (options2.disabled !== void 0)
    props.push(["disabled", String(options2.disabled)]);
  if (options2.selected !== void 0)
    props.push(["selected", String(options2.selected)]);
  if (options2.expanded !== void 0)
    props.push(["expanded", String(options2.expanded)]);
  if (options2.includeHidden !== void 0)
    props.push(["include-hidden", String(options2.includeHidden)]);
  if (options2.level !== void 0)
    props.push(["level", String(options2.level)]);
  if (options2.name !== void 0)
    props.push(["name", escapeForAttributeSelector(options2.name, !!options2.exact)]);
  if (options2.pressed !== void 0)
    props.push(["pressed", String(options2.pressed)]);
  return `internal:role=${role}${props.map(([n, v]) => `[${n}=${v}]`).join("")}`;
}
__name(getByRoleSelector, "getByRoleSelector");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/locator.js
var Locator = class _Locator {
  static {
    __name(this, "Locator");
  }
  constructor(frame, selector, options2) {
    this._frame = frame;
    this._selector = selector;
    if (options2?.hasText)
      this._selector += ` >> internal:has-text=${escapeForTextSelector(options2.hasText, false)}`;
    if (options2?.hasNotText)
      this._selector += ` >> internal:has-not-text=${escapeForTextSelector(options2.hasNotText, false)}`;
    if (options2?.has) {
      const locator = options2.has;
      if (locator._frame !== frame)
        throw new Error(`Inner "has" locator must belong to the same frame.`);
      this._selector += ` >> internal:has=` + JSON.stringify(locator._selector);
    }
    if (options2?.hasNot) {
      const locator = options2.hasNot;
      if (locator._frame !== frame)
        throw new Error(`Inner "hasNot" locator must belong to the same frame.`);
      this._selector += ` >> internal:has-not=` + JSON.stringify(locator._selector);
    }
    if (options2?.visible !== void 0)
      this._selector += ` >> visible=${options2.visible ? "true" : "false"}`;
    if (this._frame._platform.inspectCustom)
      this[this._frame._platform.inspectCustom] = () => this._inspect();
  }
  async _withElement(task, timeout) {
    timeout = this._frame.page()._timeoutSettings.timeout({ timeout });
    const deadline = timeout ? monotonicTime() + timeout : 0;
    return await this._frame._wrapApiCall(async () => {
      const result = await this._frame._channel.waitForSelector({ selector: this._selector, strict: true, state: "attached", timeout });
      const handle = ElementHandle2.fromNullable(result.element);
      if (!handle)
        throw new Error(`Could not resolve ${this._selector} to DOM Element`);
      try {
        return await task(handle, deadline ? deadline - monotonicTime() : 0);
      } finally {
        await handle.dispose();
      }
    });
  }
  _equals(locator) {
    return this._frame === locator._frame && this._selector === locator._selector;
  }
  page() {
    return this._frame.page();
  }
  async boundingBox(options2) {
    return await this._withElement((h) => h.boundingBox(), options2?.timeout);
  }
  async check(options2 = {}) {
    return await this._frame.check(this._selector, { strict: true, ...options2 });
  }
  async click(options2 = {}) {
    return await this._frame.click(this._selector, { strict: true, ...options2 });
  }
  async dblclick(options2 = {}) {
    return await this._frame.dblclick(this._selector, { strict: true, ...options2 });
  }
  async dispatchEvent(type2, eventInit = {}, options2) {
    return await this._frame.dispatchEvent(this._selector, type2, eventInit, { strict: true, ...options2 });
  }
  async dragTo(target, options2 = {}) {
    return await this._frame.dragAndDrop(this._selector, target._selector, {
      strict: true,
      ...options2
    });
  }
  async evaluate(pageFunction, arg, options2) {
    return await this._withElement((h) => h.evaluate(pageFunction, arg), options2?.timeout);
  }
  async evaluateAll(pageFunction, arg) {
    return await this._frame.$$eval(this._selector, pageFunction, arg);
  }
  async evaluateHandle(pageFunction, arg, options2) {
    return await this._withElement((h) => h.evaluateHandle(pageFunction, arg), options2?.timeout);
  }
  async fill(value, options2 = {}) {
    return await this._frame.fill(this._selector, value, { strict: true, ...options2 });
  }
  async clear(options2 = {}) {
    return await this.fill("", options2);
  }
  async _highlight() {
    return await this._frame._highlight(this._selector);
  }
  async highlight() {
    return await this._frame._highlight(this._selector);
  }
  locator(selectorOrLocator, options2) {
    if (isString2(selectorOrLocator))
      return new _Locator(this._frame, this._selector + " >> " + selectorOrLocator, options2);
    if (selectorOrLocator._frame !== this._frame)
      throw new Error(`Locators must belong to the same frame.`);
    return new _Locator(this._frame, this._selector + " >> internal:chain=" + JSON.stringify(selectorOrLocator._selector), options2);
  }
  getByTestId(testId) {
    return this.locator(getByTestIdSelector(testIdAttributeName(), testId));
  }
  getByAltText(text, options2) {
    return this.locator(getByAltTextSelector(text, options2));
  }
  getByLabel(text, options2) {
    return this.locator(getByLabelSelector(text, options2));
  }
  getByPlaceholder(text, options2) {
    return this.locator(getByPlaceholderSelector(text, options2));
  }
  getByText(text, options2) {
    return this.locator(getByTextSelector(text, options2));
  }
  getByTitle(text, options2) {
    return this.locator(getByTitleSelector(text, options2));
  }
  getByRole(role, options2 = {}) {
    return this.locator(getByRoleSelector(role, options2));
  }
  frameLocator(selector) {
    return new FrameLocator(this._frame, this._selector + " >> " + selector);
  }
  filter(options2) {
    return new _Locator(this._frame, this._selector, options2);
  }
  async elementHandle(options2) {
    return await this._frame.waitForSelector(this._selector, { strict: true, state: "attached", ...options2 });
  }
  async elementHandles() {
    return await this._frame.$$(this._selector);
  }
  contentFrame() {
    return new FrameLocator(this._frame, this._selector);
  }
  first() {
    return new _Locator(this._frame, this._selector + " >> nth=0");
  }
  last() {
    return new _Locator(this._frame, this._selector + ` >> nth=-1`);
  }
  nth(index2) {
    return new _Locator(this._frame, this._selector + ` >> nth=${index2}`);
  }
  and(locator) {
    if (locator._frame !== this._frame)
      throw new Error(`Locators must belong to the same frame.`);
    return new _Locator(this._frame, this._selector + ` >> internal:and=` + JSON.stringify(locator._selector));
  }
  or(locator) {
    if (locator._frame !== this._frame)
      throw new Error(`Locators must belong to the same frame.`);
    return new _Locator(this._frame, this._selector + ` >> internal:or=` + JSON.stringify(locator._selector));
  }
  async focus(options2) {
    return await this._frame.focus(this._selector, { strict: true, ...options2 });
  }
  async blur(options2) {
    await this._frame._channel.blur({ selector: this._selector, strict: true, ...options2 });
  }
  async count() {
    return await this._frame._queryCount(this._selector);
  }
  async _generateLocatorString() {
    return await this._withElement((h) => h._generateLocatorString());
  }
  async getAttribute(name, options2) {
    return await this._frame.getAttribute(this._selector, name, { strict: true, ...options2 });
  }
  async hover(options2 = {}) {
    return await this._frame.hover(this._selector, { strict: true, ...options2 });
  }
  async innerHTML(options2) {
    return await this._frame.innerHTML(this._selector, { strict: true, ...options2 });
  }
  async innerText(options2) {
    return await this._frame.innerText(this._selector, { strict: true, ...options2 });
  }
  async inputValue(options2) {
    return await this._frame.inputValue(this._selector, { strict: true, ...options2 });
  }
  async isChecked(options2) {
    return await this._frame.isChecked(this._selector, { strict: true, ...options2 });
  }
  async isDisabled(options2) {
    return await this._frame.isDisabled(this._selector, { strict: true, ...options2 });
  }
  async isEditable(options2) {
    return await this._frame.isEditable(this._selector, { strict: true, ...options2 });
  }
  async isEnabled(options2) {
    return await this._frame.isEnabled(this._selector, { strict: true, ...options2 });
  }
  async isHidden(options2) {
    return await this._frame.isHidden(this._selector, { strict: true, ...options2 });
  }
  async isVisible(options2) {
    return await this._frame.isVisible(this._selector, { strict: true, ...options2 });
  }
  async press(key, options2 = {}) {
    return await this._frame.press(this._selector, key, { strict: true, ...options2 });
  }
  async screenshot(options2 = {}) {
    const mask = options2.mask;
    return await this._withElement((h, timeout) => h.screenshot({ ...options2, mask, timeout }), options2.timeout);
  }
  async ariaSnapshot(options2) {
    const result = await this._frame._channel.ariaSnapshot({ ...options2, mode: options2?._mode, selector: this._selector });
    return result.snapshot;
  }
  async scrollIntoViewIfNeeded(options2 = {}) {
    return await this._withElement((h, timeout) => h.scrollIntoViewIfNeeded({ ...options2, timeout }), options2.timeout);
  }
  async selectOption(values, options2 = {}) {
    return await this._frame.selectOption(this._selector, values, { strict: true, ...options2 });
  }
  async selectText(options2 = {}) {
    return await this._withElement((h, timeout) => h.selectText({ ...options2, timeout }), options2.timeout);
  }
  async setChecked(checked, options2) {
    if (checked)
      await this.check(options2);
    else
      await this.uncheck(options2);
  }
  async setInputFiles(files, options2 = {}) {
    return await this._frame.setInputFiles(this._selector, files, { strict: true, ...options2 });
  }
  async tap(options2 = {}) {
    return await this._frame.tap(this._selector, { strict: true, ...options2 });
  }
  async textContent(options2) {
    return await this._frame.textContent(this._selector, { strict: true, ...options2 });
  }
  async type(text, options2 = {}) {
    return await this._frame.type(this._selector, text, { strict: true, ...options2 });
  }
  async pressSequentially(text, options2 = {}) {
    return await this.type(text, options2);
  }
  async uncheck(options2 = {}) {
    return await this._frame.uncheck(this._selector, { strict: true, ...options2 });
  }
  async all() {
    return new Array(await this.count()).fill(0).map((e, i) => this.nth(i));
  }
  async allInnerTexts() {
    return await this._frame.$$eval(this._selector, (ee) => ee.map((e) => e.innerText));
  }
  async allTextContents() {
    return await this._frame.$$eval(this._selector, (ee) => ee.map((e) => e.textContent || ""));
  }
  async waitFor(options2) {
    await this._frame._channel.waitForSelector({ selector: this._selector, strict: true, omitReturnValue: true, ...options2 });
  }
  async _expect(expression, options2) {
    const params = { selector: this._selector, expression, ...options2, isNot: !!options2.isNot };
    params.expectedValue = serializeArgument(options2.expectedValue);
    const result = await this._frame._channel.expect(params);
    if (result.received !== void 0)
      result.received = parseResult(result.received);
    return result;
  }
  _inspect() {
    return this.toString();
  }
  toString() {
    return asLocator("javascript", this._selector);
  }
};
var FrameLocator = class _FrameLocator {
  static {
    __name(this, "FrameLocator");
  }
  constructor(frame, selector) {
    this._frame = frame;
    this._frameSelector = selector;
  }
  locator(selectorOrLocator, options2) {
    if (isString2(selectorOrLocator))
      return new Locator(this._frame, this._frameSelector + " >> internal:control=enter-frame >> " + selectorOrLocator, options2);
    if (selectorOrLocator._frame !== this._frame)
      throw new Error(`Locators must belong to the same frame.`);
    return new Locator(this._frame, this._frameSelector + " >> internal:control=enter-frame >> " + selectorOrLocator._selector, options2);
  }
  getByTestId(testId) {
    return this.locator(getByTestIdSelector(testIdAttributeName(), testId));
  }
  getByAltText(text, options2) {
    return this.locator(getByAltTextSelector(text, options2));
  }
  getByLabel(text, options2) {
    return this.locator(getByLabelSelector(text, options2));
  }
  getByPlaceholder(text, options2) {
    return this.locator(getByPlaceholderSelector(text, options2));
  }
  getByText(text, options2) {
    return this.locator(getByTextSelector(text, options2));
  }
  getByTitle(text, options2) {
    return this.locator(getByTitleSelector(text, options2));
  }
  getByRole(role, options2 = {}) {
    return this.locator(getByRoleSelector(role, options2));
  }
  owner() {
    return new Locator(this._frame, this._frameSelector);
  }
  frameLocator(selector) {
    return new _FrameLocator(this._frame, this._frameSelector + " >> internal:control=enter-frame >> " + selector);
  }
  first() {
    return new _FrameLocator(this._frame, this._frameSelector + " >> nth=0");
  }
  last() {
    return new _FrameLocator(this._frame, this._frameSelector + ` >> nth=-1`);
  }
  nth(index2) {
    return new _FrameLocator(this._frame, this._frameSelector + ` >> nth=${index2}`);
  }
};
var _testIdAttributeName = "data-testid";
function testIdAttributeName() {
  return _testIdAttributeName;
}
__name(testIdAttributeName, "testIdAttributeName");
function setTestIdAttribute(attributeName) {
  _testIdAttributeName = attributeName;
}
__name(setTestIdAttribute, "setTestIdAttribute");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/network.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/fetch.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/tracing.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Tracing2 = class extends ChannelOwner {
  static {
    __name(this, "Tracing");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._includeSources = false;
    this._isTracing = false;
    this.markAsInternalType();
  }
  static from(channel2) {
    return channel2._object;
  }
  async start(options2 = {}) {
    this._includeSources = !!options2.sources;
    await this._channel.tracingStart({
      name: options2.name,
      snapshots: options2.snapshots,
      screenshots: options2.screenshots,
      live: options2._live
    });
    const { traceName } = await this._channel.tracingStartChunk({ name: options2.name, title: options2.title });
    await this._startCollectingStacks(traceName);
  }
  async startChunk(options2 = {}) {
    const { traceName } = await this._channel.tracingStartChunk(options2);
    await this._startCollectingStacks(traceName);
  }
  async group(name, options2 = {}) {
    await this._wrapApiCall(async () => {
      await this._channel.tracingGroup({ name, location: options2.location });
    }, false);
  }
  async groupEnd() {
    await this._wrapApiCall(async () => {
      await this._channel.tracingGroupEnd();
    }, false);
  }
  async _startCollectingStacks(traceName) {
    if (!this._isTracing) {
      this._isTracing = true;
      this._connection.setIsTracing(true);
    }
    const result = await this._connection.localUtils()?.tracingStarted({ tracesDir: this._tracesDir, traceName });
    this._stacksId = result?.stacksId;
  }
  async stopChunk(options2 = {}) {
    await this._doStopChunk(options2.path);
  }
  async stop(options2 = {}) {
    await this._doStopChunk(options2.path);
    await this._channel.tracingStop();
  }
  async _doStopChunk(filePath) {
    this._resetStackCounter();
    if (!filePath) {
      await this._channel.tracingStopChunk({ mode: "discard" });
      if (this._stacksId)
        await this._connection.localUtils().traceDiscarded({ stacksId: this._stacksId });
      return;
    }
    const localUtils = this._connection.localUtils();
    if (!localUtils)
      throw new Error("Cannot save trace in thin clients");
    const isLocal = !this._connection.isRemote();
    if (isLocal) {
      const result2 = await this._channel.tracingStopChunk({ mode: "entries" });
      await localUtils.zip({ zipFile: filePath, entries: result2.entries, mode: "write", stacksId: this._stacksId, includeSources: this._includeSources });
      return;
    }
    const result = await this._channel.tracingStopChunk({ mode: "archive" });
    if (!result.artifact) {
      if (this._stacksId)
        await localUtils.traceDiscarded({ stacksId: this._stacksId });
      return;
    }
    const artifact = Artifact2.from(result.artifact);
    await artifact.saveAs(filePath);
    await artifact.delete();
    await localUtils.zip({ zipFile: filePath, entries: [], mode: "append", stacksId: this._stacksId, includeSources: this._includeSources });
  }
  _resetStackCounter() {
    if (this._isTracing) {
      this._isTracing = false;
      this._connection.setIsTracing(false);
    }
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/fetch.js
var APIRequest = class {
  static {
    __name(this, "APIRequest");
  }
  constructor(playwright2) {
    this._contexts = /* @__PURE__ */ new Set();
    this._playwright = playwright2;
  }
  async newContext(options2 = {}) {
    options2 = {
      ...this._playwright._defaultContextOptions,
      timeout: this._playwright._defaultContextTimeout,
      ...options2
    };
    const storageState = typeof options2.storageState === "string" ? JSON.parse(await this._playwright._platform.fs().promises.readFile(options2.storageState, "utf8")) : options2.storageState;
    const context2 = APIRequestContext2.from((await this._playwright._channel.newRequest({
      ...options2,
      extraHTTPHeaders: options2.extraHTTPHeaders ? headersObjectToArray(options2.extraHTTPHeaders) : void 0,
      storageState,
      tracesDir: this._playwright._defaultLaunchOptions?.tracesDir,
      // We do not expose tracesDir in the API, so do not allow options to accidentally override it.
      clientCertificates: await toClientCertificatesProtocol(this._playwright._platform, options2.clientCertificates)
    })).request);
    this._contexts.add(context2);
    context2._request = this;
    context2._tracing._tracesDir = this._playwright._defaultLaunchOptions?.tracesDir;
    await context2._instrumentation.runAfterCreateRequestContext(context2);
    return context2;
  }
};
var APIRequestContext2 = class extends ChannelOwner {
  static {
    __name(this, "APIRequestContext");
  }
  static from(channel2) {
    return channel2._object;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._tracing = Tracing2.from(initializer.tracing);
  }
  async [Symbol.asyncDispose]() {
    await this.dispose();
  }
  async dispose(options2 = {}) {
    this._closeReason = options2.reason;
    await this._instrumentation.runBeforeCloseRequestContext(this);
    try {
      await this._channel.dispose(options2);
    } catch (e) {
      if (isTargetClosedError2(e))
        return;
      throw e;
    }
    this._tracing._resetStackCounter();
    this._request?._contexts.delete(this);
  }
  async delete(url4, options2) {
    return await this.fetch(url4, {
      ...options2,
      method: "DELETE"
    });
  }
  async head(url4, options2) {
    return await this.fetch(url4, {
      ...options2,
      method: "HEAD"
    });
  }
  async get(url4, options2) {
    return await this.fetch(url4, {
      ...options2,
      method: "GET"
    });
  }
  async patch(url4, options2) {
    return await this.fetch(url4, {
      ...options2,
      method: "PATCH"
    });
  }
  async post(url4, options2) {
    return await this.fetch(url4, {
      ...options2,
      method: "POST"
    });
  }
  async put(url4, options2) {
    return await this.fetch(url4, {
      ...options2,
      method: "PUT"
    });
  }
  async fetch(urlOrRequest, options2 = {}) {
    const url4 = isString2(urlOrRequest) ? urlOrRequest : void 0;
    const request4 = isString2(urlOrRequest) ? void 0 : urlOrRequest;
    return await this._innerFetch({ url: url4, request: request4, ...options2 });
  }
  async _innerFetch(options2 = {}) {
    return await this._wrapApiCall(async () => {
      if (this._closeReason)
        throw new TargetClosedError2(this._closeReason);
      assert3(options2.request || typeof options2.url === "string", "First argument must be either URL string or Request");
      assert3((options2.data === void 0 ? 0 : 1) + (options2.form === void 0 ? 0 : 1) + (options2.multipart === void 0 ? 0 : 1) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
      assert3(options2.maxRedirects === void 0 || options2.maxRedirects >= 0, `'maxRedirects' must be greater than or equal to '0'`);
      assert3(options2.maxRetries === void 0 || options2.maxRetries >= 0, `'maxRetries' must be greater than or equal to '0'`);
      const url4 = options2.url !== void 0 ? options2.url : options2.request.url();
      const method = options2.method || options2.request?.method();
      let encodedParams = void 0;
      if (typeof options2.params === "string")
        encodedParams = options2.params;
      else if (options2.params instanceof URLSearchParams)
        encodedParams = options2.params.toString();
      const headersObj = options2.headers || options2.request?.headers();
      const headers = headersObj ? headersObjectToArray(headersObj) : void 0;
      let jsonData;
      let formData;
      let multipartData;
      let postDataBuffer;
      if (options2.data !== void 0) {
        if (isString2(options2.data)) {
          if (isJsonContentType(headers))
            jsonData = isJsonParsable(options2.data) ? options2.data : JSON.stringify(options2.data);
          else
            postDataBuffer = Buffer.from(options2.data, "utf8");
        } else if (Buffer.isBuffer(options2.data)) {
          postDataBuffer = options2.data;
        } else if (typeof options2.data === "object" || typeof options2.data === "number" || typeof options2.data === "boolean") {
          jsonData = JSON.stringify(options2.data);
        } else {
          throw new Error(`Unexpected 'data' type`);
        }
      } else if (options2.form) {
        if (globalThis.FormData && options2.form instanceof FormData) {
          formData = [];
          for (const [name, value] of options2.form.entries()) {
            if (typeof value !== "string")
              throw new Error(`Expected string for options.form["${name}"], found File. Please use options.multipart instead.`);
            formData.push({ name, value });
          }
        } else {
          formData = objectToArray(options2.form);
        }
      } else if (options2.multipart) {
        multipartData = [];
        if (globalThis.FormData && options2.multipart instanceof FormData) {
          const form = options2.multipart;
          for (const [name, value] of form.entries()) {
            if (isString2(value)) {
              multipartData.push({ name, value });
            } else {
              const file = {
                name: value.name,
                mimeType: value.type,
                buffer: Buffer.from(await value.arrayBuffer())
              };
              multipartData.push({ name, file });
            }
          }
        } else {
          for (const [name, value] of Object.entries(options2.multipart))
            multipartData.push(await toFormField(this._platform, name, value));
        }
      }
      if (postDataBuffer === void 0 && jsonData === void 0 && formData === void 0 && multipartData === void 0)
        postDataBuffer = options2.request?.postDataBuffer() || void 0;
      const fixtures = {
        __testHookLookup: options2.__testHookLookup
      };
      const result = await this._channel.fetch({
        url: url4,
        params: typeof options2.params === "object" ? objectToArray(options2.params) : void 0,
        encodedParams,
        method,
        headers,
        postData: postDataBuffer,
        jsonData,
        formData,
        multipartData,
        timeout: options2.timeout,
        failOnStatusCode: options2.failOnStatusCode,
        ignoreHTTPSErrors: options2.ignoreHTTPSErrors,
        maxRedirects: options2.maxRedirects,
        maxRetries: options2.maxRetries,
        ...fixtures
      });
      return new APIResponse(this, result.response);
    });
  }
  async storageState(options2 = {}) {
    const state = await this._channel.storageState({ indexedDB: options2.indexedDB });
    if (options2.path) {
      await mkdirIfNeeded2(this._platform, options2.path);
      await this._platform.fs().promises.writeFile(options2.path, JSON.stringify(state, void 0, 2), "utf8");
    }
    return state;
  }
};
async function toFormField(platform4, name, value) {
  const typeOfValue = typeof value;
  if (isFilePayload(value)) {
    const payload = value;
    if (!Buffer.isBuffer(payload.buffer))
      throw new Error(`Unexpected buffer type of 'data.${name}'`);
    return { name, file: filePayloadToJson(payload) };
  } else if (typeOfValue === "string" || typeOfValue === "number" || typeOfValue === "boolean") {
    return { name, value: String(value) };
  } else {
    return { name, file: await readStreamToJson(platform4, value) };
  }
}
__name(toFormField, "toFormField");
function isJsonParsable(value) {
  if (typeof value !== "string")
    return false;
  try {
    JSON.parse(value);
    return true;
  } catch (e) {
    if (e instanceof SyntaxError)
      return false;
    else
      throw e;
  }
}
__name(isJsonParsable, "isJsonParsable");
var APIResponse = class {
  static {
    __name(this, "APIResponse");
  }
  constructor(context2, initializer) {
    this._request = context2;
    this._initializer = initializer;
    this._headers = new RawHeaders(this._initializer.headers);
    if (context2._platform.inspectCustom)
      this[context2._platform.inspectCustom] = () => this._inspect();
  }
  ok() {
    return this._initializer.status >= 200 && this._initializer.status <= 299;
  }
  url() {
    return this._initializer.url;
  }
  status() {
    return this._initializer.status;
  }
  statusText() {
    return this._initializer.statusText;
  }
  headers() {
    return this._headers.headers();
  }
  headersArray() {
    return this._headers.headersArray();
  }
  async body() {
    return await this._request._wrapApiCall(async () => {
      try {
        const result = await this._request._channel.fetchResponseBody({ fetchUid: this._fetchUid() });
        if (result.binary === void 0)
          throw new Error("Response has been disposed");
        return result.binary;
      } catch (e) {
        if (isTargetClosedError2(e))
          throw new Error("Response has been disposed");
        throw e;
      }
    }, true);
  }
  async text() {
    const content = await this.body();
    return content.toString("utf8");
  }
  async json() {
    const content = await this.text();
    return JSON.parse(content);
  }
  async [Symbol.asyncDispose]() {
    await this.dispose();
  }
  async dispose() {
    await this._request._channel.disposeAPIResponse({ fetchUid: this._fetchUid() });
  }
  _inspect() {
    const headers = this.headersArray().map(({ name, value }) => `  ${name}: ${value}`);
    return `APIResponse: ${this.status()} ${this.statusText()}
${headers.join("\n")}`;
  }
  _fetchUid() {
    return this._initializer.fetchUid;
  }
  async _fetchLog() {
    const { log: log4 } = await this._request._channel.fetchLog({ fetchUid: this._fetchUid() });
    return log4;
  }
};
function filePayloadToJson(payload) {
  return {
    name: payload.name,
    mimeType: payload.mimeType,
    buffer: payload.buffer
  };
}
__name(filePayloadToJson, "filePayloadToJson");
async function readStreamToJson(platform4, stream) {
  const buffer2 = await new Promise((resolve, reject) => {
    const chunks = [];
    stream.on("data", (chunk) => chunks.push(chunk));
    stream.on("end", () => resolve(Buffer.concat(chunks)));
    stream.on("error", (err) => reject(err));
  });
  const streamPath = Buffer.isBuffer(stream.path) ? stream.path.toString("utf8") : stream.path;
  return {
    name: platform4.path().basename(streamPath),
    buffer: buffer2
  };
}
__name(readStreamToJson, "readStreamToJson");
function isJsonContentType(headers) {
  if (!headers)
    return false;
  for (const { name, value } of headers) {
    if (name.toLocaleLowerCase() === "content-type")
      return value === "application/json";
  }
  return false;
}
__name(isJsonContentType, "isJsonContentType");
function objectToArray(map2) {
  if (!map2)
    return void 0;
  const result = [];
  for (const [name, value] of Object.entries(map2)) {
    if (value !== void 0)
      result.push({ name, value: String(value) });
  }
  return result;
}
__name(objectToArray, "objectToArray");
function isFilePayload(value) {
  return typeof value === "object" && value["name"] && value["mimeType"] && value["buffer"];
}
__name(isFilePayload, "isFilePayload");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/waiter.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Waiter = class _Waiter {
  static {
    __name(this, "Waiter");
  }
  constructor(channelOwner, event) {
    this._failures = [];
    this._logs = [];
    this._waitId = channelOwner._platform.createGuid();
    this._channelOwner = channelOwner;
    this._savedZone = channelOwner._platform.zones.current().pop();
    this._channelOwner._channel.waitForEventInfo({ info: { waitId: this._waitId, phase: "before", event } }).catch(() => {
    });
    this._dispose = [
      () => this._channelOwner._wrapApiCall(async () => {
        await this._channelOwner._channel.waitForEventInfo({ info: { waitId: this._waitId, phase: "after", error: this._error } });
      }, true).catch(() => {
      })
    ];
  }
  static createForEvent(channelOwner, event) {
    return new _Waiter(channelOwner, event);
  }
  async waitForEvent(emitter, event, predicate) {
    const { promise, dispose } = waitForEvent(emitter, event, this._savedZone, predicate);
    return await this.waitForPromise(promise, dispose);
  }
  rejectOnEvent(emitter, event, error4, predicate) {
    const { promise, dispose } = waitForEvent(emitter, event, this._savedZone, predicate);
    this._rejectOn(promise.then(() => {
      throw typeof error4 === "function" ? error4() : error4;
    }), dispose);
  }
  rejectOnTimeout(timeout, message) {
    if (!timeout)
      return;
    const { promise, dispose } = waitForTimeout(timeout);
    this._rejectOn(promise.then(() => {
      throw new TimeoutError2(message);
    }), dispose);
  }
  rejectImmediately(error4) {
    this._immediateError = error4;
  }
  dispose() {
    for (const dispose of this._dispose)
      dispose();
  }
  async waitForPromise(promise, dispose) {
    try {
      if (this._immediateError)
        throw this._immediateError;
      const result = await Promise.race([promise, ...this._failures]);
      if (dispose)
        dispose();
      return result;
    } catch (e) {
      if (dispose)
        dispose();
      this._error = e.message;
      this.dispose();
      rewriteErrorMessage(e, e.message + formatLogRecording(this._logs));
      throw e;
    }
  }
  log(s) {
    this._logs.push(s);
    this._channelOwner._wrapApiCall(async () => {
      await this._channelOwner._channel.waitForEventInfo({ info: { waitId: this._waitId, phase: "log", message: s } });
    }, true).catch(() => {
    });
  }
  _rejectOn(promise, dispose) {
    this._failures.push(promise);
    if (dispose)
      this._dispose.push(dispose);
  }
};
function waitForEvent(emitter, event, savedZone, predicate) {
  let listener;
  const promise = new Promise((resolve, reject) => {
    listener = /* @__PURE__ */ __name(async (eventArg) => {
      await savedZone.run(async () => {
        try {
          if (predicate && !await predicate(eventArg))
            return;
          emitter.removeListener(event, listener);
          resolve(eventArg);
        } catch (e) {
          emitter.removeListener(event, listener);
          reject(e);
        }
      });
    }, "listener");
    emitter.addListener(event, listener);
  });
  const dispose = /* @__PURE__ */ __name(() => emitter.removeListener(event, listener), "dispose");
  return { promise, dispose };
}
__name(waitForEvent, "waitForEvent");
function waitForTimeout(timeout) {
  let timeoutId;
  const promise = new Promise((resolve) => timeoutId = setTimeout(resolve, timeout));
  const dispose = /* @__PURE__ */ __name(() => clearTimeout(timeoutId), "dispose");
  return { promise, dispose };
}
__name(waitForTimeout, "waitForTimeout");
function formatLogRecording(log4) {
  if (!log4.length)
    return "";
  const header = ` logs `;
  const headerLength = 60;
  const leftLength = (headerLength - header.length) / 2;
  const rightLength = headerLength - header.length - leftLength;
  return `
${"=".repeat(leftLength)}${header}${"=".repeat(rightLength)}
${log4.join("\n")}
${"=".repeat(headerLength)}`;
}
__name(formatLogRecording, "formatLogRecording");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/worker.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Worker2 = class extends ChannelOwner {
  static {
    __name(this, "Worker");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._closedScope = new LongStandingScope();
    this._channel.on("close", () => {
      if (this._page)
        this._page._workers.delete(this);
      if (this._context)
        this._context._serviceWorkers.delete(this);
      this.emit(Events.Worker.Close, this);
    });
    this.once(Events.Worker.Close, () => this._closedScope.close(this._page?._closeErrorWithReason() || new TargetClosedError2()));
  }
  static from(worker) {
    return worker._object;
  }
  url() {
    return this._initializer.url;
  }
  async evaluate(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async evaluateHandle(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    const result = await this._channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return JSHandle2.from(result.handle);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/network.js
var Request2 = class _Request extends ChannelOwner {
  static {
    __name(this, "Request");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._redirectedFrom = null;
    this._redirectedTo = null;
    this._failureText = null;
    this._fallbackOverrides = {};
    this.markAsInternalType();
    this._redirectedFrom = _Request.fromNullable(initializer.redirectedFrom);
    if (this._redirectedFrom)
      this._redirectedFrom._redirectedTo = this;
    this._provisionalHeaders = new RawHeaders(initializer.headers);
    this._timing = {
      startTime: 0,
      domainLookupStart: -1,
      domainLookupEnd: -1,
      connectStart: -1,
      secureConnectionStart: -1,
      connectEnd: -1,
      requestStart: -1,
      responseStart: -1,
      responseEnd: -1
    };
  }
  static from(request4) {
    return request4._object;
  }
  static fromNullable(request4) {
    return request4 ? _Request.from(request4) : null;
  }
  url() {
    return this._fallbackOverrides.url || this._initializer.url;
  }
  resourceType() {
    return this._initializer.resourceType;
  }
  method() {
    return this._fallbackOverrides.method || this._initializer.method;
  }
  postData() {
    return (this._fallbackOverrides.postDataBuffer || this._initializer.postData)?.toString("utf-8") || null;
  }
  postDataBuffer() {
    return this._fallbackOverrides.postDataBuffer || this._initializer.postData || null;
  }
  postDataJSON() {
    const postData = this.postData();
    if (!postData)
      return null;
    const contentType = this.headers()["content-type"];
    if (contentType?.includes("application/x-www-form-urlencoded")) {
      const entries = {};
      const parsed = new URLSearchParams(postData);
      for (const [k, v] of parsed.entries())
        entries[k] = v;
      return entries;
    }
    try {
      return JSON.parse(postData);
    } catch (e) {
      throw new Error("POST data is not a valid JSON object: " + postData);
    }
  }
  /**
   * @deprecated
   */
  headers() {
    if (this._fallbackOverrides.headers)
      return RawHeaders._fromHeadersObjectLossy(this._fallbackOverrides.headers).headers();
    return this._provisionalHeaders.headers();
  }
  async _actualHeaders() {
    if (this._fallbackOverrides.headers)
      return RawHeaders._fromHeadersObjectLossy(this._fallbackOverrides.headers);
    if (!this._actualHeadersPromise) {
      this._actualHeadersPromise = this._wrapApiCall(async () => {
        return new RawHeaders((await this._channel.rawRequestHeaders()).headers);
      });
    }
    return await this._actualHeadersPromise;
  }
  async allHeaders() {
    return (await this._actualHeaders()).headers();
  }
  async headersArray() {
    return (await this._actualHeaders()).headersArray();
  }
  async headerValue(name) {
    return (await this._actualHeaders()).get(name);
  }
  async response() {
    return Response3.fromNullable((await this._channel.response()).response);
  }
  async _internalResponse() {
    return await this._wrapApiCall(async () => {
      return Response3.fromNullable((await this._channel.response()).response);
    }, true);
  }
  frame() {
    if (!this._initializer.frame) {
      assert3(this.serviceWorker());
      throw new Error("Service Worker requests do not have an associated frame.");
    }
    const frame = Frame2.from(this._initializer.frame);
    if (!frame._page) {
      throw new Error([
        "Frame for this navigation request is not available, because the request",
        "was issued before the frame is created. You can check whether the request",
        "is a navigation request by calling isNavigationRequest() method."
      ].join("\n"));
    }
    return frame;
  }
  _safePage() {
    return Frame2.fromNullable(this._initializer.frame)?._page || null;
  }
  serviceWorker() {
    return this._initializer.serviceWorker ? Worker2.from(this._initializer.serviceWorker) : null;
  }
  isNavigationRequest() {
    return this._initializer.isNavigationRequest;
  }
  redirectedFrom() {
    return this._redirectedFrom;
  }
  redirectedTo() {
    return this._redirectedTo;
  }
  failure() {
    if (this._failureText === null)
      return null;
    return {
      errorText: this._failureText
    };
  }
  timing() {
    return this._timing;
  }
  async sizes() {
    const response = await this.response();
    if (!response)
      throw new Error("Unable to fetch sizes for failed request");
    return (await response._channel.sizes()).sizes;
  }
  _setResponseEndTiming(responseEndTiming) {
    this._timing.responseEnd = responseEndTiming;
    if (this._timing.responseStart === -1)
      this._timing.responseStart = responseEndTiming;
  }
  _finalRequest() {
    return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
  }
  _applyFallbackOverrides(overrides) {
    if (overrides.url)
      this._fallbackOverrides.url = overrides.url;
    if (overrides.method)
      this._fallbackOverrides.method = overrides.method;
    if (overrides.headers)
      this._fallbackOverrides.headers = overrides.headers;
    if (isString2(overrides.postData))
      this._fallbackOverrides.postDataBuffer = Buffer.from(overrides.postData, "utf-8");
    else if (overrides.postData instanceof Buffer)
      this._fallbackOverrides.postDataBuffer = overrides.postData;
    else if (overrides.postData)
      this._fallbackOverrides.postDataBuffer = Buffer.from(JSON.stringify(overrides.postData), "utf-8");
  }
  _fallbackOverridesForContinue() {
    return this._fallbackOverrides;
  }
  _targetClosedScope() {
    return this.serviceWorker()?._closedScope || this._safePage()?._closedOrCrashedScope || new LongStandingScope();
  }
};
var Route2 = class extends ChannelOwner {
  static {
    __name(this, "Route");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._handlingPromise = null;
    this._didThrow = false;
    this.markAsInternalType();
  }
  static from(route) {
    return route._object;
  }
  request() {
    return Request2.from(this._initializer.request);
  }
  async _raceWithTargetClose(promise) {
    return await this.request()._targetClosedScope().safeRace(promise);
  }
  async _startHandling() {
    this._handlingPromise = new ManualPromise();
    return await this._handlingPromise;
  }
  async fallback(options2 = {}) {
    this._checkNotHandled();
    this.request()._applyFallbackOverrides(options2);
    this._reportHandled(false);
  }
  async abort(errorCode) {
    await this._handleRoute(async () => {
      await this._raceWithTargetClose(this._channel.abort({ errorCode }));
    });
  }
  async _redirectNavigationRequest(url4) {
    await this._handleRoute(async () => {
      await this._raceWithTargetClose(this._channel.redirectNavigationRequest({ url: url4 }));
    });
  }
  async fetch(options2 = {}) {
    return await this._wrapApiCall(async () => {
      return await this._context.request._innerFetch({ request: this.request(), data: options2.postData, ...options2 });
    });
  }
  async fulfill(options2 = {}) {
    await this._handleRoute(async () => {
      await this._wrapApiCall(async () => {
        await this._innerFulfill(options2);
      });
    });
  }
  async _handleRoute(callback) {
    this._checkNotHandled();
    try {
      await callback();
      this._reportHandled(true);
    } catch (e) {
      this._didThrow = true;
      throw e;
    }
  }
  async _innerFulfill(options2 = {}) {
    let fetchResponseUid;
    let { status: statusOption, headers: headersOption, body } = options2;
    if (options2.json !== void 0) {
      assert3(options2.body === void 0, "Can specify either body or json parameters");
      body = JSON.stringify(options2.json);
    }
    if (options2.response instanceof APIResponse) {
      statusOption ??= options2.response.status();
      headersOption ??= options2.response.headers();
      if (body === void 0 && options2.path === void 0) {
        if (options2.response._request._connection === this._connection)
          fetchResponseUid = options2.response._fetchUid();
        else
          body = await options2.response.body();
      }
    }
    let isBase64 = false;
    let length = 0;
    if (options2.path) {
      const buffer2 = await this._platform.fs().promises.readFile(options2.path);
      body = buffer2.toString("base64");
      isBase64 = true;
      length = buffer2.length;
    } else if (isString2(body)) {
      isBase64 = false;
      length = Buffer.byteLength(body);
    } else if (body) {
      length = body.length;
      body = body.toString("base64");
      isBase64 = true;
    }
    const headers = {};
    for (const header of Object.keys(headersOption || {}))
      headers[header.toLowerCase()] = String(headersOption[header]);
    if (options2.contentType)
      headers["content-type"] = String(options2.contentType);
    else if (options2.json)
      headers["content-type"] = "application/json";
    else if (options2.path)
      headers["content-type"] = getMimeTypeForPath(options2.path) || "application/octet-stream";
    if (length && !("content-length" in headers))
      headers["content-length"] = String(length);
    await this._raceWithTargetClose(this._channel.fulfill({
      status: statusOption || 200,
      headers: headersObjectToArray(headers),
      body,
      isBase64,
      fetchResponseUid
    }));
  }
  async continue(options2 = {}) {
    await this._handleRoute(async () => {
      this.request()._applyFallbackOverrides(options2);
      await this._innerContinue(
        false
        /* isFallback */
      );
    });
  }
  _checkNotHandled() {
    if (!this._handlingPromise)
      throw new Error("Route is already handled!");
  }
  _reportHandled(done) {
    const chain = this._handlingPromise;
    this._handlingPromise = null;
    chain.resolve(done);
  }
  async _innerContinue(isFallback) {
    const options2 = this.request()._fallbackOverridesForContinue();
    return await this._raceWithTargetClose(this._channel.continue({
      url: options2.url,
      method: options2.method,
      headers: options2.headers ? headersObjectToArray(options2.headers) : void 0,
      postData: options2.postDataBuffer,
      isFallback
    }));
  }
};
var WebSocketRoute = class extends ChannelOwner {
  static {
    __name(this, "WebSocketRoute");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._connected = false;
    this.markAsInternalType();
    this._server = {
      onMessage: /* @__PURE__ */ __name((handler) => {
        this._onServerMessage = handler;
      }, "onMessage"),
      onClose: /* @__PURE__ */ __name((handler) => {
        this._onServerClose = handler;
      }, "onClose"),
      connectToServer: /* @__PURE__ */ __name(() => {
        throw new Error(`connectToServer must be called on the page-side WebSocketRoute`);
      }, "connectToServer"),
      url: /* @__PURE__ */ __name(() => {
        return this._initializer.url;
      }, "url"),
      close: /* @__PURE__ */ __name(async (options2 = {}) => {
        await this._channel.closeServer({ ...options2, wasClean: true }).catch(() => {
        });
      }, "close"),
      send: /* @__PURE__ */ __name((message) => {
        if (isString2(message))
          this._channel.sendToServer({ message, isBase64: false }).catch(() => {
          });
        else
          this._channel.sendToServer({ message: message.toString("base64"), isBase64: true }).catch(() => {
          });
      }, "send"),
      async [Symbol.asyncDispose]() {
        await this.close();
      }
    };
    this._channel.on("messageFromPage", ({ message, isBase64 }) => {
      if (this._onPageMessage)
        this._onPageMessage(isBase64 ? Buffer.from(message, "base64") : message);
      else if (this._connected)
        this._channel.sendToServer({ message, isBase64 }).catch(() => {
        });
    });
    this._channel.on("messageFromServer", ({ message, isBase64 }) => {
      if (this._onServerMessage)
        this._onServerMessage(isBase64 ? Buffer.from(message, "base64") : message);
      else
        this._channel.sendToPage({ message, isBase64 }).catch(() => {
        });
    });
    this._channel.on("closePage", ({ code, reason, wasClean }) => {
      if (this._onPageClose)
        this._onPageClose(code, reason);
      else
        this._channel.closeServer({ code, reason, wasClean }).catch(() => {
        });
    });
    this._channel.on("closeServer", ({ code, reason, wasClean }) => {
      if (this._onServerClose)
        this._onServerClose(code, reason);
      else
        this._channel.closePage({ code, reason, wasClean }).catch(() => {
        });
    });
  }
  static from(route) {
    return route._object;
  }
  url() {
    return this._initializer.url;
  }
  async close(options2 = {}) {
    await this._channel.closePage({ ...options2, wasClean: true }).catch(() => {
    });
  }
  connectToServer() {
    if (this._connected)
      throw new Error("Already connected to the server");
    this._connected = true;
    this._channel.connect().catch(() => {
    });
    return this._server;
  }
  send(message) {
    if (isString2(message))
      this._channel.sendToPage({ message, isBase64: false }).catch(() => {
      });
    else
      this._channel.sendToPage({ message: message.toString("base64"), isBase64: true }).catch(() => {
      });
  }
  onMessage(handler) {
    this._onPageMessage = handler;
  }
  onClose(handler) {
    this._onPageClose = handler;
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async _afterHandle() {
    if (this._connected)
      return;
    await this._channel.ensureOpened();
  }
};
var WebSocketRouteHandler = class {
  static {
    __name(this, "WebSocketRouteHandler");
  }
  constructor(baseURL, url4, handler) {
    this._baseURL = baseURL;
    this.url = url4;
    this.handler = handler;
  }
  static prepareInterceptionPatterns(handlers) {
    const patterns = [];
    let all = false;
    for (const handler of handlers) {
      if (isString2(handler.url))
        patterns.push({ glob: handler.url });
      else if (isRegExp4(handler.url))
        patterns.push({ regexSource: handler.url.source, regexFlags: handler.url.flags });
      else
        all = true;
    }
    if (all)
      return [{ glob: "**/*" }];
    return patterns;
  }
  matches(wsURL) {
    return urlMatches(this._baseURL, wsURL, this.url, true);
  }
  async handle(webSocketRoute) {
    const handler = this.handler;
    await handler(webSocketRoute);
    await webSocketRoute._afterHandle();
  }
};
var Response3 = class _Response extends ChannelOwner {
  static {
    __name(this, "Response");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._finishedPromise = new ManualPromise();
    this.markAsInternalType();
    this._provisionalHeaders = new RawHeaders(initializer.headers);
    this._request = Request2.from(this._initializer.request);
    Object.assign(this._request._timing, this._initializer.timing);
  }
  static from(response) {
    return response._object;
  }
  static fromNullable(response) {
    return response ? _Response.from(response) : null;
  }
  url() {
    return this._initializer.url;
  }
  ok() {
    return this._initializer.status === 0 || this._initializer.status >= 200 && this._initializer.status <= 299;
  }
  status() {
    return this._initializer.status;
  }
  statusText() {
    return this._initializer.statusText;
  }
  fromServiceWorker() {
    return this._initializer.fromServiceWorker;
  }
  /**
   * @deprecated
   */
  headers() {
    return this._provisionalHeaders.headers();
  }
  async _actualHeaders() {
    if (!this._actualHeadersPromise) {
      this._actualHeadersPromise = (async () => {
        return new RawHeaders((await this._channel.rawResponseHeaders()).headers);
      })();
    }
    return await this._actualHeadersPromise;
  }
  async allHeaders() {
    return (await this._actualHeaders()).headers();
  }
  async headersArray() {
    return (await this._actualHeaders()).headersArray().slice();
  }
  async headerValue(name) {
    return (await this._actualHeaders()).get(name);
  }
  async headerValues(name) {
    return (await this._actualHeaders()).getAll(name);
  }
  async finished() {
    return await this.request()._targetClosedScope().race(this._finishedPromise);
  }
  async body() {
    return (await this._channel.body()).binary;
  }
  async text() {
    const content = await this.body();
    return content.toString("utf8");
  }
  async json() {
    const content = await this.text();
    return JSON.parse(content);
  }
  request() {
    return this._request;
  }
  frame() {
    return this._request.frame();
  }
  async serverAddr() {
    return (await this._channel.serverAddr()).value || null;
  }
  async securityDetails() {
    return (await this._channel.securityDetails()).value || null;
  }
};
var WebSocket4 = class extends ChannelOwner {
  static {
    __name(this, "WebSocket");
  }
  static from(webSocket) {
    return webSocket._object;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._isClosed = false;
    this._page = parent;
    this._channel.on("frameSent", (event) => {
      if (event.opcode === 1)
        this.emit(Events.WebSocket.FrameSent, { payload: event.data });
      else if (event.opcode === 2)
        this.emit(Events.WebSocket.FrameSent, { payload: Buffer.from(event.data, "base64") });
    });
    this._channel.on("frameReceived", (event) => {
      if (event.opcode === 1)
        this.emit(Events.WebSocket.FrameReceived, { payload: event.data });
      else if (event.opcode === 2)
        this.emit(Events.WebSocket.FrameReceived, { payload: Buffer.from(event.data, "base64") });
    });
    this._channel.on("socketError", ({ error: error4 }) => this.emit(Events.WebSocket.Error, error4));
    this._channel.on("close", () => {
      this._isClosed = true;
      this.emit(Events.WebSocket.Close, this);
    });
  }
  url() {
    return this._initializer.url;
  }
  isClosed() {
    return this._isClosed;
  }
  async waitForEvent(event, optionsOrPredicate = {}) {
    return await this._wrapApiCall(async () => {
      const timeout = this._page._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
      const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
      const waiter = Waiter.createForEvent(this, event);
      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== Events.WebSocket.Error)
        waiter.rejectOnEvent(this, Events.WebSocket.Error, new Error("Socket error"));
      if (event !== Events.WebSocket.Close)
        waiter.rejectOnEvent(this, Events.WebSocket.Close, new Error("Socket closed"));
      waiter.rejectOnEvent(this._page, Events.Page.Close, () => this._page._closeErrorWithReason());
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }
};
function validateHeaders(headers) {
  for (const key of Object.keys(headers)) {
    const value = headers[key];
    if (!Object.is(value, void 0) && !isString2(value))
      throw new Error(`Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
  }
}
__name(validateHeaders, "validateHeaders");
var RouteHandler = class {
  static {
    __name(this, "RouteHandler");
  }
  constructor(platform4, baseURL, url4, handler, times = Number.MAX_SAFE_INTEGER) {
    this.handledCount = 0;
    this._ignoreException = false;
    this._activeInvocations = /* @__PURE__ */ new Set();
    this._baseURL = baseURL;
    this._times = times;
    this.url = url4;
    this.handler = handler;
    this._savedZone = platform4.zones.current().pop();
  }
  static prepareInterceptionPatterns(handlers) {
    const patterns = [];
    let all = false;
    for (const handler of handlers) {
      if (isString2(handler.url))
        patterns.push({ glob: handler.url });
      else if (isRegExp4(handler.url))
        patterns.push({ regexSource: handler.url.source, regexFlags: handler.url.flags });
      else
        all = true;
    }
    if (all)
      return [{ glob: "**/*" }];
    return patterns;
  }
  matches(requestURL) {
    return urlMatches(this._baseURL, requestURL, this.url);
  }
  async handle(route) {
    return await this._savedZone.run(async () => this._handleImpl(route));
  }
  async _handleImpl(route) {
    const handlerInvocation = { complete: new ManualPromise(), route };
    this._activeInvocations.add(handlerInvocation);
    try {
      return await this._handleInternal(route);
    } catch (e) {
      if (this._ignoreException)
        return false;
      if (isTargetClosedError2(e)) {
        rewriteErrorMessage(e, `"${e.message}" while running route callback.
Consider awaiting \`await page.unrouteAll({ behavior: 'ignoreErrors' })\`
before the end of the test to ignore remaining routes in flight.`);
      }
      throw e;
    } finally {
      handlerInvocation.complete.resolve();
      this._activeInvocations.delete(handlerInvocation);
    }
  }
  async stop(behavior) {
    if (behavior === "ignoreErrors") {
      this._ignoreException = true;
    } else {
      const promises2 = [];
      for (const activation of this._activeInvocations) {
        if (!activation.route._didThrow)
          promises2.push(activation.complete);
      }
      await Promise.all(promises2);
    }
  }
  async _handleInternal(route) {
    ++this.handledCount;
    const handledPromise = route._startHandling();
    const handler = this.handler;
    const [handled] = await Promise.all([
      handledPromise,
      handler(route, route.request())
    ]);
    return handled;
  }
  willExpire() {
    return this.handledCount + 1 >= this._times;
  }
};
var RawHeaders = class _RawHeaders {
  static {
    __name(this, "RawHeaders");
  }
  constructor(headers) {
    this._headersMap = new MultiMap();
    this._headersArray = headers;
    for (const header of headers)
      this._headersMap.set(header.name.toLowerCase(), header.value);
  }
  static _fromHeadersObjectLossy(headers) {
    const headersArray = Object.entries(headers).map(([name, value]) => ({
      name,
      value
    })).filter((header) => header.value !== void 0);
    return new _RawHeaders(headersArray);
  }
  get(name) {
    const values = this.getAll(name);
    if (!values || !values.length)
      return null;
    return values.join(name.toLowerCase() === "set-cookie" ? "\n" : ", ");
  }
  getAll(name) {
    return [...this._headersMap.get(name.toLowerCase())];
  }
  headers() {
    const result = {};
    for (const name of this._headersMap.keys())
      result[name] = this.get(name);
    return result;
  }
  headersArray() {
    return this._headersArray;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/types.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var kLifecycleEvents2 = /* @__PURE__ */ new Set(["load", "domcontentloaded", "networkidle", "commit"]);

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/frame.js
var Frame2 = class _Frame extends ChannelOwner {
  static {
    __name(this, "Frame");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._parentFrame = null;
    this._url = "";
    this._name = "";
    this._detached = false;
    this._childFrames = /* @__PURE__ */ new Set();
    this._eventEmitter = new EventEmitter18(parent._platform);
    this._eventEmitter.setMaxListeners(0);
    this._parentFrame = _Frame.fromNullable(initializer.parentFrame);
    if (this._parentFrame)
      this._parentFrame._childFrames.add(this);
    this._name = initializer.name;
    this._url = initializer.url;
    this._loadStates = new Set(initializer.loadStates);
    this._channel.on("loadstate", (event) => {
      if (event.add) {
        this._loadStates.add(event.add);
        this._eventEmitter.emit("loadstate", event.add);
      }
      if (event.remove)
        this._loadStates.delete(event.remove);
      if (!this._parentFrame && event.add === "load" && this._page)
        this._page.emit(Events.Page.Load, this._page);
      if (!this._parentFrame && event.add === "domcontentloaded" && this._page)
        this._page.emit(Events.Page.DOMContentLoaded, this._page);
    });
    this._channel.on("navigated", (event) => {
      this._url = event.url;
      this._name = event.name;
      this._eventEmitter.emit("navigated", event);
      if (!event.error && this._page)
        this._page.emit(Events.Page.FrameNavigated, this);
    });
  }
  static from(frame) {
    return frame._object;
  }
  static fromNullable(frame) {
    return frame ? _Frame.from(frame) : null;
  }
  page() {
    return this._page;
  }
  async goto(url4, options2 = {}) {
    const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    return Response3.fromNullable((await this._channel.goto({ url: url4, ...options2, waitUntil })).response);
  }
  _setupNavigationWaiter(options2) {
    const waiter = new Waiter(this._page, "");
    if (this._page.isClosed())
      waiter.rejectImmediately(this._page._closeErrorWithReason());
    waiter.rejectOnEvent(this._page, Events.Page.Close, () => this._page._closeErrorWithReason());
    waiter.rejectOnEvent(this._page, Events.Page.Crash, new Error("Navigation failed because page crashed!"));
    waiter.rejectOnEvent(this._page, Events.Page.FrameDetached, new Error("Navigating frame was detached!"), (frame) => frame === this);
    const timeout = this._page._timeoutSettings.navigationTimeout(options2);
    waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded.`);
    return waiter;
  }
  async waitForNavigation(options2 = {}) {
    return await this._page._wrapApiCall(async () => {
      const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
      const waiter = this._setupNavigationWaiter(options2);
      const toUrl = typeof options2.url === "string" ? ` to "${options2.url}"` : "";
      waiter.log(`waiting for navigation${toUrl} until "${waitUntil}"`);
      const navigatedEvent = await waiter.waitForEvent(this._eventEmitter, "navigated", (event) => {
        if (event.error)
          return true;
        waiter.log(`  navigated to "${event.url}"`);
        return urlMatches(this._page?.context()._options.baseURL, event.url, options2.url);
      });
      if (navigatedEvent.error) {
        const e = new Error(navigatedEvent.error);
        e.stack = "";
        await waiter.waitForPromise(Promise.reject(e));
      }
      if (!this._loadStates.has(waitUntil)) {
        await waiter.waitForEvent(this._eventEmitter, "loadstate", (s) => {
          waiter.log(`  "${s}" event fired`);
          return s === waitUntil;
        });
      }
      const request4 = navigatedEvent.newDocument ? Request2.fromNullable(navigatedEvent.newDocument.request) : null;
      const response = request4 ? await waiter.waitForPromise(request4._finalRequest()._internalResponse()) : null;
      waiter.dispose();
      return response;
    });
  }
  async waitForLoadState(state = "load", options2 = {}) {
    state = verifyLoadState("state", state);
    return await this._page._wrapApiCall(async () => {
      const waiter = this._setupNavigationWaiter(options2);
      if (this._loadStates.has(state)) {
        waiter.log(`  not waiting, "${state}" event already fired`);
      } else {
        await waiter.waitForEvent(this._eventEmitter, "loadstate", (s) => {
          waiter.log(`  "${s}" event fired`);
          return s === state;
        });
      }
      waiter.dispose();
    });
  }
  async waitForURL(url4, options2 = {}) {
    if (urlMatches(this._page?.context()._options.baseURL, this.url(), url4))
      return await this.waitForLoadState(options2.waitUntil, options2);
    await this.waitForNavigation({ url: url4, ...options2 });
  }
  async frameElement() {
    return ElementHandle2.from((await this._channel.frameElement()).element);
  }
  async evaluateHandle(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    const result = await this._channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return JSHandle2.from(result.handle);
  }
  async evaluate(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async _evaluateExposeUtilityScript(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async $(selector, options2) {
    const result = await this._channel.querySelector({ selector, ...options2 });
    return ElementHandle2.fromNullable(result.element);
  }
  async waitForSelector(selector, options2 = {}) {
    if (options2.visibility)
      throw new Error("options.visibility is not supported, did you mean options.state?");
    if (options2.waitFor && options2.waitFor !== "visible")
      throw new Error("options.waitFor is not supported, did you mean options.state?");
    const result = await this._channel.waitForSelector({ selector, ...options2 });
    return ElementHandle2.fromNullable(result.element);
  }
  async dispatchEvent(selector, type2, eventInit, options2 = {}) {
    await this._channel.dispatchEvent({ selector, type: type2, eventInit: serializeArgument(eventInit), ...options2 });
  }
  async $eval(selector, pageFunction, arg) {
    assertMaxArguments(arguments.length, 3);
    const result = await this._channel.evalOnSelector({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async $$eval(selector, pageFunction, arg) {
    assertMaxArguments(arguments.length, 3);
    const result = await this._channel.evalOnSelectorAll({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async $$(selector) {
    const result = await this._channel.querySelectorAll({ selector });
    return result.elements.map((e) => ElementHandle2.from(e));
  }
  async _queryCount(selector) {
    return (await this._channel.queryCount({ selector })).value;
  }
  async content() {
    return (await this._channel.content()).value;
  }
  async setContent(html, options2 = {}) {
    const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    await this._channel.setContent({ html, ...options2, waitUntil });
  }
  name() {
    return this._name || "";
  }
  url() {
    return this._url;
  }
  parentFrame() {
    return this._parentFrame;
  }
  childFrames() {
    return Array.from(this._childFrames);
  }
  isDetached() {
    return this._detached;
  }
  async addScriptTag(options2 = {}) {
    const copy = { ...options2 };
    if (copy.path) {
      copy.content = (await this._platform.fs().promises.readFile(copy.path)).toString();
      copy.content = addSourceUrlToScript(copy.content, copy.path);
    }
    return ElementHandle2.from((await this._channel.addScriptTag({ ...copy })).element);
  }
  async addStyleTag(options2 = {}) {
    const copy = { ...options2 };
    if (copy.path) {
      copy.content = (await this._platform.fs().promises.readFile(copy.path)).toString();
      copy.content += "/*# sourceURL=" + copy.path.replace(/\n/g, "") + "*/";
    }
    return ElementHandle2.from((await this._channel.addStyleTag({ ...copy })).element);
  }
  async click(selector, options2 = {}) {
    return await this._channel.click({ selector, ...options2 });
  }
  async dblclick(selector, options2 = {}) {
    return await this._channel.dblclick({ selector, ...options2 });
  }
  async dragAndDrop(source7, target, options2 = {}) {
    return await this._channel.dragAndDrop({ source: source7, target, ...options2 });
  }
  async tap(selector, options2 = {}) {
    return await this._channel.tap({ selector, ...options2 });
  }
  async fill(selector, value, options2 = {}) {
    return await this._channel.fill({ selector, value, ...options2 });
  }
  async _highlight(selector) {
    return await this._channel.highlight({ selector });
  }
  locator(selector, options2) {
    return new Locator(this, selector, options2);
  }
  getByTestId(testId) {
    return this.locator(getByTestIdSelector(testIdAttributeName(), testId));
  }
  getByAltText(text, options2) {
    return this.locator(getByAltTextSelector(text, options2));
  }
  getByLabel(text, options2) {
    return this.locator(getByLabelSelector(text, options2));
  }
  getByPlaceholder(text, options2) {
    return this.locator(getByPlaceholderSelector(text, options2));
  }
  getByText(text, options2) {
    return this.locator(getByTextSelector(text, options2));
  }
  getByTitle(text, options2) {
    return this.locator(getByTitleSelector(text, options2));
  }
  getByRole(role, options2 = {}) {
    return this.locator(getByRoleSelector(role, options2));
  }
  frameLocator(selector) {
    return new FrameLocator(this, selector);
  }
  async focus(selector, options2 = {}) {
    await this._channel.focus({ selector, ...options2 });
  }
  async textContent(selector, options2 = {}) {
    const value = (await this._channel.textContent({ selector, ...options2 })).value;
    return value === void 0 ? null : value;
  }
  async innerText(selector, options2 = {}) {
    return (await this._channel.innerText({ selector, ...options2 })).value;
  }
  async innerHTML(selector, options2 = {}) {
    return (await this._channel.innerHTML({ selector, ...options2 })).value;
  }
  async getAttribute(selector, name, options2 = {}) {
    const value = (await this._channel.getAttribute({ selector, name, ...options2 })).value;
    return value === void 0 ? null : value;
  }
  async inputValue(selector, options2 = {}) {
    return (await this._channel.inputValue({ selector, ...options2 })).value;
  }
  async isChecked(selector, options2 = {}) {
    return (await this._channel.isChecked({ selector, ...options2 })).value;
  }
  async isDisabled(selector, options2 = {}) {
    return (await this._channel.isDisabled({ selector, ...options2 })).value;
  }
  async isEditable(selector, options2 = {}) {
    return (await this._channel.isEditable({ selector, ...options2 })).value;
  }
  async isEnabled(selector, options2 = {}) {
    return (await this._channel.isEnabled({ selector, ...options2 })).value;
  }
  async isHidden(selector, options2 = {}) {
    return (await this._channel.isHidden({ selector, ...options2 })).value;
  }
  async isVisible(selector, options2 = {}) {
    return (await this._channel.isVisible({ selector, ...options2 })).value;
  }
  async hover(selector, options2 = {}) {
    await this._channel.hover({ selector, ...options2 });
  }
  async selectOption(selector, values, options2 = {}) {
    return (await this._channel.selectOption({ selector, ...convertSelectOptionValues(values), ...options2 })).values;
  }
  async setInputFiles(selector, files, options2 = {}) {
    const converted = await convertInputFiles(this._platform, files, this.page().context());
    await this._channel.setInputFiles({ selector, ...converted, ...options2 });
  }
  async type(selector, text, options2 = {}) {
    await this._channel.type({ selector, text, ...options2 });
  }
  async press(selector, key, options2 = {}) {
    await this._channel.press({ selector, key, ...options2 });
  }
  async check(selector, options2 = {}) {
    await this._channel.check({ selector, ...options2 });
  }
  async uncheck(selector, options2 = {}) {
    await this._channel.uncheck({ selector, ...options2 });
  }
  async setChecked(selector, checked, options2) {
    if (checked)
      await this.check(selector, options2);
    else
      await this.uncheck(selector, options2);
  }
  async waitForTimeout(timeout) {
    await this._channel.waitForTimeout({ timeout });
  }
  async waitForFunction(pageFunction, arg, options2 = {}) {
    if (typeof options2.polling === "string")
      assert3(options2.polling === "raf", "Unknown polling option: " + options2.polling);
    const result = await this._channel.waitForFunction({
      ...options2,
      pollingInterval: options2.polling === "raf" ? void 0 : options2.polling,
      expression: String(pageFunction),
      isFunction: typeof pageFunction === "function",
      arg: serializeArgument(arg)
    });
    return JSHandle2.from(result.handle);
  }
  async title() {
    return (await this._channel.title()).value;
  }
};
function verifyLoadState(name, waitUntil) {
  if (waitUntil === "networkidle0")
    waitUntil = "networkidle";
  if (!kLifecycleEvents2.has(waitUntil))
    throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
  return waitUntil;
}
__name(verifyLoadState, "verifyLoadState");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/writableStream.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WritableStream = class extends ChannelOwner {
  static {
    __name(this, "WritableStream");
  }
  static from(Stream2) {
    return Stream2._object;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
  }
  stream() {
    return this._platform.streamWritable(this._channel);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/elementHandle.js
var ElementHandle2 = class _ElementHandle extends JSHandle2 {
  static {
    __name(this, "ElementHandle");
  }
  static from(handle) {
    return handle._object;
  }
  static fromNullable(handle) {
    return handle ? _ElementHandle.from(handle) : null;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._elementChannel = this._channel;
  }
  asElement() {
    return this;
  }
  async ownerFrame() {
    return Frame2.fromNullable((await this._elementChannel.ownerFrame()).frame);
  }
  async contentFrame() {
    return Frame2.fromNullable((await this._elementChannel.contentFrame()).frame);
  }
  async _generateLocatorString() {
    const value = (await this._elementChannel.generateLocatorString()).value;
    return value === void 0 ? null : value;
  }
  async getAttribute(name) {
    const value = (await this._elementChannel.getAttribute({ name })).value;
    return value === void 0 ? null : value;
  }
  async inputValue() {
    return (await this._elementChannel.inputValue()).value;
  }
  async textContent() {
    const value = (await this._elementChannel.textContent()).value;
    return value === void 0 ? null : value;
  }
  async innerText() {
    return (await this._elementChannel.innerText()).value;
  }
  async innerHTML() {
    return (await this._elementChannel.innerHTML()).value;
  }
  async isChecked() {
    return (await this._elementChannel.isChecked()).value;
  }
  async isDisabled() {
    return (await this._elementChannel.isDisabled()).value;
  }
  async isEditable() {
    return (await this._elementChannel.isEditable()).value;
  }
  async isEnabled() {
    return (await this._elementChannel.isEnabled()).value;
  }
  async isHidden() {
    return (await this._elementChannel.isHidden()).value;
  }
  async isVisible() {
    return (await this._elementChannel.isVisible()).value;
  }
  async dispatchEvent(type2, eventInit = {}) {
    await this._elementChannel.dispatchEvent({ type: type2, eventInit: serializeArgument(eventInit) });
  }
  async scrollIntoViewIfNeeded(options2 = {}) {
    await this._elementChannel.scrollIntoViewIfNeeded(options2);
  }
  async hover(options2 = {}) {
    await this._elementChannel.hover(options2);
  }
  async click(options2 = {}) {
    return await this._elementChannel.click(options2);
  }
  async dblclick(options2 = {}) {
    return await this._elementChannel.dblclick(options2);
  }
  async tap(options2 = {}) {
    return await this._elementChannel.tap(options2);
  }
  async selectOption(values, options2 = {}) {
    const result = await this._elementChannel.selectOption({ ...convertSelectOptionValues(values), ...options2 });
    return result.values;
  }
  async fill(value, options2 = {}) {
    return await this._elementChannel.fill({ value, ...options2 });
  }
  async selectText(options2 = {}) {
    await this._elementChannel.selectText(options2);
  }
  async setInputFiles(files, options2 = {}) {
    const frame = await this.ownerFrame();
    if (!frame)
      throw new Error("Cannot set input files to detached element");
    const converted = await convertInputFiles(this._platform, files, frame.page().context());
    await this._elementChannel.setInputFiles({ ...converted, ...options2 });
  }
  async focus() {
    await this._elementChannel.focus();
  }
  async type(text, options2 = {}) {
    await this._elementChannel.type({ text, ...options2 });
  }
  async press(key, options2 = {}) {
    await this._elementChannel.press({ key, ...options2 });
  }
  async check(options2 = {}) {
    return await this._elementChannel.check(options2);
  }
  async uncheck(options2 = {}) {
    return await this._elementChannel.uncheck(options2);
  }
  async setChecked(checked, options2) {
    if (checked)
      await this.check(options2);
    else
      await this.uncheck(options2);
  }
  async boundingBox() {
    const value = (await this._elementChannel.boundingBox()).value;
    return value === void 0 ? null : value;
  }
  async screenshot(options2 = {}) {
    const mask = options2.mask;
    const copy = { ...options2, mask: void 0 };
    if (!copy.type)
      copy.type = determineScreenshotType(options2);
    if (mask) {
      copy.mask = mask.map((locator) => ({
        frame: locator._frame._channel,
        selector: locator._selector
      }));
    }
    const result = await this._elementChannel.screenshot(copy);
    if (options2.path) {
      await mkdirIfNeeded2(this._platform, options2.path);
      await this._platform.fs().promises.writeFile(options2.path, result.binary);
    }
    return result.binary;
  }
  async $(selector) {
    return _ElementHandle.fromNullable((await this._elementChannel.querySelector({ selector })).element);
  }
  async $$(selector) {
    const result = await this._elementChannel.querySelectorAll({ selector });
    return result.elements.map((h) => _ElementHandle.from(h));
  }
  async $eval(selector, pageFunction, arg) {
    const result = await this._elementChannel.evalOnSelector({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async $$eval(selector, pageFunction, arg) {
    const result = await this._elementChannel.evalOnSelectorAll({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async waitForElementState(state, options2 = {}) {
    return await this._elementChannel.waitForElementState({ state, ...options2 });
  }
  async waitForSelector(selector, options2 = {}) {
    const result = await this._elementChannel.waitForSelector({ selector, ...options2 });
    return _ElementHandle.fromNullable(result.element);
  }
};
function convertSelectOptionValues(values) {
  if (values === null)
    return {};
  if (!Array.isArray(values))
    values = [values];
  if (!values.length)
    return {};
  for (let i = 0; i < values.length; i++)
    assert3(values[i] !== null, `options[${i}]: expected object, got null`);
  if (values[0] instanceof ElementHandle2)
    return { elements: values.map((v) => v._elementChannel) };
  if (isString2(values[0]))
    return { options: values.map((valueOrLabel) => ({ valueOrLabel })) };
  return { options: values };
}
__name(convertSelectOptionValues, "convertSelectOptionValues");
function filePayloadExceedsSizeLimit(payloads) {
  return payloads.reduce((size, item) => size + (item.buffer ? item.buffer.byteLength : 0), 0) >= fileUploadSizeLimit2;
}
__name(filePayloadExceedsSizeLimit, "filePayloadExceedsSizeLimit");
async function resolvePathsAndDirectoryForInputFiles(platform4, items) {
  let localPaths;
  let localDirectory;
  for (const item of items) {
    const stat2 = await platform4.fs().promises.stat(item);
    if (stat2.isDirectory()) {
      if (localDirectory)
        throw new Error("Multiple directories are not supported");
      localDirectory = platform4.path().resolve(item);
    } else {
      localPaths ??= [];
      localPaths.push(platform4.path().resolve(item));
    }
  }
  if (localPaths?.length && localDirectory)
    throw new Error("File paths must be all files or a single directory");
  return [localPaths, localDirectory];
}
__name(resolvePathsAndDirectoryForInputFiles, "resolvePathsAndDirectoryForInputFiles");
async function convertInputFiles(platform4, files, context2) {
  const items = Array.isArray(files) ? files.slice() : [files];
  if (items.some((item) => typeof item === "string")) {
    if (!items.every((item) => typeof item === "string"))
      throw new Error("File paths cannot be mixed with buffers");
    const [localPaths, localDirectory] = await resolvePathsAndDirectoryForInputFiles(platform4, items);
    if (context2._connection.isRemote()) {
      const files2 = localDirectory ? (await platform4.fs().promises.readdir(localDirectory, { withFileTypes: true, recursive: true })).filter((f) => f.isFile()).map((f) => platform4.path().join(f.path, f.name)) : localPaths;
      const { writableStreams, rootDir } = await context2._wrapApiCall(async () => context2._channel.createTempFiles({
        rootDirName: localDirectory ? platform4.path().basename(localDirectory) : void 0,
        items: await Promise.all(files2.map(async (file) => {
          const lastModifiedMs = (await platform4.fs().promises.stat(file)).mtimeMs;
          return {
            name: localDirectory ? platform4.path().relative(localDirectory, file) : platform4.path().basename(file),
            lastModifiedMs
          };
        }))
      }), true);
      for (let i = 0; i < files2.length; i++) {
        const writable = WritableStream.from(writableStreams[i]);
        await platform4.streamFile(files2[i], writable.stream());
      }
      return {
        directoryStream: rootDir,
        streams: localDirectory ? void 0 : writableStreams
      };
    }
    return {
      localPaths,
      localDirectory
    };
  }
  const payloads = items;
  if (filePayloadExceedsSizeLimit(payloads))
    throw new Error("Cannot set buffer larger than 50Mb, please write it to a file and pass its path instead.");
  return { payloads };
}
__name(convertInputFiles, "convertInputFiles");
function determineScreenshotType(options2) {
  if (options2.path) {
    const mimeType = getMimeTypeForPath(options2.path);
    if (mimeType === "image/png")
      return "png";
    else if (mimeType === "image/jpeg")
      return "jpeg";
    throw new Error(`path: unsupported mime type "${mimeType}"`);
  }
  return options2.type;
}
__name(determineScreenshotType, "determineScreenshotType");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/fileChooser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FileChooser2 = class {
  static {
    __name(this, "FileChooser");
  }
  constructor(page, elementHandle, isMultiple) {
    this._page = page;
    this._elementHandle = elementHandle;
    this._isMultiple = isMultiple;
  }
  element() {
    return this._elementHandle;
  }
  isMultiple() {
    return this._isMultiple;
  }
  page() {
    return this._page;
  }
  async setFiles(files, options2) {
    return await this._elementHandle.setInputFiles(files, options2);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/harRouter.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HarRouter = class _HarRouter {
  static {
    __name(this, "HarRouter");
  }
  static async create(localUtils, file, notFoundAction, options2) {
    const { harId, error: error4 } = await localUtils.harOpen({ file });
    if (error4)
      throw new Error(error4);
    return new _HarRouter(localUtils, harId, notFoundAction, options2);
  }
  constructor(localUtils, harId, notFoundAction, options2) {
    this._localUtils = localUtils;
    this._harId = harId;
    this._options = options2;
    this._notFoundAction = notFoundAction;
  }
  async _handle(route) {
    const request4 = route.request();
    const response = await this._localUtils.harLookup({
      harId: this._harId,
      url: request4.url(),
      method: request4.method(),
      headers: await request4.headersArray(),
      postData: request4.postDataBuffer() || void 0,
      isNavigationRequest: request4.isNavigationRequest()
    });
    if (response.action === "redirect") {
      route._platform.log("api", `HAR: ${route.request().url()} redirected to ${response.redirectURL}`);
      await route._redirectNavigationRequest(response.redirectURL);
      return;
    }
    if (response.action === "fulfill") {
      if (response.status === -1)
        return;
      await route.fulfill({
        status: response.status,
        headers: Object.fromEntries(response.headers.map((h) => [h.name, h.value])),
        body: response.body
      });
      return;
    }
    if (response.action === "error")
      route._platform.log("api", "HAR: " + response.message);
    if (this._notFoundAction === "abort") {
      await route.abort();
      return;
    }
    await route.fallback();
  }
  async addContextRoute(context2) {
    await context2.route(this._options.urlMatch || "**/*", (route) => this._handle(route));
  }
  async addPageRoute(page) {
    await page.route(this._options.urlMatch || "**/*", (route) => this._handle(route));
  }
  async [Symbol.asyncDispose]() {
    await this.dispose();
  }
  dispose() {
    this._localUtils.harClose({ harId: this._harId }).catch(() => {
    });
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/input.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Keyboard2 = class {
  static {
    __name(this, "Keyboard");
  }
  constructor(page) {
    this._page = page;
  }
  async down(key) {
    await this._page._channel.keyboardDown({ key });
  }
  async up(key) {
    await this._page._channel.keyboardUp({ key });
  }
  async insertText(text) {
    await this._page._channel.keyboardInsertText({ text });
  }
  async type(text, options2 = {}) {
    await this._page._channel.keyboardType({ text, ...options2 });
  }
  async press(key, options2 = {}) {
    await this._page._channel.keyboardPress({ key, ...options2 });
  }
};
var Mouse2 = class {
  static {
    __name(this, "Mouse");
  }
  constructor(page) {
    this._page = page;
  }
  async move(x, y, options2 = {}) {
    await this._page._channel.mouseMove({ x, y, ...options2 });
  }
  async down(options2 = {}) {
    await this._page._channel.mouseDown({ ...options2 });
  }
  async up(options2 = {}) {
    await this._page._channel.mouseUp(options2);
  }
  async click(x, y, options2 = {}) {
    await this._page._channel.mouseClick({ x, y, ...options2 });
  }
  async dblclick(x, y, options2 = {}) {
    await this.click(x, y, { ...options2, clickCount: 2 });
  }
  async wheel(deltaX, deltaY) {
    await this._page._channel.mouseWheel({ deltaX, deltaY });
  }
};
var Touchscreen2 = class {
  static {
    __name(this, "Touchscreen");
  }
  constructor(page) {
    this._page = page;
  }
  async tap(x, y) {
    await this._page._channel.touchscreenTap({ x, y });
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/video.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Video = class {
  static {
    __name(this, "Video");
  }
  constructor(page, connection) {
    this._artifact = null;
    this._artifactReadyPromise = new ManualPromise();
    this._isRemote = false;
    this._isRemote = connection.isRemote();
    this._artifact = page._closedOrCrashedScope.safeRace(this._artifactReadyPromise);
  }
  _artifactReady(artifact) {
    this._artifactReadyPromise.resolve(artifact);
  }
  async path() {
    if (this._isRemote)
      throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
    const artifact = await this._artifact;
    if (!artifact)
      throw new Error("Page did not produce any video frames");
    return artifact._initializer.absolutePath;
  }
  async saveAs(path31) {
    const artifact = await this._artifact;
    if (!artifact)
      throw new Error("Page did not produce any video frames");
    return await artifact.saveAs(path31);
  }
  async delete() {
    const artifact = await this._artifact;
    if (artifact)
      await artifact.delete();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/timeoutSettings.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DEFAULT_TIMEOUT2 = 3e4;
var TimeoutSettings2 = class {
  static {
    __name(this, "TimeoutSettings");
  }
  constructor(platform4, parent) {
    this._parent = parent;
    this._platform = platform4;
  }
  setDefaultTimeout(timeout) {
    this._defaultTimeout = timeout;
  }
  setDefaultNavigationTimeout(timeout) {
    this._defaultNavigationTimeout = timeout;
  }
  defaultNavigationTimeout() {
    return this._defaultNavigationTimeout;
  }
  defaultTimeout() {
    return this._defaultTimeout;
  }
  navigationTimeout(options2) {
    if (typeof options2.timeout === "number")
      return options2.timeout;
    if (this._defaultNavigationTimeout !== void 0)
      return this._defaultNavigationTimeout;
    if (this._platform.isDebugMode())
      return 0;
    if (this._defaultTimeout !== void 0)
      return this._defaultTimeout;
    if (this._parent)
      return this._parent.navigationTimeout(options2);
    return DEFAULT_TIMEOUT2;
  }
  timeout(options2) {
    if (typeof options2.timeout === "number")
      return options2.timeout;
    if (this._platform.isDebugMode())
      return 0;
    if (this._defaultTimeout !== void 0)
      return this._defaultTimeout;
    if (this._parent)
      return this._parent.timeout(options2);
    return DEFAULT_TIMEOUT2;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/page.js
var Page2 = class _Page extends ChannelOwner {
  static {
    __name(this, "Page");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._frames = /* @__PURE__ */ new Set();
    this._workers = /* @__PURE__ */ new Set();
    this._closed = false;
    this._closedOrCrashedScope = new LongStandingScope();
    this._routes = [];
    this._webSocketRoutes = [];
    this._bindings = /* @__PURE__ */ new Map();
    this._video = null;
    this._closeWasCalled = false;
    this._harRouters = [];
    this._locatorHandlers = /* @__PURE__ */ new Map();
    this._browserContext = parent;
    this._timeoutSettings = new TimeoutSettings2(this._platform, this._browserContext._timeoutSettings);
    this.accessibility = new Accessibility2(this._channel);
    this.keyboard = new Keyboard2(this);
    this.mouse = new Mouse2(this);
    this.request = this._browserContext.request;
    this.touchscreen = new Touchscreen2(this);
    this.clock = this._browserContext.clock;
    this._mainFrame = Frame2.from(initializer.mainFrame);
    this._mainFrame._page = this;
    this._frames.add(this._mainFrame);
    this._viewportSize = initializer.viewportSize || null;
    this._closed = initializer.isClosed;
    this._opener = _Page.fromNullable(initializer.opener);
    this._channel.on("bindingCall", ({ binding: binding3 }) => this._onBinding(BindingCall.from(binding3)));
    this._channel.on("close", () => this._onClose());
    this._channel.on("crash", () => this._onCrash());
    this._channel.on("download", ({ url: url4, suggestedFilename, artifact }) => {
      const artifactObject = Artifact2.from(artifact);
      this.emit(Events.Page.Download, new Download2(this, url4, suggestedFilename, artifactObject));
    });
    this._channel.on("fileChooser", ({ element, isMultiple }) => this.emit(Events.Page.FileChooser, new FileChooser2(this, ElementHandle2.from(element), isMultiple)));
    this._channel.on("frameAttached", ({ frame }) => this._onFrameAttached(Frame2.from(frame)));
    this._channel.on("frameDetached", ({ frame }) => this._onFrameDetached(Frame2.from(frame)));
    this._channel.on("locatorHandlerTriggered", ({ uid }) => this._onLocatorHandlerTriggered(uid));
    this._channel.on("route", ({ route }) => this._onRoute(Route2.from(route)));
    this._channel.on("webSocketRoute", ({ webSocketRoute }) => this._onWebSocketRoute(WebSocketRoute.from(webSocketRoute)));
    this._channel.on("video", ({ artifact }) => {
      const artifactObject = Artifact2.from(artifact);
      this._forceVideo()._artifactReady(artifactObject);
    });
    this._channel.on("webSocket", ({ webSocket }) => this.emit(Events.Page.WebSocket, WebSocket4.from(webSocket)));
    this._channel.on("worker", ({ worker }) => this._onWorker(Worker2.from(worker)));
    this.coverage = new Coverage(this._channel);
    this.once(Events.Page.Close, () => this._closedOrCrashedScope.close(this._closeErrorWithReason()));
    this.once(Events.Page.Crash, () => this._closedOrCrashedScope.close(new TargetClosedError2()));
    this._setEventToSubscriptionMapping(/* @__PURE__ */ new Map([
      [Events.Page.Console, "console"],
      [Events.Page.Dialog, "dialog"],
      [Events.Page.Request, "request"],
      [Events.Page.Response, "response"],
      [Events.Page.RequestFinished, "requestFinished"],
      [Events.Page.RequestFailed, "requestFailed"],
      [Events.Page.FileChooser, "fileChooser"]
    ]));
  }
  static from(page) {
    return page._object;
  }
  static fromNullable(page) {
    return page ? _Page.from(page) : null;
  }
  _onFrameAttached(frame) {
    frame._page = this;
    this._frames.add(frame);
    if (frame._parentFrame)
      frame._parentFrame._childFrames.add(frame);
    this.emit(Events.Page.FrameAttached, frame);
  }
  _onFrameDetached(frame) {
    this._frames.delete(frame);
    frame._detached = true;
    if (frame._parentFrame)
      frame._parentFrame._childFrames.delete(frame);
    this.emit(Events.Page.FrameDetached, frame);
  }
  async _onRoute(route) {
    route._context = this.context();
    const routeHandlers = this._routes.slice();
    for (const routeHandler of routeHandlers) {
      if (this._closeWasCalled || this._browserContext._closeWasCalled)
        return;
      if (!routeHandler.matches(route.request().url()))
        continue;
      const index2 = this._routes.indexOf(routeHandler);
      if (index2 === -1)
        continue;
      if (routeHandler.willExpire())
        this._routes.splice(index2, 1);
      const handled = await routeHandler.handle(route);
      if (!this._routes.length)
        this._wrapApiCall(() => this._updateInterceptionPatterns(), true).catch(() => {
        });
      if (handled)
        return;
    }
    await this._browserContext._onRoute(route);
  }
  async _onWebSocketRoute(webSocketRoute) {
    const routeHandler = this._webSocketRoutes.find((route) => route.matches(webSocketRoute.url()));
    if (routeHandler)
      await routeHandler.handle(webSocketRoute);
    else
      await this._browserContext._onWebSocketRoute(webSocketRoute);
  }
  async _onBinding(bindingCall) {
    const func = this._bindings.get(bindingCall._initializer.name);
    if (func) {
      await bindingCall.call(func);
      return;
    }
    await this._browserContext._onBinding(bindingCall);
  }
  _onWorker(worker) {
    this._workers.add(worker);
    worker._page = this;
    this.emit(Events.Page.Worker, worker);
  }
  _onClose() {
    this._closed = true;
    this._browserContext._pages.delete(this);
    this._browserContext._backgroundPages.delete(this);
    this._disposeHarRouters();
    this.emit(Events.Page.Close, this);
  }
  _onCrash() {
    this.emit(Events.Page.Crash, this);
  }
  context() {
    return this._browserContext;
  }
  async opener() {
    if (!this._opener || this._opener.isClosed())
      return null;
    return this._opener;
  }
  mainFrame() {
    return this._mainFrame;
  }
  frame(frameSelector) {
    const name = isString2(frameSelector) ? frameSelector : frameSelector.name;
    const url4 = isObject2(frameSelector) ? frameSelector.url : void 0;
    assert3(name || url4, "Either name or url matcher should be specified");
    return this.frames().find((f) => {
      if (name)
        return f.name() === name;
      return urlMatches(this._browserContext._options.baseURL, f.url(), url4);
    }) || null;
  }
  frames() {
    return [...this._frames];
  }
  setDefaultNavigationTimeout(timeout) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    this._wrapApiCall(async () => {
      await this._channel.setDefaultNavigationTimeoutNoReply({ timeout });
    }, true).catch(() => {
    });
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
    this._wrapApiCall(async () => {
      await this._channel.setDefaultTimeoutNoReply({ timeout });
    }, true).catch(() => {
    });
  }
  _forceVideo() {
    if (!this._video)
      this._video = new Video(this, this._connection);
    return this._video;
  }
  video() {
    if (!this._browserContext._options.recordVideo)
      return null;
    return this._forceVideo();
  }
  async $(selector, options2) {
    return await this._mainFrame.$(selector, options2);
  }
  async waitForSelector(selector, options2) {
    return await this._mainFrame.waitForSelector(selector, options2);
  }
  async dispatchEvent(selector, type2, eventInit, options2) {
    return await this._mainFrame.dispatchEvent(selector, type2, eventInit, options2);
  }
  async evaluateHandle(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    return await this._mainFrame.evaluateHandle(pageFunction, arg);
  }
  async $eval(selector, pageFunction, arg) {
    assertMaxArguments(arguments.length, 3);
    return await this._mainFrame.$eval(selector, pageFunction, arg);
  }
  async $$eval(selector, pageFunction, arg) {
    assertMaxArguments(arguments.length, 3);
    return await this._mainFrame.$$eval(selector, pageFunction, arg);
  }
  async $$(selector) {
    return await this._mainFrame.$$(selector);
  }
  async addScriptTag(options2 = {}) {
    return await this._mainFrame.addScriptTag(options2);
  }
  async addStyleTag(options2 = {}) {
    return await this._mainFrame.addStyleTag(options2);
  }
  async exposeFunction(name, callback) {
    await this._channel.exposeBinding({ name });
    const binding3 = /* @__PURE__ */ __name((source7, ...args) => callback(...args), "binding");
    this._bindings.set(name, binding3);
  }
  async exposeBinding(name, callback, options2 = {}) {
    await this._channel.exposeBinding({ name, needsHandle: options2.handle });
    this._bindings.set(name, callback);
  }
  async setExtraHTTPHeaders(headers) {
    validateHeaders(headers);
    await this._channel.setExtraHTTPHeaders({ headers: headersObjectToArray(headers) });
  }
  url() {
    return this._mainFrame.url();
  }
  async content() {
    return await this._mainFrame.content();
  }
  async setContent(html, options2) {
    return await this._mainFrame.setContent(html, options2);
  }
  async goto(url4, options2) {
    return await this._mainFrame.goto(url4, options2);
  }
  async reload(options2 = {}) {
    const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    return Response3.fromNullable((await this._channel.reload({ ...options2, waitUntil })).response);
  }
  async addLocatorHandler(locator, handler, options2 = {}) {
    if (locator._frame !== this._mainFrame)
      throw new Error(`Locator must belong to the main frame of this page`);
    if (options2.times === 0)
      return;
    const { uid } = await this._channel.registerLocatorHandler({ selector: locator._selector, noWaitAfter: options2.noWaitAfter });
    this._locatorHandlers.set(uid, { locator, handler, times: options2.times });
  }
  async _onLocatorHandlerTriggered(uid) {
    let remove = false;
    try {
      const handler = this._locatorHandlers.get(uid);
      if (handler && handler.times !== 0) {
        if (handler.times !== void 0)
          handler.times--;
        await handler.handler(handler.locator);
      }
      remove = handler?.times === 0;
    } finally {
      if (remove)
        this._locatorHandlers.delete(uid);
      this._wrapApiCall(() => this._channel.resolveLocatorHandlerNoReply({ uid, remove }), true).catch(() => {
      });
    }
  }
  async removeLocatorHandler(locator) {
    for (const [uid, data] of this._locatorHandlers) {
      if (data.locator._equals(locator)) {
        this._locatorHandlers.delete(uid);
        await this._channel.unregisterLocatorHandler({ uid }).catch(() => {
        });
      }
    }
  }
  async waitForLoadState(state, options2) {
    return await this._mainFrame.waitForLoadState(state, options2);
  }
  async waitForNavigation(options2) {
    return await this._mainFrame.waitForNavigation(options2);
  }
  async waitForURL(url4, options2) {
    return await this._mainFrame.waitForURL(url4, options2);
  }
  async waitForRequest(urlOrPredicate, options2 = {}) {
    const predicate = /* @__PURE__ */ __name(async (request4) => {
      if (isString2(urlOrPredicate) || isRegExp4(urlOrPredicate))
        return urlMatches(this._browserContext._options.baseURL, request4.url(), urlOrPredicate);
      return await urlOrPredicate(request4);
    }, "predicate");
    const trimmedUrl = trimUrl(urlOrPredicate);
    const logLine = trimmedUrl ? `waiting for request ${trimmedUrl}` : void 0;
    return await this._waitForEvent(Events.Page.Request, { predicate, timeout: options2.timeout }, logLine);
  }
  async waitForResponse(urlOrPredicate, options2 = {}) {
    const predicate = /* @__PURE__ */ __name(async (response) => {
      if (isString2(urlOrPredicate) || isRegExp4(urlOrPredicate))
        return urlMatches(this._browserContext._options.baseURL, response.url(), urlOrPredicate);
      return await urlOrPredicate(response);
    }, "predicate");
    const trimmedUrl = trimUrl(urlOrPredicate);
    const logLine = trimmedUrl ? `waiting for response ${trimmedUrl}` : void 0;
    return await this._waitForEvent(Events.Page.Response, { predicate, timeout: options2.timeout }, logLine);
  }
  async waitForEvent(event, optionsOrPredicate = {}) {
    return await this._waitForEvent(event, optionsOrPredicate, `waiting for event "${event}"`);
  }
  _closeErrorWithReason() {
    return new TargetClosedError2(this._closeReason || this._browserContext._effectiveCloseReason());
  }
  async _waitForEvent(event, optionsOrPredicate, logLine) {
    return await this._wrapApiCall(async () => {
      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
      const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
      const waiter = Waiter.createForEvent(this, event);
      if (logLine)
        waiter.log(logLine);
      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== Events.Page.Crash)
        waiter.rejectOnEvent(this, Events.Page.Crash, new Error("Page crashed"));
      if (event !== Events.Page.Close)
        waiter.rejectOnEvent(this, Events.Page.Close, () => this._closeErrorWithReason());
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }
  async goBack(options2 = {}) {
    const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    return Response3.fromNullable((await this._channel.goBack({ ...options2, waitUntil })).response);
  }
  async goForward(options2 = {}) {
    const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    return Response3.fromNullable((await this._channel.goForward({ ...options2, waitUntil })).response);
  }
  async requestGC() {
    await this._channel.requestGC();
  }
  async emulateMedia(options2 = {}) {
    await this._channel.emulateMedia({
      media: options2.media === null ? "no-override" : options2.media,
      colorScheme: options2.colorScheme === null ? "no-override" : options2.colorScheme,
      reducedMotion: options2.reducedMotion === null ? "no-override" : options2.reducedMotion,
      forcedColors: options2.forcedColors === null ? "no-override" : options2.forcedColors,
      contrast: options2.contrast === null ? "no-override" : options2.contrast
    });
  }
  async setViewportSize(viewportSize) {
    this._viewportSize = viewportSize;
    await this._channel.setViewportSize({ viewportSize });
  }
  viewportSize() {
    return this._viewportSize;
  }
  async evaluate(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    return await this._mainFrame.evaluate(pageFunction, arg);
  }
  async addInitScript(script, arg) {
    const source7 = await evaluationScript(this._platform, script, arg);
    await this._channel.addInitScript({ source: source7 });
  }
  async route(url4, handler, options2 = {}) {
    this._routes.unshift(new RouteHandler(this._platform, this._browserContext._options.baseURL, url4, handler, options2.times));
    await this._updateInterceptionPatterns();
  }
  async routeFromHAR(har, options2 = {}) {
    const localUtils = this._connection.localUtils();
    if (!localUtils)
      throw new Error("Route from har is not supported in thin clients");
    if (options2.update) {
      await this._browserContext._recordIntoHAR(har, this, options2);
      return;
    }
    const harRouter = await HarRouter.create(localUtils, har, options2.notFound || "abort", { urlMatch: options2.url });
    this._harRouters.push(harRouter);
    await harRouter.addPageRoute(this);
  }
  async routeWebSocket(url4, handler) {
    this._webSocketRoutes.unshift(new WebSocketRouteHandler(this._browserContext._options.baseURL, url4, handler));
    await this._updateWebSocketInterceptionPatterns();
  }
  _disposeHarRouters() {
    this._harRouters.forEach((router) => router.dispose());
    this._harRouters = [];
  }
  async unrouteAll(options2) {
    await this._unrouteInternal(this._routes, [], options2?.behavior);
    this._disposeHarRouters();
  }
  async unroute(url4, handler) {
    const removed = [];
    const remaining = [];
    for (const route of this._routes) {
      if (urlMatchesEqual(route.url, url4) && (!handler || route.handler === handler))
        removed.push(route);
      else
        remaining.push(route);
    }
    await this._unrouteInternal(removed, remaining, "default");
  }
  async _unrouteInternal(removed, remaining, behavior) {
    this._routes = remaining;
    await this._updateInterceptionPatterns();
    if (!behavior || behavior === "default")
      return;
    const promises2 = removed.map((routeHandler) => routeHandler.stop(behavior));
    await Promise.all(promises2);
  }
  async _updateInterceptionPatterns() {
    const patterns = RouteHandler.prepareInterceptionPatterns(this._routes);
    await this._channel.setNetworkInterceptionPatterns({ patterns });
  }
  async _updateWebSocketInterceptionPatterns() {
    const patterns = WebSocketRouteHandler.prepareInterceptionPatterns(this._webSocketRoutes);
    await this._channel.setWebSocketInterceptionPatterns({ patterns });
  }
  async screenshot(options2 = {}) {
    const mask = options2.mask;
    const copy = { ...options2, mask: void 0 };
    if (!copy.type)
      copy.type = determineScreenshotType(options2);
    if (mask) {
      copy.mask = mask.map((locator) => ({
        frame: locator._frame._channel,
        selector: locator._selector
      }));
    }
    const result = await this._channel.screenshot(copy);
    if (options2.path) {
      await mkdirIfNeeded2(this._platform, options2.path);
      await this._platform.fs().promises.writeFile(options2.path, result.binary);
    }
    return result.binary;
  }
  async _expectScreenshot(options2) {
    const mask = options2?.mask ? options2?.mask.map((locator2) => ({
      frame: locator2._frame._channel,
      selector: locator2._selector
    })) : void 0;
    const locator = options2.locator ? {
      frame: options2.locator._frame._channel,
      selector: options2.locator._selector
    } : void 0;
    return await this._channel.expectScreenshot({
      ...options2,
      isNot: !!options2.isNot,
      locator,
      mask
    });
  }
  async title() {
    return await this._mainFrame.title();
  }
  async bringToFront() {
    await this._channel.bringToFront();
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async close(options2 = {}) {
    this._closeReason = options2.reason;
    this._closeWasCalled = true;
    try {
      if (this._ownedContext)
        await this._ownedContext.close();
      else
        await this._channel.close(options2);
    } catch (e) {
      if (isTargetClosedError2(e) && !options2.runBeforeUnload)
        return;
      throw e;
    }
  }
  isClosed() {
    return this._closed;
  }
  async click(selector, options2) {
    return await this._mainFrame.click(selector, options2);
  }
  async dragAndDrop(source7, target, options2) {
    return await this._mainFrame.dragAndDrop(source7, target, options2);
  }
  async dblclick(selector, options2) {
    return await this._mainFrame.dblclick(selector, options2);
  }
  async tap(selector, options2) {
    return await this._mainFrame.tap(selector, options2);
  }
  async fill(selector, value, options2) {
    return await this._mainFrame.fill(selector, value, options2);
  }
  locator(selector, options2) {
    return this.mainFrame().locator(selector, options2);
  }
  getByTestId(testId) {
    return this.mainFrame().getByTestId(testId);
  }
  getByAltText(text, options2) {
    return this.mainFrame().getByAltText(text, options2);
  }
  getByLabel(text, options2) {
    return this.mainFrame().getByLabel(text, options2);
  }
  getByPlaceholder(text, options2) {
    return this.mainFrame().getByPlaceholder(text, options2);
  }
  getByText(text, options2) {
    return this.mainFrame().getByText(text, options2);
  }
  getByTitle(text, options2) {
    return this.mainFrame().getByTitle(text, options2);
  }
  getByRole(role, options2 = {}) {
    return this.mainFrame().getByRole(role, options2);
  }
  frameLocator(selector) {
    return this.mainFrame().frameLocator(selector);
  }
  async focus(selector, options2) {
    return await this._mainFrame.focus(selector, options2);
  }
  async textContent(selector, options2) {
    return await this._mainFrame.textContent(selector, options2);
  }
  async innerText(selector, options2) {
    return await this._mainFrame.innerText(selector, options2);
  }
  async innerHTML(selector, options2) {
    return await this._mainFrame.innerHTML(selector, options2);
  }
  async getAttribute(selector, name, options2) {
    return await this._mainFrame.getAttribute(selector, name, options2);
  }
  async inputValue(selector, options2) {
    return await this._mainFrame.inputValue(selector, options2);
  }
  async isChecked(selector, options2) {
    return await this._mainFrame.isChecked(selector, options2);
  }
  async isDisabled(selector, options2) {
    return await this._mainFrame.isDisabled(selector, options2);
  }
  async isEditable(selector, options2) {
    return await this._mainFrame.isEditable(selector, options2);
  }
  async isEnabled(selector, options2) {
    return await this._mainFrame.isEnabled(selector, options2);
  }
  async isHidden(selector, options2) {
    return await this._mainFrame.isHidden(selector, options2);
  }
  async isVisible(selector, options2) {
    return await this._mainFrame.isVisible(selector, options2);
  }
  async hover(selector, options2) {
    return await this._mainFrame.hover(selector, options2);
  }
  async selectOption(selector, values, options2) {
    return await this._mainFrame.selectOption(selector, values, options2);
  }
  async setInputFiles(selector, files, options2) {
    return await this._mainFrame.setInputFiles(selector, files, options2);
  }
  async type(selector, text, options2) {
    return await this._mainFrame.type(selector, text, options2);
  }
  async press(selector, key, options2) {
    return await this._mainFrame.press(selector, key, options2);
  }
  async check(selector, options2) {
    return await this._mainFrame.check(selector, options2);
  }
  async uncheck(selector, options2) {
    return await this._mainFrame.uncheck(selector, options2);
  }
  async setChecked(selector, checked, options2) {
    return await this._mainFrame.setChecked(selector, checked, options2);
  }
  async waitForTimeout(timeout) {
    return await this._mainFrame.waitForTimeout(timeout);
  }
  async waitForFunction(pageFunction, arg, options2) {
    return await this._mainFrame.waitForFunction(pageFunction, arg, options2);
  }
  workers() {
    return [...this._workers];
  }
  async pause(_options) {
    if (this._platform.isJSDebuggerAttached())
      return;
    const defaultNavigationTimeout = this._browserContext._timeoutSettings.defaultNavigationTimeout();
    const defaultTimeout = this._browserContext._timeoutSettings.defaultTimeout();
    this._browserContext.setDefaultNavigationTimeout(0);
    this._browserContext.setDefaultTimeout(0);
    this._instrumentation?.onWillPause({ keepTestTimeout: !!_options?.__testHookKeepTestTimeout });
    await this._closedOrCrashedScope.safeRace(this.context()._channel.pause());
    this._browserContext.setDefaultNavigationTimeout(defaultNavigationTimeout);
    this._browserContext.setDefaultTimeout(defaultTimeout);
  }
  async pdf(options2 = {}) {
    const transportOptions = { ...options2 };
    if (transportOptions.margin)
      transportOptions.margin = { ...transportOptions.margin };
    if (typeof options2.width === "number")
      transportOptions.width = options2.width + "px";
    if (typeof options2.height === "number")
      transportOptions.height = options2.height + "px";
    for (const margin of ["top", "right", "bottom", "left"]) {
      const index2 = margin;
      if (options2.margin && typeof options2.margin[index2] === "number")
        transportOptions.margin[index2] = transportOptions.margin[index2] + "px";
    }
    const result = await this._channel.pdf(transportOptions);
    if (options2.path) {
      const platform4 = this._platform;
      await platform4.fs().promises.mkdir(platform4.path().dirname(options2.path), { recursive: true });
      await platform4.fs().promises.writeFile(options2.path, result.pdf);
    }
    return result.pdf;
  }
};
var BindingCall = class extends ChannelOwner {
  static {
    __name(this, "BindingCall");
  }
  static from(channel2) {
    return channel2._object;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
  }
  async call(func) {
    try {
      const frame = Frame2.from(this._initializer.frame);
      const source7 = {
        context: frame._page.context(),
        page: frame._page,
        frame
      };
      let result;
      if (this._initializer.handle)
        result = await func(source7, JSHandle2.from(this._initializer.handle));
      else
        result = await func(source7, ...this._initializer.args.map(parseResult));
      this._channel.resolve({ result: serializeArgument(result) }).catch(() => {
      });
    } catch (e) {
      this._channel.reject({ error: serializeError2(e) }).catch(() => {
      });
    }
  }
};
function trimUrl(param) {
  if (isRegExp4(param))
    return `/${trimStringWithEllipsis(param.source, 50)}/${param.flags}`;
  if (isString2(param))
    return `"${trimStringWithEllipsis(param, 50)}"`;
}
__name(trimUrl, "trimUrl");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/consoleMessage.js
var ConsoleMessage2 = class {
  static {
    __name(this, "ConsoleMessage");
  }
  constructor(platform4, event) {
    this._page = "page" in event && event.page ? Page2.from(event.page) : null;
    this._event = event;
    if (platform4.inspectCustom)
      this[platform4.inspectCustom] = () => this._inspect();
  }
  page() {
    return this._page;
  }
  type() {
    return this._event.type;
  }
  text() {
    return this._event.text;
  }
  args() {
    return this._event.args.map(JSHandle2.from);
  }
  location() {
    return this._event.location;
  }
  _inspect() {
    return this.text();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/dialog.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Dialog2 = class extends ChannelOwner {
  static {
    __name(this, "Dialog");
  }
  static from(dialog) {
    return dialog._object;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._page = Page2.fromNullable(initializer.page);
  }
  page() {
    return this._page;
  }
  type() {
    return this._initializer.type;
  }
  message() {
    return this._initializer.message;
  }
  defaultValue() {
    return this._initializer.defaultValue;
  }
  async accept(promptText) {
    await this._channel.accept({ promptText });
  }
  async dismiss() {
    await this._channel.dismiss();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/webError.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WebError = class {
  static {
    __name(this, "WebError");
  }
  constructor(page, error4) {
    this._page = page;
    this._error = error4;
  }
  page() {
    return this._page;
  }
  error() {
    return this._error;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/browserContext.js
var BrowserContext2 = class _BrowserContext extends ChannelOwner {
  static {
    __name(this, "BrowserContext");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._pages = /* @__PURE__ */ new Set();
    this._routes = [];
    this._webSocketRoutes = [];
    this._browser = null;
    this._bindings = /* @__PURE__ */ new Map();
    this._options = {};
    this._backgroundPages = /* @__PURE__ */ new Set();
    this._serviceWorkers = /* @__PURE__ */ new Set();
    this._harRecorders = /* @__PURE__ */ new Map();
    this._closeWasCalled = false;
    this._harRouters = [];
    this._timeoutSettings = new TimeoutSettings2(this._platform);
    if (parent instanceof Browser2)
      this._browser = parent;
    this._browser?._contexts.add(this);
    this._isChromium = this._browser?._name === "chromium";
    this.tracing = Tracing2.from(initializer.tracing);
    this.request = APIRequestContext2.from(initializer.requestContext);
    this.clock = new Clock2(this);
    this._channel.on("bindingCall", ({ binding: binding3 }) => this._onBinding(BindingCall.from(binding3)));
    this._channel.on("close", () => this._onClose());
    this._channel.on("page", ({ page }) => this._onPage(Page2.from(page)));
    this._channel.on("route", ({ route }) => this._onRoute(Route2.from(route)));
    this._channel.on("webSocketRoute", ({ webSocketRoute }) => this._onWebSocketRoute(WebSocketRoute.from(webSocketRoute)));
    this._channel.on("backgroundPage", ({ page }) => {
      const backgroundPage = Page2.from(page);
      this._backgroundPages.add(backgroundPage);
      this.emit(Events.BrowserContext.BackgroundPage, backgroundPage);
    });
    this._channel.on("serviceWorker", ({ worker }) => {
      const serviceWorker = Worker2.from(worker);
      serviceWorker._context = this;
      this._serviceWorkers.add(serviceWorker);
      this.emit(Events.BrowserContext.ServiceWorker, serviceWorker);
    });
    this._channel.on("console", (event) => {
      const consoleMessage = new ConsoleMessage2(this._platform, event);
      this.emit(Events.BrowserContext.Console, consoleMessage);
      const page = consoleMessage.page();
      if (page)
        page.emit(Events.Page.Console, consoleMessage);
    });
    this._channel.on("pageError", ({ error: error4, page }) => {
      const pageObject = Page2.from(page);
      const parsedError = parseError2(error4);
      this.emit(Events.BrowserContext.WebError, new WebError(pageObject, parsedError));
      if (pageObject)
        pageObject.emit(Events.Page.PageError, parsedError);
    });
    this._channel.on("dialog", ({ dialog }) => {
      const dialogObject = Dialog2.from(dialog);
      let hasListeners = this.emit(Events.BrowserContext.Dialog, dialogObject);
      const page = dialogObject.page();
      if (page)
        hasListeners = page.emit(Events.Page.Dialog, dialogObject) || hasListeners;
      if (!hasListeners) {
        if (dialogObject.type() === "beforeunload")
          dialog.accept({}).catch(() => {
          });
        else
          dialog.dismiss().catch(() => {
          });
      }
    });
    this._channel.on("request", ({ request: request4, page }) => this._onRequest(Request2.from(request4), Page2.fromNullable(page)));
    this._channel.on("requestFailed", ({ request: request4, failureText, responseEndTiming, page }) => this._onRequestFailed(Request2.from(request4), responseEndTiming, failureText, Page2.fromNullable(page)));
    this._channel.on("requestFinished", (params) => this._onRequestFinished(params));
    this._channel.on("response", ({ response, page }) => this._onResponse(Response3.from(response), Page2.fromNullable(page)));
    this._closedPromise = new Promise((f) => this.once(Events.BrowserContext.Close, f));
    this._setEventToSubscriptionMapping(/* @__PURE__ */ new Map([
      [Events.BrowserContext.Console, "console"],
      [Events.BrowserContext.Dialog, "dialog"],
      [Events.BrowserContext.Request, "request"],
      [Events.BrowserContext.Response, "response"],
      [Events.BrowserContext.RequestFinished, "requestFinished"],
      [Events.BrowserContext.RequestFailed, "requestFailed"]
    ]));
  }
  static from(context2) {
    return context2._object;
  }
  static fromNullable(context2) {
    return context2 ? _BrowserContext.from(context2) : null;
  }
  _setOptions(contextOptions, browserOptions) {
    this._options = contextOptions;
    if (this._options.recordHar)
      this._harRecorders.set("", { path: this._options.recordHar.path, content: this._options.recordHar.content });
    this.tracing._tracesDir = browserOptions.tracesDir;
  }
  _onPage(page) {
    this._pages.add(page);
    this.emit(Events.BrowserContext.Page, page);
    if (page._opener && !page._opener.isClosed())
      page._opener.emit(Events.Page.Popup, page);
  }
  _onRequest(request4, page) {
    this.emit(Events.BrowserContext.Request, request4);
    if (page)
      page.emit(Events.Page.Request, request4);
  }
  _onResponse(response, page) {
    this.emit(Events.BrowserContext.Response, response);
    if (page)
      page.emit(Events.Page.Response, response);
  }
  _onRequestFailed(request4, responseEndTiming, failureText, page) {
    request4._failureText = failureText || null;
    request4._setResponseEndTiming(responseEndTiming);
    this.emit(Events.BrowserContext.RequestFailed, request4);
    if (page)
      page.emit(Events.Page.RequestFailed, request4);
  }
  _onRequestFinished(params) {
    const { responseEndTiming } = params;
    const request4 = Request2.from(params.request);
    const response = Response3.fromNullable(params.response);
    const page = Page2.fromNullable(params.page);
    request4._setResponseEndTiming(responseEndTiming);
    this.emit(Events.BrowserContext.RequestFinished, request4);
    if (page)
      page.emit(Events.Page.RequestFinished, request4);
    if (response)
      response._finishedPromise.resolve(null);
  }
  async _onRoute(route) {
    route._context = this;
    const page = route.request()._safePage();
    const routeHandlers = this._routes.slice();
    for (const routeHandler of routeHandlers) {
      if (page?._closeWasCalled || this._closeWasCalled)
        return;
      if (!routeHandler.matches(route.request().url()))
        continue;
      const index2 = this._routes.indexOf(routeHandler);
      if (index2 === -1)
        continue;
      if (routeHandler.willExpire())
        this._routes.splice(index2, 1);
      const handled = await routeHandler.handle(route);
      if (!this._routes.length)
        this._wrapApiCall(() => this._updateInterceptionPatterns(), true).catch(() => {
        });
      if (handled)
        return;
    }
    await route._innerContinue(
      true
      /* isFallback */
    ).catch(() => {
    });
  }
  async _onWebSocketRoute(webSocketRoute) {
    const routeHandler = this._webSocketRoutes.find((route) => route.matches(webSocketRoute.url()));
    if (routeHandler)
      await routeHandler.handle(webSocketRoute);
    else
      webSocketRoute.connectToServer();
  }
  async _onBinding(bindingCall) {
    const func = this._bindings.get(bindingCall._initializer.name);
    if (!func)
      return;
    await bindingCall.call(func);
  }
  setDefaultNavigationTimeout(timeout) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    this._wrapApiCall(async () => {
      await this._channel.setDefaultNavigationTimeoutNoReply({ timeout });
    }, true).catch(() => {
    });
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
    this._wrapApiCall(async () => {
      await this._channel.setDefaultTimeoutNoReply({ timeout });
    }, true).catch(() => {
    });
  }
  browser() {
    return this._browser;
  }
  pages() {
    return [...this._pages];
  }
  async newPage() {
    if (this._ownerPage)
      throw new Error("Please use browser.newContext()");
    return Page2.from((await this._channel.newPage()).page);
  }
  async cookies(urls) {
    if (!urls)
      urls = [];
    if (urls && typeof urls === "string")
      urls = [urls];
    return (await this._channel.cookies({ urls })).cookies;
  }
  async addCookies(cookies) {
    await this._channel.addCookies({ cookies });
  }
  async clearCookies(options2 = {}) {
    await this._channel.clearCookies({
      name: isString2(options2.name) ? options2.name : void 0,
      nameRegexSource: isRegExp4(options2.name) ? options2.name.source : void 0,
      nameRegexFlags: isRegExp4(options2.name) ? options2.name.flags : void 0,
      domain: isString2(options2.domain) ? options2.domain : void 0,
      domainRegexSource: isRegExp4(options2.domain) ? options2.domain.source : void 0,
      domainRegexFlags: isRegExp4(options2.domain) ? options2.domain.flags : void 0,
      path: isString2(options2.path) ? options2.path : void 0,
      pathRegexSource: isRegExp4(options2.path) ? options2.path.source : void 0,
      pathRegexFlags: isRegExp4(options2.path) ? options2.path.flags : void 0
    });
  }
  async grantPermissions(permissions, options2) {
    await this._channel.grantPermissions({ permissions, ...options2 });
  }
  async clearPermissions() {
    await this._channel.clearPermissions();
  }
  async setGeolocation(geolocation) {
    await this._channel.setGeolocation({ geolocation: geolocation || void 0 });
  }
  async setExtraHTTPHeaders(headers) {
    validateHeaders(headers);
    await this._channel.setExtraHTTPHeaders({ headers: headersObjectToArray(headers) });
  }
  async setOffline(offline) {
    await this._channel.setOffline({ offline });
  }
  async setHTTPCredentials(httpCredentials) {
    await this._channel.setHTTPCredentials({ httpCredentials: httpCredentials || void 0 });
  }
  async addInitScript(script, arg) {
    const source7 = await evaluationScript(this._platform, script, arg);
    await this._channel.addInitScript({ source: source7 });
  }
  async exposeBinding(name, callback, options2 = {}) {
    await this._channel.exposeBinding({ name, needsHandle: options2.handle });
    this._bindings.set(name, callback);
  }
  async exposeFunction(name, callback) {
    await this._channel.exposeBinding({ name });
    const binding3 = /* @__PURE__ */ __name((source7, ...args) => callback(...args), "binding");
    this._bindings.set(name, binding3);
  }
  async route(url4, handler, options2 = {}) {
    this._routes.unshift(new RouteHandler(this._platform, this._options.baseURL, url4, handler, options2.times));
    await this._updateInterceptionPatterns();
  }
  async routeWebSocket(url4, handler) {
    this._webSocketRoutes.unshift(new WebSocketRouteHandler(this._options.baseURL, url4, handler));
    await this._updateWebSocketInterceptionPatterns();
  }
  async _recordIntoHAR(har, page, options2 = {}) {
    const { harId } = await this._channel.harStart({
      page: page?._channel,
      options: prepareRecordHarOptions({
        path: har,
        content: options2.updateContent ?? "attach",
        mode: options2.updateMode ?? "minimal",
        urlFilter: options2.url
      })
    });
    this._harRecorders.set(harId, { path: har, content: options2.updateContent ?? "attach" });
  }
  async routeFromHAR(har, options2 = {}) {
    const localUtils = this._connection.localUtils();
    if (!localUtils)
      throw new Error("Route from har is not supported in thin clients");
    if (options2.update) {
      await this._recordIntoHAR(har, null, options2);
      return;
    }
    const harRouter = await HarRouter.create(localUtils, har, options2.notFound || "abort", { urlMatch: options2.url });
    this._harRouters.push(harRouter);
    await harRouter.addContextRoute(this);
  }
  _disposeHarRouters() {
    this._harRouters.forEach((router) => router.dispose());
    this._harRouters = [];
  }
  async unrouteAll(options2) {
    await this._unrouteInternal(this._routes, [], options2?.behavior);
    this._disposeHarRouters();
  }
  async unroute(url4, handler) {
    const removed = [];
    const remaining = [];
    for (const route of this._routes) {
      if (urlMatchesEqual(route.url, url4) && (!handler || route.handler === handler))
        removed.push(route);
      else
        remaining.push(route);
    }
    await this._unrouteInternal(removed, remaining, "default");
  }
  async _unrouteInternal(removed, remaining, behavior) {
    this._routes = remaining;
    await this._updateInterceptionPatterns();
    if (!behavior || behavior === "default")
      return;
    const promises2 = removed.map((routeHandler) => routeHandler.stop(behavior));
    await Promise.all(promises2);
  }
  async _updateInterceptionPatterns() {
    const patterns = RouteHandler.prepareInterceptionPatterns(this._routes);
    await this._channel.setNetworkInterceptionPatterns({ patterns });
  }
  async _updateWebSocketInterceptionPatterns() {
    const patterns = WebSocketRouteHandler.prepareInterceptionPatterns(this._webSocketRoutes);
    await this._channel.setWebSocketInterceptionPatterns({ patterns });
  }
  _effectiveCloseReason() {
    return this._closeReason || this._browser?._closeReason;
  }
  async waitForEvent(event, optionsOrPredicate = {}) {
    return await this._wrapApiCall(async () => {
      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
      const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
      const waiter = Waiter.createForEvent(this, event);
      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== Events.BrowserContext.Close)
        waiter.rejectOnEvent(this, Events.BrowserContext.Close, () => new TargetClosedError2(this._effectiveCloseReason()));
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }
  async storageState(options2 = {}) {
    const state = await this._channel.storageState({ indexedDB: options2.indexedDB });
    if (options2.path) {
      await mkdirIfNeeded2(this._platform, options2.path);
      await this._platform.fs().promises.writeFile(options2.path, JSON.stringify(state, void 0, 2), "utf8");
    }
    return state;
  }
  backgroundPages() {
    return [...this._backgroundPages];
  }
  serviceWorkers() {
    return [...this._serviceWorkers];
  }
  async newCDPSession(page) {
    if (!(page instanceof Page2) && !(page instanceof Frame2))
      throw new Error("page: expected Page or Frame");
    const result = await this._channel.newCDPSession(page instanceof Page2 ? { page: page._channel } : { frame: page._channel });
    return CDPSession2.from(result.session);
  }
  _onClose() {
    if (this._browser)
      this._browser._contexts.delete(this);
    this._browserType?._contexts?.delete(this);
    this._disposeHarRouters();
    this.tracing._resetStackCounter();
    this.emit(Events.BrowserContext.Close, this);
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async close(options2 = {}) {
    if (this._closeWasCalled)
      return;
    this._closeReason = options2.reason;
    this._closeWasCalled = true;
    await this._wrapApiCall(async () => {
      await this.request.dispose(options2);
    }, true);
    await this._wrapApiCall(async () => {
      await this._browserType?._willCloseContext(this);
      for (const [harId, harParams] of this._harRecorders) {
        const har = await this._channel.harExport({ harId });
        const artifact = Artifact2.from(har.artifact);
        const isCompressed = harParams.content === "attach" || harParams.path.endsWith(".zip");
        const needCompressed = harParams.path.endsWith(".zip");
        if (isCompressed && !needCompressed) {
          const localUtils = this._connection.localUtils();
          if (!localUtils)
            throw new Error("Uncompressed har is not supported in thin clients");
          await artifact.saveAs(harParams.path + ".tmp");
          await localUtils.harUnzip({ zipFile: harParams.path + ".tmp", harFile: harParams.path });
        } else {
          await artifact.saveAs(harParams.path);
        }
        await artifact.delete();
      }
    }, true);
    await this._channel.close(options2);
    await this._closedPromise;
  }
  async _enableRecorder(params) {
    await this._channel.enableRecorder(params);
  }
};
async function prepareStorageState(platform4, options2) {
  if (typeof options2.storageState !== "string")
    return options2.storageState;
  try {
    return JSON.parse(await platform4.fs().promises.readFile(options2.storageState, "utf8"));
  } catch (e) {
    rewriteErrorMessage(e, `Error reading storage state from ${options2.storageState}:
` + e.message);
    throw e;
  }
}
__name(prepareStorageState, "prepareStorageState");
function prepareRecordHarOptions(options2) {
  if (!options2)
    return;
  return {
    path: options2.path,
    content: options2.content || (options2.omitContent ? "omit" : void 0),
    urlGlob: isString2(options2.urlFilter) ? options2.urlFilter : void 0,
    urlRegexSource: isRegExp4(options2.urlFilter) ? options2.urlFilter.source : void 0,
    urlRegexFlags: isRegExp4(options2.urlFilter) ? options2.urlFilter.flags : void 0,
    mode: options2.mode
  };
}
__name(prepareRecordHarOptions, "prepareRecordHarOptions");
async function prepareBrowserContextParams(platform4, options2) {
  if (options2.videoSize && !options2.videosPath)
    throw new Error(`"videoSize" option requires "videosPath" to be specified`);
  if (options2.extraHTTPHeaders)
    validateHeaders(options2.extraHTTPHeaders);
  const contextParams = {
    ...options2,
    viewport: options2.viewport === null ? void 0 : options2.viewport,
    noDefaultViewport: options2.viewport === null,
    extraHTTPHeaders: options2.extraHTTPHeaders ? headersObjectToArray(options2.extraHTTPHeaders) : void 0,
    storageState: await prepareStorageState(platform4, options2),
    serviceWorkers: options2.serviceWorkers,
    recordHar: prepareRecordHarOptions(options2.recordHar),
    colorScheme: options2.colorScheme === null ? "no-override" : options2.colorScheme,
    reducedMotion: options2.reducedMotion === null ? "no-override" : options2.reducedMotion,
    forcedColors: options2.forcedColors === null ? "no-override" : options2.forcedColors,
    contrast: options2.contrast === null ? "no-override" : options2.contrast,
    acceptDownloads: toAcceptDownloadsProtocol(options2.acceptDownloads),
    clientCertificates: await toClientCertificatesProtocol(platform4, options2.clientCertificates)
  };
  if (!contextParams.recordVideo && options2.videosPath) {
    contextParams.recordVideo = {
      dir: options2.videosPath,
      size: options2.videoSize
    };
  }
  if (contextParams.recordVideo && contextParams.recordVideo.dir)
    contextParams.recordVideo.dir = platform4.path().resolve(contextParams.recordVideo.dir);
  return contextParams;
}
__name(prepareBrowserContextParams, "prepareBrowserContextParams");
function toAcceptDownloadsProtocol(acceptDownloads) {
  if (acceptDownloads === void 0)
    return void 0;
  if (acceptDownloads)
    return "accept";
  return "deny";
}
__name(toAcceptDownloadsProtocol, "toAcceptDownloadsProtocol");
async function toClientCertificatesProtocol(platform4, certs) {
  if (!certs)
    return void 0;
  const bufferizeContent = /* @__PURE__ */ __name(async (value, path31) => {
    if (value)
      return value;
    if (path31)
      return await platform4.fs().promises.readFile(path31);
  }, "bufferizeContent");
  return await Promise.all(certs.map(async (cert) => ({
    origin: cert.origin,
    cert: await bufferizeContent(cert.cert, cert.certPath),
    key: await bufferizeContent(cert.key, cert.keyPath),
    pfx: await bufferizeContent(cert.pfx, cert.pfxPath),
    passphrase: cert.passphrase
  })));
}
__name(toClientCertificatesProtocol, "toClientCertificatesProtocol");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/webSocket.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function connectOverWebSocket(parentConnection, params) {
  const localUtils = parentConnection.localUtils();
  const transport = localUtils ? new JsonPipeTransport(localUtils) : new WebSocketTransport2();
  const connectHeaders = await transport.connect(params);
  const connection = new Connection(parentConnection._platform, localUtils, parentConnection._instrumentation, connectHeaders);
  connection.markAsRemote();
  connection.on("close", () => transport.close());
  let closeError;
  const onTransportClosed = /* @__PURE__ */ __name((reason) => {
    connection.close(reason || closeError);
  }, "onTransportClosed");
  transport.onClose((reason) => onTransportClosed(reason));
  connection.onmessage = (message) => transport.send(message).catch(() => onTransportClosed());
  transport.onMessage((message) => {
    try {
      connection.dispatch(message);
    } catch (e) {
      closeError = String(e);
      transport.close().catch(() => {
      });
    }
  });
  return connection;
}
__name(connectOverWebSocket, "connectOverWebSocket");
var JsonPipeTransport = class {
  static {
    __name(this, "JsonPipeTransport");
  }
  constructor(owner) {
    this._owner = owner;
  }
  async connect(params) {
    const { pipe, headers: connectHeaders } = await this._owner._wrapApiCall(
      async () => {
        return await this._owner._channel.connect(params);
      },
      /* isInternal */
      true
    );
    this._pipe = pipe;
    return connectHeaders;
  }
  async send(message) {
    await this._owner._wrapApiCall(
      async () => {
        await this._pipe.send({ message });
      },
      /* isInternal */
      true
    );
  }
  onMessage(callback) {
    this._pipe.on("message", ({ message }) => callback(message));
  }
  onClose(callback) {
    this._pipe.on("closed", ({ reason }) => callback(reason));
  }
  async close() {
    await this._owner._wrapApiCall(
      async () => {
        await this._pipe.close().catch(() => {
        });
      },
      /* isInternal */
      true
    );
  }
};
var WebSocketTransport2 = class {
  static {
    __name(this, "WebSocketTransport");
  }
  async connect(params) {
    this._ws = new window.WebSocket(params.wsEndpoint);
    return [];
  }
  async send(message) {
    this._ws.send(JSON.stringify(message));
  }
  onMessage(callback) {
    this._ws.addEventListener("message", (event) => callback(JSON.parse(event.data)));
  }
  onClose(callback) {
    this._ws.addEventListener("close", () => callback());
  }
  async close() {
    this._ws.close();
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/android.js
var Android2 = class extends ChannelOwner {
  static {
    __name(this, "Android");
  }
  static from(android) {
    return android._object;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._timeoutSettings = new TimeoutSettings2(this._platform);
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
    this._wrapApiCall(async () => {
      await this._channel.setDefaultTimeoutNoReply({ timeout });
    }, true).catch(() => {
    });
  }
  async devices(options2 = {}) {
    const { devices: devices2 } = await this._channel.devices(options2);
    return devices2.map((d) => AndroidDevice2.from(d));
  }
  async launchServer(options2 = {}) {
    if (!this._serverLauncher)
      throw new Error("Launching server is not supported");
    return await this._serverLauncher.launchServer(options2);
  }
  async connect(wsEndpoint, options2 = {}) {
    return await this._wrapApiCall(async () => {
      const deadline = options2.timeout ? monotonicTime() + options2.timeout : 0;
      const headers = { "x-playwright-browser": "android", ...options2.headers };
      const connectParams = { wsEndpoint, headers, slowMo: options2.slowMo, timeout: options2.timeout };
      const connection = await connectOverWebSocket(this._connection, connectParams);
      let device;
      connection.on("close", () => {
        device?._didClose();
      });
      const result = await raceAgainstDeadline(async () => {
        const playwright2 = await connection.initializePlaywright();
        if (!playwright2._initializer.preConnectedAndroidDevice) {
          connection.close();
          throw new Error("Malformed endpoint. Did you use Android.launchServer method?");
        }
        device = AndroidDevice2.from(playwright2._initializer.preConnectedAndroidDevice);
        device._shouldCloseConnectionOnClose = true;
        device.on(Events.AndroidDevice.Close, () => connection.close());
        return device;
      }, deadline);
      if (!result.timedOut) {
        return result.result;
      } else {
        connection.close();
        throw new Error(`Timeout ${options2.timeout}ms exceeded`);
      }
    });
  }
};
var AndroidDevice2 = class extends ChannelOwner {
  static {
    __name(this, "AndroidDevice");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._webViews = /* @__PURE__ */ new Map();
    this._shouldCloseConnectionOnClose = false;
    this.input = new AndroidInput(this);
    this._timeoutSettings = new TimeoutSettings2(this._platform, parent._timeoutSettings);
    this._channel.on("webViewAdded", ({ webView }) => this._onWebViewAdded(webView));
    this._channel.on("webViewRemoved", ({ socketName }) => this._onWebViewRemoved(socketName));
    this._channel.on("close", () => this._didClose());
  }
  static from(androidDevice) {
    return androidDevice._object;
  }
  _onWebViewAdded(webView) {
    const view = new AndroidWebView(this, webView);
    this._webViews.set(webView.socketName, view);
    this.emit(Events.AndroidDevice.WebView, view);
  }
  _onWebViewRemoved(socketName) {
    const view = this._webViews.get(socketName);
    this._webViews.delete(socketName);
    if (view)
      view.emit(Events.AndroidWebView.Close);
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
    this._wrapApiCall(async () => {
      await this._channel.setDefaultTimeoutNoReply({ timeout });
    }, true).catch(() => {
    });
  }
  serial() {
    return this._initializer.serial;
  }
  model() {
    return this._initializer.model;
  }
  webViews() {
    return [...this._webViews.values()];
  }
  async webView(selector, options2) {
    const predicate = /* @__PURE__ */ __name((v) => {
      if (selector.pkg)
        return v.pkg() === selector.pkg;
      if (selector.socketName)
        return v._socketName() === selector.socketName;
      return false;
    }, "predicate");
    const webView = [...this._webViews.values()].find(predicate);
    if (webView)
      return webView;
    return await this.waitForEvent("webview", { ...options2, predicate });
  }
  async wait(selector, options2) {
    await this._channel.wait({ selector: toSelectorChannel(selector), ...options2 });
  }
  async fill(selector, text, options2) {
    await this._channel.fill({ selector: toSelectorChannel(selector), text, ...options2 });
  }
  async press(selector, key, options2) {
    await this.tap(selector, options2);
    await this.input.press(key);
  }
  async tap(selector, options2) {
    await this._channel.tap({ selector: toSelectorChannel(selector), ...options2 });
  }
  async drag(selector, dest, options2) {
    await this._channel.drag({ selector: toSelectorChannel(selector), dest, ...options2 });
  }
  async fling(selector, direction, options2) {
    await this._channel.fling({ selector: toSelectorChannel(selector), direction, ...options2 });
  }
  async longTap(selector, options2) {
    await this._channel.longTap({ selector: toSelectorChannel(selector), ...options2 });
  }
  async pinchClose(selector, percent, options2) {
    await this._channel.pinchClose({ selector: toSelectorChannel(selector), percent, ...options2 });
  }
  async pinchOpen(selector, percent, options2) {
    await this._channel.pinchOpen({ selector: toSelectorChannel(selector), percent, ...options2 });
  }
  async scroll(selector, direction, percent, options2) {
    await this._channel.scroll({ selector: toSelectorChannel(selector), direction, percent, ...options2 });
  }
  async swipe(selector, direction, percent, options2) {
    await this._channel.swipe({ selector: toSelectorChannel(selector), direction, percent, ...options2 });
  }
  async info(selector) {
    return (await this._channel.info({ selector: toSelectorChannel(selector) })).info;
  }
  async screenshot(options2 = {}) {
    const { binary: binary2 } = await this._channel.screenshot();
    if (options2.path)
      await this._platform.fs().promises.writeFile(options2.path, binary2);
    return binary2;
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async close() {
    try {
      if (this._shouldCloseConnectionOnClose)
        this._connection.close();
      else
        await this._channel.close();
    } catch (e) {
      if (isTargetClosedError2(e))
        return;
      throw e;
    }
  }
  _didClose() {
    this.emit(Events.AndroidDevice.Close, this);
  }
  async shell(command2) {
    const { result } = await this._channel.shell({ command: command2 });
    return result;
  }
  async open(command2) {
    return AndroidSocket.from((await this._channel.open({ command: command2 })).socket);
  }
  async installApk(file, options2) {
    await this._channel.installApk({ file: await loadFile(this._platform, file), args: options2 && options2.args });
  }
  async push(file, path31, options2) {
    await this._channel.push({ file: await loadFile(this._platform, file), path: path31, mode: options2 ? options2.mode : void 0 });
  }
  async launchBrowser(options2 = {}) {
    const contextOptions = await prepareBrowserContextParams(this._platform, options2);
    const result = await this._channel.launchBrowser(contextOptions);
    const context2 = BrowserContext2.from(result.context);
    context2._setOptions(contextOptions, {});
    return context2;
  }
  async waitForEvent(event, optionsOrPredicate = {}) {
    return await this._wrapApiCall(async () => {
      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
      const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
      const waiter = Waiter.createForEvent(this, event);
      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== Events.AndroidDevice.Close)
        waiter.rejectOnEvent(this, Events.AndroidDevice.Close, () => new TargetClosedError2());
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }
};
var AndroidSocket = class extends ChannelOwner {
  static {
    __name(this, "AndroidSocket");
  }
  static from(androidDevice) {
    return androidDevice._object;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._channel.on("data", ({ data }) => this.emit(Events.AndroidSocket.Data, data));
    this._channel.on("close", () => this.emit(Events.AndroidSocket.Close));
  }
  async write(data) {
    await this._channel.write({ data });
  }
  async close() {
    await this._channel.close();
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
};
async function loadFile(platform4, file) {
  if (isString2(file))
    return await platform4.fs().promises.readFile(file);
  return file;
}
__name(loadFile, "loadFile");
var AndroidInput = class {
  static {
    __name(this, "AndroidInput");
  }
  constructor(device) {
    this._device = device;
  }
  async type(text) {
    await this._device._channel.inputType({ text });
  }
  async press(key) {
    await this._device._channel.inputPress({ key });
  }
  async tap(point) {
    await this._device._channel.inputTap({ point });
  }
  async swipe(from, segments, steps) {
    await this._device._channel.inputSwipe({ segments, steps });
  }
  async drag(from, to, steps) {
    await this._device._channel.inputDrag({ from, to, steps });
  }
};
function toSelectorChannel(selector) {
  const {
    checkable,
    checked,
    clazz,
    clickable,
    depth,
    desc,
    enabled,
    focusable,
    focused,
    hasChild,
    hasDescendant,
    longClickable,
    pkg,
    res,
    scrollable,
    selected,
    text
  } = selector;
  const toRegex = /* @__PURE__ */ __name((value) => {
    if (value === void 0)
      return void 0;
    if (isRegExp4(value))
      return value.source;
    return "^" + value.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") + "$";
  }, "toRegex");
  return {
    checkable,
    checked,
    clazz: toRegex(clazz),
    pkg: toRegex(pkg),
    desc: toRegex(desc),
    res: toRegex(res),
    text: toRegex(text),
    clickable,
    depth,
    enabled,
    focusable,
    focused,
    hasChild: hasChild ? { selector: toSelectorChannel(hasChild.selector) } : void 0,
    hasDescendant: hasDescendant ? { selector: toSelectorChannel(hasDescendant.selector), maxDepth: hasDescendant.maxDepth } : void 0,
    longClickable,
    scrollable,
    selected
  };
}
__name(toSelectorChannel, "toSelectorChannel");
var AndroidWebView = class extends EventEmitter18 {
  static {
    __name(this, "AndroidWebView");
  }
  constructor(device, data) {
    super(device._platform);
    this._device = device;
    this._data = data;
  }
  pid() {
    return this._data.pid;
  }
  pkg() {
    return this._data.pkg;
  }
  _socketName() {
    return this._data.socketName;
  }
  async page() {
    if (!this._pagePromise)
      this._pagePromise = this._fetchPage();
    return await this._pagePromise;
  }
  async _fetchPage() {
    const { context: context2 } = await this._device._channel.connectToWebView({ socketName: this._data.socketName });
    return BrowserContext2.from(context2).pages()[0];
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/browserType.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BrowserType2 = class extends ChannelOwner {
  static {
    __name(this, "BrowserType");
  }
  constructor() {
    super(...arguments);
    this._contexts = /* @__PURE__ */ new Set();
  }
  static from(browserType) {
    return browserType._object;
  }
  executablePath() {
    if (!this._initializer.executablePath)
      throw new Error("Browser is not supported on current platform");
    return this._initializer.executablePath;
  }
  name() {
    return this._initializer.name;
  }
  async launch(options2 = {}) {
    assert3(!options2.userDataDir, "userDataDir option is not supported in `browserType.launch`. Use `browserType.launchPersistentContext` instead");
    assert3(!options2.port, "Cannot specify a port without launching as a server.");
    const logger = options2.logger || this._playwright._defaultLaunchOptions?.logger;
    options2 = { ...this._playwright._defaultLaunchOptions, ...options2 };
    const launchOptions = {
      ...options2,
      ignoreDefaultArgs: Array.isArray(options2.ignoreDefaultArgs) ? options2.ignoreDefaultArgs : void 0,
      ignoreAllDefaultArgs: !!options2.ignoreDefaultArgs && !Array.isArray(options2.ignoreDefaultArgs),
      env: options2.env ? envObjectToArray2(options2.env) : void 0
    };
    return await this._wrapApiCall(async () => {
      const browser3 = Browser2.from((await this._channel.launch(launchOptions)).browser);
      this._didLaunchBrowser(browser3, options2, logger);
      return browser3;
    });
  }
  async launchServer(options2 = {}) {
    if (!this._serverLauncher)
      throw new Error("Launching server is not supported");
    options2 = { ...this._playwright._defaultLaunchOptions, ...options2 };
    return await this._serverLauncher.launchServer(options2);
  }
  async launchPersistentContext(userDataDir, options2 = {}) {
    const logger = options2.logger || this._playwright._defaultLaunchOptions?.logger;
    assert3(!options2.port, "Cannot specify a port without launching as a server.");
    options2 = { ...this._playwright._defaultLaunchOptions, ...this._playwright._defaultContextOptions, ...options2 };
    const contextParams = await prepareBrowserContextParams(this._platform, options2);
    const persistentParams = {
      ...contextParams,
      ignoreDefaultArgs: Array.isArray(options2.ignoreDefaultArgs) ? options2.ignoreDefaultArgs : void 0,
      ignoreAllDefaultArgs: !!options2.ignoreDefaultArgs && !Array.isArray(options2.ignoreDefaultArgs),
      env: options2.env ? envObjectToArray2(options2.env) : void 0,
      channel: options2.channel,
      userDataDir: this._platform.path().isAbsolute(userDataDir) || !userDataDir ? userDataDir : this._platform.path().resolve(userDataDir)
    };
    return await this._wrapApiCall(async () => {
      const result = await this._channel.launchPersistentContext(persistentParams);
      const context2 = BrowserContext2.from(result.context);
      await this._didCreateContext(context2, contextParams, options2, logger);
      return context2;
    });
  }
  async connect(optionsOrWsEndpoint, options2) {
    if (typeof optionsOrWsEndpoint === "string")
      return await this._connect({ ...options2, wsEndpoint: optionsOrWsEndpoint });
    assert3(optionsOrWsEndpoint.wsEndpoint, "options.wsEndpoint is required");
    return await this._connect(optionsOrWsEndpoint);
  }
  async _connect(params) {
    const logger = params.logger;
    return await this._wrapApiCall(async () => {
      const deadline = params.timeout ? monotonicTime() + params.timeout : 0;
      const headers = { "x-playwright-browser": this.name(), ...params.headers };
      const connectParams = {
        wsEndpoint: params.wsEndpoint,
        headers,
        exposeNetwork: params.exposeNetwork ?? params._exposeNetwork,
        slowMo: params.slowMo,
        timeout: params.timeout
      };
      if (params.__testHookRedirectPortForwarding)
        connectParams.socksProxyRedirectPortForTest = params.__testHookRedirectPortForwarding;
      const connection = await connectOverWebSocket(this._connection, connectParams);
      let browser3;
      connection.on("close", () => {
        for (const context2 of browser3?.contexts() || []) {
          for (const page of context2.pages())
            page._onClose();
          context2._onClose();
        }
        setTimeout(() => browser3?._didClose(), 0);
      });
      const result = await raceAgainstDeadline(async () => {
        if (params.__testHookBeforeCreateBrowser)
          await params.__testHookBeforeCreateBrowser();
        const playwright2 = await connection.initializePlaywright();
        if (!playwright2._initializer.preLaunchedBrowser) {
          connection.close();
          throw new Error("Malformed endpoint. Did you use BrowserType.launchServer method?");
        }
        playwright2._setSelectors(this._playwright.selectors);
        browser3 = Browser2.from(playwright2._initializer.preLaunchedBrowser);
        this._didLaunchBrowser(browser3, {}, logger);
        browser3._shouldCloseConnectionOnClose = true;
        browser3.on(Events.Browser.Disconnected, () => connection.close());
        return browser3;
      }, deadline);
      if (!result.timedOut) {
        return result.result;
      } else {
        connection.close();
        throw new Error(`Timeout ${params.timeout}ms exceeded`);
      }
    });
  }
  async connectOverCDP(endpointURLOrOptions, options2) {
    if (typeof endpointURLOrOptions === "string")
      return await this._connectOverCDP(endpointURLOrOptions, options2);
    const endpointURL = "endpointURL" in endpointURLOrOptions ? endpointURLOrOptions.endpointURL : endpointURLOrOptions.wsEndpoint;
    assert3(endpointURL, "Cannot connect over CDP without wsEndpoint.");
    return await this.connectOverCDP(endpointURL, endpointURLOrOptions);
  }
  async _connectOverCDP(endpointURL, params = {}) {
    if (this.name() !== "chromium")
      throw new Error("Connecting over CDP is only supported in Chromium.");
    const headers = params.headers ? headersObjectToArray(params.headers) : void 0;
    const result = await this._channel.connectOverCDP({
      endpointURL,
      headers,
      slowMo: params.slowMo,
      timeout: params.timeout
    });
    const browser3 = Browser2.from(result.browser);
    this._didLaunchBrowser(browser3, {}, params.logger);
    if (result.defaultContext)
      await this._didCreateContext(BrowserContext2.from(result.defaultContext), {}, {}, params.logger);
    return browser3;
  }
  _didLaunchBrowser(browser3, browserOptions, logger) {
    browser3._browserType = this;
    browser3._options = browserOptions;
    browser3._logger = logger;
  }
  async _didCreateContext(context2, contextOptions, browserOptions, logger) {
    context2._logger = logger;
    context2._browserType = this;
    this._contexts.add(context2);
    context2._setOptions(contextOptions, browserOptions);
    if (this._playwright._defaultContextTimeout !== void 0)
      context2.setDefaultTimeout(this._playwright._defaultContextTimeout);
    if (this._playwright._defaultContextNavigationTimeout !== void 0)
      context2.setDefaultNavigationTimeout(this._playwright._defaultContextNavigationTimeout);
    await this._instrumentation.runAfterCreateBrowserContext(context2);
  }
  async _willCloseContext(context2) {
    this._contexts.delete(context2);
    await this._instrumentation.runBeforeCloseBrowserContext(context2);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/clientInstrumentation.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function createInstrumentation2() {
  const listeners2 = [];
  return new Proxy({}, {
    get: /* @__PURE__ */ __name((obj, prop) => {
      if (typeof prop !== "string")
        return obj[prop];
      if (prop === "addListener")
        return (listener) => listeners2.push(listener);
      if (prop === "removeListener")
        return (listener) => listeners2.splice(listeners2.indexOf(listener), 1);
      if (prop === "removeAllListeners")
        return () => listeners2.splice(0, listeners2.length);
      if (prop.startsWith("run")) {
        return async (...params) => {
          for (const listener of listeners2)
            await listener[prop]?.(...params);
        };
      }
      if (prop.startsWith("on")) {
        return (...params) => {
          for (const listener of listeners2)
            listener[prop]?.(...params);
        };
      }
      return obj[prop];
    }, "get")
  });
}
__name(createInstrumentation2, "createInstrumentation");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/electron.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Electron2 = class extends ChannelOwner {
  static {
    __name(this, "Electron");
  }
  static from(electron) {
    return electron._object;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
  }
  async launch(options2 = {}) {
    const params = {
      ...await prepareBrowserContextParams(this._platform, options2),
      env: envObjectToArray2(options2.env ? options2.env : this._platform.env),
      tracesDir: options2.tracesDir
    };
    const app = ElectronApplication2.from((await this._channel.launch(params)).electronApplication);
    app._context._setOptions(params, options2);
    return app;
  }
};
var ElectronApplication2 = class extends ChannelOwner {
  static {
    __name(this, "ElectronApplication");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this._windows = /* @__PURE__ */ new Set();
    this._timeoutSettings = new TimeoutSettings2(this._platform);
    this._context = BrowserContext2.from(initializer.context);
    for (const page of this._context._pages)
      this._onPage(page);
    this._context.on(Events.BrowserContext.Page, (page) => this._onPage(page));
    this._channel.on("close", () => {
      this.emit(Events.ElectronApplication.Close);
    });
    this._channel.on("console", (event) => this.emit(Events.ElectronApplication.Console, new ConsoleMessage2(this._platform, event)));
    this._setEventToSubscriptionMapping(/* @__PURE__ */ new Map([
      [Events.ElectronApplication.Console, "console"]
    ]));
  }
  static from(electronApplication) {
    return electronApplication._object;
  }
  process() {
    return this._toImpl().process();
  }
  _onPage(page) {
    this._windows.add(page);
    this.emit(Events.ElectronApplication.Window, page);
    page.once(Events.Page.Close, () => this._windows.delete(page));
  }
  windows() {
    return [...this._windows];
  }
  async firstWindow(options2) {
    if (this._windows.size)
      return this._windows.values().next().value;
    return await this.waitForEvent("window", options2);
  }
  context() {
    return this._context;
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async close() {
    try {
      await this._context.close();
    } catch (e) {
      if (isTargetClosedError2(e))
        return;
      throw e;
    }
  }
  async waitForEvent(event, optionsOrPredicate = {}) {
    return await this._wrapApiCall(async () => {
      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
      const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
      const waiter = Waiter.createForEvent(this, event);
      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== Events.ElectronApplication.Close)
        waiter.rejectOnEvent(this, Events.ElectronApplication.Close, () => new TargetClosedError2());
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }
  async browserWindow(page) {
    const result = await this._channel.browserWindow({ page: page._channel });
    return JSHandle2.from(result.handle);
  }
  async evaluate(pageFunction, arg) {
    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async evaluateHandle(pageFunction, arg) {
    const result = await this._channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return JSHandle2.from(result.handle);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/jsonPipe.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JsonPipe = class extends ChannelOwner {
  static {
    __name(this, "JsonPipe");
  }
  static from(jsonPipe) {
    return jsonPipe._object;
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
  }
  channel() {
    return this._channel;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/localUtils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var LocalUtils = class extends ChannelOwner {
  static {
    __name(this, "LocalUtils");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this.markAsInternalType();
    this.devices = {};
    for (const { name, descriptor } of initializer.deviceDescriptors)
      this.devices[name] = descriptor;
  }
  async zip(params) {
    return await this._channel.zip(params);
  }
  async harOpen(params) {
    return await this._channel.harOpen(params);
  }
  async harLookup(params) {
    return await this._channel.harLookup(params);
  }
  async harClose(params) {
    return await this._channel.harClose(params);
  }
  async harUnzip(params) {
    return await this._channel.harUnzip(params);
  }
  async tracingStarted(params) {
    return await this._channel.tracingStarted(params);
  }
  async traceDiscarded(params) {
    return await this._channel.traceDiscarded(params);
  }
  async addStackToTracingNoReply(params) {
    return await this._channel.addStackToTracingNoReply(params);
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/playwright.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/selectors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/platform.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/utils/isomorphic/colors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var webColors = {
  enabled: true,
  reset: /* @__PURE__ */ __name((text) => applyStyle(0, 0, text), "reset"),
  bold: /* @__PURE__ */ __name((text) => applyStyle(1, 22, text), "bold"),
  dim: /* @__PURE__ */ __name((text) => applyStyle(2, 22, text), "dim"),
  italic: /* @__PURE__ */ __name((text) => applyStyle(3, 23, text), "italic"),
  underline: /* @__PURE__ */ __name((text) => applyStyle(4, 24, text), "underline"),
  inverse: /* @__PURE__ */ __name((text) => applyStyle(7, 27, text), "inverse"),
  hidden: /* @__PURE__ */ __name((text) => applyStyle(8, 28, text), "hidden"),
  strikethrough: /* @__PURE__ */ __name((text) => applyStyle(9, 29, text), "strikethrough"),
  black: /* @__PURE__ */ __name((text) => applyStyle(30, 39, text), "black"),
  red: /* @__PURE__ */ __name((text) => applyStyle(31, 39, text), "red"),
  green: /* @__PURE__ */ __name((text) => applyStyle(32, 39, text), "green"),
  yellow: /* @__PURE__ */ __name((text) => applyStyle(33, 39, text), "yellow"),
  blue: /* @__PURE__ */ __name((text) => applyStyle(34, 39, text), "blue"),
  magenta: /* @__PURE__ */ __name((text) => applyStyle(35, 39, text), "magenta"),
  cyan: /* @__PURE__ */ __name((text) => applyStyle(36, 39, text), "cyan"),
  white: /* @__PURE__ */ __name((text) => applyStyle(37, 39, text), "white"),
  gray: /* @__PURE__ */ __name((text) => applyStyle(90, 39, text), "gray"),
  grey: /* @__PURE__ */ __name((text) => applyStyle(90, 39, text), "grey")
};
var applyStyle = /* @__PURE__ */ __name((open6, close3, text) => `\x1B[${open6}m${text}\x1B[${close3}m`, "applyStyle");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/platform.js
var noopZone = {
  push: /* @__PURE__ */ __name(() => noopZone, "push"),
  pop: /* @__PURE__ */ __name(() => noopZone, "pop"),
  run: /* @__PURE__ */ __name((func) => func(), "run"),
  data: /* @__PURE__ */ __name(() => void 0, "data")
};
var emptyPlatform = {
  name: "empty",
  boxedStackPrefixes: /* @__PURE__ */ __name(() => [], "boxedStackPrefixes"),
  calculateSha1: /* @__PURE__ */ __name(async () => {
    throw new Error("Not implemented");
  }, "calculateSha1"),
  colors: webColors,
  createGuid: /* @__PURE__ */ __name(() => {
    throw new Error("Not implemented");
  }, "createGuid"),
  defaultMaxListeners: /* @__PURE__ */ __name(() => 10, "defaultMaxListeners"),
  env: {},
  fs: /* @__PURE__ */ __name(() => {
    throw new Error("Not implemented");
  }, "fs"),
  inspectCustom: void 0,
  isDebugMode: /* @__PURE__ */ __name(() => false, "isDebugMode"),
  isJSDebuggerAttached: /* @__PURE__ */ __name(() => false, "isJSDebuggerAttached"),
  isLogEnabled(name) {
    return false;
  },
  isUnderTest: /* @__PURE__ */ __name(() => false, "isUnderTest"),
  log(name, message) {
  },
  path: /* @__PURE__ */ __name(() => {
    throw new Error("Function not implemented.");
  }, "path"),
  pathSeparator: "/",
  showInternalStackFrames: /* @__PURE__ */ __name(() => false, "showInternalStackFrames"),
  streamFile(path31, writable) {
    throw new Error("Streams are not available");
  },
  streamReadable: /* @__PURE__ */ __name((channel2) => {
    throw new Error("Streams are not available");
  }, "streamReadable"),
  streamWritable: /* @__PURE__ */ __name((channel2) => {
    throw new Error("Streams are not available");
  }, "streamWritable"),
  zones: { empty: noopZone, current: /* @__PURE__ */ __name(() => noopZone, "current") }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/selectors.js
var platform3 = emptyPlatform;
function setPlatformForSelectors(p) {
  platform3 = p;
}
__name(setPlatformForSelectors, "setPlatformForSelectors");
var Selectors2 = class {
  static {
    __name(this, "Selectors");
  }
  constructor() {
    this._channels = /* @__PURE__ */ new Set();
    this._registrations = [];
  }
  async register(name, script, options2 = {}) {
    const source7 = await evaluationScript(platform3, script, void 0, false);
    const params = { ...options2, name, source: source7 };
    for (const channel2 of this._channels)
      await channel2._channel.register(params);
    this._registrations.push(params);
  }
  setTestIdAttribute(attributeName) {
    setTestIdAttribute(attributeName);
    for (const channel2 of this._channels)
      channel2._channel.setTestIdAttributeName({ testIdAttributeName: attributeName }).catch(() => {
      });
  }
  _addChannel(channel2) {
    this._channels.add(channel2);
    for (const params of this._registrations) {
      channel2._channel.register(params).catch(() => {
      });
      channel2._channel.setTestIdAttributeName({ testIdAttributeName: testIdAttributeName() }).catch(() => {
      });
    }
  }
  _removeChannel(channel2) {
    this._channels.delete(channel2);
  }
};
var SelectorsOwner = class extends ChannelOwner {
  static {
    __name(this, "SelectorsOwner");
  }
  static from(browser3) {
    return browser3._object;
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/playwright.js
var Playwright2 = class extends ChannelOwner {
  static {
    __name(this, "Playwright");
  }
  constructor(parent, type2, guid, initializer) {
    super(parent, type2, guid, initializer);
    this.request = new APIRequest(this);
    this.chromium = BrowserType2.from(initializer.chromium);
    this.chromium._playwright = this;
    this.firefox = BrowserType2.from(initializer.firefox);
    this.firefox._playwright = this;
    this.webkit = BrowserType2.from(initializer.webkit);
    this.webkit._playwright = this;
    this._android = Android2.from(initializer.android);
    this._electron = Electron2.from(initializer.electron);
    this._bidiChromium = BrowserType2.from(initializer.bidiChromium);
    this._bidiChromium._playwright = this;
    this._bidiFirefox = BrowserType2.from(initializer.bidiFirefox);
    this._bidiFirefox._playwright = this;
    this.devices = this._connection.localUtils()?.devices ?? {};
    this.selectors = new Selectors2();
    this.errors = { TimeoutError: TimeoutError2 };
    const selectorsOwner = SelectorsOwner.from(initializer.selectors);
    this.selectors._addChannel(selectorsOwner);
    this._connection.on("close", () => {
      this.selectors._removeChannel(selectorsOwner);
    });
    global._playwrightInstance = this;
  }
  _setSelectors(selectors2) {
    const selectorsOwner = SelectorsOwner.from(this._initializer.selectors);
    this.selectors._removeChannel(selectorsOwner);
    this.selectors = selectors2;
    this.selectors._addChannel(selectorsOwner);
  }
  static from(channel2) {
    return channel2._object;
  }
  _browserTypes() {
    return [this.chromium, this.firefox, this.webkit, this._bidiChromium, this._bidiFirefox];
  }
  _preLaunchedBrowser() {
    const browser3 = Browser2.from(this._initializer.preLaunchedBrowser);
    browser3._browserType = this[browser3._name];
    return browser3;
  }
  _allContexts() {
    return this._browserTypes().flatMap((type2) => [...type2._contexts]);
  }
  _allPages() {
    return this._allContexts().flatMap((context2) => context2.pages());
  }
};

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/client/connection.js
var Root = class extends ChannelOwner {
  static {
    __name(this, "Root");
  }
  constructor(connection) {
    super(connection, "Root", "", {});
  }
  async initialize() {
    return Playwright2.from((await this._channel.initialize({
      sdkLanguage: "javascript"
    })).playwright);
  }
};
var DummyChannelOwner = class extends ChannelOwner {
  static {
    __name(this, "DummyChannelOwner");
  }
};
var Connection = class extends EventEmitter18 {
  static {
    __name(this, "Connection");
  }
  constructor(platform4, localUtils, instrumentation, headers = []) {
    super(platform4);
    this._objects = /* @__PURE__ */ new Map();
    this.onmessage = (message) => {
    };
    this._lastId = 0;
    this._callbacks = /* @__PURE__ */ new Map();
    this._isRemote = false;
    this._rawBuffers = false;
    this._tracingCount = 0;
    this._instrumentation = instrumentation || createInstrumentation2();
    this._localUtils = localUtils;
    this._rootObject = new Root(this);
    this.headers = headers;
  }
  markAsRemote() {
    this._isRemote = true;
  }
  isRemote() {
    return this._isRemote;
  }
  useRawBuffers() {
    this._rawBuffers = true;
  }
  rawBuffers() {
    return this._rawBuffers;
  }
  localUtils() {
    return this._localUtils;
  }
  async initializePlaywright() {
    return await this._rootObject.initialize();
  }
  getObjectWithKnownName(guid) {
    return this._objects.get(guid);
  }
  setIsTracing(isTracing) {
    if (isTracing)
      this._tracingCount++;
    else
      this._tracingCount--;
  }
  async sendMessageToServer(object, method, params, apiName, frames, stepId) {
    if (this._closedError)
      throw this._closedError;
    if (object._wasCollected)
      throw new Error("The object has been collected to prevent unbounded heap growth.");
    const guid = object._guid;
    const type2 = object._type;
    const id = ++this._lastId;
    const message = { id, guid, method, params };
    if (this._platform.isLogEnabled("channel")) {
      this._platform.log("channel", "SEND> " + JSON.stringify(message));
    }
    const location2 = frames[0] ? { file: frames[0].file, line: frames[0].line, column: frames[0].column } : void 0;
    const metadata = { apiName, location: location2, internal: !apiName, stepId };
    if (this._tracingCount && frames && type2 !== "LocalUtils")
      this._localUtils?.addStackToTracingNoReply({ callData: { stack: frames, id } }).catch(() => {
      });
    this._platform.zones.empty.run(() => this.onmessage({ ...message, metadata }));
    return await new Promise((resolve, reject) => this._callbacks.set(id, { resolve, reject, apiName, type: type2, method }));
  }
  _validatorFromWireContext() {
    return {
      tChannelImpl: this._tChannelImplFromWire.bind(this),
      binary: this._rawBuffers ? "buffer" : "fromBase64",
      isUnderTest: /* @__PURE__ */ __name(() => this._platform.isUnderTest(), "isUnderTest")
    };
  }
  dispatch(message) {
    if (this._closedError)
      return;
    const { id, guid, method, params, result, error: error4, log: log4 } = message;
    if (id) {
      if (this._platform.isLogEnabled("channel"))
        this._platform.log("channel", "<RECV " + JSON.stringify(message));
      const callback = this._callbacks.get(id);
      if (!callback)
        throw new Error(`Cannot find command to respond: ${id}`);
      this._callbacks.delete(id);
      if (error4 && !result) {
        const parsedError = parseError2(error4);
        rewriteErrorMessage(parsedError, parsedError.message + formatCallLog(this._platform, log4));
        callback.reject(parsedError);
      } else {
        const validator2 = findValidator(callback.type, callback.method, "Result");
        callback.resolve(validator2(result, "", this._validatorFromWireContext()));
      }
      return;
    }
    if (this._platform.isLogEnabled("channel"))
      this._platform.log("channel", "<EVENT " + JSON.stringify(message));
    if (method === "__create__") {
      this._createRemoteObject(guid, params.type, params.guid, params.initializer);
      return;
    }
    const object = this._objects.get(guid);
    if (!object)
      throw new Error(`Cannot find object to "${method}": ${guid}`);
    if (method === "__adopt__") {
      const child = this._objects.get(params.guid);
      if (!child)
        throw new Error(`Unknown new child: ${params.guid}`);
      object._adopt(child);
      return;
    }
    if (method === "__dispose__") {
      object._dispose(params.reason);
      return;
    }
    const validator = findValidator(object._type, method, "Event");
    object._channel.emit(method, validator(params, "", this._validatorFromWireContext()));
  }
  close(cause) {
    if (this._closedError)
      return;
    this._closedError = new TargetClosedError2(cause);
    for (const callback of this._callbacks.values())
      callback.reject(this._closedError);
    this._callbacks.clear();
    this.emit("close");
  }
  _tChannelImplFromWire(names, arg, path31, context2) {
    if (arg && typeof arg === "object" && typeof arg.guid === "string") {
      const object = this._objects.get(arg.guid);
      if (!object)
        throw new Error(`Object with guid ${arg.guid} was not bound in the connection`);
      if (names !== "*" && !names.includes(object._type))
        throw new ValidationError(`${path31}: expected channel ${names.toString()}`);
      return object._channel;
    }
    throw new ValidationError(`${path31}: expected channel ${names.toString()}`);
  }
  _createRemoteObject(parentGuid, type2, guid, initializer) {
    const parent = this._objects.get(parentGuid);
    if (!parent)
      throw new Error(`Cannot find parent object ${parentGuid} to create ${guid}`);
    let result;
    const validator = findValidator(type2, "", "Initializer");
    initializer = validator(initializer, "", this._validatorFromWireContext());
    switch (type2) {
      case "Android":
        result = new Android2(parent, type2, guid, initializer);
        break;
      case "AndroidSocket":
        result = new AndroidSocket(parent, type2, guid, initializer);
        break;
      case "AndroidDevice":
        result = new AndroidDevice2(parent, type2, guid, initializer);
        break;
      case "APIRequestContext":
        result = new APIRequestContext2(parent, type2, guid, initializer);
        break;
      case "Artifact":
        result = new Artifact2(parent, type2, guid, initializer);
        break;
      case "BindingCall":
        result = new BindingCall(parent, type2, guid, initializer);
        break;
      case "Browser":
        result = new Browser2(parent, type2, guid, initializer);
        break;
      case "BrowserContext":
        result = new BrowserContext2(parent, type2, guid, initializer);
        break;
      case "BrowserType":
        result = new BrowserType2(parent, type2, guid, initializer);
        break;
      case "CDPSession":
        result = new CDPSession2(parent, type2, guid, initializer);
        break;
      case "Dialog":
        result = new Dialog2(parent, type2, guid, initializer);
        break;
      case "Electron":
        result = new Electron2(parent, type2, guid, initializer);
        break;
      case "ElectronApplication":
        result = new ElectronApplication2(parent, type2, guid, initializer);
        break;
      case "ElementHandle":
        result = new ElementHandle2(parent, type2, guid, initializer);
        break;
      case "Frame":
        result = new Frame2(parent, type2, guid, initializer);
        break;
      case "JSHandle":
        result = new JSHandle2(parent, type2, guid, initializer);
        break;
      case "JsonPipe":
        result = new JsonPipe(parent, type2, guid, initializer);
        break;
      case "LocalUtils":
        result = new LocalUtils(parent, type2, guid, initializer);
        if (!this._localUtils)
          this._localUtils = result;
        break;
      case "Page":
        result = new Page2(parent, type2, guid, initializer);
        break;
      case "Playwright":
        result = new Playwright2(parent, type2, guid, initializer);
        break;
      case "Request":
        result = new Request2(parent, type2, guid, initializer);
        break;
      case "Response":
        result = new Response3(parent, type2, guid, initializer);
        break;
      case "Route":
        result = new Route2(parent, type2, guid, initializer);
        break;
      case "Stream":
        result = new Stream(parent, type2, guid, initializer);
        break;
      case "Selectors":
        result = new SelectorsOwner(parent, type2, guid, initializer);
        break;
      case "SocksSupport":
        result = new DummyChannelOwner(parent, type2, guid, initializer);
        break;
      case "Tracing":
        result = new Tracing2(parent, type2, guid, initializer);
        break;
      case "WebSocket":
        result = new WebSocket4(parent, type2, guid, initializer);
        break;
      case "WebSocketRoute":
        result = new WebSocketRoute(parent, type2, guid, initializer);
        break;
      case "Worker":
        result = new Worker2(parent, type2, guid, initializer);
        break;
      case "WritableStream":
        result = new WritableStream(parent, type2, guid, initializer);
        break;
      default:
        throw new Error("Missing type " + type2);
    }
    return result;
  }
};
function formatCallLog(platform4, log4) {
  if (!log4 || !log4.some((l) => !!l))
    return "";
  return `
Call log:
${platform4.colors.dim(log4.join("\n"))}
`;
}
__name(formatCallLog, "formatCallLog");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/playwright-core/src/inProcessFactory.js
function createInProcessPlaywright() {
  const playwright2 = createPlaywright({ sdkLanguage: process.env.PW_LANG_NAME || "javascript" });
  setPlatformForSelectors(nodePlatform);
  const clientConnection = new Connection(nodePlatform);
  clientConnection.useRawBuffers();
  const dispatcherConnection = new DispatcherConnection(
    true
    /* local */
  );
  dispatcherConnection.onmessage = (message) => clientConnection.dispatch(message);
  clientConnection.onmessage = (message) => dispatcherConnection.dispatch(message);
  const rootScope = new RootDispatcher(dispatcherConnection);
  new PlaywrightDispatcher(rootScope, playwright2);
  const playwrightAPI = clientConnection.getObjectWithKnownName("Playwright");
  playwrightAPI.chromium._serverLauncher = new BrowserServerLauncherImpl("chromium");
  playwrightAPI.firefox._serverLauncher = new BrowserServerLauncherImpl("firefox");
  playwrightAPI.webkit._serverLauncher = new BrowserServerLauncherImpl("webkit");
  playwrightAPI._android._serverLauncher = new AndroidServerLauncherImpl();
  playwrightAPI._bidiChromium._serverLauncher = new BrowserServerLauncherImpl("bidiChromium");
  playwrightAPI._bidiFirefox._serverLauncher = new BrowserServerLauncherImpl("bidiFirefox");
  dispatcherConnection.onmessage = (message) => setImmediate(() => clientConnection.dispatch(message));
  clientConnection.onmessage = (message) => setImmediate(() => dispatcherConnection.dispatch(message));
  clientConnection.toImpl = (x) => x ? dispatcherConnection._dispatchers.get(x._guid)._object : dispatcherConnection._dispatchers.get("");
  playwrightAPI._toImpl = clientConnection.toImpl;
  return playwrightAPI;
}
__name(createInProcessPlaywright, "createInProcessPlaywright");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/index.js
import { env as env2 } from "cloudflare:workers";

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/cloudflare/wrapClientApis.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var apis = {
  accessibility: [Accessibility2.prototype, { snapshot: true }],
  // android: [Android.prototype],
  // androidDevice: [AndroidDevice.prototype],
  // androidWebView: [AndroidWebView.prototype],
  // androidInput: [AndroidInput.prototype],
  // androidSocket: [AndroidSocket.prototype],
  browser: [Browser2.prototype, { newContext: true, newPage: true, newBrowserCDPSession: true, startTracing: true, stopTracing: true, close: true }],
  browserContext: [BrowserContext2.prototype, {
    newPage: true,
    cookies: true,
    addCookies: true,
    clearCookies: true,
    grantPermissions: true,
    clearPermissions: true,
    setGeolocation: true,
    setExtraHTTPHeaders: true,
    setOffline: true,
    setHTTPCredentials: true,
    addInitScript: true,
    exposeBinding: true,
    exposeFunction: true,
    route: true,
    routeFromHAR: true,
    unrouteAll: true,
    unroute: true,
    waitForEvent: true,
    storageState: true,
    newCDPSession: true,
    close: true,
    routeWebSocket: true
  }],
  browserType: [BrowserType2.prototype, { launch: true, launchServer: true, launchPersistentContext: true, connect: true, connectOverCDP: true }],
  // clock: [Clock.prototype, { install: true, fastForward: true, pauseAt: true, resume: true, runFor: true, setFixedTime: true, setSystemTime: true }],
  consoleMessage: [ConsoleMessage2.prototype, {}],
  coverage: [Coverage.prototype, { startCSSCoverage: true, stopCSSCoverage: true, startJSCoverage: true, stopJSCoverage: true }],
  dialog: [Dialog2.prototype, { accept: true, dismiss: true }],
  download: [Download2.prototype, { cancel: true, createReadStream: true, path: true, failure: true, delete: true, saveAs: true }],
  // electron: [Electron.prototype, {}],
  // electronApplication: [ElectronApplication.prototype, {}],
  locator: [Locator.prototype, {
    boundingBox: true,
    check: true,
    click: true,
    dblclick: true,
    dispatchEvent: true,
    dragTo: true,
    evaluate: true,
    evaluateAll: true,
    evaluateHandle: true,
    fill: true,
    clear: true,
    highlight: true,
    elementHandle: true,
    elementHandles: true,
    focus: true,
    blur: true,
    count: true,
    getAttribute: true,
    hover: true,
    innerHTML: true,
    innerText: true,
    inputValue: true,
    isChecked: true,
    isDisabled: true,
    isEditable: true,
    isEnabled: true,
    isHidden: true,
    isVisible: true,
    press: true,
    screenshot: true,
    scrollIntoViewIfNeeded: true,
    selectOption: true,
    selectText: true,
    setChecked: true,
    setInputFiles: true,
    tap: true,
    textContent: true,
    type: true,
    pressSequentially: true,
    uncheck: true,
    all: true,
    allInnerTexts: true,
    allTextContents: true,
    waitFor: true,
    ariaSnapshot: true
  }],
  frameLocator: [FrameLocator.prototype, {}],
  elementHandle: [ElementHandle2.prototype, {
    // from JSHandle
    evaluate: true,
    evaluateHandle: true,
    getProperty: true,
    getProperties: true,
    jsonValue: true,
    dispose: true,
    // from ElementHandle
    ownerFrame: true,
    contentFrame: true,
    getAttribute: true,
    inputValue: true,
    textContent: true,
    innerText: true,
    innerHTML: true,
    isChecked: true,
    isDisabled: true,
    isEditable: true,
    isEnabled: true,
    isHidden: true,
    isVisible: true,
    dispatchEvent: true,
    scrollIntoViewIfNeeded: true,
    hover: true,
    click: true,
    dblclick: true,
    tap: true,
    selectOption: true,
    fill: true,
    selectText: true,
    setInputFiles: true,
    focus: true,
    type: true,
    press: true,
    check: true,
    uncheck: true,
    setChecked: true,
    boundingBox: true,
    screenshot: true,
    $: true,
    $$: true,
    $eval: true,
    $$eval: true,
    waitForElementState: true,
    waitForSelector: true
  }],
  fileChooser: [FileChooser2.prototype, { setFiles: true }],
  timeoutError: [TimeoutError2.prototype, {}],
  frame: [Frame2.prototype, {
    goto: true,
    waitForNavigation: true,
    waitForLoadState: true,
    waitForURL: true,
    frameElement: true,
    evaluateHandle: true,
    evaluate: true,
    $: true,
    $$: true,
    waitForSelector: true,
    dispatchEvent: true,
    $eval: true,
    $$eval: true,
    content: true,
    setContent: true,
    addScriptTag: true,
    addStyleTag: true,
    click: true,
    dblclick: true,
    dragAndDrop: true,
    tap: true,
    fill: true,
    focus: true,
    textContent: true,
    innerText: true,
    innerHTML: true,
    getAttribute: true,
    inputValue: true,
    isChecked: true,
    isDisabled: true,
    isEditable: true,
    isEnabled: true,
    isHidden: true,
    isVisible: true,
    hover: true,
    selectOption: true,
    setInputFiles: true,
    type: true,
    press: true,
    check: true,
    uncheck: true,
    setChecked: true,
    waitForTimeout: true,
    waitForFunction: true,
    title: true
  }],
  keyboard: [Keyboard2.prototype, { down: true, up: true, insertText: true, type: true, press: true }],
  mouse: [Mouse2.prototype, { click: true, dblclick: true, down: true, up: true, move: true, wheel: true }],
  touchscreen: [Touchscreen2.prototype, { tap: true }],
  jSHandle: [JSHandle2.prototype, { evaluate: true, evaluateHandle: true, getProperty: true, jsonValue: true, getProperties: true, dispose: true }],
  route: [Route2.prototype, { fallback: true, abort: true, fetch: true, fulfill: true, continue: true }],
  webSocket: [WebSocket4.prototype, { waitForEvent: true }],
  // webSocketRoute: [WebSocketRoute.prototype, { close: true }],
  request: [APIRequest.prototype, { newContext: true }],
  requestContext: [APIRequestContext2.prototype, { dispose: true, delete: true, head: true, get: true, patch: true, post: true, put: true, fetch: true, storageState: true }],
  response: [APIResponse.prototype, { body: true, json: true, text: true, dispose: true }],
  page: [Page2.prototype, {
    opener: true,
    waitForSelector: true,
    dispatchEvent: true,
    evaluateHandle: true,
    $: true,
    $$: true,
    $eval: true,
    $$eval: true,
    addScriptTag: true,
    addStyleTag: true,
    exposeFunction: true,
    exposeBinding: true,
    setExtraHTTPHeaders: true,
    content: true,
    setContent: true,
    goto: true,
    reload: true,
    addLocatorHandler: true,
    waitForLoadState: true,
    waitForNavigation: true,
    waitForURL: true,
    waitForRequest: true,
    waitForResponse: true,
    waitForEvent: true,
    goBack: true,
    goForward: true,
    emulateMedia: true,
    setViewportSize: true,
    evaluate: true,
    addInitScript: true,
    route: true,
    routeFromHAR: true,
    unrouteAll: true,
    unroute: true,
    screenshot: true,
    title: true,
    bringToFront: true,
    close: true,
    click: true,
    dragAndDrop: true,
    dblclick: true,
    tap: true,
    fill: true,
    focus: true,
    textContent: true,
    innerText: true,
    innerHTML: true,
    getAttribute: true,
    inputValue: true,
    isChecked: true,
    isDisabled: true,
    isEditable: true,
    isEnabled: true,
    isHidden: true,
    isVisible: true,
    hover: true,
    selectOption: true,
    setInputFiles: true,
    type: true,
    press: true,
    check: true,
    uncheck: true,
    setChecked: true,
    waitForTimeout: true,
    waitForFunction: true,
    pause: true,
    pdf: true,
    removeLocatorHandler: true,
    requestGC: true,
    routeWebSocket: true
  }],
  selectors: [Selectors2.prototype, { register: true }],
  tracing: [Tracing2.prototype, { start: true, startChunk: true, stop: true, stopChunk: true, group: false, groupEnd: false }],
  video: [Video.prototype, { delete: true, path: true, saveAs: true }],
  worker: [Worker2.prototype, { evaluate: true, evaluateHandle: true }],
  session: [CDPSession2.prototype, { send: true, detach: true }],
  playwright: [Playwright2.prototype, { devices: false }],
  webError: [WebError.prototype, {}]
};
var kApiFunctionWrapped = Symbol("kApiFunctionWrapped");
function wrapClientApis() {
  for (const [typeName, [proto, props]] of Object.entries(apis)) {
    for (const [key, needsWrap] of Object.entries(props)) {
      if (!needsWrap)
        continue;
      const originalFn = proto[key];
      if (!originalFn || typeof originalFn !== "function")
        throw new Error(`Method ${key} not found in ${typeName}`);
      if (originalFn[kApiFunctionWrapped] === true)
        continue;
      const wrapFn = /* @__PURE__ */ __name(async function(...args) {
        const apiName = apiCallZone.getStore();
        if (apiName)
          return await originalFn.apply(this, args);
        return await apiCallZone.run({ apiName: `${typeName}.${key}` }, async () => await originalFn.apply(this, args));
      }, "wrapFn");
      wrapFn[kApiFunctionWrapped] = true;
      proto[key] = wrapFn;
    }
  }
}
__name(wrapClientApis, "wrapClientApis");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/cloudflare/unsupportedOperations.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function unsupportedOperations(playwright2) {
  playwright2.chromium.launch = async () => {
    throw new Error("Cloudflare Workers does not support browserType.launch.");
  };
  playwright2.chromium.launchPersistentContext = async () => {
    throw new Error("Cloudflare Workers does not support browserType.launchPersistentContext.");
  };
  playwright2.chromium.launchServer = async () => {
    throw new Error("Cloudflare Workers does not support browserType.launchServer.");
  };
  playwright2.chromium.connect = async () => {
    throw new Error("Cloudflare Workers does not support browserType.connect.");
  };
}
__name(unsupportedOperations, "unsupportedOperations");

// node_modules/.pnpm/@cloudflare+playwright@0.0.10/node_modules/@cloudflare/playwright/lib/esm/index.js
var playwright = createInProcessPlaywright();
unsupportedOperations(playwright);
wrapClientApis();
var HTTP_FAKE_HOST = "http://fake.host";
var WS_FAKE_HOST = "ws://fake.host";
var originalConnectOverCDP = playwright.chromium.connectOverCDP;
playwright.chromium.connectOverCDP = (endpointURLOrOptions) => {
  const wsEndpoint = typeof endpointURLOrOptions === "string" ? endpointURLOrOptions : endpointURLOrOptions.wsEndpoint ?? endpointURLOrOptions.endpointURL;
  if (!wsEndpoint)
    throw new Error("No wsEndpoint provided");
  const wsUrl = new URL(wsEndpoint);
  if (!wsUrl.searchParams.has("persistent"))
    wsUrl.searchParams.set("persistent", "true");
  return wsUrl.searchParams.has("browser_session") ? connect3(wsUrl.toString()) : launch(wsUrl.toString());
};
async function connectDevtools(endpoint, options2) {
  const url4 = new URL(`${HTTP_FAKE_HOST}/v1/connectDevtools`);
  url4.searchParams.set("browser_session", options2.sessionId);
  if (options2.persistent)
    url4.searchParams.set("persistent", "true");
  const response = await getBrowserBinding(endpoint).fetch(url4, {
    headers: {
      Upgrade: "websocket"
    }
  });
  const webSocket = response.webSocket;
  webSocket.accept();
  return webSocket;
}
__name(connectDevtools, "connectDevtools");
function extractOptions(endpoint) {
  if (typeof endpoint === "string" || endpoint instanceof URL) {
    const url4 = endpoint instanceof URL ? endpoint : new URL(endpoint);
    const sessionId = url4.searchParams.get("browser_session") ?? void 0;
    const keepAlive = url4.searchParams.has("keep_alive") ? parseInt(url4.searchParams.get("keep_alive"), 10) : void 0;
    const persistent = url4.searchParams.has("persistent");
    return { sessionId, keep_alive: keepAlive, persistent };
  }
  return {};
}
__name(extractOptions, "extractOptions");
async function createBrowser(transport, options2) {
  return await transportZone.run(transport, async () => {
    const url4 = new URL(WS_FAKE_HOST);
    if (options2?.persistent)
      url4.searchParams.set("persistent", "true");
    const browser3 = await originalConnectOverCDP.call(playwright.chromium, url4.toString());
    browser3.sessionId = () => transport.sessionId;
    return browser3;
  });
}
__name(createBrowser, "createBrowser");
function getBrowserBinding(endpoint) {
  if (typeof endpoint === "string" || endpoint instanceof URL) {
    const url4 = endpoint instanceof URL ? endpoint : new URL(endpoint);
    const binding3 = url4.searchParams.get("browser_binding");
    if (!binding3 || !(binding3 in env2))
      throw new Error(`No binding found for ${binding3}`);
    return env2[binding3];
  }
  return endpoint;
}
__name(getBrowserBinding, "getBrowserBinding");
async function connect3(endpoint, sessionIdOrOptions) {
  const extraOptions = typeof sessionIdOrOptions === "string" ? { sessionId: sessionIdOrOptions } : sessionIdOrOptions ?? {};
  const options2 = { ...extractOptions(endpoint), ...extraOptions };
  if (!options2.sessionId)
    throw new Error(`Session ID is required for connect()`);
  const webSocket = await connectDevtools(getBrowserBinding(endpoint), options2);
  const transport = new WebSocketTransport(webSocket, options2.sessionId);
  return await createBrowser(transport, options2);
}
__name(connect3, "connect");
async function launch(endpoint, launchOptions) {
  const { sessionId } = await acquire(endpoint, launchOptions);
  const options2 = { ...extractOptions(endpoint), ...launchOptions, sessionId };
  const webSocket = await connectDevtools(getBrowserBinding(endpoint), options2);
  const transport = new WebSocketTransport(webSocket, sessionId);
  const browser3 = await createBrowser(transport, options2);
  const browserImpl = browser3._toImpl();
  const doClose = /* @__PURE__ */ __name(async () => {
    const message = { method: "Browser.close", id: kBrowserCloseMessageId, params: {} };
    transport.send(message);
  }, "doClose");
  browserImpl.options.browserProcess = { close: doClose, kill: doClose };
  return browser3;
}
__name(launch, "launch");
async function acquire(endpoint, options2) {
  options2 = { ...extractOptions(endpoint), ...options2 };
  let acquireUrl = `${HTTP_FAKE_HOST}/v1/acquire`;
  if (options2?.keep_alive)
    acquireUrl = `${acquireUrl}?keep_alive=${options2.keep_alive}`;
  const res = await getBrowserBinding(endpoint).fetch(acquireUrl);
  const status = res.status;
  const text = await res.text();
  if (status !== 200) {
    throw new Error(
      `Unable to create new browser: code: ${status}: message: ${text}`
    );
  }
  const response = JSON.parse(text);
  return response;
}
__name(acquire, "acquire");
var chromium = playwright.chromium;
var selectors = playwright.selectors;
var devices = playwright.devices;
var errors2 = playwright.errors;
var request3 = playwright.request;
var _instrumentation = playwright._instrumentation;

// src/index.ts
var index_default = {
  async fetch(request4, env3) {
    const browser3 = await launch(env3.MYBROWSER);
    const page = await browser3.newPage();
    await page.goto("https://demo.playwright.dev/todomvc");
    const TODO_ITEMS = [
      "buy some cheese",
      "feed the cat",
      "book a doctors appointment"
    ];
    const newTodo = page.getByPlaceholder("What needs to be done?");
    for (const item of TODO_ITEMS) {
      await newTodo.fill(item);
      await newTodo.press("Enter");
    }
    const img = await page.screenshot();
    await browser3.close();
    return new Response(img, {
      headers: {
        "Content-Type": "image/png"
      }
    });
  }
};
export {
  index_default as default
};
/*! Bundled license information:

@cloudflare/playwright/lib/esm/bundles/utilsBundleImpl.js:
  (*!
   * node-progress
   * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
   * MIT Licensed
   *)

@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/third_party/bidiProtocolCore.js:
@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/third_party/bidiProtocolPermissions.js:
@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/third_party/bidiDeserializer.js:
@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/third_party/bidiSerializer.js:
@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/third_party/bidiKeyboard.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * Modifications copyright (c) Microsoft Corporation.
   * SPDX-License-Identifier: Apache-2.0
   *)

@cloudflare/playwright/lib/esm/playwright-core/src/server/bidi/third_party/firefoxPrefs.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=index.js.map
